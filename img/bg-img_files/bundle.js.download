/**
 * Created by MrSingh on 1/17/16.
 */
'use strict';

var hsApp = angular.module('homesome', [
    'ngRoute',
    'ngResource',
    'ngCookies',
	'toastr',
	'LocalStorageModule',
	'customFilters',
	'homesome.factories',
    'ui.bootstrap',
    'config',
    'ngValidate',
    'ngMask',
	'google.places',
	'payment',
	'ngDialog',
    'angular.filter',
	'ngMap',
	'benharold.haversine',
	'angularLazyImg',
    'bc.TelephoneFilter',
	'ngTable',
	'ngSanitize',
	'ngCsv',
	'infinite-scroll',
    'ngFileUpload',
    'ngAnimate',
	'dndLists',
    'angularjs-dropdown-multiselect',
]);

hsApp.config(['$httpProvider', function($httpProvider) {
    $httpProvider.interceptors.push('hsHttpInterceptor');
}]);

hsApp.config(["$animateProvider", function($animateProvider){
    // all animations css class names must be of the form ng-animate-{animationName}
    $animateProvider.classNameFilter(/ng-animate-\w+/);
}]);

hsApp.config(['ngDialogProvider', function (ngDialogProvider) {
	ngDialogProvider.setDefaults({
		className			: 'ngdialog-theme-default',
		closeByNavigation	: true,
		closeByDocument		: true,
		closeByEscape		: true
	});

	ngDialogProvider.setOpenOnePerName(true);
}]);



hsApp.run(['$rootScope', '$location', '$window','hsAuth','$http','ENV','OpenGraphTags','hsCart','$filter','localStorageService','globalFunctions', 'hsTableSideOrders', 'hsMarketingService', '$route', 'hsPickingApp',
    function($rootScope, $location, $window, hsAuth,$http, ENV, OpenGraphTags,hsCart, $filter, localStorageService, globalFunctions, hsTableSideOrders, hsMarketingService, $route, hsPickingApp) {

		localStorageService.set('productSearchIndex', null);
		localStorageService.set('searchQuery', null);
		localStorageService.set('previousPath', null);

		if (!ENV.enablePriceList) {
			localStorageService.remove('selectedPriceList');
		}
		if (!ENV.enableLocations) {
			localStorageService.remove('location');
			localStorageService.remove('adminLocationSelected');
		}

		if (ENV.enablePriceList && !$location.search().plist && !$location.search().pListName) {
			$rootScope.showPriceListSelector = true;
		}

        $rootScope.isWrapped = hsPickingApp.isWrapped();
		
        var location = localStorageService.get('location');
        if (ENV.enableLocations && location && location.selectedLocation) {
            globalFunctions
                .isSelectedLocationValid()
                .then(function (isValid) {
                    void 0;
                    if (!isValid) {
                        localStorageService.remove('location');
                        localStorageService.remove('selectedPriceList');
                        var tableNumber = $location.search().tableNumber;
                        if (tableNumber !== undefined || $rootScope.tableSideOrder) {
                            $location.url('/table-side/error');
                        }
                    } else {
                        $rootScope.$emit('locationUpdated', true);
                    }
                })
                .catch(function (e) {
                    void 0;
                });
        } else if (!ENV.enableLocations) {
            globalFunctions.getSelectedLocation(true)
                .then(function(location) {
                    $rootScope.country = location.country;
                    $rootScope.paymentProcessor = location.paymentProcessor;
                    void 0;
                    void 0;
					if (!$rootScope.location) {
						$rootScope.location = {
							selectedLocation: location
						};
					} else if (!$rootScope.location.selectedLocation) {
						$rootScope.location.selectedLocation = location;
					}
                    var priceList = globalFunctions.getDefaultPriceListFromLocation(location);

                    if (priceList && typeof priceList.chargeUser === 'boolean') {
                        $rootScope.acceptCreditCard = priceList.chargeUser;
                    } else {
                        $rootScope.acceptCreditCard = location.chargeUser === true;
                    }
                });
        }

	    //Checking if the session is valid then adding user info to CurrentUser object and setting the loggedIn status to true
        hsAuth.isSessionValid();
		if ($rootScope.currentUser) {
			// The purpose of this is to reflect updated permissions when user refreshes the application
			// For now, this is not a blocking flow. Errors are silently ignored.
			globalFunctions.updateUserInStorage()
				.catch(function(err) {
					// Nothing to do here.
				});
		}

	    globalFunctions.checkIfOrderingDisabled();

        hsTableSideOrders.checkSession();

        $rootScope.ENV = ENV;
        $rootScope.globalFunctions = globalFunctions;

        globalFunctions.getAnnoucements();
        globalFunctions.checkLocationParam();

	    setTimeout(function() {
		    $rootScope.isInternetEnabled = navigator.onLine;
		    $rootScope.showInternetConnectionWarning = !navigator.onLine;
		    $rootScope.isInternetEnabledText = "Please make sure you have a working internet connection and try again.";
	    }, 0);

	    // Check for Internet Connectivity
	    window.addEventListener('online', function (event) {
		    $rootScope.$broadcast('isInternetEnabled', true);
	    });
	    window.addEventListener('offline', function (event) {
		    $rootScope.$broadcast('isInternetEnabled', false);
	    });
        
        var referralCode = localStorageService.get('referralCode');
        if(referralCode){
        	$rootScope.globalNotification = {
        	    show    : true,
		        html    : '<p class="mtopbot0 text-white text-center text-small vertical-middle">' +
		        'Lucky You! You\'ll get <b class="text-900 mleftright2">$10 off</b> your first order of $35.' +
		        '<a class="btn btn-white mleft10" href="/signup">Join Today!</a>' +
		        '</p>'
	        }
        } else if($location.search().referralCode && !$rootScope.loggedIn) {
        	localStorageService.set('referralCode', $location.search().referralCode);
	        $rootScope.globalNotification = {
		        show    : true,
		        html    : '<p class="mtopbot0 text-white text-center text-small">' +
		        'Lucky You! You\'ll get $10 off your first order of $35.' +
		        '<a class="btn btn-white mleft10" href="/signup">Join Today!</a>' +
		        '</p>'
	        }
        } else {
	        $rootScope.globalNotification = false;
        }
        
        $rootScope.$on('$routeChangeStart', function(event, nextLocation) {

			if ($location.search().viewport) {
				$rootScope.viewport = $location.search().viewport;
			} else if ($rootScope.viewport) {
				$location.search('viewport', $rootScope.viewport);
			}

            if (ENV.contactPageOveride && nextLocation.originalPath.indexOf('/contact') !== -1) {
                event.preventDefault();
                window.open(ENV.contactPageOveride,"_blank");
            }

            if (ENV.enforceLogin
				&& (!$rootScope.isWrapped || nextLocation.originalPath !== '/app/init')
                && !$rootScope.loggedIn
                && nextLocation.originalPath.indexOf('login') === -1
                && nextLocation.originalPath.indexOf('password') === -1) {
                $location.url('/login');
            }

            if (nextLocation.originalPath.indexOf('/products') === -1
                 && nextLocation.originalPath.indexOf('/search') === -1
                 && nextLocation.originalPath.indexOf('/shop') === -1
 				&& nextLocation.originalPath.indexOf('/product') === -1) {
                 $rootScope.allProducts = null;
				 $rootScope.fullListLoaded = false;
             }

            if (ENV.enableDarkMode &&
                globalFunctions.darkModeUrls.indexOf(nextLocation.originalPath) !== -1) {
                $rootScope.enableDarkMode = true;
            } else {
                $rootScope.enableDarkMode = false;
            }
			hsAuth.checkPermissionsForAdminRoutes(nextLocation);
        });

        $rootScope.$on('$routeChangeSuccess', function(event) {
        	$rootScope.currentLocation = $location.url();
	        if ($location.path().indexOf('/404') !== -1) {
		        $rootScope.prerender404 = true;
	        } else {
		        $rootScope.prerender404 = false;
	        }

	        if ($location.path().includes('/admin')) {
		        $rootScope.onAdminPage = true;
	        } else {
		        $rootScope.onAdminPage = false;
	        }

	        angular.element('#navbar').removeClass('in');
	        $window.scrollTo(0, 0);

	        if (!$window.ga) {
		        return;
	        }
	        $window.ga('send', 'pageview', {
		        page: $location.path()
	        });

	        // We can't trigger session expired event on route change because
            // a controller's listener would fire before its scope is destroyed.
            // if (ENV.enablePriceList) {
            //     globalFunctions.checkPriceList();
            // }

	        globalFunctions.checkAndUpdateSession()
        });
        
        // closing navbar collapse when content is loaded
        $rootScope.$on('$viewContentLoaded', function (event) {
            $(".nav a").click(function () {
                if ($(".navbar-collapse").hasClass("in")) {
                    $('[data-toggle="collapse"]').click();
                }
            });

            // if (ENV.enablePriceList) {
            //     setTimeout(function () {
            //         globalFunctions.checkPriceList();
            //     }, 0);
            // }

	        if (ENV.socialHeader) {
	        	$('.main-view').css({
			       'margin-top': '91px'
		        });
	        }
        });

        var screenWidth = {
            lg  : false,
            md  : false,
            sm  : false,
            xs  : false
        };
        
        angular.element($window).bind('resize', function(){
            var winWidth = $window.innerWidth;
            __processWinWidth(winWidth);
        }).trigger('resize');

        function __processWinWidth(winWidth){
            if(winWidth > 1200){
                __setWidthProperties('lg');
            } else if(winWidth > 992){
                __setWidthProperties('md');
            }else if(winWidth >= 768){
                __setWidthProperties('sm');
            }else if(winWidth < 768){
                __setWidthProperties('xs');
            }
        }

        function __setWidthProperties(property){
            angular.forEach(screenWidth, function(val, prop){
                prop == property ? screenWidth[prop] = true : screenWidth[prop] = false;
            });
            $rootScope.screenWidth = screenWidth;
            $rootScope.$broadcast('screenWidth', $rootScope.screenWidth);
        }

        $rootScope.$on('screenWidth', function (event, data) {
            //do something with new value 'data'
            $rootScope.screenWidth = data;
            $rootScope.$digest();
        });
	
	    $rootScope.$on('cartUpdated', function (event, data) {
		    if(!$rootScope.loggedIn){
		    	var basket = localStorageService.get('basket');
			    if(basket){
				    $rootScope.cartGlobal = {
					    items       : basket,
					    itemsTotal  : basket.length,
					    cartSubTotal: 0,
					    cartTotal   : 0,
					    coupon      : '',
					    deliveryFee : 0
				    };
			    }
		    } else {
			    var reqData = hsAuth.getUserAuthObj();
			    hsCart.getCartItems(reqData, true)
			    .then(function(response) {
				    if(response.status === 200){
				    	var basket = {
						    items       : response.data.basketItems,
						    itemsTotal  : response.data.basketItems.length,
						    cartSubTotal: $filter('number')(response.data.basketSubTotal,2),
						    cartTotal   : $filter('number')(response.data.basketTotal,2),
                            tax         : $filter('number')(response.data.tax, 2),
                            isPickupOnly: response.data.isPickupOnly,
					    };

				    	localStorageService.set('basket', basket);
					    $rootScope.cartGlobal = basket;
				    }else{
					    void 0;
				    }
			    });
		    }
	    });
	
	    $rootScope.$on('locationUpdated', function (event, data) {
		    event.preventDefault();
		    var location = localStorageService.get('location');
		    var selectedPriceList = localStorageService.get('selectedPriceList');

            if (location) {
                $rootScope.location = location;
                $rootScope.paymentProcessor = location.selectedLocation.paymentProcessor;
                $rootScope.country = location.selectedLocation.country;
                $rootScope.acceptCreditCard = location.selectedLocation.chargeUser === true;
                void 0;
                void 0;
		    }

            var pListName = $location.search().pListName;
            var locName = $location.search().locName;

			if (pListName && !locName) {
				if (!$location.search().jwt) {
					$location.search('pListName', null);
				}
				if (location) {
					if (selectedPriceList && selectedPriceList.pListName !== pListName) {
						var found = false;
						location.selectedLocation.priceLists.forEach(function (priceList) {
							if (hsMarketingService.isMatchingPriceList(pListName, priceList)) {
								localStorageService.set('selectedPriceList', priceList);
								$rootScope.selectedPriceList = priceList;
								$rootScope.minimalProductLayout = priceList.smallProductCount || false;
								found = true;

                                if (typeof priceList.chargeUser === 'boolean') {
                                    $rootScope.acceptCreditCard = priceList.chargeUser;
                                }
							}
						});
						if (!found) {
                            $rootScope.showPriceListSelector = true;
						}
					}
				} else {
					localStorageService.remove('selectedPriceList');
		    		$route.reload();
				}
			} else if (selectedPriceList) {
				if (!selectedPriceList.title) {
					if (location) {
						location.selectedLocation.priceLists.forEach(function (priceList) {
						    if (priceList.uniqueName === selectedPriceList.uniqueName) {
							    localStorageService.set('selectedPriceList', priceList);
							    $rootScope.selectedPriceList = priceList;
							    $rootScope.minimalProductLayout = priceList.smallProductCount || false;

                                if (typeof priceList.chargeUser === 'boolean') {
                                    $rootScope.acceptCreditCard = priceList.chargeUser;
                                }
						    }
					    });
				    } else {
		    			localStorageService.remove('selectedPriceList');
		    			$route.reload();
				    }
			    } else {
		    	    $rootScope.selectedPriceList = selectedPriceList;
				    $rootScope.minimalProductLayout = selectedPriceList.smallProductCount || false;

                    if (typeof selectedPriceList.chargeUser === 'boolean') {
                        $rootScope.acceptCreditCard = selectedPriceList.chargeUser;
                    }
			    }
		    } else {
			    $rootScope.selectedPriceList = null;
			    $rootScope.minimalProductLayout = false;

                if (location && !ENV.enablePriceList) {
                    var priceList = globalFunctions.getDefaultPriceListFromLocation(location.selectedLocation)
                        || location.selectedLocation.priceLists[0];

                    if (priceList && typeof priceList.chargeUser === 'boolean') {
                        $rootScope.acceptCreditCard = priceList.chargeUser;
                    }
                }
		    }

		    globalFunctions.getAnnoucements();
		    globalFunctions.checkIfOrderingDisabled();
		    $rootScope.$broadcast('cartUpdated', true);
			$rootScope.$broadcast('changeLocation');
	    });

	    $rootScope.$on('priceListUpdated', function (event, data) {
		    event.preventDefault();
		    var selectedPriceList = localStorageService.get('selectedPriceList');
		    void 0;

		    if (selectedPriceList) {
		    	$rootScope.selectedPriceList = selectedPriceList;
			    $rootScope.minimalProductLayout = selectedPriceList.smallProductCount;

                if (typeof selectedPriceList.chargeUser === 'boolean') {
                    $rootScope.acceptCreditCard = selectedPriceList.chargeUser;
                }
		    } else {
			    $rootScope.selectedPriceList = null;
			    $rootScope.minimalProductLayout = false;
		    }

		    globalFunctions.checkIfOrderingDisabled();
		    $rootScope.$broadcast('cartUpdated', true);
			$rootScope.$broadcast('changePriceList');
	    });

	    $rootScope.$on('isInternetEnabled', function (event, isEnabled) {
		    $rootScope.isInternetEnabled = isEnabled;
		    $rootScope.showInternetConnectionWarning = !isEnabled;

		    $rootScope.$apply();
	    });

        $rootScope.$on('healthClaimsMapUpdated', function(_, healthClaimsMap) {
            $rootScope.healthClaimsMap = healthClaimsMap;
			var healthClaimsMapClone = {};
			globalFunctions.copyKeys(healthClaimsMap, healthClaimsMapClone);
			$rootScope.healthClaimsByDisplayName = globalFunctions.invertMap(healthClaimsMapClone, "displayName");
        });
    }
]);

hsApp.config(["$validatorProvider", function ($validatorProvider) {
    $validatorProvider.setDefaults({
        errorElement: 'span',
        errorClass: 'help-block text-red border-red text-medium-smaller text-left mtop0 error-msg'
    });

    $validatorProvider.addMethod("phoneUS", function (a, b) {
        return a = a.replace(/\s+/g, ""), this.optional(b) || a.length > 9 && a.match(/^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/);
    }, "Please enter a valid US Phone number.");

    $validatorProvider.addMethod("emailRobust", function (a, b) {
        return a = a.replace(/\s+/g, ""), this.optional(b) || a.length > 9 && a.match(/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/);
    }, "Please enter a valid Email.");

    $validatorProvider.addMethod("decimals", function (value, element, digits) {
        var exp = new RegExp('^\\d*\\.\\d{' + digits + '}.+$');
        return this.optional(element) || !exp.test(value);
    }, $validatorProvider.format("Please enter at most {0} decimal digits."));

    $validatorProvider.addMethod("gt", function (value, element, min) {
        if (!value) return this.optional(element) || true;
        value = parseFloat(value);
        return this.optional(element) || (isNaN(value) || value <= min) ? false : true;
    }, $validatorProvider.format("Please enter a value greater than {0}."));

	$validatorProvider.addMethod("caZip", function (value, element) {
		var exp = new RegExp('^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$');
		return this.optional(element) || exp.test(value);
	}, $validatorProvider.format("Please enter a valid Canada zip code"));

	$validatorProvider.addMethod("standardTips", function (value, element) {
		try {
			value = JSON.parse(value);
		} catch(err) {
			return false;
		}
		if (!Array.isArray(value)) {
			return false;
		}
		var percentages = value.map(function(tipObject) {
			return tipObject ? tipObject.percentage : null;
		});
		var isValidStandardTips = (
			percentages.length === 0
			|| percentages.length === 3
			&& percentages.every(function(percentage) {
				return (
					!isNaN(percentage)
					&& percentage > 0
				);
			})
			&& !percentages.some(function(percentage, index) {
				return percentages.indexOf(percentage) !== index;
			})
		);
        return isValidStandardTips;
    }, $validatorProvider.format("Please enter valid standard tips"));
}]);

hsApp.config(["toastrConfig", function(toastrConfig) {
    angular.extend(toastrConfig, {
        autoDismiss             : true,
        containerId             : 'toast-container',
        maxOpened               : 2,
        newestOnTop             : true,
        positionClass           : 'toast-bottom-left',
	    extendedTimeOut         : 2000,
	    timeOut                 : 3000,
        preventOpenDuplicates   : false,
        target                  : 'body'
    });
}]);

hsApp.filter("multiWordFilter", ["$filter", function($filter){
	return function(inputArray, searchText){
		var wordArray = searchText ? searchText.toLowerCase().split(/\s+/) : [];
		var wordCount = wordArray.length;
		for(var i=0; i<wordCount; i++){
			inputArray = $filter('filter')(inputArray, {displayName: wordArray[i]});
		}
		return inputArray;
	}
}]);

hsApp.filter("adminMultiWordFilter", ["$filter", function($filter){
	return function(inputArray, searchText){
		var wordArray = searchText ? searchText.toLowerCase().split(/\s+/) : [];
		var wordCount = wordArray.length;
		for(var i=0; i<wordCount; i++){
			inputArray = $filter('filter')(inputArray, {displayName: wordArray[i]});
		}
		return inputArray;
	}
}]);

hsApp.factory('hsHttpInterceptor', ['localStorageService', 'ENV', '$injector', '$rootScope', '$cookies', '$location', 'hsUtils',
	function (localStorageService, ENV, $injector, $rootScope, $cookies, $location, hsUtils) {
    var interceptor = {};

    interceptor.request = function (config) {
	    config.headers['apikey'] = ENV.APIKey;

        var forterToken = $cookies.get('forterToken');
	    var user = localStorageService.get('user');
	    if (user){
		    config.headers['emailid'] = user.email;
		    config.headers['authToken'] = user.authToken;
	    }

        if (forterToken) {
            config.headers['forterToken'] = forterToken;
        }

        if ($rootScope.tableSideOrder) {
            var hsTableSideOrders = $injector.get('hsTableSideOrders');
            var tsoSession = hsTableSideOrders.getSession();

            if (!tsoSession || !tsoSession.location || tsoSession.location.length !== 36
                || !tsoSession.pricelist || tsoSession.pricelist.length !== 36
            ) {
                hsTableSideOrders.endSession();
                window.location.href = '/table-side/error';
            } else {
                config.headers.location = tsoSession.location;
                config.headers.pricelist = tsoSession.pricelist;
            }
        }

	    if(ENV.enableLocations){
	    	var location = localStorageService.get('location');
	    	if (location && !config.headers['location']){
		        config.headers['location'] = location.selectedLocation.uniqueName;
		    }
	    }

	    if (ENV.enablePriceList) {
		    var selectedPriceList = localStorageService.get('selectedPriceList');
		    if (selectedPriceList && !config.headers['pricelist']) {
			    config.headers['pricelist'] = selectedPriceList.uniqueName;
		    }
	    }

        if ($rootScope.tableSideOrder) {
            config.headers.isTableSideOrder = true;
        }

        return config;
    };

    interceptor.responseError = function (response) {
	    /*ga('send', {
		    hitType: 'event',
		    eventCategory: 'API_ERRORS',
		    eventAction: 'ERROR',
		    eventLabel: 'API call: ' + response.config.url + ' failed with status code: ' + response.status
	    });*/

	    // logging out user if API returns with 401 Unauthorized
	    if (response.status === 401) {
		    var user = localStorageService.get('user');
			var url = new URL('/login', window.location.origin);
			var searchParams = $location.search();
			if (hsUtils.isObject(searchParams)) {
				if (hsUtils.isNonEmptyString(searchParams.redirect)) {
					url.searchParams.append('redirect', searchParams.redirect)
				}
			}
		    if (user) {
			    localStorageService.clearAll();
			    window.location.href = url.pathname + (url.search || '');
		    }
	    }

    	if (response.status === 504 || response.status === 408) {
            var notificationService = $injector.get('notificationService');
    		notificationService.showToastrMessage('error', 'Please make sure you have a working internet connection and try again.');
	    }
        return response;
    };

    return interceptor;
}]);


/**
 * Created by MrSingh on 1/17/16.
 */
'use strict';

var cf = angular.module('customFilters', []);

cf.filter('trusted', ['$sce', function($sce){
    return function(text) {
        return $sce.trustAsHtml(text);
    };
}]);

cf.filter('escape', function() {
	return window.encodeURIComponent;
});

cf.filter('removeSpaces', function(){
    return function(text){
        text = text.replace(/\s/g, '');
        text = text.replace(/&/g, '');
        text = text.replace(/\(/g, '');
        text = text.replace(/\)/g, '');
        text = text.replace(/,/g, '');
        text = text.replace(/'/g, '');
        text = text.replace(/\//g, '');
        return text;
    }
});

cf.filter('truncateText', function(){
    return function(text){
        /*var difference = 200 - text.length;
        var spacesArray = new Array(difference).join('&nsbp; ');
        console.log(text);*/
        return text;
    }
});

cf.filter('formatPhoneNumber', function(){
    return function(text){
        return text.replace(/(\d{3})(\d{3})(\d{4})/, "($1) $2-$3");
    }
});

cf.filter('prioritizeSubCategory', function() {
    return function(products, targetSubType) {
        if (targetSubType && products && products.length) {
            return products.sort(function(a,b) {
                if ((a.subType !== targetSubType && b.subType !== targetSubType) || (a.subType === targetSubType && b.subType === targetSubType)) {
                    return 0;
                } else if (a.subType === targetSubType && b.subType !== targetSubType) {
                    return -1;
                } else {
                    return 1;
                }
            });
        }
        return products;
    }
});


cf.factory('OpenGraphTags', ["$location", function ($location) {
    var ogTitle = '';
    var ogSubTitle = '';
    var ogImage = '';
    var ogDescription = '';
    var ogUrl = $location.absUrl();
    var seoDescription = '';
    var seoKeyword = '';
    var fbAppId    = '';
    var ogImageWidth = 300;
    var ogImageHeight = 300;

    return {
        ogTitle: function () {
            return ogTitle;
        },
        setOgTitle: function (newTitle) {
            ogTitle = newTitle;
        },
        ogSubTitle: function () {
            return ogSubTitle;
        },
        setOgSubTitle: function (newSubTitle) {
            ogSubTitle = newSubTitle;
        },
        ogImage: function () {
            return ogImage;
        },
        setOgImage: function (newImage) {
            ogImage = newImage;
        },
        ogDescription: function () {
            return ogDescription;
        },
        setOgDescription: function (newDescription) {
            ogDescription = newDescription;
        },
        seoDescription: function () {
            return seoDescription;
        },
        setSeoDescription: function (newSeoDescription) {
            seoDescription = newSeoDescription;
        },
        seoKeyword: function () {
            return seoKeyword;
        },
        setSeoKeyword: function (newSeoKeyword) {
            seoKeyword = newSeoKeyword;
        },
        ogUrl: function () {
            return ogUrl;
        },
        setOgUrl: function (newUrl) {
            ogUrl = newUrl;
        },
        fbAppId: function () {
            return fbAppId;
        },
        setFbAppId: function (fbAppId) {
            fbAppId = fbAppId;
        },
        ogImageWidth: function () {
            return ogImageWidth;
        },
        setOgImageWidth: function (imageWidth) {
            ogImageWidth = imageWidth;
        },
        ogImageHeight: function () {
            return ogImageHeight;
        },
        setOgImageHeight: function (imageHeight) {
            ogImageHeight = imageHeight;
        }
    };
}]);


/**
 * Created by MrSingh on 1/23/16.
 */
hsApp.config(["$routeProvider", "$locationProvider", "ENV", function($routeProvider, $locationProvider, ENV){
    $locationProvider.html5Mode(true).hashPrefix('!');
    
    var _getHomeBg = function(templateUrlPath) {
        return {
            templateUrl : templateUrlPath,
            controller  : function ($scope, $routeParams, $rootScope) {
                $rootScope.bgHome = true;
                window.prerenderReady = false;
	            $rootScope.$on( "$routeChangeStart", function(event, next, current) {
		            //..do something  //if you don't want event to bubble up
		            $rootScope.bgHome = false;
	            });
            }
        };
    };

    var _showDealsPage = function() {
        var routeMetadata = {
        	templateUrl: '/partials/discounts.html',
	        controller: 'landingCtrl'
	    };
		if (ENV.showDealsPage) {
			return routeMetadata;
		} else {
			routeMetadata.redirectTo = '/';
			return routeMetadata;
		}
    };

    var _showCheckoutPage = function() {
	    var routeMetadata = {
		    templateUrl: '',
		    controller: 'cartCtrl',
	    };

	    if (ENV.enableNewCheckout) {
		    routeMetadata.templateUrl = '/partials/cart/checkout-v2.html';
	    } else {
		    routeMetadata.templateUrl = '/partials/cart/checkout.html';
	    }

	    return routeMetadata;
    };

    var _showLandingPage = function(templateUrl) {
        var routeMetadata = {
        	templateUrl: templateUrl,
	        controller: 'landingCtrl',
	        reloadOnSearch : false
    };

        if (!ENV.showProductsPage) {
	        routeMetadata.redirectTo = '/order';
	        return routeMetadata;
        } else if (!ENV.showOrderPage) {
	        routeMetadata.redirectTo = '/products';
	        return routeMetadata;
        } else {
	        return routeMetadata;
        }
    };

    var _showRewardsPage = function(templateUrl, ctrlName) {
        var routeMetadata = {
        	templateUrl: templateUrl,
	        controller: ctrlName,
	    };

        if (!ENV.enableRewards) {
	        routeMetadata.redirectTo = '/';
	        return routeMetadata;
        } else {
        	return routeMetadata;
        }
    };



    var _showPage = function(templateObj, property, redirectUrl, negate) {
    	if (negate && ENV[property]) {
		    templateObj.redirectTo = redirectUrl || '/';
		    return templateObj;
	    } else if (ENV[property]) {
	        return templateObj;
        } else {
	        templateObj.redirectTo = redirectUrl || '/';
        	return templateObj;
        }
    };
    
    var TemplateEnum = {
		TEMPLATE_SHOWCASE : '/partials/landing-templates/showcase.html',
		TEMPLATE_HERO     : '/partials/landing-templates/hero.html',
		TEMPLATE_HERO_DARK: '/partials/landing-templates/hero-dark.html',
		TEMPLATE_SIGNATURE: '/partials/landing-templates/signature.html',
		TEMPLATE_RESTAURANT_SHOWCASE: '/partials/landing-templates/restaurant-showcase.html',
	    TEMPLATE_ALL_DARK: '/partials/landing-templates/all-dark.html',
	    TEMPLATE_REWARDS: '/partials/landing-templates/rewards.html',
	    TEMPLATE_APNA_BAZAR: '/partials/landing-templates/apna-bazar.html',
	    TEMPLATE_MOD_CUT: '/partials/landing-templates/mod-cut.html',
	    TEMPLATE_JOKER: '/partials/landing-templates/joker.html',
	    TEMPLATE_WESTSIDE: '/partials/landing-templates/westside.html',
	    TEMPLATE_BATMAN: '/partials/landing-templates/batman.html',
        TEMPLATE_HERO_WITH_LOGO: '/partials/landing-templates/hero-with-logo.html',
	    TEMPLATE_HERO_SIDEBAR: '/partials/landing-templates/hero-sidebar.html',
        TEMPLATE_EREWHON: '/partials/landing-templates/erewhon.html',
        TEMPLATE_SUMMERHILL: '/partials/landing-templates/summerhill.html',
        TEMPLATE_HERO_CAROUSEL: '/partials/landing-templates/hero-carousel.html',
        TEMPLATE_DOMS: '/partials/landing-templates/doms.html',
        TIN_BUILDING: '/partials/landing-templates/tin-building.html'
    };

    $routeProvider.caseInsensitiveMatch = true;

    var aboutUsPageTemplateUrl = ENV.aboutUs && ENV.aboutUs.timelineObj ? '/partials/about-timeline.html' : '/partials/about.html';

    $routeProvider
        .when('/', {templateUrl: TemplateEnum[ENV.landing.template.name], controller: 'landingCtrl'})
        .when('/locations', {templateUrl:'/partials/locations/locations.html', controller: 'locationCtrl'})
	    .when('/p/:page', {templateUrl:'/partials/client-pages/base-page.html', controller: 'landingCtrl'})
        .when('/deals', _showDealsPage())
        .when('/order', _showLandingPage('/partials/order-tabular-view.html'))
        .when('/products', _showLandingPage('/partials/products-landing.html'))
        .when('/rewards', _showRewardsPage('/partials/rewards/landing.html', 'rewardsCtrl'))
        .when('/my-rewards', _showRewardsPage('/partials/rewards/my-rewards.html', 'rewardsCtrl'))
        .when('/whats-next', {templateUrl:'/partials/whats-next.html', controller: 'landingCtrl'})
        .when('/whats-new', {templateUrl:'/partials/whats-new.html', controller: 'landingCtrl'})
        .when('/whats-new/:target', {templateUrl:'/partials/whats-new-content.html', controller: 'landingCtrl'})
        .when('/departments', {templateUrl:'/partials/departments.html', controller: 'landingCtrl'})
        .when('/product/:productId', {templateUrl:'/partials/product-details.html', controller: 'landingCtrl'})
        .when('/shop/:category', {templateUrl:'/partials/shop/category.html', controller: 'landingCtrl'})
        //.when('/shop/:category/:subcategory', {templateUrl:'/partials/shop/sub-category.html', controller: 'landingCtrl'})
        .when('/search', {templateUrl:'/partials/search/search-page.html', controller: 'landingCtrl', reloadOnSearch: false})
        .when('/password/forgot', {templateUrl:'/partials/password/forgot-password.html', controller: 'loginCtrl'})
        .when('/password/reset', {templateUrl:'/partials/password/reset-password.html', controller: 'loginCtrl'})
        .when('/signup', {templateUrl:'/partials/signup/signup.html', controller: 'signupCtrl'})
        .when('/signup/ecrs', {template:'<ecrs-signup></ecrs-signup>', reloadOnSearch: false})
        .when('/signup/erewhon/membership', {template:'<erewhon-membership></erewhon-membership>', reloadOnSearch: false})
        .when('/signup/erewhon/success', {template:'<erewhon-success></erewhon-success>', reloadOnSearch: false})
        .when('/social-signup-callback', {templateUrl:'/partials/signup/social-signup-callback.html', controller: 'signupCtrl'})
        .when('/login', {templateUrl:'/partials/login/login.html', controller: 'loginCtrl'})
        .when('/social-login-callback', {templateUrl:'/partials/login/social-login-callback.html', controller: 'loginCtrl'})
        .when('/app/auto-login', {templateUrl:'/partials/login/app-login.html', controller: 'loginCtrl'})
        .when('/app/auto-login/user', {templateUrl:'/partials/login/user-app-login.html', controller: 'loginCtrl'})
        .when('/app/init', {templateUrl:'/partials/landing/app-init.html', controller: 'landingCtrl'})
        .when('/my-account', {templateUrl:'/partials/user/my-account.html', controller: 'accountCtrl', reloadOnSearch: false})
        .when('/account-settings', { template:'<account-settings-v2></account-settings-v2>', reloadOnSearch: false })
        .when('/quote/:quoteId', { template:'<quote-details></quote-details>', reloadOnSearch: false })
        .when('/quote/:quoteId/checkout', { template:'<quote-checkout></quote-checkout>', reloadOnSearch: false })

        .when('/admin/manager-dashboard', { templateUrl: '/partials/admin/manager-dashboard.html', controller: 'adminCtrl'})
        .when('/admin/dashboard', { templateUrl: '/partials/admin/order/dashboard.html', controller: 'adminCtrl'})
        .when('/admin/order-history', { templateUrl: '/partials/admin/order/order-history.html', controller: 'adminCtrl'})
        .when('/admin/tip-summary', { templateUrl: '/partials/admin/order/tip-summary.html', controller: 'adminCtrl'})
        .when('/admin/dashboard/orders', { templateUrl: '/partials/admin/order/orders-dashboard.html',
                controller: 'adminCtrl',reloadOnSearch: false})
        .when('/admin/order', {templateUrl: '/partials/admin/order/order-details.html', controller: 'adminCtrl'})

        .when('/admin/create-order', {template:'<select-order-filters></select-order-filters>', reloadOnSearch: false})
        .when('/admin/create-order/cart', {template:'<for-user-cart></for-user-cart>', reloadOnSearch: false})
        .when('/admin/create-order/checkout', {template:'<for-user-checkout></for-user-checkout>', reloadOnSearch: false})
        .when('/admin/create-order/confirmation', {template:'<for-user-confirmation></for-user-confirmation>', reloadOnSearch: false})
        .when('/admin/create-order/add-items', {template:'<add-items-to-order></add-items-to-order>', reloadOnSearch: false})

        .when('/admin/quote/:quoteId', { template:'<quote-details is-admin-screen="true" back-link="/admin/quotes"></quote-details>', reloadOnSearch: false })
        .when('/admin/quote/:quoteId/checkout', { template:'<quote-checkout is-for-user="true"></quote-checkout>', reloadOnSearch: false })
        .when('/admin/quote/:quoteId/confirmation', { template:'<for-user-confirmation></for-user-confirmation>', reloadOnSearch: false })
        .when('/admin/quotes', { template:'<quotes></quotes>', reloadOnSearch: false })
        .when('/admin/create-quote', {template:'<select-order-filters is-quote="true"></select-order-filters>', reloadOnSearch: false})
        .when('/admin/create-quote/add-items', {template:'<add-items-to-order is-quote="true"></add-items-to-order>', reloadOnSearch: false})
        .when('/admin/create-quote/cart', {template:'<for-user-cart is-quote="true"></for-user-cart>', reloadOnSearch: false})
        .when('/admin/create-quote/checkout', {template:'<for-user-checkout is-quote="true"></for-user-checkout>', reloadOnSearch: false})
        .when('/admin/create-quote/confirmation', {template:'<for-user-confirmation is-quote="true"></for-user-confirmation>', reloadOnSearch: false})
        
        .when('/admin/users', {templateUrl: '/partials/admin/users/user-dashboard.html', controller: 'adminCtrl'})
        .when('/admin/users/all', {templateUrl: '/partials/admin/users/all-users.html', controller: 'adminCtrl'})
        .when('/admin/users/update', {templateUrl: '/partials/admin/users/update-user.html', controller: 'adminCtrl'})
        .when('/admin/users/approve', {templateUrl: '/partials/admin/users/approve-users.html', controller: 'adminCtrl'})
        .when('/admin/location', {templateUrl: '/partials/admin/location/location-dashboard.html', controller: 'adminCtrl'})
        .when('/admin/location/settings', { template: '<location-settings-v2></location-settings-v2>', reloadOnSearch: false })
        .when('/admin/location/bank-account', {templateUrl: '/partials/admin/location/bank-account.html', controller: 'adminCtrl'})
        .when('/admin/location/staff', {templateUrl: '/partials/admin/location/staffer.html', controller: 'adminCtrl'})

	    .when('/admin/reports', {templateUrl: '/partials/admin/reports/reports-dashboard.html', controller: 'adminCtrl'})
	    .when('/admin/reports/sales', {templateUrl: '/partials/admin/reports/sales-reports-dashboard.html', controller: 'adminCtrl'})
	    .when('/admin/reports/sales/daily', {templateUrl: '/partials/admin/reports/daily-sales.html', controller: 'adminCtrl', reloadOnSearch: false})
	    .when('/admin/reports/sales/weekly', {templateUrl: '/partials/admin/reports/weekly-sales.html', controller: 'adminCtrl', reloadOnSearch: false})
	    .when('/admin/reports/sales/monthly', {templateUrl: '/partials/admin/reports/monthly-sales.html', controller: 'adminCtrl', reloadOnSearch: false})

        .when('/admin/reports/movement', {templateUrl: '/partials/admin/reports/movement-reports-dashboard.html', controller: 'adminCtrl'})
        .when('/admin/reports/movement/daily', {templateUrl: '/partials/admin/reports/movement.html', controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/reports/movement/weekly', {templateUrl: '/partials/admin/reports/movement.html', controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/reports/movement/monthly', {templateUrl: '/partials/admin/reports/movement.html', controller: 'adminCtrl', reloadOnSearch: false})

        .when('/admin/reports/lostRevenue', {templateUrl: '/partials/admin/reports/lostRevenue.html', controller: 'reportsCtrl', reloadOnSearch: false})

        .when('/admin/reports/stripe', { template: '<stripe-payments></stripe-payments>', reloadOnSearch: false})

        .when('/admin/view-dashboards', { templateUrl: '/partials/admin/dashboards/view-dashboards.html', controller: 'adminCtrl' })
        .when('/admin/view-dashboards/dashboard', { template: '<report-dashboard></report-dashboard>', reloadOnSearch: false })


	    .when('/admin/rewards',
		    _showRewardsPage('/partials/admin/rewards/rewards-manager.html', 'adminCtrl'))

        .when('/admin/promotions', {template:'<promotions></promotions>', reloadOnSearch: false})
        .when('/admin/deliveries', {template:'<delivery-service></delivery-service>', reloadOnSearch: false})
        .when('/admin/products/bulk-ops/add', {template:'<bulk-add-products></bulk-add-products>', reloadOnSearch: false})
        .when('/admin/coupons', {template:'<coupons-main></coupons-main>', reloadOnSearch: false})

        .when('/admin/products', { templateUrl: '/partials/admin/product/product-dashboard.html',
	            controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/all', { templateUrl: '/partials/admin/product/all-products.html',
	            controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/out-of-stock', { templateUrl: '/partials/admin/product/out-of-stock-products.html',
	            controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/auto-added', { templateUrl: '/partials/admin/product/auto-added-products.html',
	            controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/inactive', { templateUrl: '/partials/admin/product/inactive-products.html',
                controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/homepage', { templateUrl: '/partials/admin/product/homepage-products.html',
                controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/bulk-ops', { templateUrl: '/partials/admin/product/bulk-product-operations.html',
	            controller: 'adminCtrl', reloadOnSearch: false})
        .when('/admin/products/bulk-update', {templateUrl: '/partials/admin/product/product-bulk-update.html', controller: 'adminCtrl'})
        .when('/admin/products/add', _showPage({templateUrl: '/partials/admin/product/add-product.html', controller: 'adminCtrl'}, 'enableAdminAddProduct', '/admin/products'))

        .when('/admin/modifiers', { template:'<all-modifiers></all-modifiers>', reloadOnSearch: false })
        .when('/admin/modifiers/create', { template:'<create-modifier></create-modifier>', reloadOnSearch: false })
        .when('/admin/modifiers/edit', { template:'<edit-modifier></edit-modifier>', reloadOnSearch: false })
        .when('/admin/modifiers/product', { template: '<product-modifiers></product-modifiers>', reloadOnSearch: false})

        .when('/deliveryPartner', _showPage({templateUrl: '/partials/deliveryPartner.html', controller: 'landingCtrl'}, 'deliveryPartner', '/products'))
        .when('/newLocation', _showPage({templateUrl: '/partials/newLocation.html', controller: 'landingCtrl'}, 'newLocation', '/products'))

        .when('/sale', _showPage({templateUrl: '/partials/sale.html', controller: 'landingCtrl'}, 'salesPage', '/products'))

        .when('/checkout/table-side', { templateUrl: '/partials/cart/table-side-checkout.html', controller: 'cartCtrl'})

        .when('/cart', { templateUrl: '/partials/cart/cart.html', controller: 'cartCtrl'})
        .when('/cart/checkout', _showCheckoutPage())
        .when('/cart/checkout/confirm', {templateUrl:'/partials/cart/checkout-confirm.html',
            controller: 'cartCtrl', reloadOnUrl:true})
        
        .when('/terms-and-conditions', {templateUrl:'/partials/legal/terms-and-conditions.html', controller: 'landingCtrl'})
        .when('/privacy-policy', {templateUrl:'/partials/legal/privacy-policy.html', controller: 'landingCtrl'})
        .when('/about', {templateUrl: aboutUsPageTemplateUrl, controller: 'locationCtrl'})
        .when('/contact', {templateUrl:'/partials/contact.html', controller: 'locationCtrl'})
        .when('/faq', {templateUrl:'/partials/faq.html', controller: 'landingCtrl'})
        .when('/404', {templateUrl:'/partials/404.html', controller: 'landingCtrl'})
        .when('/sso', {template:'<login-sso></login-sso>', reloadOnSearch: false})
        .when('/:redirectKey', {templateUrl:'/partials/redirect.html', controller: 'landingCtrl'})
        .when('/table-side/error', {template:'<table-side-error></table-side-error>'})
        .when('/admin/loyalty-dashboards', { templateUrl: '/partials/admin/dashboards/loyalty-dashboard.html'})
        .when('/admin/loyalty-dashboards/loyalty-analytics', { template: '<loyalty-dashboards type="loyaltyAnalytics"></loyalty-dashboards>'})
        .when('/admin/loyalty-dashboards/electronic-journal', { template: '<loyalty-dashboards type="electronicJournal"></loyalty-dashboards>'})
        .otherwise({
            redirectTo: '/404'
        });

}]);

angular.module('config', []).constant('ENV',{"disableTip":false,"enableHiddenHealthClaims":false,"allowToPackLessLB":false,"allAdminFieldsEditable":true,"scripts":[{"string":"<!-- Facebook Pixel Code --> \n<script> \n!function(f,b,e,v,n,t,s) \n{if(f.fbq)return;n=f.fbq=function(){n.callMethod? \nn.callMethod.apply(n,arguments):n.queue.push(arguments)}; \nif(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0'; \nn.queue=[];t=b.createElement(e);t.async=!0; \nt.src=v;s=b.getElementsByTagName(e)[0]; \ns.parentNode.insertBefore(t,s)}(window, document,'script', 'https://connect.facebook.net/en_US/fbevents.js'); \nfbq('init', '693183878020576'); \nfbq('track', 'PageView'); \n</script> \n<noscript><img height=\"1\" width=\"1\" style=\"display:none\" src=\"https://www.facebook.com/tr?id=693183878020576&ev=PageView&noscript=1\"; /></noscript> \n<!-- End Facebook Pixel Code -->\n\n<!-- Global site tag (gtag.js) - Google Analytics --> \n<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-8Z3WVSM2L2\"></script>;\n<script> \nwindow.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'AW-429568383');\n</script>\n","source":"index.html","marker":"</body>"},{"string":"<!-- Event snippet for Purchases conversion page --> <script> \n                        gtag('event', 'conversion', { 'send_to': 'AW-429568383/6mvLCK3rpf0BEP_i6swB', 'transaction_id': '' }); </script>","source":"partials/cart/checkout-confirm.html"}],"apiEndPoint":"https://partnersapi.gethomesome.com","apiEndPointEast":"https://partnersapi-east.gethomesome.com","storeAdminUrl":"https://store-admin.homesome.com","gMapKey":"AIzaSyB9M2NAsFjHgWzeOZT3j95cAZwrh_En1ak","stripePublishableKey":"pk_live_tuQUR3UyhLcc7c39iudpQz2K","vgsConfig":{"vaultId":"tntkweoambp","env":"live"},"FB":null,"googleClientId":null,"gaID":"UA-111381992-1","reservation":{"enabled":false,"url":""},"externalMenu":{"enabled":false,"url":""},"productLinkText":"Products","theme":{"primary":"#e32228","primaryHover":"#ba0c19","secondary":"#088e4b","secondaryHover":"#036632","tertiary":"#f9a41a","tertiaryHover":"#e08500"},"APIKey":"F848FD68-E12A-49E8-8A02-ABA76636A701","aboutLinkLocation":"footer","faqLinkLocation":"footer","allProducts":{"categories":{"Default":{"heroImage":"../images/hero-images/icc-header-default.jpg","seoImage":"/images/hero-images/icc-header-default.jpg"},"Bakery":{"heroImage":"../images/hero-images/bakery.jpg","seoImage":"/images/hero-images/bakery.jpg"},"IndianPantry":{"heroImage":"../images/hero-images/indian-pantry.jpg","seoImage":"/images/hero-images/indian-pantry.jpg"},"DairyEggs":{"heroImage":"../images/hero-images/dairy-eggs.jpg","seoImage":"/images/hero-images/dairy-eggs.jpg"},"Snacks":{"heroImage":"../images/hero-images/snacks.jpg","seoImage":"/images/hero-images/snacks.jpg"},"RicePasta":{"heroImage":"../images/hero-images/rice-pasta.jpg","seoImage":"/images/hero-images/rice-pasta.jpg"},"RiceNoodles":{"heroImage":"../images/hero-images/rice-pasta.jpg","seoImage":"/images/hero-images/rice-pasta.jpg"},"Fruits":{"heroImage":"../images/hero-images/fruits.jpg","seoImage":"/images/hero-images/fruits.jpg"},"Beverages":{"heroImage":"../images/hero-images/beverages.jpg","seoImage":"/images/hero-images/beverages.jpg"},"CannedGoods":{"heroImage":"../images/hero-images/canned-goods.jpg","seoImage":"/images/hero-images/canned-goods.jpg"},"Vegetables":{"heroImage":"../images/hero-images/vegetables.jpg","seoImage":"/images/hero-images/vegetables.jpg"},"Babies":{"heroImage":"../images/hero-images/babies.jpg","seoImage":"/images/hero-images/babies.jpg"},"MeatSeafood":{"heroImage":"../images/hero-images/meat-seafood.jpg","seoImage":"/images/hero-images/meat-seafood.jpg"},"Pantry":{"heroImage":"../images/hero-images/pantry.jpg","seoImage":"/images/hero-images/pantry.jpg"},"Breakfast":{"heroImage":"../images/hero-images/breakfast.jpg","seoImage":"/images/hero-images/breakfast.jpg"},"Deli":{"heroImage":"../images/hero-images/deli.jpg","seoImage":"/images/hero-images/deli.jpg"},"Frozen":{"heroImage":"../images/hero-images/frozen.jpg","seoImage":"/images/hero-images/frozen.jpg"},"OrganicVegetables":{"heroImage":"../images/hero-images/organic-vegetables.jpg","seoImage":"/images/hero-images/organic-vegetables.jpg"},"OrganicFruits":{"heroImage":"../images/hero-images/organic-fruits.jpg","seoImage":"/images/hero-images/organic-fruits.jpg"},"Pulses":{"heroImage":"../images/hero-images/pulses.jpg","seoImage":"/images/hero-images/pulses.jpg"},"MealKits":{"heroImage":"../images/hero-images/meal-kits.jpg","seoImage":"/images/hero-images/meal-kits.jpg"},"Flours":{"heroImage":"../images/hero-images/flours.jpg","seoImage":"/images/hero-images/flours.jpg"},"HealthBeauty":{"heroImage":"../images/hero-images/health-beauty.jpg","seoImage":"/images/hero-images/health-beauty.jpg"},"Household":{"heroImage":"../images/hero-images/household.jpg","seoImage":"/images/hero-images/household.jpg"}}},"isRestaurant":false,"enableRewards":true,"enableDarkMode":false,"enableDarkModeHeader":false,"enableDarkModeSignup":false,"enableDarkModeFooter":false,"enableTransparentHeader":false,"socialHeader":false,"socialFooter":false,"rewardsConfig":{"landing":{"hero":{"heading":"Introducing<br>India Cash and Carry Rewards","desc":"India Cash and Carry Rewards Program lets you earn points for every dollar spent with us 'In Store' or Online. Points can be redeemed for Discounts or Free Items.","image":"icc-hero.svg"},"howToJoin":{"heading":"How to Join","desc":"All you need is a phone number to join! Sign Up during Checkout at Store or Online. One Phone Number = One Account, 'In Store' or Online.","options":[{"heading":"In Store","desc":"Provide your phone number when prompted during Checkout & Boom! You are a Rewards Member. You will earn points for every dollar spent at any of our stores.","image":"free-curbside-pickup.svg"},{"heading":"Online","desc":"If you are new to Rewards Program, you are automatically enrolled when you place your first Online Order. Or our system links with the account created 'In Store' based on the phone number.","image":"cash-and-carry-logo.svg"}],"cta":[{"btnText":"Sign up","href":"/signup","target":""},{"btnText":"Login","href":"/login","target":""}]},"howItWorks":{"heading":"How It Works","desc":"As a Rewards Member you earn Points on every dollar you spend at India Cash and Carry. Points add up to Rewards in as few as 2 - 3 visits.","sections":[{"id":1,"title":"Shop India Cash & Carry","description":"Shop 'In Store' or Online the way you do. Earn points for every dollar you spend with us.","image":"icc-shop.svg"},{"id":2,"title":"Earn Points","description":"Earn 10 Points for every dollar spent 'In Store' or Online. Points add up to rewards quickly, in as few as 2 - 3 vists.","image":"icc-earnpoints.svg"},{"id":3,"title":"Redeem Rewards","description":"Redeem Rewards for Discounts or Free items. Save even more at India Cash and Carry, your most favorite Indian Store.","image":"icc-redeem-rewards.svg"}],"cta":[{"btnText":"Sign up","href":"/signup","target":""},{"btnText":"Login","href":"/login","target":""}]}}},"showAllProducts":false,"showProductsPage":true,"showOrderPage":false,"showCreditCardHoldMsg":true,"showCheckDeliveryArea":false,"enablePopupImageZoom":true,"hideTipInfo":false,"acceptCreditCard":true,"hideItemUnit":false,"enableBagCount":true,"enableLocations":true,"enablePriceList":true,"enablePriceSync":true,"enableItemInstructions":true,"customDeliveryTime":false,"customItem":false,"adminCustomItem":true,"showCategoryBanner":true,"showDealsPage":true,"showWhatsNewPage":true,"enableOrderDate":true,"driverTip":true,"showTax":true,"ip":true,"exportToQB":false,"invoicePrinting":false,"receiptPrinting":true,"labelPrinting":false,"showBusinessName":false,"folderLocation":"icc","defaultFulfillmentMethod":"delivery","fulfillmentOptions":{"pickup":true,"delivery":true,"shipping":false},"admin":{"manageUsers":false},"signupFields":{"businessName":false,"address":false,"phoneNumber":false},"categoryOrder":{"GaneshChaturthi":"","DiwaliSpecials":"","Specials":"","FreshSweets":"","HomestyleFood":"","CutVegetables":"","FruitsVegetables":"","DairyEggs":"","Snacks":"","Pulses":"","Pantry":"","MealKits":"","RiceNoodles":"","Flours":"","Bakery":"","Beverages":"","Frozen":"","HealthBeauty":"","Household":"","Appetizers":"","RotisChapati":"","BreadsNMore":"","Entrees":"","Desserts":""},"categoryDescription":{},"subCategoryOrder":{},"FAQ":[{"id":1,"ques":"What is India Cash & Carry?","ans":"India Cash & Carry is Bay Area's most favorite store for Indian & ethnic groceries. You can learn more about us <a href='/about'>here</a>."},{"id":2,"ques":"Where are India Cash & Carry stores located?","ans":"Our stores are conveniently located all over the Bay Area. You can learn more <a href='/contact'>here</a>."},{"id":3,"ques":"What is indiacashandcarry.com?","ans":"indiacashandcarry.com is our website where you can conveniently order any of our products sold at our physical store."},{"id":4,"ques":"Do I need to create an account to use indiacashandcarry.com?","ans":"You do not need an account to browse the products or build your shopping cart. But an account is required to place an order."},{"id":5,"ques":"How are the online orders fulfilled?","ans":"You can either choose to \"Pick Up\" your order at our store or have it Delivered to your address of choice."},{"id":6,"ques":"Can I choose \"Pick Up\" or Delivery time?","ans":"Absolutely! You choose Pick Up or Delivery Time of your preference before placing an order."},{"id":7,"ques":"Do you offer Same Day Delivery or \"Pick Up\"?","ans":"Absolutely! We take a huge pride in offering convenience of the Same Day Delivery & \"Pick Up\"."},{"id":8,"ques":"Is there any Cut-Off time for the Same Day Delivery or \"Pick Up\"","ans":"No specific Cut-Off time for the Same Day orders. Our system shows earliest available Delivery & Pick Up times during Checkout before you place an order."},{"id":9,"ques":"Is there any minimum to place an order?","ans":"All the information about minimum order requirement is shown while placing the order during the checkout flow."},{"id":10,"ques":"Is there any fee for Pick Up?","ans":"No fee for Pick Up. Just place an order and stop by our store at your \"Pick Up\" time."},{"id":11,"ques":"Is there any minimum order for Free Delivery?","ans":"For your convenience, all the information about delivery fees or the free delivery, if is is offered, is always shown during the checkout flow before placing an order."},{"id":12,"ques":"How much is the Delivery Fee if my order doesnt meet minimum?","ans":"For your convenience, all the information about delivery fees is always shown during the checkout flow before placing an order."},{"id":13,"ques":"What if an item I ordered is not available?","ans":"It happens in rare situations! Our store representative will contact you to get a replacement input. You can always ask us to remove the item that is unavailable."},{"id":14,"ques":"If removed items cause my total to go below minimum, will I be charged a Delivery Fee?","ans":"No. If you are not charged a Delivery Fee at the Checkout, you wont be charged a Delivery Fee later."},{"id":15,"ques":"What is your return policy?","ans":"All the claims must be made within 24 hours of \"Pick Up\" or Delivery time. You are 100% covered for quality satisfaction, if something doesnt meet your expectations, just let us know and we will refund you in full."},{"id":16,"ques":"Can I make changes to the order once it is placed?","ans":"All the requests for changes must be made before the order is Picked Up or is out for Delivery. After that, no changes can be made to the order."},{"id":17,"ques":"If I ordered an item that I no longer need, do you provide a refund or exchange?","ans":"All the requests for Removing an Item must be made before the order is Picked Up or is out for Delivery. After that, no changes can be made to the order."},{"id":18,"ques":"Why is my credit card charged different amount than my order total?","ans":"When you place your order, instead of immediately charging your card, we place a temporary authorization hold for an amount slightly higher than your order total at checkout.  We place this authorization hold in case your total turns out to be higher due to added items, replacement items, or weight adjustments. After the order is complete, the hold will drop off, and your card will be charged for the final total as shown in the email receipt. The final charge will appear on the statement within 7 business days after order completion."},{"id":19,"ques":"How can I contact further if I need more information?","ans":"You can Contact Us using <a href='/contact'>this</a>."}],"logoFileName":"cash-and-carry-logo.svg","logo":{"src":"../images/logo/cash-and-carry-logo.svg"},"name":{"companyName":"India Cash & Carry","heading":"India Cash & Carry Store At Your Fingertips!","tagline":"Always Fresh!"},"landing":{"heroImage":"","template":{"name":"TEMPLATE_SIGNATURE","heroData":{"logo":"../images/logo/cash-and-carry-logo.svg","heading":"Always Fresh!","subHeading":"Bay Area's most favorite grocery store now at your fingertips."}},"hasMetadata":false,"metadata":[],"howItWorks":{"type":"DELIVERY_AND_PICKUP","heading":"Here's How It Works","subHeading":"India Cash & Carry Store At Your Fingertips!","sections":[{"id":1,"title":"India Cash & Carry Online","description":"Your most favorite grocery store, your most trusted brand, now at your fingertips! Order Online, pick up from the store or get groceries conveniently delivered to your home.","image":"cash-n-carry-logo.svg"},{"id":2,"title":"Free Same Day Delivery","description":"Get your groceries delivered in as little as two hours or at the time of your choice. We bring the entire India Cash & Carry store to you.","image":"free-same-day-delivery.svg"},{"id":3,"title":"Free Curbside Pick Up","description":"Skip the line! Order online & conveniently pick up at the store location of your choice. No Lines No Rush! Groceries done with a few clicks from the comfort of your couch!","image":"free-curbside-pickup.svg"},{"id":4,"title":"100% Satisfaction Guaranteed","description":"Always Fresh, Guaranteed! India Cash & Carry's great Quality, Savings & Customer Service, now available Online.","image":"satisfaction-guaranteed.svg"}]}},"aboutUs":{"heroImage":"../images/client-assets/icc/about-image.jpg","sections":[{"title":"About India Cash & Carry","description":"India Cash and Carry is the one stop shop for all your South East Asian grocery needs. We carry the largest assortment of Indian groceries: produce, dairy, rice, grains, nuts, spices, snacks, ice cream, organic products, you name it, we got it! Since early 2000s, our mission has been, and always will be to provide customers the \"Always Fresh\" grocery products at great prices."},{"title":"Where can you find us?","description":"Our stores are conveniently located all over the San Francisco Bay Area. You can also order all our products online for store pickup or fast free delivery: <a href=\"/products\">Here</a>"},{"title":"Why India Cash & Carry?","description":"India Cash & Carry is Bay Area's most favorite Indian grocery store. We are the grocery experts! Our staff works tirelessly & meticulously to ensure every product on our shelves is \"Always Fresh\" & meets the highest quality standards. Our innovative supply chain & procurement process enables us to bring you the best products from around the world at great prices. Come by and visit one of our stores, or Order Online <a href=\"/products\">Here</a>"}]},"contact":{"fullAddress":"1032 E El Camino Real, Sunnyvale, CA 94087","address":{"street1":"1032 E El Camino Real","street2":"","city":"Sunnyvale","state":"CA","zip":"94087"},"lat":37.351363,"lng":-122.005734},"locations":false,"legal":{"legalName":"India Cash & Carry, Inc.","website":"https://www.indiacashandcarry.com","contactEmail":" indiacashandcarry@gmail.com ","terms":{"title":"Terms of Use","opening":"Welcome to the India Cash & Carry Application (defined below). By using it, you are agreeing to these Terms of Use (defined below). Please read them carefully. If you have any questions, contact us at1032 E El Camino Real, Sunnyvale, CA 94087.<br> These Terms of Use were last updated on October 9, 2015.","sections":[{"title":"ACCEPTANCE OF TERMS OF USE","description":"India Cash & Carry, Inc.(\"India Cash & Carry\" \"we\" or \"us\" or \"our\") owns and operates the website, www.indiacashandcarry.com, the mobile web, the mobile app and the touch versions and any sites we have now or in the future that reference these Terms of Use (collectively, \"Application\"). By using the Application and India Cash & Carry's services through the Application, you agree to these Terms of Use (defined below) and any additional terms applicable to certain programs in which you may elect to participate. You also agree to our Privacy Statement, located at www.indiacashandcarry.com/privacy-policy, and acknowledge that you will regularly visit the Terms of Use (defined below) to familiarize yourself with any updates. The Privacy Statement, together with these terms of use, and any other terms contained herein or incorporated herein by reference, are collectively referred to as the \"Terms of Use.\" The term \"using\" also includes any person or entity that accesses or uses the Application with crawlers, robots, data mining or extraction tools or any other functionality.IF YOU DO NOT AGREE TO THESE TERMS OF USE, IMMEDIATELY STOP USING THE APPLICATION AND DO NOT USE ANY India Cash & Carry SERVICE, PARTICIPATE IN ANY PROGRAM, REDEEM ANY VALIDATED USER REDEMPTION VOUCHER OR USE ANY PRODUCT OR OTHER GOOD OR SERVICE OFFERED THROUGH THE APPLICATION."},{"title":"About the Application","description":"The Application is a platform through which Registered Users order groceries and have them delivered to a specified location. Over time and use, the Application will learn the Registered User's grocery habits and begin to propose a weekly grocery basket. All available grocery and delivery programs on the Application may change at any time in India Cash & Carry's discretion, without notice."},{"title":"Ownership of the Application","description":"The Application, any content on the Application and the infrastructure used to provide the Application are proprietary to us, our affiliates and other content providers. By using the Application and accepting these Terms of Use: (a) India Cash & Carry grants you a limited, personal, nontransferable, nonexclusive, revocable license to use the Application pursuant to these Terms of Use and to any additional terms and policies set forth by India Cash & Carry; and (b) you agree not to reproduce, distribute, create derivative works from, publicly display, publicly perform, license, sell or re-sell any content, products or services obtained from or through the Application without the express permission of India Cash & Carry."},{"title":"Use of the Application","description":"As a condition of your use of the Application, you agree that:<br> You are at least 16 years of age;<br> You are able to create a binding legal obligation;<br> You are not barred from receiving products or services under applicable law;<br> You will not attempt to use the Application with crawlers, robots, data mining or extraction tools or any other functionality;<br> You r use of the Application will at all times comply with these Terms of Use;<br> You will only engage in transactions that comply with the letter and spirit of the terms of the respective offers;<br> You have the right to provide any and all information you submit to the Application, the information and all such information is accurate, true, current and complete; and <br> You will update and correct information you have submitted to the Application and ensure that it is accurate at all times (out-of-date information will invalidate your account). <br>If you are 16 or older but under the age of majority (which is 18 years old in most states), then your parent or guardian may be liable for some or all of your activities on the Application. Because of this, and because it is prudent for your parent or guardian to be aware of your activities, including the websites that you visit, you should make your parent or guardian aware that you are using the Application  as this Terms of Service and your use of the Application affect their legal rights and obligations.<br>If you have any requests for order cancellations, please call us on the phone number provided on the Contact page.<br>If you have any requests for refunds or returns of the items in the order, please call us on the phone number provided on the Contact page. All the requests for refunds or returns must be initiated within 24 hours of your receiving of the items."},{"title":"Access to the Application","description":"India Cash & Carry retains the right, at our sole discretion, to deny service or use of the Application or an account to anyone at any time and for any reason. While we use reasonable efforts to keep the Application and your account accessible, the Application and/or your account may be unavailable from time to time. You understand and agree that there may be interruptions in service or events, Application access or access to your account due to circumstances both within our control (e.g., routine maintenance) and outside of our control."},{"title":"Modification","description":"We reserve the right at all times to discontinue or modify any part of these Terms of Use in our sole discretion. If we make changes that affect your use of the Application or our services we will post notice of the change on the Application. If you have an account on the Application, any changes to these Terms of Use will be effective upon our notice of the changes on the Application. If you do not agree to the changes, you may close your account without penalty and you should not use the Application or any services offered through the Application after the effective date of the changes. If you do not have an account, any changes will be effective immediately for new and existing users of the Application. We suggest that you revisit our Terms of Use regularly to ensure that you stay informed of any changes. Your use of the Application after we update these Terms of Use will constitute acceptance of the modified Terms of Use."},{"title":"Your Account","description":"In order to use the Application, you will have to provide your (i) first name; (ii) last name; (iii) email address; (iv) delivery location; (v) payment information; and, (vi) set an account password. The required information you will have provided is referred to herein as your Account. <br>In addition, as you use the Application, we will collect certain information regarding your usage or actions. For example, to provide the most accurate weekly grocery proposal, we may store your grocery lists for future reference. We use the information we gather from your use of the Application in accordance with the terms of our Privacy Policy which is located at www.indiacashandcarry.com/privacy-policy.<br>You may only hold one Account on the Application for your personal use. When you agree to these Terms of Use, you represent that you will have only one Account and that you will use your Account as a bona fide consumer and with no intent to defraud India Cash & Carry.<br>You are responsible for updating and correcting information you have submitted to create or maintain your Account. You understand and agree that India Cash & Carry shall have no responsibility for any incident arising out of, or related to, your Account. You are solely responsible for maintaining the security of your Account. We will assume that anyone using the Application or transacting through your Account is you. You agree that you are solely responsible for any activity that occurs under your Account. You will be persistently logged into the Application unless you choose to delete the Application from your mobile device or we terminate your Account.<br>Your Account is non-transferrable. You cannot sell, combine, or otherwise share it with any other person. Any violation of these Terms of Use, including failure to maintain updated and correct information about your Account, may cause us to cancel your Account in our sole discretion. If your Account is cancelled, you will forfeit any pending, current or future promotional vouchers and any other forms of unredeemed value in your Account. Upon termination, the provisions of these Terms of Use that are by their nature intended to survive termination (e.g., any disclaimers, all limitations of liability and all indemnities) shall survive. We also reserve the right to change or discontinue any aspect or feature of our services or the Application, including, but not limited to, requirements for use."},{"title":"Your Conduct","description":"All interactions on the Application must comply with these Terms of Use. To the extent your conduct, in our sole discretion, restricts or inhibits any other user from using or enjoying any part of the Application, we may limit your privileges on the Application and seek other remedies. The following activities are prohibited on the Application and constitute express violations of these Terms of Use: Submitting any content to the Application that: Violates applicable laws (including but not limited to intellectual property laws, laws relating to rights of privacy and rights of publicity and laws related to defamation); Contains personal information, except when we expressly ask you to provide such information; Contains viruses or malware; Offers unauthorized downloads of any copyrighted, confidential or private information; Has the effect of impersonating others; Contains messages by non-spokesperson employees of India Cash & Carry purporting to speak on behalf of India Cash & Carry or provides confidential information concerning India Cash & Carry; Is purposely inaccurate, commits fraud or falsifies information in connection with your India Cash & Carry account or to create multiple India Cash & Carry accounts; or Is protected by copyright, trademark or other proprietary right without the express permission of the owner of the copyright, trademark or other proprietary right. Attempting to do or actually doing any of the following: Accessing data not intended for you, such as logging into a server or an account which you are not authorized to access; Scanning or monitoring the Application for data gathering purposes in an effort to track sales, usage, aggregate offering information, pricing information or similar data; Scanning or testing the security or configuration of the Application or to breach security or authentication measures; or Interfering with service to any user in any manner, including, without limitation, by means of submitting a virus to the Application or attempting to overload, flood, spam, mail bomb or crash the Application. Using any of the following: Frames, framing techniques or framing technology to enclose any content included on the Application without our express written permission; Any Application content, including without limitation User Content (defined below), in any meta tags or any other hidden text techniques or technologies without our express written permission; The Application or any of its contents to advertise or solicit, for any commercial, political or religious purpose or to compete, directly or indirectly, with India Cash & Carry; or The Application or any of its resources to solicit consumers or other third-parties to become users or partners of other online or offline services directly or indirectly competitive or potentially competitive with India Cash & Carry, including, without limitation, aggregating current or previously offered deals. Collecting any of the following: Content from the Application, including, but not limited to, in connection with current or previously offered deals, and featuring such content to consumers in any manner that diverts traffic from the Application without our express written permission; or Personal Information (defined in our Privacy Statement), User Content (defined in Section 10 below) or content of any consumers. Engaging in any of the following: Tampering or interfering with the proper functioning of any part, page or area of the Application or any functions or services provided by India Cash & Carry; Taking any action that places excessive demand on our services or imposes, or may impose, an unreasonable or disproportionately large load on our servers or other portion of our infrastructure (as determined in our sole discretion); Reselling or repurposing your access to the Application; Accessing, monitoring or copying any content from the Application using any robot, spider, scraper or other automated means or any manual process for any purpose without our express written permission; Violating the restrictions in any robot exclusion headers on the Application or bypassing or circumventing other measures employed to prevent or limit access to the Application; Aggregating any current or previously-offered deals or content or other information from the Application (whether using links or other technical means or physical records associated with purchases made through the Application) with material from other sites or on a secondary site without our express written permission; Deep-linking to any portion of the Application without our express written permission; Hyperlinking to the Application from any other website without our initial and ongoing consent; or Acting illegally or maliciously against the business interests or reputation of India Cash & Carry or our services."},{"title":"Your Privacy","description":"We take the privacy of your personal data seriously. We encourage you to carefully review our Privacy Statement for important disclosures about ways that we may collect, use, and share personal data and your choices. Our Privacy Statement is incorporated in these Terms of Use, and available here."},{"title":"Copyright and Trademarks","description":"The Application contains copyrighted material, trademarks and other proprietary information, including, but not limited to, text, software, photos, video, graphics, music and sound and the entire contents of the Application are protected by copyright, trademark and other intellectual property laws of the United States. India Cash & Carry' owns a copyright in the selection, coordination, arrangement and enhancement of such content, as well as in the content original to it. You may not modify, distribute, publish, transmit, publicly display, publicly perform, participate in the transfer or sale, create derivative works or in any way exploit any of the content, in whole or in part. Except as otherwise expressly stated under copyright law, no downloading, copying, redistribution, retransmission, publication or commercial exploitation of the content without the express permission of India Cash & Carry or the copyright owner is permitted. If downloading, copying, redistribution, retransmission or publication of copyrighted material is permitted, you will make independent attribution and/or make no changes in or deletion of any author attribution, trademark legend or copyright notice. You acknowledge that you do not acquire any ownership rights by downloading copyrighted material. Any violation of these restrictions may result in a copyright, trademark or other intellectual property right infringement that may subject you to civil and/or criminal penalties.You will not upload, post or otherwise make available on the Application any material protected by copyright, trademark or other proprietary right without the express permission of the owner of the copyright, trademark or other proprietary right. India Cash & Carry does not have any express burden or responsibility to provide you with indications, markings or anything else that may aid you in determining whether the material in question is copyrighted or trademarked. You will be solely liable for any damage resulting from any infringement of copyrights, trademarks, proprietary rights or any other harm resulting from such a submission.India Cash & Carry USA, Inc.. owns trademarks, registered and unregistered in the United States and India Cash & Carry, the India Cash & Carry logo and variations thereof found on the Application are trademarks owned by India Cash & Carry USA, Inc.. or its related entities and all use of these marks inures to the benefit of India Cash & Carry USA, Inc..Other marks on the Application not owned by India Cash & Carry may be under license from the trademark owner thereof, in which case such license is for the exclusive benefit and use of India Cash & Carry unless otherwise stated, or may be the property of their respective owners. You may not use India Cash & Carrys name, logos, trademarks or brands without India Cash & Carrys express permission."},{"title":"User Content","description":"The Application may provide registered users and visitors various opportunities to submit or post reviews, opinions, advice, ratings, discussions, comments, messages, survey responses and other communications and other content (collectively, \"User Content\") through forums, bulletin boards, discussion groups, chat rooms, surveys, blogs or other communication facilities that may be offered on, through, or in connection with the Application from time to time. You may be required to have a India Cash & Carry account to submit User Content. If you contribute any User Content, you represent and warrant that: (a) you are the creator the User Content; or (b) if you are acting on behalf of the creator, that you have (i) express, advance authority from the creator to submit or post the User Content, and (ii) all rights necessary to grant the licenses and grants in these Terms of Use. You further represent and warrant (or, if you are acting on behalf of the creator of the User Content, you have assured that the creator represents and warrants) that the sharing of the User Content for the purposes you have selected will not violate or infringe any copyrights, trademarks or any other intellectual property rights or rights of third parties, including the rights of publicity or privacy. You represent and warrant that you will not upload, post, transmit or otherwise make available User Content that is unlawful, harmful, tortious, threatening, abusive, harassing, hateful, racist, infringing, pornographic, obscene, violent, misleading, defamatory or libelous, invasive of the privacy of another person or violative of any third-party rights; or if User Content contains any material that harbors viruses or any other computer codes, files or programs designed to interrupt, destroy or limit the functionality of any software or computer equipment. India Cash & Carry' shall have the sole and absolute right, but not the obligation, to review, edit, post, refuse to post, remove, monitor the User Content and disclose the User Content and the circumstances surrounding its transmission to any third-party, at any time, for any reason, including to determine compliance with these Terms of Use and any operating rules established by India Cash & Carry as well as to satisfy any applicable law, regulation or authorized government request. Without limiting the foregoing, India Cash & Carry shall have the right to remove any material from the Application in its sole and absolute discretion. India Cash & Carry assumes no liability for any User Content or other information that appears or is removed from the Application or elsewhere. India Cash & Carry has no obligation to use User Content and may not use it at all. In some instances and from time to time, it may be possible to modify or remove the User Content submitted or posted through your account. India Cash & Carry makes no representations or warranties that the User Content you modify or remove will be modified or removed from the Application or elsewhere, or that the User Content will cease to appear on the Internet, in search engines, social media websites, or in any other form, media or technology."},{"title":"Public Nature of Your User Content.","description":"You understand and agree that User Content is public. Any person (whether or not a user of India Cash & Carrys services) may read your User Content without your knowledge. Please do not include any Personal Information in your User Content unless you wish for it to be publicly disclosed. India Cash & Carry is not responsible for the use or disclosure of any Personal Information that you disclose in connection with User Content. Any User Content of any kind made by you or any third-party is made by the respective author(s) or distributor(s) and not by India Cash & Carry. Other users may post User Content that is inaccurate, misleading or deceptive. India Cash & Carry does not endorse and is not responsible for any User Content, and will not be liable for any loss or damage caused by your reliance on such User Content. User Content reflects the opinions of the person submitting it and may not reflect the opinion of India Cash & Carry. India Cash & Carry does not control or endorse any User Content, and specifically disclaims any liability concerning or relating to your contribution of, use of, or reliance on any User Content and any actions resulting from your participation in any part of the Application, including any objectionable User Content."},{"title":"Disclaimer of Warranty","description":"YOU EXPRESSLY AGREE THAT USE OF THE APPLICATION IS AT YOUR SOLE RISK. NONE OF India Cash & Carry, Inc., ITS SUBSIDIARIES OR AFFILIATES OR ANY OF THEIR RESPECTIVE EMPLOYEES, AGENTS, THIRD-PARTY CONTENT PROVIDERS OR LICENSORS OR ANY OF THEIR OFFICERS, DIRECTORS, EMPLOYEES OR AGENTS, WARRANT THAT USE OF THE APPLICATION WILL BE UNINTERRUPTED, SECURE, VIRUS-FREE OR ERROR FREE, NOR DO THEY MAKE ANY WARRANTY AS TO (A) THE RESULTS THAT MAY BE OBTAINED FROM USE OF THE APPLICATION, OR (B) THE ACCURACY, COMPLETENESS OR RELIABILITY OF (I) THE CONTENT ON THE APPLICATION, INCLUDING WITHOUT LIMITATION AVAILABLE PROGRAMS, (II) OR USER CONTENT PROVIDED THROUGH THE APPLICATION. THE APPLICATION AND ALL CONTENT, USER CONTENT AND OTHER INFORMATION CONTAINED ON THE APPLICATION, OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION, ARE MADE ACCESSIBLE OR AVAILABLE ON AN AS IS AND AS AVAILABLE BASIS. TO THE EXTENT ALLOWED BY APPLICABLE LAW, India Cash & Carry HEREBY DISCLAIMS ANY AND ALL REPRESENTATIONS, WARRANTIES AND CONDITIONS, WHETHER EXPRESS OR IMPLIED, AS TO THE OPERATION OF THE APPLICATION OR THE CONTENT, USER CONTENT OR OTHER INFORMATION CONTAINED ON THE APPLICATION OR OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION, INCLUDING, BUT NOT LIMITED TO, THOSE OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, SUITABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AS WELL AS WARRANTIES IMPLIED FROM A COURSE OF PERFORMANCE OR COURSE OF DEALING."},{"title":"Limitation of Liability","description":"IN NO EVENT SHALL India Cash & Carry, Inc.., ITS SUBSIDIARIES OR AFFILIATES OR ANY OF THEIR RESPECTIVE EMPLOYEES, OFFICERS, DIRECTORS, AGENTS, PARTNERS, THIRD-PARTY CONTENT PROVIDERS OR LICENSORS, OR ANY OF THEIR OFFICERS, DIRECTORS, EMPLOYEES OR AGENTS, BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES ARISING OUT OF OR RELATED TO: (A) YOUR USE OF THE APPLICATION, THE CONTENT, USER CONTENT AND OTHER INFORMATION CONTAINED IN THE APPLICATION; (B) PRODUCTS DELIVERED THROUGH THE India Cash & Carry APPLICATION; (C) YOUR INABILITY TO USE THE APPLICATION; (D) MODIFICATION OR REMOVAL OF CONTENT SUBMITTED ON THE APPLICATION; (E) OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION; OR (F) THESE TERMS OF USE. TOTAL AGGREGATE LIABILITY ARISING OUT OF OR RELATED TO THESE TERMS OF USE SHALL NOT EXCEED ONE HUNDRED DOLLARS. YOU AGREE THAT ANY CAUSE OF ACTION ARISING OUT OF OR RELATED TO THE APPLICATION MUST COMMENCE WITHIN ONE (1) YEAR AFTER THE CAUSE OF ACTION ACCRUES, OR THE CAUSE OF ACTION IS PERMANENTLY BARRED. BECAUSE SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS ON HOW LONG AN IMPLIED WARRANTY LASTS, ALL OR A PORTION OF THE ABOVE LIMITATION MAY NOT APPLY TO YOU."},{"title":"Electronic Communications","description":"When you use the Application or send emails to India Cash & Carry, you are communicating with us electronically and consent to receive electronic communications related to your use of the Application. We will communicate with you by email or by posting notices on the Application. You agree that all agreements, notices, disclosures and other communications that are provided to you electronically satisfy any legal requirement that such communications be in writing. Notices from us will be considered delivered to you and effective when sent to the email address you provide on the Application or from which you otherwise email us."},{"title":"Indemnification/Release","description":"You agree to defend, indemnify and hold harmless India Cash & Carry, its subsidiaries and affiliates and their respective directors, officers, employees and agents from and against all claims and expenses, including attorneys fees, arising out of or related to: (a) any User Content submitted or posted by you, in connection with the Application, or any use of the Application in violation of these Terms of Use; (b) fraud you commit or your intentional misconduct or gross negligence; or (c) your violation of any applicable law or rights of a third-party."},{"title":"Force Majeure","description":"India Cash & Carry shall be excused from performance under these Terms of Use, to the extent it is prevented or delayed from performing, in whole or in part, as a result of an event or series of events caused by or resulting from: (a) weather conditions or other elements of nature or acts of God; (b) acts of war, acts of terrorism, insurrection, riots, civil disorders or rebellion; (c) quarantines or embargoes; (d) labor strikes; (e) error or disruption to major computer hardware or networks or software failures; or (g) other causes beyond the reasonable control of India Cash & Carry."},{"title":"Assignment","description":"You may not assign these Terms of Use, or any rights, benefits or obligations hereunder, by operation of law or otherwise, without the express written permission of India Cash & Carry. Any attempted assignment that does not comply with these Terms of Use shall be null and void. India Cash & Carry may assign these Terms of Use, in whole or in part, to any third-party in its sole discretion."},{"title":"Entire Agreement","description":"The Terms of Use, including the incorporated Privacy Statement and other terms incorporated by reference, constitutes the entire agreement and understanding between you and India Cash & Carry with respect to the subject matter hereof and supersedes all prior or contemporaneous communications and proposals, whether oral or written, between you and India Cash & Carry with respect to such subject matter."},{"title":"Choice of Law","description":"Any disputes arising out of or related to these Terms of Use and/or any use by you of the Application or India Cash & Carrys services shall be governed by the laws of the State of California, without regard to its choice of law rules and without regard to conflicts of laws principles."},{"title":"Dispute Resolution","description":"A printed version of the Terms of Use and of any notice given in electronic form shall be admissible in judicial or administrative proceedings based upon or relating to the Terms of Use to the same extent and subject to the same conditions as other business documents and records originally generated and maintained in printed form. You and India Cash & Carry agree that any cause of action arising out of or related to the Service must commence within one (1) year after the cause of action arose; otherwise, such cause of action is permanently barred. The Terms of Use shall be governed by and construed in accordance with the laws of the State of California, excluding its conflicts of law rules, and the United States of America. Any dispute arising from or relating to the subject matter of this Agreement shall be finally settled by arbitration in Santa Clara County, California, using the English language in accordance with the Arbitration Rules and Procedures of JAMS then in effect, by one commercial arbitrator with substantial experience in resolving intellectual property and commercial contract disputes, who shall be selected from the appropriate list of JAMS arbitrators in accordance with the Arbitration Rules and Procedures of JAMS. The prevailing party in the arbitration shall be entitled to receive reimbursement of its reasonable expenses (including reasonable attorneys fees, expert witness fees and all other expenses) incurred in connection therewith. Judgment upon the award so rendered may be entered in a court having jurisdiction or application may be made to such court for judicial acceptance of any award and an order of enforcement, as the case may be. Notwithstanding the foregoing, each party shall have the right to institute an action in a court of proper jurisdiction for injunctive or other equitable relief pending a final decision by the arbitrator. For all purposes of this Agreement, the parties consent to exclusive jurisdiction and venue in the United States Federal Courts located in the Northern District of California. Use of the Service is not authorized in any jurisdiction that does not give effect to all provisions of the Terms of Use, including without limitation, this section. We each agree that we shall bring any Dispute against the other in our respective individual capacities and not as a plaintiff or class member in any purported class, representative proceeding or as an association. In addition, we each agree that Disputes shall be arbitrated only on an individual basis and not in a class, consolidated or representative action. The arbitrator does not have the power to vary these provisions. If any part of this Section 20 is ruled to be unenforceable, then the balance of this Section 20 shall remain in full effect and construed and enforced as if the portion ruled unenforceable were not contained herein."},{"title":"Additional Disclosures","description":"No waiver by either you or India Cash & Carry, Inc.. of any breach or default or failure to exercise any right allowed under these Terms of Use is a waiver of any preceding or subsequent breach or default or a waiver or forfeiture of any similar or future rights under our Terms of Use. The section headings used herein are for convenience only and shall be of no legal force or effect. If a court of competent jurisdiction holds any provision of our Agreement invalid, such invalidity shall not affect the enforceability of any other provisions contained in these Terms of Use, and the remaining portions of our Agreement shall continue in full force and effect.<br>You are contracting with India Cash & Carry, Inc.. Correspondence should be directed to: 1032 E El Camino Real, Sunnyvale, CA 94087.<br>If you are a California resident, you may report complaints to the Complaint Assistance Unit of the Division of Consumer Services of the California Department of Consumer Affairs by contacting them in writing at 400 R Street, Sacramento, CA 95814, or by telephone at (800) 952-5210.<br>The provisions of these Terms of Use apply equally to and are for the benefit of India Cash & Carry, Inc., its subsidiaries, affiliates, Sponsors and India Cash & Carry, Inc.. third-party content providers and licensors, and each shall have the right to assert and enforce such provisions directly."}]},"privacyPolicy":{"title":"Privacy Policy","opening":"Effective as of October 9, 2015<br><br>This Privacy Notice describes the principles and practices that apply to the use of personal information (defined below) that India Cash & Carry, Inc. (\"India Cash & Carry\", we, us) collects from users of the website, www.indiacashandcarry.com, the mobile web, the mobile app and the touch versions and any sites we have now or in the future that reference this Privacy Notice (collectively, the Application).<br>Users (as defined below), by using the Application and selecting a location, consent to our processing of your information as set forth in this Privacy Notice.","sections":[{"title":"Your California Privacy Rights","description":"Under California Civil Code Section 1798.83, California residents have the right to request in writing that we provide (a) a list of the categories of personal information, such as name, email and mailing address, and the type of services provided to the customer, that we have disclosed to third parties (including affiliates that are separate legal entities) during the immediately preceding calendar year, for the third parties direct marketing purpose and (b) the names and addresses of all such third parties.<br>To request the above information, please contact us as indicated in the How to Contact Us Section of this Privacy Notice, with a reference to California Shine the Light Law.<br>We will respond to such requests within 30 days following receipt of the letter or email sent to the address provided in the How to Contact Us Section. If we receive your request at a different email or mailing address, we will respond with a reasonable period, but not to exceed 150 days from the date received. Please note that we are only required to respond to each individual once per calendar year."},{"title":"Definitions and Background","description":"For ease of use of this document, certain terms have been associated with the specific meaning provided below.<br>Device means a smart phone, tablet, and any other similar mobile or connected equipment that is used for online activities.<br>Personal Information means information that identifies an individual or that, when combined with other information available to the data holder may allow identifying an individual with reasonable certainty. Personal information includes any information that is collected from the Application or from any communication between us and an individual, such as contact information that a visitor might provide when asking for information about the Application. It also includes an individuals name, address, or contact information.<br>Registered User means a User of the Application that has provided a delivery location.<br>User is an individual who uses the Application. A User can be a visitor of the Application (who merely explores the Application), or a Registered User."},{"title":"Scope","description":"This Privacy Notice applies to information that we collect or receive from Users and Registered Users of the Application. "},{"title":"Consent","description":"Users, by using the Application and providing a delivery location, consent to our processing of your information as set forth in this Privacy Notice.<br>Your continued use of the Application, or continued interaction with us after we have notified you of a material change in our Privacy Notice in accordance with the Updates will be deemed an acceptance of these new terms."},{"title":"Our Policy Towards Children and Minors","description":"India Cash & Carry does not intend that any portion of the Application will be accessed or used by children under the age of sixteen, and such use is prohibited. The Application is designed and intended for Registered Users at least 16 years of age. By using the Application, you represent that you are at least 16 years old. If you are 16 or older but under the age of majority (which is 18 years old in most states), then your parent or guardian may be liable for some or all of your activities on the Application. Because of this, and because it is prudent for your parent or guardian to be aware of your activities, including the websites that you visit, you should make your parent or guardian aware that you are using the Application."},{"title":"India Cash & Carrys Privacy Practices for Users 16 Or Older","description":"The Information We Collect<br>The Application is a platform through which Registered Users order groceries and have them delivered to a specified location. Therefore, although you do not have to share any Personal Information to browse the Application, you do need to provide a payment method and delivery location to use the Application.<br>Users may provide us with certain Personal Information when you use the Application, for instance if you include your name in your account. We refer to the information Users provider us, including the delivery location a User provides, and any Personal Information a User provides us as the Information.<br>How We Collect Information.<br>From Users<br>We collect Information in a number of ways. First, Users provide us with Information when they provide a delivery location or otherwise include Personal Information in their account.<br>Technology<br>We also use technology to collect certain information automatically, like your Internet Protocol (IP) address (which is the automatic number assigned to your computer by your Internet service provider when you surf the Web, or unique device identifier (UDID), international mobile equipment identity (IMEI), mobile equipment identifier (MEID) or media access control MAC) address; computer operating system (e.g., Microsoft Windows, Mac OS); your browser (e.g., Internet Explorer, Firefox); websites visited before or after you visit the Application; pages viewed and activities on the Application; and advertisements shown or clicked on. In addition, we use GPS and other location techniques to determine the general location of a Registered Users Device.<br>Cookies<br>We use cookies and other technologies as described below to gather information about the Users of the Application in order to know what information is or might be of interest to them. All information collected through cookies and other technologies is processed in accordance with this Privacy Notice.<br>Some cookies are managed by us, and others by our service providers. These cookies are used for a variety of purposes.<br>Some cookies enable services that you have specifically asked for. Other cookies are used to remember the choices you made (for example, the size of the font, or the language you prefer) in order to make it easier for you to use our Application when you return. Other cookies collect information about how Users use the Application. Finally, other cookies are used to collect information about your perceived interest in our products or services so that we can arrange for advertisements regarding these products or services to display on the Application or other sites that you visit on the Internet. This way, when you visit other sites that display advertisements, the advertisements that you see are more relevant to you.<br>These cookies are not linked to any contact information or identifying information, thus cookies do not tell us who you are, but they may identify your Device.<br>If you have any other questions about cookies and other technologies, please visit http://www.allaboutcookies.org/ or http://networkadvertising.org/ or contact us as indicated in the How to contact us section.<br>How We Use the Information We Collect<br>For Marketing and Business Development<br>When not precluded from doing so, we may use the Information we have received from you or about you to solicit feedback from you, including through surveys or to send you marketing communications and promotional material about other products and services. If you consistently demonstrate an interest in certain grocery items, we may propose a weekly grocery basket or otherwise initiate communication with you about this product or service, and may periodically send you additional information and news.<br>To opt out from receiving any communications from us, you need to delete the Application from your Device.<br>Analytics<br>We may aggregate (or have third parties aggregate) the Information we collect from Users and usage data in order to obtain statistical information, such as to calculate the percentage of Users in a certain area or location. We use aggregated Information to understand how the Application is used, for research or product development, for example, to measure interest in, or monitor the use of any content, product, services or promotions that we provide through the Application, to improve the content, products, services or promotions, and for the technical administration of the Application.<br>Investigations<br>We may use your Information to prevent or investigate potentially prohibited or illegal activities or to enforce our Terms of Use.<br>To Defend or Enforce our Rights<br>We may use or share your Information to establish or exercise our legal rights; to respond to a breach of our Terms of Use; when we believe it is appropriate to protect the Application, our property and rights or those of a third party; to protect ourselves and the security and safety of our company, our customers or others; and to investigate, prevent, take action against, or stop any fraudulent, illegal, unethical, or legally actionable activity, in connection with the Application.<br>Who We Share Your Information With<br>Our Workforce<br>India Cash & Carry employees and independent contractors need to have access to the Information we have collected about you to carry out their duties and obligations, such as to provide customer support, respond to inquiries, or correct an error. Only the minimum amount of Information will be made available to them as needed, and in accordance with their responsibilities. They are required to ensure at all times the confidentiality and security of your Information.<br>Service Providers<br>We may engage certain third parties to perform services including, without limitation, hosting and maintenance, customer relationship, storage, database management, collection, fraud prevention, business analytics, chat, website analytics, website optimization, lead scoring, retargeting, direct marketing campaign, or similar services. For example, we use an outside credit card processing company to bill Users for their groceries. We will share your Information with these third parties, but only to the extent that this Information is necessary to perform these functions and provide such services, and only pursuant to binding contractual obligations requiring such third parties to maintain the privacy and security of your Information.<br>If India Cash & Carry is Sold or Goes Bankrupt<br>If any or all of the assets of India Cash & Carry are acquired by, or if India Cash & Carry merges with, another entity, or in the unlikely event of a bankruptcy, we may disclose, share or transfer some or all of your Information to or with this entity in preparation of the transaction, as part of the due diligence, or after the transaction has been consummated, and we may transfer your Information after the transaction has been consummated, so that the successor entity can continue providing the Application to our Users. If the recipient of the Information has practices regarding Personal Information that do not substantially meet the substance of this Privacy Notice, you will be given the opportunity not to continue to use the Application and to have your Information deleted.<br>Compliance with Laws and Third Party Requests<br>India Cash & Carry cooperates with government and law enforcement officials or private parties to enforce and comply with the law. We may disclose any Information about you to government or law enforcement officials or private parties as we, in our reasonable discretion, believe necessary or appropriate to respond to and defend against legal claims, respond to legal process (including a facially valid subpoena, warrant, court order or other legal process), or otherwise as required by law.<br>Please note that we may not be able to notify you of a request for the disclosure of your Information as described above, either because it might be prohibited by law, or because doing so would jeopardize an investigation of illegal or fraudulent activity, or because we do not have your contact information."},{"title":"Users' Rights","description":"We want our Users to enjoy their visit to and use of the Application, and we respect their privacy. To this end, we provide numerous privacy choices.<br>While we have tried to provide all tools necessary so that Users can manage their interaction with us, as listed below, you may prefer to interact directly with us. In this case, be aware that you can contact us at any time with your questions or requests for assistance. Please refer to the How to contact us section.<br>Right to Access Your Information<br>You may access the Information we have regarding you by contacting us as indicated in the How to Contact Us. In addition, you may obtain a copy (electronic or physical) of this information by requesting it in the same manner. If the requested Information is no longer available or cannot be produced using reasonably commercial means, or if the burden or expense of accessing it would be disproportionate to the risks to you, we may deny your request and we will provide you an explanation for this denial.<br>Right to Amend, Correct, Substitute or Delete Information<br>You may request that we amend, correct, substitute, or delete information maintained and/or stored by us if you believe that it is not accurate, timely, complete, relevant, or necessary to accomplish our services. To do so, please let us know what you need, by contacting us as indicated in the How to Contact Us. If the requested Information is no longer available or cannot be modified or deleted using reasonably commercial means, or if the burden or expense of deleting it would be disproportionate to the risks to you, we may deny your request and we will provide you an explanation for this denial.<br>Right to Block Marketing Communications<br>If you no longer wish to receive marketing information or communications from us or from our affiliate entities, you must delete the Application from your Device."},{"title":"California Disclosures","description":"Do Not Track<br>California law requires that website operators disclose how they respond to a Do Not Track signal. However, because there is not yet a common understanding of how to interpret Do Not Track signals, we do not currently respond to Do Not Track signals, if any, that we might receive from browsers. We will continue to work with the online industry to define a common understanding of how to treat Do Not Track signals.<br>To learn more about online behavioral advertising, and/or to opt-out of this type of advertising, please visit the Network Advertising Initiative website or the Digital Advertising Alliance website. You can also contact us as indicated in the How to Contact Us section.<br>Third Party Cookies<br>California law requires that website operators disclose whether third parties may collect personally identifiable information about an individuals online activities. We allow third parties with which we have a separate agreement to use cookies or other technologies to collect Information about Users visit to the Application. These third parties may include business partners, which may collect information when you view or interact with certain areas of the Application, and advertising networks, which may collect information about your interests or preferences, so that they can display promotional material tailored to your apparent interest on the Application or across the Internet.<br>We do not share with these third parties any Information that would readily identify you, such as an email address, but these third parties may have access to information about your Device, such as an IP or MAC address. We do not have access to, or control over, the technologies that these third parties may use to collect information about your interests."},{"title":"Security","description":"India Cash & Carry employs administrative, physical, and electronic measures designed to protect your information from unauthorized access, loss, misuse, disclosure, alteration, and destruction.<br>When we need to transfer Information out of our firewall, we use industry-standard technological means to protect your information while in transit through the Internet. We use encryption and a comprehensive authentication protocol to provide reasonable security. However, please remember that no security system on the Internet is perfect."},{"title":"Limitation of Liability","description":"We exercise reasonable efforts to safeguard the security and confidentiality of your information; however, transmissions protected by industry standard technology and administered by humans cannot be guaranteed to be secure. We will not be liable for unauthorized disclosure of your Information that occurs through no fault of India Cash & Carry including, but not limited to, errors in transmission, uses of your data by a third party, your failure to comply with your security obligations, and the unauthorized acts of India Cash & Carrys employees."},{"title":"Links to Other Websites","description":"This Privacy Notice addresses only the use and disclosure of Information that we collect from you through the Application, through our interaction with you or from interaction with our business partners. The Application may contain links to other websites. The fact that we link to a website is not an endorsement, authorization or representation of our affiliation with that third party. We do not exercise control over third party websites. These other websites may place their own cookies or other files on your computer, collect data, or solicit personal information from you. They follow their own rules regarding the use or disclosure of the personal information you submit to them. We recommend that you to read the privacy policies or statements of these other websites."},{"title":"Disputes","description":"If you have any concerns or claims with respect to our Privacy Notice, please contact us as indicated in the How to Contact Us section. We will investigate and attempt to resolve any complaints and disputes regarding our use and disclosure of your information.<br>If the complaint or dispute cannot be resolved through our internal process, or India Cash & Carry does not adequately respond to your question, the parties agree to arbitrate the dispute. Arbitration will be conducted by telephone and email, and if it must be done in person, it will be conducted in Santa Clara County, California, using the English language in accordance with the Arbitration Rules and Procedures of JAMS then in effect, by one commercial arbitrator with substantial experience in resolving intellectual property and commercial contract disputes, who shall be selected from the appropriate list of JAMS arbitrators in accordance with the Arbitration Rules and Procedures of JAMS. The prevailing party in the arbitration shall be entitled to receive reimbursement of its reasonable expenses (including reasonable attorneys fees, expert witness fees and all other expenses) incurred in connection therewith. Judgment upon the award so rendered may be entered in a court having jurisdiction or application may be made to such court for judicial acceptance of any award and an order of enforcement, as the case may be. Notwithstanding the foregoing, each party shall have the right to institute an action in a court of proper jurisdiction for injunctive or other equitable relief pending a final decision by the arbitrator. For all purposes of this Agreement, the parties consent to exclusive jurisdiction and venue in the United States Federal Courts located in the Northern District of California."},{"title":"Updates","description":"This Privacy Notice may be updated from time to time in order to reflect changes in our practices. We will notify you of any material changes by posting the new Privacy Notice on the Application, and will obtain the necessary consents as may be required under applicable law if we seek to collect, use or disclose personal data for purposes other than those for which consent has been obtained.<br>Except as stated above, all changes will apply to the information that we have are already collected, and to information that is collected after the effective date of the revised Notice. If any proposed change is unacceptable to you, you will have the right to ask for the deletion of your information. You are advised to consult this Privacy Notice regularly for any changes."},{"title":"How to Contact Us","description":"If you have any questions, comments, concerns, complaints or claims with respect to the Site, other users of the Application, if your account has been compromised by a hacker or scammer, if another user is abusing, harassing, or stalking you, if you find that certain content displayed on the Application is inappropriate or prohibited by these Terms, or if you have any other concern, please contact us as indicated below. We will investigate and attempt to resolve the matter.<br>If you have any questions regarding these Terms or the Application, please contact us by email at   indiacashandcarry@gmail.com , or by mail at India Cash & Carry, Inc., 1032 E El Camino Real, Sunnyvale, CA 94087. "}]}},"SEO":{"title":"India Cash & Carry - Online Ordering, Indian Grocery Delivery!","description":"We are Bay Area's most favorite Indian grocery store.","image":"/images/client-assets/icc/seo-image.jpg"},"hideAnnouncementBanner":false,"sitemapFolder":"icc","thermalPrinting":true,"placeOrderForUser":false,"showOrderFormInAdmin":false,"showOrderFormAdminProduct":false,"enableNewCheckout":true,"enableAdminAddProduct":false,"hideProductPrice":false,"limitCreateOrderProducts":true,"disabledRestrictedAdminProductChange":false,"salesPage":false,"disableOrdering":false,"noOrderingConfig":{"productPage":{"icon":"ordering-disabled.jpg","title":"Online Ordering Temporarily Suspended","description":"We have temporarily suspended online ordering. We have received huge amount of online orders and these orders have filled all our capacity for the next few days. Please check back in a couple of days as we resume online ordering. We apologize for any inconvenience this may cause.<br><br>The stores are open and operating at usual business hours. Please stop by our one of our stores to shop.<br><br>We thank you for your understanding as we work through making online ordering operational again in the next couple of days.","btn":{"text":"Contact Us","href":"/contact","target":""}}},"showOrderCreatedTime":false,"sortCategoryOrder":false,"enableSendToQB":false,"sortSubCategoryOrder":false,"enableFacebookLogin":false,"enableGoogleLogin":false,"assignPackerDriver":true,"hideAboutPage":false,"disableDiscountCode":false,"showReports":{"sales":true,"users":true,"movement":true,"lostRevenue":true},"showLocationSettings":true,"showBottleFee":true,"enableBulkProductUpdate":false,"showPriceToRestrictedAdmin":false,"redirectConfig":false,"autoCheckoutLocationChange":true,"canPackersUpdatePriceInOrder":true,"canRestrictedAdminCancelOrder":false,"canRestrictedAdminCompleteOrder":true,"clientPages":[],"contactPageOveride":"","promptOutOfStockWhenRemoved":false,"enablePackingCompletedFlow":false,"showSkipButtonPackingCompletedFlow":true,"showExitButtonPackingCompletedFlow":true,"enableTableSideOrder":false,"showGridMenuItemImage":false,"enableSeparateTips":false,"enableUpcScanner":false,"packerRequiredToInputUpc":false,"canPackersIssueRefund":true,"canPackersCreateCustomItem":true,"enableDeliveryService":true,"hideRefundButton":false,"isWarehouse":false,"showManageCoupons":true,"showManagePromotions":true,"deliveryPartner":false,"newLocation":false,"deliveryPartnerFooter":false,"headerLogoPosition":"center","enableJumpToTop":false,"enableLoginToStoreAdmin":false,"itemInstructionsPlaceholderText":"For Example: No Onions, No Bell Peppers, Make It Extra Spicy.","fiservConfig":{"site":"isv"},"showHeaderBoxShadow":true,"customOrderPoints":false,"enableProductBulkOps":true,"hideChargesAndFulfillmentFAQ":false,"hideHeaderContactTab":false,"footerContactLink":"/contact","showPrivacyPolicy":true,"showTermsAndConditions":true});
var ENV = {"disableTip":false,"enableHiddenHealthClaims":false,"allowToPackLessLB":false,"allAdminFieldsEditable":true,"scripts":[{"string":"<!-- Facebook Pixel Code --> \n<script> \n!function(f,b,e,v,n,t,s) \n{if(f.fbq)return;n=f.fbq=function(){n.callMethod? \nn.callMethod.apply(n,arguments):n.queue.push(arguments)}; \nif(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0'; \nn.queue=[];t=b.createElement(e);t.async=!0; \nt.src=v;s=b.getElementsByTagName(e)[0]; \ns.parentNode.insertBefore(t,s)}(window, document,'script', 'https://connect.facebook.net/en_US/fbevents.js'); \nfbq('init', '693183878020576'); \nfbq('track', 'PageView'); \n</script> \n<noscript><img height=\"1\" width=\"1\" style=\"display:none\" src=\"https://www.facebook.com/tr?id=693183878020576&ev=PageView&noscript=1\"; /></noscript> \n<!-- End Facebook Pixel Code -->\n\n<!-- Global site tag (gtag.js) - Google Analytics --> \n<script async src=\"https://www.googletagmanager.com/gtag/js?id=G-8Z3WVSM2L2\"></script>;\n<script> \nwindow.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'AW-429568383');\n</script>\n","source":"index.html","marker":"</body>"},{"string":"<!-- Event snippet for Purchases conversion page --> <script> \n                        gtag('event', 'conversion', { 'send_to': 'AW-429568383/6mvLCK3rpf0BEP_i6swB', 'transaction_id': '' }); </script>","source":"partials/cart/checkout-confirm.html"}],"apiEndPoint":"https://partnersapi.gethomesome.com","apiEndPointEast":"https://partnersapi-east.gethomesome.com","storeAdminUrl":"https://store-admin.homesome.com","gMapKey":"AIzaSyB9M2NAsFjHgWzeOZT3j95cAZwrh_En1ak","stripePublishableKey":"pk_live_tuQUR3UyhLcc7c39iudpQz2K","vgsConfig":{"vaultId":"tntkweoambp","env":"live"},"FB":null,"googleClientId":null,"gaID":"UA-111381992-1","reservation":{"enabled":false,"url":""},"externalMenu":{"enabled":false,"url":""},"productLinkText":"Products","theme":{"primary":"#e32228","primaryHover":"#ba0c19","secondary":"#088e4b","secondaryHover":"#036632","tertiary":"#f9a41a","tertiaryHover":"#e08500"},"APIKey":"F848FD68-E12A-49E8-8A02-ABA76636A701","aboutLinkLocation":"footer","faqLinkLocation":"footer","allProducts":{"categories":{"Default":{"heroImage":"../images/hero-images/icc-header-default.jpg","seoImage":"/images/hero-images/icc-header-default.jpg"},"Bakery":{"heroImage":"../images/hero-images/bakery.jpg","seoImage":"/images/hero-images/bakery.jpg"},"IndianPantry":{"heroImage":"../images/hero-images/indian-pantry.jpg","seoImage":"/images/hero-images/indian-pantry.jpg"},"DairyEggs":{"heroImage":"../images/hero-images/dairy-eggs.jpg","seoImage":"/images/hero-images/dairy-eggs.jpg"},"Snacks":{"heroImage":"../images/hero-images/snacks.jpg","seoImage":"/images/hero-images/snacks.jpg"},"RicePasta":{"heroImage":"../images/hero-images/rice-pasta.jpg","seoImage":"/images/hero-images/rice-pasta.jpg"},"RiceNoodles":{"heroImage":"../images/hero-images/rice-pasta.jpg","seoImage":"/images/hero-images/rice-pasta.jpg"},"Fruits":{"heroImage":"../images/hero-images/fruits.jpg","seoImage":"/images/hero-images/fruits.jpg"},"Beverages":{"heroImage":"../images/hero-images/beverages.jpg","seoImage":"/images/hero-images/beverages.jpg"},"CannedGoods":{"heroImage":"../images/hero-images/canned-goods.jpg","seoImage":"/images/hero-images/canned-goods.jpg"},"Vegetables":{"heroImage":"../images/hero-images/vegetables.jpg","seoImage":"/images/hero-images/vegetables.jpg"},"Babies":{"heroImage":"../images/hero-images/babies.jpg","seoImage":"/images/hero-images/babies.jpg"},"MeatSeafood":{"heroImage":"../images/hero-images/meat-seafood.jpg","seoImage":"/images/hero-images/meat-seafood.jpg"},"Pantry":{"heroImage":"../images/hero-images/pantry.jpg","seoImage":"/images/hero-images/pantry.jpg"},"Breakfast":{"heroImage":"../images/hero-images/breakfast.jpg","seoImage":"/images/hero-images/breakfast.jpg"},"Deli":{"heroImage":"../images/hero-images/deli.jpg","seoImage":"/images/hero-images/deli.jpg"},"Frozen":{"heroImage":"../images/hero-images/frozen.jpg","seoImage":"/images/hero-images/frozen.jpg"},"OrganicVegetables":{"heroImage":"../images/hero-images/organic-vegetables.jpg","seoImage":"/images/hero-images/organic-vegetables.jpg"},"OrganicFruits":{"heroImage":"../images/hero-images/organic-fruits.jpg","seoImage":"/images/hero-images/organic-fruits.jpg"},"Pulses":{"heroImage":"../images/hero-images/pulses.jpg","seoImage":"/images/hero-images/pulses.jpg"},"MealKits":{"heroImage":"../images/hero-images/meal-kits.jpg","seoImage":"/images/hero-images/meal-kits.jpg"},"Flours":{"heroImage":"../images/hero-images/flours.jpg","seoImage":"/images/hero-images/flours.jpg"},"HealthBeauty":{"heroImage":"../images/hero-images/health-beauty.jpg","seoImage":"/images/hero-images/health-beauty.jpg"},"Household":{"heroImage":"../images/hero-images/household.jpg","seoImage":"/images/hero-images/household.jpg"}}},"isRestaurant":false,"enableRewards":true,"enableDarkMode":false,"enableDarkModeHeader":false,"enableDarkModeSignup":false,"enableDarkModeFooter":false,"enableTransparentHeader":false,"socialHeader":false,"socialFooter":false,"rewardsConfig":{"landing":{"hero":{"heading":"Introducing<br>India Cash and Carry Rewards","desc":"India Cash and Carry Rewards Program lets you earn points for every dollar spent with us 'In Store' or Online. Points can be redeemed for Discounts or Free Items.","image":"icc-hero.svg"},"howToJoin":{"heading":"How to Join","desc":"All you need is a phone number to join! Sign Up during Checkout at Store or Online. One Phone Number = One Account, 'In Store' or Online.","options":[{"heading":"In Store","desc":"Provide your phone number when prompted during Checkout & Boom! You are a Rewards Member. You will earn points for every dollar spent at any of our stores.","image":"free-curbside-pickup.svg"},{"heading":"Online","desc":"If you are new to Rewards Program, you are automatically enrolled when you place your first Online Order. Or our system links with the account created 'In Store' based on the phone number.","image":"cash-and-carry-logo.svg"}],"cta":[{"btnText":"Sign up","href":"/signup","target":""},{"btnText":"Login","href":"/login","target":""}]},"howItWorks":{"heading":"How It Works","desc":"As a Rewards Member you earn Points on every dollar you spend at India Cash and Carry. Points add up to Rewards in as few as 2 - 3 visits.","sections":[{"id":1,"title":"Shop India Cash & Carry","description":"Shop 'In Store' or Online the way you do. Earn points for every dollar you spend with us.","image":"icc-shop.svg"},{"id":2,"title":"Earn Points","description":"Earn 10 Points for every dollar spent 'In Store' or Online. Points add up to rewards quickly, in as few as 2 - 3 vists.","image":"icc-earnpoints.svg"},{"id":3,"title":"Redeem Rewards","description":"Redeem Rewards for Discounts or Free items. Save even more at India Cash and Carry, your most favorite Indian Store.","image":"icc-redeem-rewards.svg"}],"cta":[{"btnText":"Sign up","href":"/signup","target":""},{"btnText":"Login","href":"/login","target":""}]}}},"showAllProducts":false,"showProductsPage":true,"showOrderPage":false,"showCreditCardHoldMsg":true,"showCheckDeliveryArea":false,"enablePopupImageZoom":true,"hideTipInfo":false,"acceptCreditCard":true,"hideItemUnit":false,"enableBagCount":true,"enableLocations":true,"enablePriceList":true,"enablePriceSync":true,"enableItemInstructions":true,"customDeliveryTime":false,"customItem":false,"adminCustomItem":true,"showCategoryBanner":true,"showDealsPage":true,"showWhatsNewPage":true,"enableOrderDate":true,"driverTip":true,"showTax":true,"ip":true,"exportToQB":false,"invoicePrinting":false,"receiptPrinting":true,"labelPrinting":false,"showBusinessName":false,"folderLocation":"icc","defaultFulfillmentMethod":"delivery","fulfillmentOptions":{"pickup":true,"delivery":true,"shipping":false},"admin":{"manageUsers":false},"signupFields":{"businessName":false,"address":false,"phoneNumber":false},"categoryOrder":{"GaneshChaturthi":"","DiwaliSpecials":"","Specials":"","FreshSweets":"","HomestyleFood":"","CutVegetables":"","FruitsVegetables":"","DairyEggs":"","Snacks":"","Pulses":"","Pantry":"","MealKits":"","RiceNoodles":"","Flours":"","Bakery":"","Beverages":"","Frozen":"","HealthBeauty":"","Household":"","Appetizers":"","RotisChapati":"","BreadsNMore":"","Entrees":"","Desserts":""},"categoryDescription":{},"subCategoryOrder":{},"FAQ":[{"id":1,"ques":"What is India Cash & Carry?","ans":"India Cash & Carry is Bay Area's most favorite store for Indian & ethnic groceries. You can learn more about us <a href='/about'>here</a>."},{"id":2,"ques":"Where are India Cash & Carry stores located?","ans":"Our stores are conveniently located all over the Bay Area. You can learn more <a href='/contact'>here</a>."},{"id":3,"ques":"What is indiacashandcarry.com?","ans":"indiacashandcarry.com is our website where you can conveniently order any of our products sold at our physical store."},{"id":4,"ques":"Do I need to create an account to use indiacashandcarry.com?","ans":"You do not need an account to browse the products or build your shopping cart. But an account is required to place an order."},{"id":5,"ques":"How are the online orders fulfilled?","ans":"You can either choose to \"Pick Up\" your order at our store or have it Delivered to your address of choice."},{"id":6,"ques":"Can I choose \"Pick Up\" or Delivery time?","ans":"Absolutely! You choose Pick Up or Delivery Time of your preference before placing an order."},{"id":7,"ques":"Do you offer Same Day Delivery or \"Pick Up\"?","ans":"Absolutely! We take a huge pride in offering convenience of the Same Day Delivery & \"Pick Up\"."},{"id":8,"ques":"Is there any Cut-Off time for the Same Day Delivery or \"Pick Up\"","ans":"No specific Cut-Off time for the Same Day orders. Our system shows earliest available Delivery & Pick Up times during Checkout before you place an order."},{"id":9,"ques":"Is there any minimum to place an order?","ans":"All the information about minimum order requirement is shown while placing the order during the checkout flow."},{"id":10,"ques":"Is there any fee for Pick Up?","ans":"No fee for Pick Up. Just place an order and stop by our store at your \"Pick Up\" time."},{"id":11,"ques":"Is there any minimum order for Free Delivery?","ans":"For your convenience, all the information about delivery fees or the free delivery, if is is offered, is always shown during the checkout flow before placing an order."},{"id":12,"ques":"How much is the Delivery Fee if my order doesnt meet minimum?","ans":"For your convenience, all the information about delivery fees is always shown during the checkout flow before placing an order."},{"id":13,"ques":"What if an item I ordered is not available?","ans":"It happens in rare situations! Our store representative will contact you to get a replacement input. You can always ask us to remove the item that is unavailable."},{"id":14,"ques":"If removed items cause my total to go below minimum, will I be charged a Delivery Fee?","ans":"No. If you are not charged a Delivery Fee at the Checkout, you wont be charged a Delivery Fee later."},{"id":15,"ques":"What is your return policy?","ans":"All the claims must be made within 24 hours of \"Pick Up\" or Delivery time. You are 100% covered for quality satisfaction, if something doesnt meet your expectations, just let us know and we will refund you in full."},{"id":16,"ques":"Can I make changes to the order once it is placed?","ans":"All the requests for changes must be made before the order is Picked Up or is out for Delivery. After that, no changes can be made to the order."},{"id":17,"ques":"If I ordered an item that I no longer need, do you provide a refund or exchange?","ans":"All the requests for Removing an Item must be made before the order is Picked Up or is out for Delivery. After that, no changes can be made to the order."},{"id":18,"ques":"Why is my credit card charged different amount than my order total?","ans":"When you place your order, instead of immediately charging your card, we place a temporary authorization hold for an amount slightly higher than your order total at checkout.  We place this authorization hold in case your total turns out to be higher due to added items, replacement items, or weight adjustments. After the order is complete, the hold will drop off, and your card will be charged for the final total as shown in the email receipt. The final charge will appear on the statement within 7 business days after order completion."},{"id":19,"ques":"How can I contact further if I need more information?","ans":"You can Contact Us using <a href='/contact'>this</a>."}],"logoFileName":"cash-and-carry-logo.svg","logo":{"src":"../images/logo/cash-and-carry-logo.svg"},"name":{"companyName":"India Cash & Carry","heading":"India Cash & Carry Store At Your Fingertips!","tagline":"Always Fresh!"},"landing":{"heroImage":"","template":{"name":"TEMPLATE_SIGNATURE","heroData":{"logo":"../images/logo/cash-and-carry-logo.svg","heading":"Always Fresh!","subHeading":"Bay Area's most favorite grocery store now at your fingertips."}},"hasMetadata":false,"metadata":[],"howItWorks":{"type":"DELIVERY_AND_PICKUP","heading":"Here's How It Works","subHeading":"India Cash & Carry Store At Your Fingertips!","sections":[{"id":1,"title":"India Cash & Carry Online","description":"Your most favorite grocery store, your most trusted brand, now at your fingertips! Order Online, pick up from the store or get groceries conveniently delivered to your home.","image":"cash-n-carry-logo.svg"},{"id":2,"title":"Free Same Day Delivery","description":"Get your groceries delivered in as little as two hours or at the time of your choice. We bring the entire India Cash & Carry store to you.","image":"free-same-day-delivery.svg"},{"id":3,"title":"Free Curbside Pick Up","description":"Skip the line! Order online & conveniently pick up at the store location of your choice. No Lines No Rush! Groceries done with a few clicks from the comfort of your couch!","image":"free-curbside-pickup.svg"},{"id":4,"title":"100% Satisfaction Guaranteed","description":"Always Fresh, Guaranteed! India Cash & Carry's great Quality, Savings & Customer Service, now available Online.","image":"satisfaction-guaranteed.svg"}]}},"aboutUs":{"heroImage":"../images/client-assets/icc/about-image.jpg","sections":[{"title":"About India Cash & Carry","description":"India Cash and Carry is the one stop shop for all your South East Asian grocery needs. We carry the largest assortment of Indian groceries: produce, dairy, rice, grains, nuts, spices, snacks, ice cream, organic products, you name it, we got it! Since early 2000s, our mission has been, and always will be to provide customers the \"Always Fresh\" grocery products at great prices."},{"title":"Where can you find us?","description":"Our stores are conveniently located all over the San Francisco Bay Area. You can also order all our products online for store pickup or fast free delivery: <a href=\"/products\">Here</a>"},{"title":"Why India Cash & Carry?","description":"India Cash & Carry is Bay Area's most favorite Indian grocery store. We are the grocery experts! Our staff works tirelessly & meticulously to ensure every product on our shelves is \"Always Fresh\" & meets the highest quality standards. Our innovative supply chain & procurement process enables us to bring you the best products from around the world at great prices. Come by and visit one of our stores, or Order Online <a href=\"/products\">Here</a>"}]},"contact":{"fullAddress":"1032 E El Camino Real, Sunnyvale, CA 94087","address":{"street1":"1032 E El Camino Real","street2":"","city":"Sunnyvale","state":"CA","zip":"94087"},"lat":37.351363,"lng":-122.005734},"locations":false,"legal":{"legalName":"India Cash & Carry, Inc.","website":"https://www.indiacashandcarry.com","contactEmail":" indiacashandcarry@gmail.com ","terms":{"title":"Terms of Use","opening":"Welcome to the India Cash & Carry Application (defined below). By using it, you are agreeing to these Terms of Use (defined below). Please read them carefully. If you have any questions, contact us at1032 E El Camino Real, Sunnyvale, CA 94087.<br> These Terms of Use were last updated on October 9, 2015.","sections":[{"title":"ACCEPTANCE OF TERMS OF USE","description":"India Cash & Carry, Inc.(\"India Cash & Carry\" \"we\" or \"us\" or \"our\") owns and operates the website, www.indiacashandcarry.com, the mobile web, the mobile app and the touch versions and any sites we have now or in the future that reference these Terms of Use (collectively, \"Application\"). By using the Application and India Cash & Carry's services through the Application, you agree to these Terms of Use (defined below) and any additional terms applicable to certain programs in which you may elect to participate. You also agree to our Privacy Statement, located at www.indiacashandcarry.com/privacy-policy, and acknowledge that you will regularly visit the Terms of Use (defined below) to familiarize yourself with any updates. The Privacy Statement, together with these terms of use, and any other terms contained herein or incorporated herein by reference, are collectively referred to as the \"Terms of Use.\" The term \"using\" also includes any person or entity that accesses or uses the Application with crawlers, robots, data mining or extraction tools or any other functionality.IF YOU DO NOT AGREE TO THESE TERMS OF USE, IMMEDIATELY STOP USING THE APPLICATION AND DO NOT USE ANY India Cash & Carry SERVICE, PARTICIPATE IN ANY PROGRAM, REDEEM ANY VALIDATED USER REDEMPTION VOUCHER OR USE ANY PRODUCT OR OTHER GOOD OR SERVICE OFFERED THROUGH THE APPLICATION."},{"title":"About the Application","description":"The Application is a platform through which Registered Users order groceries and have them delivered to a specified location. Over time and use, the Application will learn the Registered User's grocery habits and begin to propose a weekly grocery basket. All available grocery and delivery programs on the Application may change at any time in India Cash & Carry's discretion, without notice."},{"title":"Ownership of the Application","description":"The Application, any content on the Application and the infrastructure used to provide the Application are proprietary to us, our affiliates and other content providers. By using the Application and accepting these Terms of Use: (a) India Cash & Carry grants you a limited, personal, nontransferable, nonexclusive, revocable license to use the Application pursuant to these Terms of Use and to any additional terms and policies set forth by India Cash & Carry; and (b) you agree not to reproduce, distribute, create derivative works from, publicly display, publicly perform, license, sell or re-sell any content, products or services obtained from or through the Application without the express permission of India Cash & Carry."},{"title":"Use of the Application","description":"As a condition of your use of the Application, you agree that:<br> You are at least 16 years of age;<br> You are able to create a binding legal obligation;<br> You are not barred from receiving products or services under applicable law;<br> You will not attempt to use the Application with crawlers, robots, data mining or extraction tools or any other functionality;<br> You r use of the Application will at all times comply with these Terms of Use;<br> You will only engage in transactions that comply with the letter and spirit of the terms of the respective offers;<br> You have the right to provide any and all information you submit to the Application, the information and all such information is accurate, true, current and complete; and <br> You will update and correct information you have submitted to the Application and ensure that it is accurate at all times (out-of-date information will invalidate your account). <br>If you are 16 or older but under the age of majority (which is 18 years old in most states), then your parent or guardian may be liable for some or all of your activities on the Application. Because of this, and because it is prudent for your parent or guardian to be aware of your activities, including the websites that you visit, you should make your parent or guardian aware that you are using the Application  as this Terms of Service and your use of the Application affect their legal rights and obligations.<br>If you have any requests for order cancellations, please call us on the phone number provided on the Contact page.<br>If you have any requests for refunds or returns of the items in the order, please call us on the phone number provided on the Contact page. All the requests for refunds or returns must be initiated within 24 hours of your receiving of the items."},{"title":"Access to the Application","description":"India Cash & Carry retains the right, at our sole discretion, to deny service or use of the Application or an account to anyone at any time and for any reason. While we use reasonable efforts to keep the Application and your account accessible, the Application and/or your account may be unavailable from time to time. You understand and agree that there may be interruptions in service or events, Application access or access to your account due to circumstances both within our control (e.g., routine maintenance) and outside of our control."},{"title":"Modification","description":"We reserve the right at all times to discontinue or modify any part of these Terms of Use in our sole discretion. If we make changes that affect your use of the Application or our services we will post notice of the change on the Application. If you have an account on the Application, any changes to these Terms of Use will be effective upon our notice of the changes on the Application. If you do not agree to the changes, you may close your account without penalty and you should not use the Application or any services offered through the Application after the effective date of the changes. If you do not have an account, any changes will be effective immediately for new and existing users of the Application. We suggest that you revisit our Terms of Use regularly to ensure that you stay informed of any changes. Your use of the Application after we update these Terms of Use will constitute acceptance of the modified Terms of Use."},{"title":"Your Account","description":"In order to use the Application, you will have to provide your (i) first name; (ii) last name; (iii) email address; (iv) delivery location; (v) payment information; and, (vi) set an account password. The required information you will have provided is referred to herein as your Account. <br>In addition, as you use the Application, we will collect certain information regarding your usage or actions. For example, to provide the most accurate weekly grocery proposal, we may store your grocery lists for future reference. We use the information we gather from your use of the Application in accordance with the terms of our Privacy Policy which is located at www.indiacashandcarry.com/privacy-policy.<br>You may only hold one Account on the Application for your personal use. When you agree to these Terms of Use, you represent that you will have only one Account and that you will use your Account as a bona fide consumer and with no intent to defraud India Cash & Carry.<br>You are responsible for updating and correcting information you have submitted to create or maintain your Account. You understand and agree that India Cash & Carry shall have no responsibility for any incident arising out of, or related to, your Account. You are solely responsible for maintaining the security of your Account. We will assume that anyone using the Application or transacting through your Account is you. You agree that you are solely responsible for any activity that occurs under your Account. You will be persistently logged into the Application unless you choose to delete the Application from your mobile device or we terminate your Account.<br>Your Account is non-transferrable. You cannot sell, combine, or otherwise share it with any other person. Any violation of these Terms of Use, including failure to maintain updated and correct information about your Account, may cause us to cancel your Account in our sole discretion. If your Account is cancelled, you will forfeit any pending, current or future promotional vouchers and any other forms of unredeemed value in your Account. Upon termination, the provisions of these Terms of Use that are by their nature intended to survive termination (e.g., any disclaimers, all limitations of liability and all indemnities) shall survive. We also reserve the right to change or discontinue any aspect or feature of our services or the Application, including, but not limited to, requirements for use."},{"title":"Your Conduct","description":"All interactions on the Application must comply with these Terms of Use. To the extent your conduct, in our sole discretion, restricts or inhibits any other user from using or enjoying any part of the Application, we may limit your privileges on the Application and seek other remedies. The following activities are prohibited on the Application and constitute express violations of these Terms of Use: Submitting any content to the Application that: Violates applicable laws (including but not limited to intellectual property laws, laws relating to rights of privacy and rights of publicity and laws related to defamation); Contains personal information, except when we expressly ask you to provide such information; Contains viruses or malware; Offers unauthorized downloads of any copyrighted, confidential or private information; Has the effect of impersonating others; Contains messages by non-spokesperson employees of India Cash & Carry purporting to speak on behalf of India Cash & Carry or provides confidential information concerning India Cash & Carry; Is purposely inaccurate, commits fraud or falsifies information in connection with your India Cash & Carry account or to create multiple India Cash & Carry accounts; or Is protected by copyright, trademark or other proprietary right without the express permission of the owner of the copyright, trademark or other proprietary right. Attempting to do or actually doing any of the following: Accessing data not intended for you, such as logging into a server or an account which you are not authorized to access; Scanning or monitoring the Application for data gathering purposes in an effort to track sales, usage, aggregate offering information, pricing information or similar data; Scanning or testing the security or configuration of the Application or to breach security or authentication measures; or Interfering with service to any user in any manner, including, without limitation, by means of submitting a virus to the Application or attempting to overload, flood, spam, mail bomb or crash the Application. Using any of the following: Frames, framing techniques or framing technology to enclose any content included on the Application without our express written permission; Any Application content, including without limitation User Content (defined below), in any meta tags or any other hidden text techniques or technologies without our express written permission; The Application or any of its contents to advertise or solicit, for any commercial, political or religious purpose or to compete, directly or indirectly, with India Cash & Carry; or The Application or any of its resources to solicit consumers or other third-parties to become users or partners of other online or offline services directly or indirectly competitive or potentially competitive with India Cash & Carry, including, without limitation, aggregating current or previously offered deals. Collecting any of the following: Content from the Application, including, but not limited to, in connection with current or previously offered deals, and featuring such content to consumers in any manner that diverts traffic from the Application without our express written permission; or Personal Information (defined in our Privacy Statement), User Content (defined in Section 10 below) or content of any consumers. Engaging in any of the following: Tampering or interfering with the proper functioning of any part, page or area of the Application or any functions or services provided by India Cash & Carry; Taking any action that places excessive demand on our services or imposes, or may impose, an unreasonable or disproportionately large load on our servers or other portion of our infrastructure (as determined in our sole discretion); Reselling or repurposing your access to the Application; Accessing, monitoring or copying any content from the Application using any robot, spider, scraper or other automated means or any manual process for any purpose without our express written permission; Violating the restrictions in any robot exclusion headers on the Application or bypassing or circumventing other measures employed to prevent or limit access to the Application; Aggregating any current or previously-offered deals or content or other information from the Application (whether using links or other technical means or physical records associated with purchases made through the Application) with material from other sites or on a secondary site without our express written permission; Deep-linking to any portion of the Application without our express written permission; Hyperlinking to the Application from any other website without our initial and ongoing consent; or Acting illegally or maliciously against the business interests or reputation of India Cash & Carry or our services."},{"title":"Your Privacy","description":"We take the privacy of your personal data seriously. We encourage you to carefully review our Privacy Statement for important disclosures about ways that we may collect, use, and share personal data and your choices. Our Privacy Statement is incorporated in these Terms of Use, and available here."},{"title":"Copyright and Trademarks","description":"The Application contains copyrighted material, trademarks and other proprietary information, including, but not limited to, text, software, photos, video, graphics, music and sound and the entire contents of the Application are protected by copyright, trademark and other intellectual property laws of the United States. India Cash & Carry' owns a copyright in the selection, coordination, arrangement and enhancement of such content, as well as in the content original to it. You may not modify, distribute, publish, transmit, publicly display, publicly perform, participate in the transfer or sale, create derivative works or in any way exploit any of the content, in whole or in part. Except as otherwise expressly stated under copyright law, no downloading, copying, redistribution, retransmission, publication or commercial exploitation of the content without the express permission of India Cash & Carry or the copyright owner is permitted. If downloading, copying, redistribution, retransmission or publication of copyrighted material is permitted, you will make independent attribution and/or make no changes in or deletion of any author attribution, trademark legend or copyright notice. You acknowledge that you do not acquire any ownership rights by downloading copyrighted material. Any violation of these restrictions may result in a copyright, trademark or other intellectual property right infringement that may subject you to civil and/or criminal penalties.You will not upload, post or otherwise make available on the Application any material protected by copyright, trademark or other proprietary right without the express permission of the owner of the copyright, trademark or other proprietary right. India Cash & Carry does not have any express burden or responsibility to provide you with indications, markings or anything else that may aid you in determining whether the material in question is copyrighted or trademarked. You will be solely liable for any damage resulting from any infringement of copyrights, trademarks, proprietary rights or any other harm resulting from such a submission.India Cash & Carry USA, Inc.. owns trademarks, registered and unregistered in the United States and India Cash & Carry, the India Cash & Carry logo and variations thereof found on the Application are trademarks owned by India Cash & Carry USA, Inc.. or its related entities and all use of these marks inures to the benefit of India Cash & Carry USA, Inc..Other marks on the Application not owned by India Cash & Carry may be under license from the trademark owner thereof, in which case such license is for the exclusive benefit and use of India Cash & Carry unless otherwise stated, or may be the property of their respective owners. You may not use India Cash & Carrys name, logos, trademarks or brands without India Cash & Carrys express permission."},{"title":"User Content","description":"The Application may provide registered users and visitors various opportunities to submit or post reviews, opinions, advice, ratings, discussions, comments, messages, survey responses and other communications and other content (collectively, \"User Content\") through forums, bulletin boards, discussion groups, chat rooms, surveys, blogs or other communication facilities that may be offered on, through, or in connection with the Application from time to time. You may be required to have a India Cash & Carry account to submit User Content. If you contribute any User Content, you represent and warrant that: (a) you are the creator the User Content; or (b) if you are acting on behalf of the creator, that you have (i) express, advance authority from the creator to submit or post the User Content, and (ii) all rights necessary to grant the licenses and grants in these Terms of Use. You further represent and warrant (or, if you are acting on behalf of the creator of the User Content, you have assured that the creator represents and warrants) that the sharing of the User Content for the purposes you have selected will not violate or infringe any copyrights, trademarks or any other intellectual property rights or rights of third parties, including the rights of publicity or privacy. You represent and warrant that you will not upload, post, transmit or otherwise make available User Content that is unlawful, harmful, tortious, threatening, abusive, harassing, hateful, racist, infringing, pornographic, obscene, violent, misleading, defamatory or libelous, invasive of the privacy of another person or violative of any third-party rights; or if User Content contains any material that harbors viruses or any other computer codes, files or programs designed to interrupt, destroy or limit the functionality of any software or computer equipment. India Cash & Carry' shall have the sole and absolute right, but not the obligation, to review, edit, post, refuse to post, remove, monitor the User Content and disclose the User Content and the circumstances surrounding its transmission to any third-party, at any time, for any reason, including to determine compliance with these Terms of Use and any operating rules established by India Cash & Carry as well as to satisfy any applicable law, regulation or authorized government request. Without limiting the foregoing, India Cash & Carry shall have the right to remove any material from the Application in its sole and absolute discretion. India Cash & Carry assumes no liability for any User Content or other information that appears or is removed from the Application or elsewhere. India Cash & Carry has no obligation to use User Content and may not use it at all. In some instances and from time to time, it may be possible to modify or remove the User Content submitted or posted through your account. India Cash & Carry makes no representations or warranties that the User Content you modify or remove will be modified or removed from the Application or elsewhere, or that the User Content will cease to appear on the Internet, in search engines, social media websites, or in any other form, media or technology."},{"title":"Public Nature of Your User Content.","description":"You understand and agree that User Content is public. Any person (whether or not a user of India Cash & Carrys services) may read your User Content without your knowledge. Please do not include any Personal Information in your User Content unless you wish for it to be publicly disclosed. India Cash & Carry is not responsible for the use or disclosure of any Personal Information that you disclose in connection with User Content. Any User Content of any kind made by you or any third-party is made by the respective author(s) or distributor(s) and not by India Cash & Carry. Other users may post User Content that is inaccurate, misleading or deceptive. India Cash & Carry does not endorse and is not responsible for any User Content, and will not be liable for any loss or damage caused by your reliance on such User Content. User Content reflects the opinions of the person submitting it and may not reflect the opinion of India Cash & Carry. India Cash & Carry does not control or endorse any User Content, and specifically disclaims any liability concerning or relating to your contribution of, use of, or reliance on any User Content and any actions resulting from your participation in any part of the Application, including any objectionable User Content."},{"title":"Disclaimer of Warranty","description":"YOU EXPRESSLY AGREE THAT USE OF THE APPLICATION IS AT YOUR SOLE RISK. NONE OF India Cash & Carry, Inc., ITS SUBSIDIARIES OR AFFILIATES OR ANY OF THEIR RESPECTIVE EMPLOYEES, AGENTS, THIRD-PARTY CONTENT PROVIDERS OR LICENSORS OR ANY OF THEIR OFFICERS, DIRECTORS, EMPLOYEES OR AGENTS, WARRANT THAT USE OF THE APPLICATION WILL BE UNINTERRUPTED, SECURE, VIRUS-FREE OR ERROR FREE, NOR DO THEY MAKE ANY WARRANTY AS TO (A) THE RESULTS THAT MAY BE OBTAINED FROM USE OF THE APPLICATION, OR (B) THE ACCURACY, COMPLETENESS OR RELIABILITY OF (I) THE CONTENT ON THE APPLICATION, INCLUDING WITHOUT LIMITATION AVAILABLE PROGRAMS, (II) OR USER CONTENT PROVIDED THROUGH THE APPLICATION. THE APPLICATION AND ALL CONTENT, USER CONTENT AND OTHER INFORMATION CONTAINED ON THE APPLICATION, OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION, ARE MADE ACCESSIBLE OR AVAILABLE ON AN AS IS AND AS AVAILABLE BASIS. TO THE EXTENT ALLOWED BY APPLICABLE LAW, India Cash & Carry HEREBY DISCLAIMS ANY AND ALL REPRESENTATIONS, WARRANTIES AND CONDITIONS, WHETHER EXPRESS OR IMPLIED, AS TO THE OPERATION OF THE APPLICATION OR THE CONTENT, USER CONTENT OR OTHER INFORMATION CONTAINED ON THE APPLICATION OR OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION, INCLUDING, BUT NOT LIMITED TO, THOSE OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, SUITABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AS WELL AS WARRANTIES IMPLIED FROM A COURSE OF PERFORMANCE OR COURSE OF DEALING."},{"title":"Limitation of Liability","description":"IN NO EVENT SHALL India Cash & Carry, Inc.., ITS SUBSIDIARIES OR AFFILIATES OR ANY OF THEIR RESPECTIVE EMPLOYEES, OFFICERS, DIRECTORS, AGENTS, PARTNERS, THIRD-PARTY CONTENT PROVIDERS OR LICENSORS, OR ANY OF THEIR OFFICERS, DIRECTORS, EMPLOYEES OR AGENTS, BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES ARISING OUT OF OR RELATED TO: (A) YOUR USE OF THE APPLICATION, THE CONTENT, USER CONTENT AND OTHER INFORMATION CONTAINED IN THE APPLICATION; (B) PRODUCTS DELIVERED THROUGH THE India Cash & Carry APPLICATION; (C) YOUR INABILITY TO USE THE APPLICATION; (D) MODIFICATION OR REMOVAL OF CONTENT SUBMITTED ON THE APPLICATION; (E) OTHER AVAILABLE PROGRAMS ACCESSIBLE OR AVAILABLE THROUGH THE APPLICATION; OR (F) THESE TERMS OF USE. TOTAL AGGREGATE LIABILITY ARISING OUT OF OR RELATED TO THESE TERMS OF USE SHALL NOT EXCEED ONE HUNDRED DOLLARS. YOU AGREE THAT ANY CAUSE OF ACTION ARISING OUT OF OR RELATED TO THE APPLICATION MUST COMMENCE WITHIN ONE (1) YEAR AFTER THE CAUSE OF ACTION ACCRUES, OR THE CAUSE OF ACTION IS PERMANENTLY BARRED. BECAUSE SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS ON HOW LONG AN IMPLIED WARRANTY LASTS, ALL OR A PORTION OF THE ABOVE LIMITATION MAY NOT APPLY TO YOU."},{"title":"Electronic Communications","description":"When you use the Application or send emails to India Cash & Carry, you are communicating with us electronically and consent to receive electronic communications related to your use of the Application. We will communicate with you by email or by posting notices on the Application. You agree that all agreements, notices, disclosures and other communications that are provided to you electronically satisfy any legal requirement that such communications be in writing. Notices from us will be considered delivered to you and effective when sent to the email address you provide on the Application or from which you otherwise email us."},{"title":"Indemnification/Release","description":"You agree to defend, indemnify and hold harmless India Cash & Carry, its subsidiaries and affiliates and their respective directors, officers, employees and agents from and against all claims and expenses, including attorneys fees, arising out of or related to: (a) any User Content submitted or posted by you, in connection with the Application, or any use of the Application in violation of these Terms of Use; (b) fraud you commit or your intentional misconduct or gross negligence; or (c) your violation of any applicable law or rights of a third-party."},{"title":"Force Majeure","description":"India Cash & Carry shall be excused from performance under these Terms of Use, to the extent it is prevented or delayed from performing, in whole or in part, as a result of an event or series of events caused by or resulting from: (a) weather conditions or other elements of nature or acts of God; (b) acts of war, acts of terrorism, insurrection, riots, civil disorders or rebellion; (c) quarantines or embargoes; (d) labor strikes; (e) error or disruption to major computer hardware or networks or software failures; or (g) other causes beyond the reasonable control of India Cash & Carry."},{"title":"Assignment","description":"You may not assign these Terms of Use, or any rights, benefits or obligations hereunder, by operation of law or otherwise, without the express written permission of India Cash & Carry. Any attempted assignment that does not comply with these Terms of Use shall be null and void. India Cash & Carry may assign these Terms of Use, in whole or in part, to any third-party in its sole discretion."},{"title":"Entire Agreement","description":"The Terms of Use, including the incorporated Privacy Statement and other terms incorporated by reference, constitutes the entire agreement and understanding between you and India Cash & Carry with respect to the subject matter hereof and supersedes all prior or contemporaneous communications and proposals, whether oral or written, between you and India Cash & Carry with respect to such subject matter."},{"title":"Choice of Law","description":"Any disputes arising out of or related to these Terms of Use and/or any use by you of the Application or India Cash & Carrys services shall be governed by the laws of the State of California, without regard to its choice of law rules and without regard to conflicts of laws principles."},{"title":"Dispute Resolution","description":"A printed version of the Terms of Use and of any notice given in electronic form shall be admissible in judicial or administrative proceedings based upon or relating to the Terms of Use to the same extent and subject to the same conditions as other business documents and records originally generated and maintained in printed form. You and India Cash & Carry agree that any cause of action arising out of or related to the Service must commence within one (1) year after the cause of action arose; otherwise, such cause of action is permanently barred. The Terms of Use shall be governed by and construed in accordance with the laws of the State of California, excluding its conflicts of law rules, and the United States of America. Any dispute arising from or relating to the subject matter of this Agreement shall be finally settled by arbitration in Santa Clara County, California, using the English language in accordance with the Arbitration Rules and Procedures of JAMS then in effect, by one commercial arbitrator with substantial experience in resolving intellectual property and commercial contract disputes, who shall be selected from the appropriate list of JAMS arbitrators in accordance with the Arbitration Rules and Procedures of JAMS. The prevailing party in the arbitration shall be entitled to receive reimbursement of its reasonable expenses (including reasonable attorneys fees, expert witness fees and all other expenses) incurred in connection therewith. Judgment upon the award so rendered may be entered in a court having jurisdiction or application may be made to such court for judicial acceptance of any award and an order of enforcement, as the case may be. Notwithstanding the foregoing, each party shall have the right to institute an action in a court of proper jurisdiction for injunctive or other equitable relief pending a final decision by the arbitrator. For all purposes of this Agreement, the parties consent to exclusive jurisdiction and venue in the United States Federal Courts located in the Northern District of California. Use of the Service is not authorized in any jurisdiction that does not give effect to all provisions of the Terms of Use, including without limitation, this section. We each agree that we shall bring any Dispute against the other in our respective individual capacities and not as a plaintiff or class member in any purported class, representative proceeding or as an association. In addition, we each agree that Disputes shall be arbitrated only on an individual basis and not in a class, consolidated or representative action. The arbitrator does not have the power to vary these provisions. If any part of this Section 20 is ruled to be unenforceable, then the balance of this Section 20 shall remain in full effect and construed and enforced as if the portion ruled unenforceable were not contained herein."},{"title":"Additional Disclosures","description":"No waiver by either you or India Cash & Carry, Inc.. of any breach or default or failure to exercise any right allowed under these Terms of Use is a waiver of any preceding or subsequent breach or default or a waiver or forfeiture of any similar or future rights under our Terms of Use. The section headings used herein are for convenience only and shall be of no legal force or effect. If a court of competent jurisdiction holds any provision of our Agreement invalid, such invalidity shall not affect the enforceability of any other provisions contained in these Terms of Use, and the remaining portions of our Agreement shall continue in full force and effect.<br>You are contracting with India Cash & Carry, Inc.. Correspondence should be directed to: 1032 E El Camino Real, Sunnyvale, CA 94087.<br>If you are a California resident, you may report complaints to the Complaint Assistance Unit of the Division of Consumer Services of the California Department of Consumer Affairs by contacting them in writing at 400 R Street, Sacramento, CA 95814, or by telephone at (800) 952-5210.<br>The provisions of these Terms of Use apply equally to and are for the benefit of India Cash & Carry, Inc., its subsidiaries, affiliates, Sponsors and India Cash & Carry, Inc.. third-party content providers and licensors, and each shall have the right to assert and enforce such provisions directly."}]},"privacyPolicy":{"title":"Privacy Policy","opening":"Effective as of October 9, 2015<br><br>This Privacy Notice describes the principles and practices that apply to the use of personal information (defined below) that India Cash & Carry, Inc. (\"India Cash & Carry\", we, us) collects from users of the website, www.indiacashandcarry.com, the mobile web, the mobile app and the touch versions and any sites we have now or in the future that reference this Privacy Notice (collectively, the Application).<br>Users (as defined below), by using the Application and selecting a location, consent to our processing of your information as set forth in this Privacy Notice.","sections":[{"title":"Your California Privacy Rights","description":"Under California Civil Code Section 1798.83, California residents have the right to request in writing that we provide (a) a list of the categories of personal information, such as name, email and mailing address, and the type of services provided to the customer, that we have disclosed to third parties (including affiliates that are separate legal entities) during the immediately preceding calendar year, for the third parties direct marketing purpose and (b) the names and addresses of all such third parties.<br>To request the above information, please contact us as indicated in the How to Contact Us Section of this Privacy Notice, with a reference to California Shine the Light Law.<br>We will respond to such requests within 30 days following receipt of the letter or email sent to the address provided in the How to Contact Us Section. If we receive your request at a different email or mailing address, we will respond with a reasonable period, but not to exceed 150 days from the date received. Please note that we are only required to respond to each individual once per calendar year."},{"title":"Definitions and Background","description":"For ease of use of this document, certain terms have been associated with the specific meaning provided below.<br>Device means a smart phone, tablet, and any other similar mobile or connected equipment that is used for online activities.<br>Personal Information means information that identifies an individual or that, when combined with other information available to the data holder may allow identifying an individual with reasonable certainty. Personal information includes any information that is collected from the Application or from any communication between us and an individual, such as contact information that a visitor might provide when asking for information about the Application. It also includes an individuals name, address, or contact information.<br>Registered User means a User of the Application that has provided a delivery location.<br>User is an individual who uses the Application. A User can be a visitor of the Application (who merely explores the Application), or a Registered User."},{"title":"Scope","description":"This Privacy Notice applies to information that we collect or receive from Users and Registered Users of the Application. "},{"title":"Consent","description":"Users, by using the Application and providing a delivery location, consent to our processing of your information as set forth in this Privacy Notice.<br>Your continued use of the Application, or continued interaction with us after we have notified you of a material change in our Privacy Notice in accordance with the Updates will be deemed an acceptance of these new terms."},{"title":"Our Policy Towards Children and Minors","description":"India Cash & Carry does not intend that any portion of the Application will be accessed or used by children under the age of sixteen, and such use is prohibited. The Application is designed and intended for Registered Users at least 16 years of age. By using the Application, you represent that you are at least 16 years old. If you are 16 or older but under the age of majority (which is 18 years old in most states), then your parent or guardian may be liable for some or all of your activities on the Application. Because of this, and because it is prudent for your parent or guardian to be aware of your activities, including the websites that you visit, you should make your parent or guardian aware that you are using the Application."},{"title":"India Cash & Carrys Privacy Practices for Users 16 Or Older","description":"The Information We Collect<br>The Application is a platform through which Registered Users order groceries and have them delivered to a specified location. Therefore, although you do not have to share any Personal Information to browse the Application, you do need to provide a payment method and delivery location to use the Application.<br>Users may provide us with certain Personal Information when you use the Application, for instance if you include your name in your account. We refer to the information Users provider us, including the delivery location a User provides, and any Personal Information a User provides us as the Information.<br>How We Collect Information.<br>From Users<br>We collect Information in a number of ways. First, Users provide us with Information when they provide a delivery location or otherwise include Personal Information in their account.<br>Technology<br>We also use technology to collect certain information automatically, like your Internet Protocol (IP) address (which is the automatic number assigned to your computer by your Internet service provider when you surf the Web, or unique device identifier (UDID), international mobile equipment identity (IMEI), mobile equipment identifier (MEID) or media access control MAC) address; computer operating system (e.g., Microsoft Windows, Mac OS); your browser (e.g., Internet Explorer, Firefox); websites visited before or after you visit the Application; pages viewed and activities on the Application; and advertisements shown or clicked on. In addition, we use GPS and other location techniques to determine the general location of a Registered Users Device.<br>Cookies<br>We use cookies and other technologies as described below to gather information about the Users of the Application in order to know what information is or might be of interest to them. All information collected through cookies and other technologies is processed in accordance with this Privacy Notice.<br>Some cookies are managed by us, and others by our service providers. These cookies are used for a variety of purposes.<br>Some cookies enable services that you have specifically asked for. Other cookies are used to remember the choices you made (for example, the size of the font, or the language you prefer) in order to make it easier for you to use our Application when you return. Other cookies collect information about how Users use the Application. Finally, other cookies are used to collect information about your perceived interest in our products or services so that we can arrange for advertisements regarding these products or services to display on the Application or other sites that you visit on the Internet. This way, when you visit other sites that display advertisements, the advertisements that you see are more relevant to you.<br>These cookies are not linked to any contact information or identifying information, thus cookies do not tell us who you are, but they may identify your Device.<br>If you have any other questions about cookies and other technologies, please visit http://www.allaboutcookies.org/ or http://networkadvertising.org/ or contact us as indicated in the How to contact us section.<br>How We Use the Information We Collect<br>For Marketing and Business Development<br>When not precluded from doing so, we may use the Information we have received from you or about you to solicit feedback from you, including through surveys or to send you marketing communications and promotional material about other products and services. If you consistently demonstrate an interest in certain grocery items, we may propose a weekly grocery basket or otherwise initiate communication with you about this product or service, and may periodically send you additional information and news.<br>To opt out from receiving any communications from us, you need to delete the Application from your Device.<br>Analytics<br>We may aggregate (or have third parties aggregate) the Information we collect from Users and usage data in order to obtain statistical information, such as to calculate the percentage of Users in a certain area or location. We use aggregated Information to understand how the Application is used, for research or product development, for example, to measure interest in, or monitor the use of any content, product, services or promotions that we provide through the Application, to improve the content, products, services or promotions, and for the technical administration of the Application.<br>Investigations<br>We may use your Information to prevent or investigate potentially prohibited or illegal activities or to enforce our Terms of Use.<br>To Defend or Enforce our Rights<br>We may use or share your Information to establish or exercise our legal rights; to respond to a breach of our Terms of Use; when we believe it is appropriate to protect the Application, our property and rights or those of a third party; to protect ourselves and the security and safety of our company, our customers or others; and to investigate, prevent, take action against, or stop any fraudulent, illegal, unethical, or legally actionable activity, in connection with the Application.<br>Who We Share Your Information With<br>Our Workforce<br>India Cash & Carry employees and independent contractors need to have access to the Information we have collected about you to carry out their duties and obligations, such as to provide customer support, respond to inquiries, or correct an error. Only the minimum amount of Information will be made available to them as needed, and in accordance with their responsibilities. They are required to ensure at all times the confidentiality and security of your Information.<br>Service Providers<br>We may engage certain third parties to perform services including, without limitation, hosting and maintenance, customer relationship, storage, database management, collection, fraud prevention, business analytics, chat, website analytics, website optimization, lead scoring, retargeting, direct marketing campaign, or similar services. For example, we use an outside credit card processing company to bill Users for their groceries. We will share your Information with these third parties, but only to the extent that this Information is necessary to perform these functions and provide such services, and only pursuant to binding contractual obligations requiring such third parties to maintain the privacy and security of your Information.<br>If India Cash & Carry is Sold or Goes Bankrupt<br>If any or all of the assets of India Cash & Carry are acquired by, or if India Cash & Carry merges with, another entity, or in the unlikely event of a bankruptcy, we may disclose, share or transfer some or all of your Information to or with this entity in preparation of the transaction, as part of the due diligence, or after the transaction has been consummated, and we may transfer your Information after the transaction has been consummated, so that the successor entity can continue providing the Application to our Users. If the recipient of the Information has practices regarding Personal Information that do not substantially meet the substance of this Privacy Notice, you will be given the opportunity not to continue to use the Application and to have your Information deleted.<br>Compliance with Laws and Third Party Requests<br>India Cash & Carry cooperates with government and law enforcement officials or private parties to enforce and comply with the law. We may disclose any Information about you to government or law enforcement officials or private parties as we, in our reasonable discretion, believe necessary or appropriate to respond to and defend against legal claims, respond to legal process (including a facially valid subpoena, warrant, court order or other legal process), or otherwise as required by law.<br>Please note that we may not be able to notify you of a request for the disclosure of your Information as described above, either because it might be prohibited by law, or because doing so would jeopardize an investigation of illegal or fraudulent activity, or because we do not have your contact information."},{"title":"Users' Rights","description":"We want our Users to enjoy their visit to and use of the Application, and we respect their privacy. To this end, we provide numerous privacy choices.<br>While we have tried to provide all tools necessary so that Users can manage their interaction with us, as listed below, you may prefer to interact directly with us. In this case, be aware that you can contact us at any time with your questions or requests for assistance. Please refer to the How to contact us section.<br>Right to Access Your Information<br>You may access the Information we have regarding you by contacting us as indicated in the How to Contact Us. In addition, you may obtain a copy (electronic or physical) of this information by requesting it in the same manner. If the requested Information is no longer available or cannot be produced using reasonably commercial means, or if the burden or expense of accessing it would be disproportionate to the risks to you, we may deny your request and we will provide you an explanation for this denial.<br>Right to Amend, Correct, Substitute or Delete Information<br>You may request that we amend, correct, substitute, or delete information maintained and/or stored by us if you believe that it is not accurate, timely, complete, relevant, or necessary to accomplish our services. To do so, please let us know what you need, by contacting us as indicated in the How to Contact Us. If the requested Information is no longer available or cannot be modified or deleted using reasonably commercial means, or if the burden or expense of deleting it would be disproportionate to the risks to you, we may deny your request and we will provide you an explanation for this denial.<br>Right to Block Marketing Communications<br>If you no longer wish to receive marketing information or communications from us or from our affiliate entities, you must delete the Application from your Device."},{"title":"California Disclosures","description":"Do Not Track<br>California law requires that website operators disclose how they respond to a Do Not Track signal. However, because there is not yet a common understanding of how to interpret Do Not Track signals, we do not currently respond to Do Not Track signals, if any, that we might receive from browsers. We will continue to work with the online industry to define a common understanding of how to treat Do Not Track signals.<br>To learn more about online behavioral advertising, and/or to opt-out of this type of advertising, please visit the Network Advertising Initiative website or the Digital Advertising Alliance website. You can also contact us as indicated in the How to Contact Us section.<br>Third Party Cookies<br>California law requires that website operators disclose whether third parties may collect personally identifiable information about an individuals online activities. We allow third parties with which we have a separate agreement to use cookies or other technologies to collect Information about Users visit to the Application. These third parties may include business partners, which may collect information when you view or interact with certain areas of the Application, and advertising networks, which may collect information about your interests or preferences, so that they can display promotional material tailored to your apparent interest on the Application or across the Internet.<br>We do not share with these third parties any Information that would readily identify you, such as an email address, but these third parties may have access to information about your Device, such as an IP or MAC address. We do not have access to, or control over, the technologies that these third parties may use to collect information about your interests."},{"title":"Security","description":"India Cash & Carry employs administrative, physical, and electronic measures designed to protect your information from unauthorized access, loss, misuse, disclosure, alteration, and destruction.<br>When we need to transfer Information out of our firewall, we use industry-standard technological means to protect your information while in transit through the Internet. We use encryption and a comprehensive authentication protocol to provide reasonable security. However, please remember that no security system on the Internet is perfect."},{"title":"Limitation of Liability","description":"We exercise reasonable efforts to safeguard the security and confidentiality of your information; however, transmissions protected by industry standard technology and administered by humans cannot be guaranteed to be secure. We will not be liable for unauthorized disclosure of your Information that occurs through no fault of India Cash & Carry including, but not limited to, errors in transmission, uses of your data by a third party, your failure to comply with your security obligations, and the unauthorized acts of India Cash & Carrys employees."},{"title":"Links to Other Websites","description":"This Privacy Notice addresses only the use and disclosure of Information that we collect from you through the Application, through our interaction with you or from interaction with our business partners. The Application may contain links to other websites. The fact that we link to a website is not an endorsement, authorization or representation of our affiliation with that third party. We do not exercise control over third party websites. These other websites may place their own cookies or other files on your computer, collect data, or solicit personal information from you. They follow their own rules regarding the use or disclosure of the personal information you submit to them. We recommend that you to read the privacy policies or statements of these other websites."},{"title":"Disputes","description":"If you have any concerns or claims with respect to our Privacy Notice, please contact us as indicated in the How to Contact Us section. We will investigate and attempt to resolve any complaints and disputes regarding our use and disclosure of your information.<br>If the complaint or dispute cannot be resolved through our internal process, or India Cash & Carry does not adequately respond to your question, the parties agree to arbitrate the dispute. Arbitration will be conducted by telephone and email, and if it must be done in person, it will be conducted in Santa Clara County, California, using the English language in accordance with the Arbitration Rules and Procedures of JAMS then in effect, by one commercial arbitrator with substantial experience in resolving intellectual property and commercial contract disputes, who shall be selected from the appropriate list of JAMS arbitrators in accordance with the Arbitration Rules and Procedures of JAMS. The prevailing party in the arbitration shall be entitled to receive reimbursement of its reasonable expenses (including reasonable attorneys fees, expert witness fees and all other expenses) incurred in connection therewith. Judgment upon the award so rendered may be entered in a court having jurisdiction or application may be made to such court for judicial acceptance of any award and an order of enforcement, as the case may be. Notwithstanding the foregoing, each party shall have the right to institute an action in a court of proper jurisdiction for injunctive or other equitable relief pending a final decision by the arbitrator. For all purposes of this Agreement, the parties consent to exclusive jurisdiction and venue in the United States Federal Courts located in the Northern District of California."},{"title":"Updates","description":"This Privacy Notice may be updated from time to time in order to reflect changes in our practices. We will notify you of any material changes by posting the new Privacy Notice on the Application, and will obtain the necessary consents as may be required under applicable law if we seek to collect, use or disclose personal data for purposes other than those for which consent has been obtained.<br>Except as stated above, all changes will apply to the information that we have are already collected, and to information that is collected after the effective date of the revised Notice. If any proposed change is unacceptable to you, you will have the right to ask for the deletion of your information. You are advised to consult this Privacy Notice regularly for any changes."},{"title":"How to Contact Us","description":"If you have any questions, comments, concerns, complaints or claims with respect to the Site, other users of the Application, if your account has been compromised by a hacker or scammer, if another user is abusing, harassing, or stalking you, if you find that certain content displayed on the Application is inappropriate or prohibited by these Terms, or if you have any other concern, please contact us as indicated below. We will investigate and attempt to resolve the matter.<br>If you have any questions regarding these Terms or the Application, please contact us by email at   indiacashandcarry@gmail.com , or by mail at India Cash & Carry, Inc., 1032 E El Camino Real, Sunnyvale, CA 94087. "}]}},"SEO":{"title":"India Cash & Carry - Online Ordering, Indian Grocery Delivery!","description":"We are Bay Area's most favorite Indian grocery store.","image":"/images/client-assets/icc/seo-image.jpg"},"hideAnnouncementBanner":false,"sitemapFolder":"icc","thermalPrinting":true,"placeOrderForUser":false,"showOrderFormInAdmin":false,"showOrderFormAdminProduct":false,"enableNewCheckout":true,"enableAdminAddProduct":false,"hideProductPrice":false,"limitCreateOrderProducts":true,"disabledRestrictedAdminProductChange":false,"salesPage":false,"disableOrdering":false,"noOrderingConfig":{"productPage":{"icon":"ordering-disabled.jpg","title":"Online Ordering Temporarily Suspended","description":"We have temporarily suspended online ordering. We have received huge amount of online orders and these orders have filled all our capacity for the next few days. Please check back in a couple of days as we resume online ordering. We apologize for any inconvenience this may cause.<br><br>The stores are open and operating at usual business hours. Please stop by our one of our stores to shop.<br><br>We thank you for your understanding as we work through making online ordering operational again in the next couple of days.","btn":{"text":"Contact Us","href":"/contact","target":""}}},"showOrderCreatedTime":false,"sortCategoryOrder":false,"enableSendToQB":false,"sortSubCategoryOrder":false,"enableFacebookLogin":false,"enableGoogleLogin":false,"assignPackerDriver":true,"hideAboutPage":false,"disableDiscountCode":false,"showReports":{"sales":true,"users":true,"movement":true,"lostRevenue":true},"showLocationSettings":true,"showBottleFee":true,"enableBulkProductUpdate":false,"showPriceToRestrictedAdmin":false,"redirectConfig":false,"autoCheckoutLocationChange":true,"canPackersUpdatePriceInOrder":true,"canRestrictedAdminCancelOrder":false,"canRestrictedAdminCompleteOrder":true,"clientPages":[],"contactPageOveride":"","promptOutOfStockWhenRemoved":false,"enablePackingCompletedFlow":false,"showSkipButtonPackingCompletedFlow":true,"showExitButtonPackingCompletedFlow":true,"enableTableSideOrder":false,"showGridMenuItemImage":false,"enableSeparateTips":false,"enableUpcScanner":false,"packerRequiredToInputUpc":false,"canPackersIssueRefund":true,"canPackersCreateCustomItem":true,"enableDeliveryService":true,"hideRefundButton":false,"isWarehouse":false,"showManageCoupons":true,"showManagePromotions":true,"deliveryPartner":false,"newLocation":false,"deliveryPartnerFooter":false,"headerLogoPosition":"center","enableJumpToTop":false,"enableLoginToStoreAdmin":false,"itemInstructionsPlaceholderText":"For Example: No Onions, No Bell Peppers, Make It Extra Spicy.","fiservConfig":{"site":"isv"},"showHeaderBoxShadow":true,"customOrderPoints":false,"enableProductBulkOps":true,"hideChargesAndFulfillmentFAQ":false,"hideHeaderContactTab":false,"footerContactLink":"/contact","showPrivacyPolicy":true,"showTermsAndConditions":true};
/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('adminCtrl', [
    '$scope', '$rootScope','$location','$http','globalFunctions','OpenGraphTags','ENV','$sce','$q','scrollToElement','$routeParams','$filter','allProducts','hsCart','hsAuth','toastr','address','localStorageService','$interval','$document','hsAdmin','ngDialog','$window','$route', 'hsApi','guid', 'NgTableParams', 'ngTableEventsChannel', 'hsSearch', 'VALIDATORS', 'hsUpc', '$timeout', 'hsDialog', 'hsUtils', 'hsManagedDelivery', 'hsConversations', 'hsPromos',
	'scannerUtils', 'hsPickingApp', 'hsModifiers',
    function($scope, $rootScope, $location,$http,globalFunctions,OpenGraphTags,ENV,$sce,$q,scrollToElement,$routeParams,$filter, allProducts, hsCart, hsAuth, toastr, address, localStorageService, $interval,$document,hsAdmin, ngDialog, $window, $route, hsApi, guid, NgTableParams, ngTableEventsChannel, hsSearch, VALIDATORS, hsUpc, $timeout, hsDialog, hsUtils, hsManagedDelivery, hsConversations, hsPromos, scannerUtils, hsPickingApp, hsModifiers){

	void 0;

    if(!$rootScope.loggedIn) {
    	if (Object.keys($location.search()).length > 0) {
    		var routeParams = $location.search();
    		routeParams['multipleParams'] = true;
    		routeParams['urlPath'] = $location.path();

	    	$location.path('/login').search(routeParams);
		} else {
            $location.url('/login?redirect=' + $location.path());
		}
    	return;
    }else if(!$rootScope.currentUser.isAdmin){
        $location.url('/');
        return;
    } else {
    	if (ENV.enableLocations) {
		    var location = localStorageService.get('location');
    		var user = localStorageService.get('user');
    		if (user.adminLocations.length > 1) {
			    if (location) {
				    var isAdminLocationSelected = localStorageService.get('adminLocationSelected');
				    if (!isAdminLocationSelected) {
					    globalFunctions.showAdminLocationsPopup(function() {
						    $route.reload();
					    });
					    return;
				    }
			    } else {
				    globalFunctions.showAdminLocationsPopup(function() {
				    	$route.reload();
				    });
				    return;
			    }
		    } else {
			    if(location){
				    if(location.allLocations){
					    location.allLocations.forEach(function(val){
						    if(val.uniqueName === $rootScope.currentUser.adminLocations[0]){
							    location.selectedLocation = val;
						    }
					    });
					    localStorageService.set('location', location);
						var defaultPricelist = location.selectedLocation.priceLists.find(function (pl) {
							return pl.default;
						});
					    if (ENV.enablePriceList) {
					    	localStorageService.set('selectedPriceList', defaultPricelist);
					    }
					    $rootScope.location = location;

					    localStorageService.set('adminLocationSelected', true);
				    } else {
					    globalFunctions.showAdminLocationsPopup(function() {
						    $route.reload();
					    });
					    return;
				    }
			    } else {
				    globalFunctions.showAdminLocationsPopup(function() {
					    $route.reload();
				    });
				    return;
			    }
		    }
		}

		if ($rootScope.orderInterval) {
			clearInterval($rootScope.orderInterval);
		}

		if ($rootScope.ENV.enableOrderDate) {
			$rootScope.orderInterval = setInterval(function() {
				if ($rootScope.loggedIn && $rootScope.currentUser.isAdmin) {
					$scope.admin.getTodaysOrders($scope.admin.config.isDashboardPage, $scope.admin.priceListFilterCriteria);
				} else if ($rootScope.orderInterval) {
					clearInterval($rootScope.orderInterval);
				}
			},60000);
		} else {
			$rootScope.orderInterval = setInterval(function() {
				if (!$scope.admin.config.dashboardConfig.dateObj) {

					var todaysDate = new Date();

					$scope.admin.config.dashboardConfig.dateObj = {
						day     : todaysDate.getDate(),
						month   : todaysDate.getMonth(),
						year    : todaysDate.getFullYear()
					};
				}

				if ($rootScope.loggedIn && $rootScope.currentUser.isAdmin) {

					$scope.admin.getDashboardItems($scope.admin.config.dashboardConfig.dateObj,
						$scope.admin.config.dashboardConfig.orderStatus,
						$scope.admin.config.dashboardConfig.isUpdating,
						$scope.admin.config.dashboardConfig.processNewOrderAlert,
						$scope.admin.config.dashboardConfig.isOrderDetailsPage,
						$scope.admin.priceListFilterCriteria);

				} else if ($rootScope.orderInterval) {
					clearInterval($rootScope.orderInterval);
				}
			},60000);
		}

    }

    $scope.csvValueFields = [];
    $scope.bulkUpdateSuccess = true;

	var usValidator = { required: true, number: true, minlength: 5, maxlength: 5};
	var caValidator = { required: true, caZip: true, minlength: 7, maxlength: 7};
    
    $scope.admin = {
	    config: {
            activateUpcScannerLength: 12,
		    pageFullyLoaded: false,
		    showPackingPreview: false,
		    showUpdatedAddressSection: false,
		    showUpdatedCCSection: false,
		    showOrderDetails: false,
		    showSyncPrices: false,
		    addressNonEditable: false,
		    showChangeLog: false,
		    total: '',
		    emptyCart: false,
		    checkoutError: '',
		    buttonLoading: false,
		    updateCCError: '',
		    updateCCButtonLoading: false,
		    updateAddressError: '',
		    updateAddressButtonLoading: false,
		    alertClass: '',
		    alertMessage: '',
		    isDashboardPage: false,
		    dashboardConfig: {
			    dateObj: null,
			    orderStatus: null,
			    isUpdating: false,
			    processNewOrderAlert: true,
			    isOrderDetailsPage: false
		    },
			showChat: false,
			autoSendMessageEnabled: false,
			packerRequiredForConversation: false,
		    scrollTo: function (section) {
			    scrollToElement(section);
		    },
		    navigateTo: function (url) {
			    $location.url(url);
		    },
		    updateSEOdata: function ($title, $keywords, $description, $image) {
			    globalFunctions.setSEOdata($title, $keywords, $description, $image);
		    },
            getFormattedDateForPrinting: function () {
                var order = _.get($scope, 'admin.adminData.orderDetails.order');
                
                if (!order || !order.deliveryDate || !order.deliveryTime) {
                    return '';
                }

                var deliveryDate = order.deliveryDate;
                var deliveryTime = order.deliveryTime;

                var deliveryDateArr = deliveryDate.split(' ');

                var day = deliveryDateArr[0];
                var month = deliveryDateArr[1];
                var year = deliveryDateArr[2];

                return month + ' ' + day + ', ' + year + ' ' + deliveryTime;
            },
		    bankAccountValidationRules: {},
            setBankAccountValidationRules: function (country) {
                void 0;
                $scope.admin.config.bankAccountValidationRules = {
                    rules               : {
                        bankAccountNumber   : { required: true, number: true },
                        bankRoutingNumber   : { required: true, maxlength: 9, minlength: 9 },
                        businessName        : { required: true },
                        businessTaxId       : { required: true },
                        firstName           : { required: true },
                        lastName            : { required: true },
                        email               : { required: true, emailRobust: true },
                        phoneUS             : { required: true, phoneUS: true },
                        title               : { required: true },
                        dobDay              : { required: true, number: true, min:1, max:31},
                        dobMonth            : { required: true, number: true, min:1, max: 12},
                        dobYear             : { required: true, number: true, minlength: 4, maxlength: 4},
                        addressStreet1      : { required: true},
                        addressCity         : { required: true},
                        addressState        : { required: true},
                        addressZip          : country === 'US' ? usValidator : caValidator,
                        addressCountry      : { required: true}
                    },
                    messages            : {
                        bankAccountNumber: {
                            required    : "Please enter a valid bank account number",
                            number      : "Please enter a valid bank account number",
                        },
                        bankRoutingNumber: {
                            required    : "Please enter a valid bank account routing number",
                            maxLength: "Please enter a valid bank account routing number",
                            minLength: "Please enter a valid bank account routing number",
                        },
                        businessName    : {
                            required    : "Valid business name required"
                        },
                        businessTaxId   : {
                            required    : "Valid business tax id required"
                        },
                        firstName       : {
                            required    : "Please enter representative legal first name"
                        },
                        lastName        : {
                            required    : "Please enter representative legal last name"
                        },
                        title        : {
                            required    : "Please enter representative official title"
                        },
                        email: {
                            required: "Please enter your email address",
                            emailRobust: "Your email address must be in the format of name@domain.com"
                        },
                        phoneUS         : {
                            required    : "Please enter valid phone number",
                            phoneUS     : "Please enter valid phone number"
                        },
                        dobDay          : {
                            required    : "Please enter day of your D.O.B",
                            number      : "Please enter valid day of your D.O.B",
                            min         : "Please enter valid day of your D.O.B",
                            max         : "Please enter valid day of your D.O.B",
                        },
                        dobMonth        : {
                            required    : "Please enter month of your D.O.B",
                            number      : "Please enter valid month of your D.O.B",
                            min         : "Please enter valid month of your D.O.B",
                            max         : "Please enter valid month of your D.O.B",
                        },
                        dobYear         : {
                            required    : "Please enter year of your D.O.B",
                            number      : "Please enter valid year of your D.O.B",
                            minLength   : "Please enter full year in YYYY format",
                            maxLength   : "Please enter full year in YYYY format",
                        },
                        addressStreet1  : {
                            required    : "Please enter business street address"
                        },
                        addressCity     : {
                            required    : "Please enter business address city"
                        },
                        addressState    : {
                            required    : "Please enter business address state"
                        },
                        addressZip      : {
                            required    : "Please enter business address zip code",
                            number      : "Please enter valid zip code",
                            minLength   : "Please enter valid zip code",
                            maxLength   : "Please enter valid zip code",
                        },
                        addressCountry  : {
                            required    : "Please enter business address country"
                        },
                    }
                };
            },
		    checkoutValidationRules: {
			    rules: {
				    ccNumber: {
					    required: true
				    },
				    ccExpiry: {
					    required: true
				    },
				    ccCvc: {
					    required: true
				    },
				    zipCode: {
					    required: true,
					    number: true,
					    minlength: 5,
					    maxlength: 5
				    },
				    street1: {
					    required: true
				    },
				    city: {
					    required: true
				    },
				    state: {
					    required: true
				    },
				    zip: {
					    required: true,
					    number: true,
					    minlength: 5,
					    maxlength: 5
				    },
				    phoneUS: {
					    required: true,
					    phoneUS: true
				    }
			    },
			    messages: {
				    ccNumber: {
					    required: "Please enter your Credit Card number"
				    },
				    ccExpiry: {
					    required: "Expiration date required"
				    },
				    ccCvc: {
					    required: "Enter security code from behind the card."
				    },
				    zipCode: {
					    required: "Please enter valid zipcode",
					    number: "Please enter numbers only",
					    minlength: "zipcode must be 5 digits",
					    maxlength: "zipcode must be 5 digits"
				    },
				    street1: {
					    required: "Please enter your street address"
				    },
				    city: {
					    required: "Please enter your city"
				    },
				    state: {
					    required: "Please select your state"
				    },
				    zip: {
					    required: "Please enter valid zipcode",
					    number: "Please only enter numbers",
					    minlength: "zipcode must be 5 digits",
					    maxlength: "zipcode must be 5 digits"
				    },
				    phoneUS: {
					    required: "Please enter valid phone number",
					    phoneUS: "Please enter valid phone number"
				    }
			    }
		    },
		    ccValidationRules: {
			    rules: {
				    ccNumber: {
					    required: true
				    },
				    ccExpiry: {
					    required: true
				    },
				    ccCvc: {
					    required: true
				    },
				    zipCode: {
					    required: true,
					    number: true,
					    minlength: 5,
					    maxlength: 5
				    }
			    },
			    messages: {
				    ccNumber: {
					    required: "Please enter your Credit Card number"
				    },
				    ccExpiry: {
					    required: "Expiration date required"
				    },
				    ccCvc: {
					    required: "Enter security code from behind the card."
				    },
				    zipCode: {
					    required: "Please enter valid zipcode",
					    number: "Please enter numbers only",
					    minlength: "zipcode must be 5 digits",
					    maxlength: "zipcode must be 5 digits"
				    }
			    }
		    },
		    addressValidationRules: {
			    rules: {
				    street1: {
					    required: true
				    },
				    city: {
					    required: true
				    },
				    state: {
					    required: true
				    },
				    zip: {
					    required: true,
					    number: true,
					    minlength: 5,
					    maxlength: 5
				    }
			    },
			    messages: {
				    street1: {
					    required: "Please enter your street address"
				    },
				    city: {
					    required: "Please enter your city"
				    },
				    state: {
					    required: "Please select your state"
				    },
				    zip: {
					    required: "Please enter valid zipcode",
					    number: "Please only enter numbers",
					    minlength: "zipcode must be 5 digits",
					    maxlength: "zipcode must be 5 digits"
				    }
			    }
		    },
		    createOrderValidationRules: {
			    rules: {
				    email: {
					    email: true
				    },
				    phone: {
					    phoneUS: true
				    },
			    },
			    messages: {
				    email: {
					    email: "Please enter a valid email"
				    },
				    phone: {
					    phoneUS: "Please enter a valid phone number"
				    },
			    }
		    },
		    productUpdateValidationRules: {
			    rules: {
				    productName: {
					    required: true
				    },
				    type: {
					    required: true
				    },
				    subType: {
					    required: true
				    },
				    unit: {
					    required: true
				    },
					unitQuantity: {
						required: true,
						number: true
					},
                    unitIncrement: {
                        number: true,
                        gt: 0,
                        decimals: 2,
                    },
				    price: {
					    required: true,
					    number: true
				    },
				    minQuantity: {
						min: 0,
						number: true
				    },
				    maxQuantity: {
						min: 0,
						number: true
				    },
				    taxRate: {
						min: 0,
						number: true
				    },
                    avgWeight: {
                        gt: 0,
                        number: true,
                        decimals: 2,
                        required: function () {
                            return $scope.admin.productData.product.sellByQty;
                        },
                    },
                    bottleFee: {
                        min: 0,
                        number: true,
                        decimals: 2,
                    },
					sortOrderCustom: {
						number: true,
                        range: [1, 20000],
                    },
					additionalDeliveryFee: {
                        min: 0,
                        number: true,
                        decimals: 2,
                    },
			    },
			    messages: {
				    productName: {
					    required: "Please enter product Name"
				    },
				    type: {
					    required: "Please enter product type"
				    },
				    subType: {
					    required: "Please enter product sub type"
				    },
				    unit: {
					    required: "Please enter unit for the product"
				    },
				    price: {
					    required: "Please enter price",
					    number: "Value must be Number"
				    },
                    avgWeight: {
                        required: "Please enter an average weight",
                        number: "Value must be a Number",
                    }
			    }
		    },
		    addProductValidationRules: {
			    rules: {
				    name: {
					    required: true
				    },
				    type: {
					    required: true
				    },
				    subType: {
					    required: true
				    },
				    typeBox: {
					    required: true
				    },
				    subTypeBox: {
					    required: true
				    },
				    price: {
					    required: true,
					    number: true
				    }
			    },
			    messages: {
				    productName: {
					    required: "Please enter product Name"
				    },
				    type: {
					    required: "Please enter product type"
				    },
				    subType: {
					    required: "Please enter product sub type"
				    },
				    typeBox: {
					    required: "Please enter product type"
				    },
				    subTypeBox: {
					    required: "Please enter product sub type"
				    },
				    unit: {
					    required: "Please enter unit for the product"
				    },
				    price: {
					    required: "Please enter price",
					    number: "Value must be Number"
				    }
			    }
		    },
            locationSettingsValidationRules: {
                rules: {
                    email: {
                        email: true,
                    },
                    phoneNumber: {
                        phoneUS: true,
                    },
                    bagFee: {
                        number: true,
                    },
                    taxRate: {
                        number: true,
                        range: [0, 100],
                    },
                    pickupFee: {
                        number: true,
                    },
                    pickupMinimumOrder: {
                        number: true,
                    },
                    minimumOrderForFreePickup: {
                        number: true,
                    },
                    pickupServiceFee: {
                        number: true,
                        range: [0, 100],
                    },
                    deliveryFee: {
                        number: true,
                    },
                    deliveryMinimumOrder: {
                        number: true,
                    },
                    minimumOrderForFreeDelivery: {
                        number: true,
                    },
                    deliveryServiceFee: {
                        number: true,
                        range: [0, 100],
                    },
                    maxDistance: {
                        number: true,
                    },
                    maxOrdersPerDay: {
                        digits: true,
                        required: true,
                        min: 1,
                    },
                    maxOrdersPerSlot: {
                        digits: true,
                        required: true,
                        min: 1,
                    },
                    weekdayMaxOrdersPerDay: {
                        digits: true,
                        required: true,
                        min: 1,
                    },
                    weekdayMaxOrdersPerSlot: {
                        digits: true,
                        required: true,
                        min: 1,
                    },
                },
            },
	    },
	    productUpdate : {
	    	file: '',
		    error: '',
		    success: false,
		    loading: false,
		    override: false,
		    isTaxable: false,
		    exts: ['.xlsx', '.xls', '.csv'],
	    	mimes: [
	    		'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
			    'application/vnd.ms-excel',
			    'application/vnd.oasis.opendocument.spreadsheet',
			    'text/csv'
		    ],
		    accept: '.xlsx , .xls, .csv',
		    pattern: '.xlsx , .xls, .csv',
		    gotFileData: false,
		    csv: [],
		    uploadedData: [],
		    parsedData: [],
		    config: {
			    taxIndex: 0,
			    descriptionIndex: null,
			    itemUpcIndex: null,
			    priceIndex: null,
			    minComponents: null
		    },
		    indexDropdownOptions: [
			    { id: 'select', value: 'Select'},
			    { id: 'price', value: 'Price'},
			    { id: 'description', value: 'Description'},
			    { id: 'upc', value: 'UPC'}
		    ],
		    processIndex() {
			    var descriptionIndex = null;
			    var itemUpcIndex = null;
			    var priceIndex = null;
			    var minComponents = this.uploadedData[0].length;
			    
			    for(var i = 0; i < minComponents; i++) {
			    	var value = $('#dropdown-' + i).val();
			    	if (value.toLowerCase() === 'price') {
			    		priceIndex = i;
				    } else if (value.toLowerCase() === 'description') {
					    descriptionIndex = i;
				    } else if (value.toLowerCase() === 'upc') {
					    itemUpcIndex = i;
				    }
			    }

			    if (priceIndex === null || descriptionIndex === null || itemUpcIndex === null) {
				    toastr.error('Selection incomplete. Please select all required columns to continue.');
				    this.error = 'Selection incomplete. Please select all required columns to continue.';
			    } else {
			    	this.config.descriptionIndex = descriptionIndex;
				    this.config.itemUpcIndex = itemUpcIndex;
				    this.config.priceIndex = priceIndex;
				    this.config.minComponents = minComponents;

				    this.loading = true;

				    this.parseCSV(this.csv, function(err, data) {
				    	if (err) {
						    toastr.error('Unable to parse file with selection. Please update selection and try again.');
						    $scope.admin.productUpdate.error = 'Unable to parse file with selection. Please update selection and try again.';
					    } else {
						    if ($scope.admin.productUpdate.parsedData.length === 0) {
							    toastr.error('Unable to parse file with selection. Please update selection and try again.');
							    $scope.admin.productUpdate.error = 'Unable to parse file with selection. Please update selection and try again.';
							    $scope.admin.productUpdate.loading = false;
							    return;
						    }

						    ngDialog.openConfirm({
							    data: {
								    data: $scope.admin.productUpdate.parsedData,
								    confirmBtnText: 'Confirm',
								    cancelBtnText: 'Cancel'
							    },
							    template: 'partials/popup/bulk-product-update-confirm-popup.html'
						    }).then(function (confirm) {
							    void 0;
							    $scope.admin.productUpdate.updateBulkProduct();
						    }, function (reject) {
							    void 0;
							    $scope.admin.productUpdate.loading = false;
							    return;
						    });
					    }
				    });
			    }
		    },
		    init() {
		    	$scope.admin.config.pageFullyLoaded = true;
		    },
		    updateBulkProduct() {
			    if ($scope.admin.productUpdate.parsedData.length === 0) {
			    	toastr.error('Unable to parse file with selection. Please update selection and try again.');
			    	this.error = 'Unable to parse file with selection. Please update selection and try again.';
				    $scope.admin.productUpdate.loading = false;
				    return;
			    }
			    
			    hsAdmin.updateBulkProduct({ productList: $scope.admin.productUpdate.parsedData })
				    .then(function (res) {
				    	if (res.status === 200) {
				    		toastr.success('Your request to update inventory has been submitted successfully.');

				    		// show success message
						    $scope.admin.productUpdate.success = true;

				    		// reset all the flags
					        $scope.admin.productUpdate.error = '';
					        $scope.admin.productUpdate.gotFileData = false;
					        $scope.admin.productUpdate.loading = false;
						    $scope.admin.productUpdate.csv = [];
						    $scope.admin.productUpdate.uploadedData = [];
						    $scope.admin.productUpdate.parsedData = [];
						    $scope.admin.productUpdate.config = {
							    taxIndex: 0,
							    descriptionIndex: null,
							    itemUpcIndex: null,
							    priceIndex: null,
							    minComponents: null
						    };
					    } else {
						    toastr.success('Something went wrong submitting your request. Please try again.');
						    $scope.admin.productUpdate.error = 'Something went wrong submitting your request. Please try again.';
						    $scope.admin.productUpdate.loading = false;
					    }
				    });

		    },
		    uploadFile(files, file) {
	    		if (file) {
				    $scope.admin.productUpdate.error = '';
	    			$scope.admin.productUpdate.loading = true;

	    			if (file.name.indexOf('.xls') !== -1) {
					    // Initialize an instance of the `FileReader`
					    var reader = new FileReader();

					    // Specify the handler for the `load` event
					    reader.onload = function (e) {
						    var binary = "";
						    var bytes = new Uint8Array(e.target.result);
						    var length = bytes.byteLength;
						    for (var i = 0; i < length; i++) {
							    binary += String.fromCharCode(bytes[i]);
						    }
						    // call 'xlsx' to read the file
						    var xlsFile = XLSX.read(binary, {type: 'binary'});

						    // console.log(xlsFile);
						    var csv = XLSX.utils.sheet_to_csv(xlsFile.Sheets[xlsFile.SheetNames[0]]);
						    $scope.admin.productUpdate.csv = csv;
						    // console.log(csv);


						    Papa.parse(csv, {
							    worker: true,
							    complete(results) {
								    if (results.data.length) {
									    $scope.admin.productUpdate.uploadedData = results.data;


									    $scope.admin.productUpdate.loading = false;
									    $scope.admin.productUpdate.gotFileData = true;
								    } else {
									    $scope.admin.productUpdate.uploadedData = [];

									    $scope.admin.productUpdate.loading = false;
									    $scope.admin.productUpdate.gotFileData = false;
									    $scope.admin.productUpdate.error = 'Error Parsing data from file.';
								    }
								    $scope.$apply();
							    }
						    });
					    }

					    // Read the file
					    reader.readAsArrayBuffer(file);

				    } else if (file.name.indexOf('.csv') !== -1) {
					    Papa.parse(file, {
						    worker: true,
						    complete(results) {
							    void 0;
							    if (results.data.length) {
								    $scope.admin.productUpdate.uploadedData = results.data;

								    $scope.admin.productUpdate.loading = false;
								    $scope.admin.productUpdate.gotFileData = true;
							    } else {
								    $scope.admin.productUpdate.uploadedData = [];

								    $scope.admin.productUpdate.loading = false;
								    $scope.admin.productUpdate.gotFileData = false;
								    $scope.admin.productUpdate.error = 'Error Parsing data from file.';
							    }

							    $scope.$apply();
						    }
					    });
				    } else {
					    $scope.admin.productUpdate.error = 'Invalid File format. Only Excel and CSV files are allowed.'
					    $scope.admin.productUpdate.loading = false;
				    }
			    }
		    },
		    parseCSV(csv, cb) {
			    $scope.admin.productUpdate.parsedData = [];

			    Papa.parse(csv, {
				    worker: true,
				    step(row) {
					    $scope.admin.productUpdate.parseInventory(row.data);
				    },
				    complete(results) {
					    cb(null, $scope.admin.productUpdate.parsedData);
				    }
			    });
		    },
		    getUpc12(upc) {

			    if (upc.length === 11) {

				    var multiplier = 1;
				    var sum = 0;

				    for (var i = 0; i < upc.length; i++) {

					    multiplier = i % 2;

					    if (multiplier === 0) {
						    multiplier = 3;
					    } else {
						    multiplier = 1;
					    }

					    sum += (upc[i] * multiplier);
				    }

				    var checkdigit = 0;

				    if (sum % 10 !== 0) {
					    multiplier = sum/10;
					    multiplier = (Math.floor(multiplier) + 1);
					    multiplier = multiplier * 10;
					    checkdigit = multiplier - sum;
				    }

				    return upc.concat(checkdigit);
			    }

			    return upc;
		    },
		    parseInventory (components) {
			    if (components.length < this.config.minComponents) {
				    // line doesnt contain required product info
				    // console.log("Error parsing line in inventory file " + line); // commented for noise reduction
				    return;
			    }
			    
			    // console.log(components.length);

			    var taxableInfo = components[this.config.taxIndex];
			    taxableInfo = taxableInfo.trim();

			    if (taxableInfo && taxableInfo.charAt(0) === '*') {

				    taxableInfo = taxableInfo.toLowerCase();

				    // department
				    this.isTaxable = taxableInfo.indexOf("tax") !== -1 && taxableInfo.indexOf("no tax") === -1;
			    }

			    var itemUpc = components[this.config.itemUpcIndex];
			    var itemPrice = components[this.config.priceIndex];

			    if (!itemUpc) {
				    // line doesnt contain required product info
				    // console.log("Invalid or not a UPC " + line); // commented for noise reduction
				    return;
			    }

			    itemUpc = itemUpc.trim();

			    if (!itemUpc || isNaN(itemUpc) === true) {
				    // line doesnt contain required product info
				    // console.log("Invalid or not a UPC " + line); // commented for noise reduction
				    return;
			    }

			    itemUpc = this.getUpc12(itemUpc);

			    if (!itemPrice) {
				    // console.log("Invalid or not a price " + line); // commented for noise reduction
				    return;
			    }

			    itemPrice = itemPrice.trim();

			    // get rid of the $ at the front if present
			    if (itemPrice.charAt(0) === '$') {
				    itemPrice = itemPrice.substring(1);
			    }

			    // trim again as sometimes there are spaces after $
			    itemPrice = itemPrice.trim();

			    if (!itemPrice || isNaN(itemPrice) === true) {
				    // console.log("Invalid or not a price " + line); // commented for noise reduction
				    return;
			    }

			    itemPrice = parseFloat(itemPrice);
			    itemPrice = Math.round(itemPrice * 100)/100;

			    var description = components[this.config.descriptionIndex];
			    description = description.trim();

			    // console.log(itemUpc, itemPrice, isTaxable);
			    this.parsedData.push({
					upc: itemUpc,
					price: itemPrice,
					isTaxable: isTaxable,
					description: description || '',
			    });
		    }
	    },

		formatOrderCreatedDate: function(order) {
			return globalFunctions.getFormattedTimeFromTimestamp(order.timeCreatedMSec);
		},

        getManagedDelivery: function() {
            return $scope.admin.adminData.orderDetails.order.managedDelivery;
        },
        
        getPostmatesDeliveryStatus: function() {
            var managedDelivery = $scope.admin.getManagedDelivery();
            if (!managedDelivery) {
                return '';
            }
            return globalFunctions.POSTMATES_STATUS_CODES[managedDelivery.status] || '';
        },
        wasDeliveryUnsuccessful: function() {
            var status = $scope.admin.getPostmatesDeliveryStatus();
            return status === globalFunctions.POSTMATES_STATUS_CODES.canceled || status === globalFunctions.POSTMATES_STATUS_CODES.returned;
        },
        isOrderDelivered: function() {
            var status = $scope.admin.getPostmatesDeliveryStatus();
            return status === globalFunctions.POSTMATES_STATUS_CODES.delivered;
        },
        isDeliveryInProgress: function() {
            return !$scope.admin.wasDeliveryUnsuccessful() && !$scope.admin.isOrderDelivered();
        },
        formatPackerName: function(order) {
            if (!order.packer || !order.packer.fullName) {
                return 'N/A';
            }

            var fullNameArr = order.packer.fullName.split(/\s+/);
            var firstName = fullNameArr[0];
            var lastName = fullNameArr[1];
            
            return firstName + ' ' + lastName[0].toUpperCase() + '.';

        },
	    showDeliveryProof(proofImage) {
		    ngDialog.open({
			    template: 'partials/popup/admin-show-delivery-proof-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    data: {
				    proof: proofImage
			    }
		    });
	    },
	    toggleActionMenu() {
		    this.showActionMenu = !this.showActionMenu;
	    },
	    showActionMenu              : false,
	    selectedProductCategory: '',
	    productBackUrl: '',
	    activeTabIndex: 0,
	    changeLogItems: ['All'],
	    selectedChangeLogItem: 'All',
	    assignDriver() {
		    ngDialog.open({
			    template        : 'partials/popup/admin-assign-driver-minimal.html',
			    controller      : 'ModalController',
			    className       : 'ngdialog-theme-default',
			    showClose       : false,
			    closeByDocument : false,
			    closeByEscape   : false,
			    scope           : $scope,
			    name            : 'assignDriver',
			    id              : 'assignDriver',
			    preCloseCallback: function(success) {
				    if (success) {
					    $scope.admin.initOrderDetails();
				    }
			    }
		    });
	    },
	    addDecimal($event, id, decimal) {
	    	if ($event.key === 'Enter') {
	    		return;
		    }

	    	$event.preventDefault();
	    	if (!decimal) { decimal = 2;}

	    	var quantity = $(id).val();
	    	quantity = quantity.toString().replace('.', '');
	    	var key = $event.key.toString();
	    	void 0;
	    	quantity += key;
	    	quantity = parseFloat(quantity);
	    	quantity = quantity/100;
	    	quantity = quantity.toFixed(decimal);
		    $(id).val(quantity);
	    },
	    rewards: {
		    numberKeyMap: {
			    48: 0,
			    49: 1,
			    50: 2,
			    51: 3,
			    52: 4,
			    53: 5,
			    54: 6,
			    55: 7,
			    56: 8,
			    57: 9,
			    96: 0,
			    97: 1,
			    98: 2,
			    99: 3,
			    100: 4,
			    101: 5,
			    102: 6,
			    103: 7,
			    104: 8,
			    105: 9,
			    8: 'backspace',
			    46: 'backspace'
		    },
		    backspace  : 8,
		    enter  : 13,
		    preventBackspaceNavigation : function () {
			    document.onkeydown = function (event) {
				    if (!event) { /* This will happen in IE */
					    event = window.event;
				    }

				    if (event.keyCode === 8) {
					    if (navigator.userAgent.toLowerCase().indexOf("msie") === -1) {
						    event.stopPropagation();
					    } else {
						    event.returnValue = false;
					    }
					    return false;
				    }
			    };
		    },
		    initRewardsDashboard: function () {
			    if (!ENV.enableRewards) {
				    $location.url('/admin/manager-dashboard');
				    return;
			    }

			    $scope.admin.rewards.preventBackspaceNavigation();

                function listener(event) {
                    $scope.admin.rewards.addPoints.processKeydown(event.keyCode);
                    $scope.$digest();
                }

                $window.document.body.addEventListener("keydown", listener);

                $scope.$on('$destroy', function () {
                    $window.document.body.removeEventListener('keydown', listener);
                });
		    },
		    config: {
			    loading: false,
			    phoneValidationRules: {
				    rules: {
					    phone: {
						    required: true,
						    phoneUS: true
					    }
				    },
				    messages: {
					    phone: {
						    required: "Please enter valid phone number",
						    phoneUS: "Please enter valid phone number"
					    }
				    }
			    },
			    transactionValidationRules: {
				    rules: {
					    transaction: {
						    required: true,
						    number: true
					    }
				    },
				    messages: {
					    transaction: {
						    required: "Please enter valid amount",
						    number: "Please only enter numbers"
					    }
				    }
			    },
		    },
		    showUnavailableRewards: false,
		    toggleShowUnavailableRewards: function () {
		    	this.showUnavailableRewards = !this.showUnavailableRewards;
		    },
		    data: {
			    all: {},
			    availableRewards: [],
			    unavailableRewards: [],
		    },
		    calculator: {
			    numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9]
		    },
		    backToRewards: function () {
		    	$scope.admin.rewards.data = {
				    all: {},
				    availableRewards: [],
				    unavailableRewards: [],
			    };
		    	$scope.admin.rewards.addPoints.steps = {
				    phoneNumber: true,
				    transaction: false
			    };
	            $scope.admin.rewards.addPoints.selectedReward = '';
			    $scope.admin.rewards.addPoints.transactionAmount = '0.00';
			    $scope.admin.rewards.addPoints.amount = '';
		    },
		    reload: function () {
		    	$scope.admin.rewards.addPoints.reset();
		    	$route.reload();
		    },
		    addPoints: {
		    	reset: function () {
				    $scope.admin.rewards.addPoints.steps = {
					    phoneNumber: false,
					    transaction: false
				    };
				    $scope.admin.rewards.addPoints.success = {
					    status: false,
					    transaction: false,
					    redeem: false
				    };
				    $scope.admin.rewards.addPoints.phone = {
					    first: '',
					    second: '',
					    third: ''
				    };
				    $scope.admin.rewards.addPoints.showSubmitBtn = false;
				    $scope.admin.rewards.addPoints.phoneNumber = '';
				    $scope.admin.rewards.addPoints.selectedReward = '';
				    $scope.admin.rewards.addPoints.transactionAmount = '0.00';
				    $scope.admin.rewards.addPoints.amount = '';
			    },
			    success: {
			    	status: false,
			    	transaction: false,
			    	redeem: false
			    },
			    steps: {
				    phoneNumber: true,
				    transaction: false
			    },
			    phone: {
				    first: '',
				    second: '',
				    third: ''
			    },
			    showSubmitBtn: false,
			    phoneNumber: '',
			    selectedReward: '',
			    transactionAmount: '0.00',
			    amount: '',
			    processKeydown : function (key) {
			    	if ($scope.admin.rewards.addPoints.steps.phoneNumber) {
			    		if ($scope.admin.rewards.numberKeyMap.hasOwnProperty(key)) {
						    $scope.admin.rewards.addPoints.addKey($scope.admin.rewards.numberKeyMap[key], true);
					    } else if (key === $scope.admin.rewards.enter
						    && this.phoneNumber.length === 10) {
			    			$scope.admin.rewards.addPoints.enterPhone();
					    }
				    }

				    if ($scope.admin.rewards.addPoints.steps.transaction) {
					    if ($scope.admin.rewards.numberKeyMap.hasOwnProperty(key)) {
						    $scope.admin.rewards.addPoints.addTransaction($scope.admin.rewards.numberKeyMap[key], true);
					    } else if (key === $scope.admin.rewards.enter) {
						    $scope.admin.rewards.addPoints.submit();
					    }
				    }

				    if ($scope.admin.rewards.addPoints.success.status) {
					    if (key === $scope.admin.rewards.enter) {
						    $scope.admin.rewards.reload();
					    }
				    }
			    },
			    addKey: function (key, updateScope) {
				    if (key === 'backspace') {
					    this.phoneNumber = this.phoneNumber.substring(0, this.phoneNumber.length - 1);
				    } else if (this.phoneNumber.length < 10) {
					    this.phoneNumber += key;
				    }

				    this.phone.first = this.phoneNumber.substring(0, 3);
				    this.phone.second = this.phoneNumber.substring(3, 6);
				    this.phone.third = this.phoneNumber.substring(6, 10);
				    
				    this.showSubmitBtn = this.phoneNumber.length === 10;

                    $scope.admin.rewards.addPoints.updateInput();
			    },
                pasteFromClipboard: function(event) {
                    // process paste event as if keys were used one by one and manually set the input model value
                    event.preventDefault();

                    var data = event.originalEvent.clipboardData.getData('text');
                    $scope.admin.rewards.addPoints.phoneNumber = '';

                    var numberToKeyMap = {
                        0: 48,
                        1: 49,
                        2: 50,
                        3: 51,
                        4: 52,
                        5: 53,
                        6: 54,
                        7: 55,
                        8: 56,
                        9: 57,
                    };

                    for (var k = 0; k < data.length; k++) {
                        var key = numberToKeyMap[data[k]];

                        if (!key) continue;

                        $scope.admin.rewards.addPoints.processKeydown(key);
                    }

                    $scope.admin.rewards.addPoints.updateInput();
                },
                updateInput: function() {
                    var val = '';

                    if ($scope.admin.rewards.addPoints.phone.first) {
                        val = $scope.admin.rewards.addPoints.phone.first;
                    }
                    if ($scope.admin.rewards.addPoints.phone.second) {
                        val += '-' + $scope.admin.rewards.addPoints.phone.second;
                    }
                    if ($scope.admin.rewards.addPoints.phone.third) {
                        val += '-' + $scope.admin.rewards.addPoints.phone.third;
                    }
                    $scope.admin.rewards.addPoints.phoneNumberInput = val;
                },
                onInputKeyDown: function (event) {
                    // stop all events from affecting input element except for paste
                    if (!((event.ctrlKey || event.metaKey) && event.keyCode == 86)) {
                        event.preventDefault();
                    }
                },
			    enterPhone: function () {
				    $scope.admin.rewards.config.loading = true;

				    hsApi.getAllPoints(this.phoneNumber)
					    .then(function (res) {
						    void 0;
						    if (res.status === 200) {
							    $scope.admin.rewards.data.all = res.data;
							    res.data.userRewards.forEach(function (reward) {
								    reward.checked = false;
								    if (reward.canRedeem) {
									    $scope.admin.rewards.data.availableRewards.push(reward);
								    } else {
									    $scope.admin.rewards.data.unavailableRewards.push(reward);
								    }
							    });

							    $scope.admin.rewards.addPoints.steps.phoneNumber = false;
							    $scope.admin.rewards.addPoints.steps.transaction = true;
						    } else if (res.status === 400) {
							    toastr.error('User doesn\'t have phone number associated with his account.');
						    } else {
							    toastr.error('Error get account details for this phone number.');
						    }

						    $scope.admin.rewards.config.loading = false;
					    });
			    },
			    selectReward: function (item) {
				    $scope.admin.rewards.data.availableRewards.forEach(function (reward) {
					    if (item.id === reward.id) {
						    reward.checked = true;
						    $scope.admin.rewards.addPoints.selectedReward = reward;
					    } else {
						    reward.checked = false;
					    }
				    });
			    },
			    addTransaction: function (key, updateScope) {
				    if (key === 'backspace') {
					    if (this.amount !== '0.00') {
						    this.amount = this.amount.substring(0, this.amount.length - 1);

						    if (!this.amount) {
							    this.transactionAmount = '0.00';
						    }
					    }
				    } else if (key === 'clear') {
					    this.amount = '';
					    this.transactionAmount = '0.00';
				    } else {
					    this.amount += key;
				    }

				    var amount = parseInt(this.amount);
				    if (!isNaN(amount)) {
					    amount = amount.toString();
					    this.amount = amount;

					    if (amount.length === 0) {
						    this.transactionAmount = '0.00';
					    } else if (amount.length < 4) {
						    var a = '000';
						    a = a.slice(0, -Math.abs(amount.length)) + amount;
						    this.transactionAmount = a.slice(0, -2) + '.' + a.slice(-2);
					    } else {
						    this.transactionAmount = this.amount.slice(0, -2) + '.' + this.amount.slice(-2);
					    }
				    } else {
					    this.amount = '';
				    }

				    if (updateScope) {
					    $scope.$apply();
				    }
			    },
			    submit: function () {
				    $scope.admin.rewards.config.loading = true;
				    $scope.admin.rewards.addPoints.success.status = false;
				    var transactionAmount = parseFloat(this.transactionAmount);
				    var transactionAPIData;
				    var redeemAPIData;
				    var index = {};
				    var apis = [];

				    if (transactionAmount) {
					    transactionAPIData = {
						    points: {
							    phoneNumber: this.phoneNumber,
							    transactionSubtotal: transactionAmount
						    }
					    };

					    apis.push(hsAdmin.addRewardPoints(transactionAPIData));
					    index.transactionApi = 1;
				    }

				    if (this.selectedReward) {
				    	redeemAPIData = {
						    targetUserPhoneNumber: this.phoneNumber,
						    rewardId: this.selectedReward.id
					    };

					    apis.push(hsAdmin.redeemRewards(redeemAPIData));
					    if (index.transactionApi) {
					    	index.redeemApi = 2;
					    } else {
					    	index.redeemApi = 1;
					    }
				    }
				    void 0;

				    if (!apis.length) {
				    	toastr.error('Please select an reward or add subtotal.');
					    $scope.admin.rewards.config.loading = false;
				    	return;
				    }
				    
				    $q.all(apis)
					    .then(function (res) {
					    	void 0;
						    var transactionRes;
						    var redeemRes;
						    var success = {
						    	transaction: {
						    		status: 'empty',
								    data  : {}
							    },
						    	redeem: {
						    		status: 'empty',
								    data  : {}
							    }
						    };

						    if (index.transactionApi) {
							    transactionRes = res[index.transactionApi - 1];
							    if (transactionRes.status === 200) {
							    	success.transaction.status = 'success';
							    	success.transaction.data = transactionRes.data;
							    	$scope.admin.rewards.addPoints.success.transaction = true;
							    } else if (transactionRes.status === 400) {
							    	success.transaction.status = 'error';
							    	toastr.error ('Subtotal Should Be Greater Than 0. Error Adding Points.');
							    	$scope.admin.rewards.addPoints.success.transaction = false;
							    } else {
							    	success.transaction.status = 'error';
							    	toastr.error ('Error Adding Points.');
							    	$scope.admin.rewards.addPoints.success.transaction = false;
							    }
						    }

						    if (index.redeemApi) {
							    redeemRes = res[index.redeemApi - 1];
							    if (redeemRes.status === 200) {
								    success.redeem.status = 'success';
								    success.redeem.data = redeemRes.data;
								    $scope.admin.rewards.addPoints.success.redeem = true;
							    } else if (redeemRes.status === 402) {
								    success.redeem.status = 'error';
								    toastr.error ('Insufficient Points/funds. Error Redeeming Reward.');
								    $scope.admin.rewards.addPoints.success.redeem = false;
							    } else {
								    success.redeem.status = 'error';
								    toastr.error ('Error Redeeming Reward.');
								    $scope.admin.rewards.addPoints.success.redeem = false;
							    }
						    }

						    if ($scope.admin.rewards.addPoints.success.transaction || $scope.admin.rewards.addPoints.success.redeem) {
							    $scope.admin.rewards.addPoints.success.status = true;
							    $scope.admin.rewards.addPoints.steps = {
								    phoneNumber: false,
								    transaction: false
							    };
						    }

						    $scope.admin.rewards.config.loading = false;
					    });
			    }
		    },
	    },
	    selectedPriceList : {},
		priceListFilterCriteria: globalFunctions.getPriceListDetails(),
	    bankAccountData  : {
		    loading                 : false,
		    success                 : false,
		    hasAccountInfo          : false,
		    data                    : {},
		    notification            : {
			    message             : '',
			    messageClass        : ''
		    },
		    form                    : {
			    bankAccountNumber   : '',
			    bankRoutingNumber   : '',
			    businessName        : '',
			    businessTaxId       : '',
			    firstName           : '',
			    lastName            : '',
			    title               : '',
			    email               : '',
			    phone               : '',
			    dobDay              : '',
			    dobMonth            : '',
			    dobYear             : '',
                personalIdNumber    : '', // SSN in US; SIN in CA
			    address             : {
				    street1         : '',
				    street2         : '',
				    city            : '',
				    state           : '',
				    zip             : '',
				    country         : 'US'
			    },
			    repAddress          : {
				    street1         : '',
				    street2         : '',
				    city            : '',
				    state           : '',
				    zip             : '',
				    country         : 'US'
			    }
		    },
            getPersonalIdFieldName: function() {
                var country = $rootScope.country;

                if (country === 'CA') {
                    return 'Social Insurance Number';
                } 
                
                return 'Social Security Number';
            },
            getZipFieldName: function () {
                var country = $rootScope.country;

                if (country === 'CA') {
                    return 'Postal Code';
                } 
                
                return 'Zip';
            },
            addBankAccount(form) {
                if (form.validate()) {
                    $scope.admin.bankAccountData.notification = {
                        message: '',
                        messageClass: '',
                    };
                    $scope.admin.bankAccountData.loading = true;

                    var modalData = $scope.admin.bankAccountData.form;

                    void 0;

                    var apiData = {
                        account: {
                            businessName: modalData.businessName, // UI field name: Legal Business Name
                            businessTaxId: modalData.businessTaxId, // UI Field Name: EIN
                            personalIdNumber: modalData.personalIdNumber,
                            businessAddress: {
                                // UI Field Name: Business Address
                                street: modalData.address.street1,
                                aptUnit: modalData.address.street2 || '',
                                city: modalData.address.city,
                                state: modalData.address.state,
                                zip: modalData.address.zip,
                            },
                            repAddress: {
                                // UI Field Name: Owner Address
                                street: modalData.repAddress.street1,
                                aptUnit: modalData.repAddress.street2 || '',
                                city: modalData.repAddress.city,
                                state: modalData.repAddress.state,
                                zip: modalData.repAddress.zip,
                            },
                            firstName: modalData.firstName, // Business Representative First Name
                            lastName: modalData.lastName, // Business Representative Last Name
                            title: modalData.title, // Business Representative Official Title
                            email: modalData.email, // Business Representative email
                            phone: modalData.phone, // Business Representative phone
                            dobMonth: parseInt(modalData.dobMonth), // 1 to 12 // Business Representative Date of Birth
                            dobDate: parseInt(modalData.dobDay), // 1 to 31
                            dobYear: parseInt(modalData.dobYear), // YYYY format
                            bankAccountToken: '',
                        },
                    };

                    var country = globalFunctions.getCountry();
                    var currency = globalFunctions.countryToCurrencyMap[country];

                    var stripeTokenReqObj = {
                        country: country,
                        currency: currency,
                        routing_number: modalData.bankRoutingNumber,
                        account_number: modalData.bankAccountNumber,
                        account_holder_name: modalData.firstName + ' ' + modalData.lastName,
                        account_holder_type: 'company',
                    };

                    return stripe
                        .createToken('bank_account', stripeTokenReqObj)
                        .then(function (res) {
                            void 0;
                            apiData.account.bankAccountToken = res.token.id;
                            return $http.put(ENV.apiEndPoint + '/location', apiData);
                        })
                        .then(function (res) {
                            void 0;
                            if (res.status === 200) {
                                $scope.admin.bankAccountData.notification.message = 'Bank account added successfully.';
                                $scope.admin.bankAccountData.notification.messageClass = 'bg-secondary text-white';
                                toastr.success('Bank account added successfully.');

                                $scope.admin.bankAccountData.hasAccountInfo = true;
                                $scope.admin.bankAccountData.form.personalIdNumber = '';
                                $scope.admin.bankAccountData.form.bankAccountNumber = '';
                                $scope.admin.bankAccountData.form.bankRoutingNumber = '';

                                $scope.admin.bankAccountData.success = true;

                                setTimeout(function () {
                                    scrollToElement('.bank-account-info');
                                    $scope.admin.bankAccountData.notification.message = '';
                                    $scope.admin.bankAccountData.notification.messageClass = '';
                                    $scope.$apply();
                                }, 5000);
                            } else {
                                var errorMessage = 'error adding bank account: status=' + res.status + ' message=' + res.data.message;
                                throw new Error(errorMessage);
                            }
                        })
                        .catch(function (e) {
                            void 0;
                            var errorMessage = 'Error validating the bank account. Please try again.';
                            toastr.error(errorMessage);
                            $scope.admin.bankAccountData.notification.message = errorMessage;
                            $scope.admin.bankAccountData.notification.messageClass = 'alert-danger';
                        })
                        .finally(function () {
                            $scope.admin.bankAccountData.loading = false;
                        });
                } else if (form.$error.hasOwnProperty('required') && form.$error.required.length) {
                    scrollToElement('#' + form.$error.required[0].$$attr.id);
                }
            },
		    toggleEditAccountInfo(){
			    $scope.admin.bankAccountData.hasAccountInfo = !$scope.admin.bankAccountData.hasAccountInfo;

			    if (!$scope.admin.bankAccountData.hasAccountInfo) {
			    	$scope.admin.bankAccountData.form = {
					    bankAccountNumber   : '',
					    bankRoutingNumber   : '',
					    businessName        : $scope.admin.bankAccountData.data.account.businessName,
					    businessTaxId       : $scope.admin.bankAccountData.data.account.businessTaxId,
					    firstName           : $scope.admin.bankAccountData.data.account.firstName,
					    lastName            : $scope.admin.bankAccountData.data.account.lastName,
					    title               : $scope.admin.bankAccountData.data.account.title || '',
					    email               : $scope.admin.bankAccountData.data.account.email || '',
					    phone               : $scope.admin.bankAccountData.data.account.phone || '',
					    dobDay              : $scope.admin.bankAccountData.data.account.dobDate,
					    dobMonth            : $scope.admin.bankAccountData.data.account.dobMonth,
					    dobYear             : $scope.admin.bankAccountData.data.account.dobYear,
					    address             : {
						    street1         : $scope.admin.bankAccountData.data.account.businessAddress.street,
						    street2         : $scope.admin.bankAccountData.data.account.businessAddress.aptUnit,
						    city            : $scope.admin.bankAccountData.data.account.businessAddress.city,
						    state           : $scope.admin.bankAccountData.data.account.businessAddress.state,
						    zip             : $scope.admin.bankAccountData.data.account.businessAddress.zip,
						    country         : 'US'
					    }
				    };

				    if($scope.admin.bankAccountData.data.account.repAddress) {
					    $scope.admin.bankAccountData.form.repAddress = {
						    street1         : $scope.admin.bankAccountData.data.account.repAddress.street || '',
						    street2         : $scope.admin.bankAccountData.data.account.repAddress.aptUnit || '',
						    city            : $scope.admin.bankAccountData.data.account.repAddress.city || '',
						    state           : $scope.admin.bankAccountData.data.account.repAddress.state || '',
						    zip             : $scope.admin.bankAccountData.data.account.repAddress.zip || '',
						    country         : 'US'
					    };
				    }
			    }
		    },
		    closeDialog(){
			    ngDialog.close();
		    },
		    resetAddBankAccountForm() {
			    $scope.admin.bankAccountData.form = {
				    businessName        : '',
				    businessTaxId       : '',
				    firstName           : '',
				    lastName            : '',
				    dobDay              : '',
				    dobMonth            : '',
				    dobYear             : '',
				    address             : {
					    street1         : '',
					    street2         : '',
					    city            : '',
					    state           : '',
					    zip             : '',
					    country         : 'US'
				    }
			    };
			    $scope.admin.bankAccountData.notification = {
				    message             : '',
				    messageClass        : ''
			    };
		    }
	    },
	    addBankAccountInit() {
		    $http.get(ENV.apiEndPoint + '/location')
			    .then(function (res) {
				    if (res.status === 200){
					    void 0;

                        // For a single location client, there is no saved location in local storage.
                        // By the time app.js gets a location response and sets country in rootscope,
                        // this controller had already finished initialization with the wrong country.
                        $rootScope.country = res.data.country || 'US';
                        $scope.admin.config.setBankAccountValidationRules($rootScope.country);

					    if(Object.keys(res.data.account).length) {
						    $scope.admin.bankAccountData.data = res.data;
						    $scope.admin.bankAccountData.hasAccountInfo = true;

						    $scope.admin.bankAccountData.form = {
							    bankAccountNumber   : '',
							    bankRoutingNumber   : '',
							    businessName        : res.data.account.businessName,
							    businessTaxId       : res.data.account.businessTaxId,
							    firstName           : res.data.account.firstName,
							    lastName            : res.data.account.lastName,
							    title               : res.data.account.title || '',
							    email               : res.data.account.email || '',
							    phone               : res.data.account.phone || '',
							    dobDay              : res.data.account.dobDate,
							    dobMonth            : res.data.account.dobMonth,
							    dobYear             : res.data.account.dobYear,
							    address             : {
								    street1         : res.data.account.businessAddress.street,
								    street2         : res.data.account.businessAddress.aptUnit,
								    city            : res.data.account.businessAddress.city,
								    state           : res.data.account.businessAddress.state,
								    zip             : res.data.account.businessAddress.zip,
								    country         : 'US'
							    }
						    };

						    if(res.data.account.repAddress) {
							    $scope.admin.bankAccountData.form.repAddress = {
								    street1         : res.data.account.repAddress.street || '',
								    street2         : res.data.account.repAddress.aptUnit || '',
								    city            : res.data.account.repAddress.city || '',
								    state           : res.data.account.repAddress.state || '',
								    zip             : res.data.account.repAddress.zip || '',
								    country         : 'US'
							    };
						    }
					    }
				    } else {
					    toastr.error('Error Retrieving Account information');
				    }

				    $scope.admin.config.pageFullyLoaded = true;
			    })
	    },
	    toggleChangeLog() {
	    	this.config.showChangeLog = !this.config.showChangeLog;
	    	if (this.config.showChangeLog) {
			    this.selectedChangeLogItem = 'All';
	    		this.initOrderDetails();
		    }
	    },
	    applyCategoryFilter(orderData) {
		    $scope.orderData = orderData;
		    ngDialog.open({
			    template: 'partials/popup/admin-category-filter-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
	    showShippingDetails: function (orderData) {
		    $scope.orderData = orderData;
		    ngDialog.open({
			    template: 'partials/popup/admin-shipping-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
	    toggleUpdateAddress: function () {
		    this.config.showUpdatedAddressSection = !this.config.showUpdatedAddressSection;

		    if (this.config.showUpdatedAddressSection) {
		    	setTimeout(function () {
				    scrollToElement('.address-update');
			    }, 300);
		    }

		    this.address = {
			    street1: "",
			    street2: "",
			    city: "",
			    state: "",
			    zip: "",
			    country: ""
		    };
	    },
	    toggleUpdateCC: function () {
		    this.config.showUpdatedCCSection = !this.config.showUpdatedCCSection;
	    },
	    confirmCompleteAll: function (order) {
		    $scope.order = order;
		    ngDialog.open({
			    template: 'partials/popup/confirm-complete-all-orders.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
	    checkAllPackedItems: function (orders) {
		    var notPackedItems = [];

		    orders.forEach(function (order) {
			    if (!order.packed) {
				    notPackedItems.push(order);
			    }
		    });

		    return this.config.showPackingPreview ? notPackedItems.length !== 0 : true;
        },
        showPackingCompletedFlow: function() {
            if (!ENV.enablePackingCompletedFlow) {
                return;
            }
            var orderState = $scope.admin.adminData.orderDetails.order.state;
            var isDelivery = $scope.admin.adminData.orderDetails.order.fulfillmentMethod === 'delivery';
            var allowDelivery = $scope.admin.adminData.orderDetails.order.allowDelivery;
            var canSetDelivery = isDelivery && allowDelivery;
            if (ENV.enableBagCount || orderState === 'Received' || canSetDelivery) {
                ngDialog.open({
                    template: 'partials/popup/admin-packing-completed-popup.html',
                    controller: 'ModalController',
                    scope: $scope,
                    closeByDocument: false,
                    closeByEscape: false,
                    showClose: ENV.showExitButtonPackingCompletedFlow,
                });
				$scope.admin.config.hasRenderedPackingCompletedFlowDialog = true;
            }
        },
        showRefundButtonAny: function() {
            return $scope.admin.adminData.orderDetails.order.state === 'Completed'
                && ($scope.admin.showRefundButton() || $scope.admin.showRefundButtonEbt());
        },
        showRefundButton: function() {
            // Showing refund button based on amount charge instead on acceptCreditCard
            // so after a switch, refund can still be issued.
            return (!$rootScope.currentUser.isAdminRestricted || ENV.canPackersIssueRefund) && !ENV.hideRefundButton
                && $scope.admin.adminData.orderDetails.order.amountCharged > 0;
        },
        showRefundButtonEbt: function() {
            return (!$rootScope.currentUser.isAdminRestricted || ENV.canPackersIssueRefund)
            	&& $scope.admin.adminData.orderDetails.order.amountChargedEbtSnap;
        },
        shouldShowRefunds: function(order) {
            return order && order.state === 'Completed' && order.refunds.length > 0;
        },
        shouldShowRefundsEbt: function(order) {
            return order && order.state === 'Completed' && hsUtils.isNonEmptyArray(order.refundsEbt);
        },
	    giveRefund: function (order) {
		    $scope.order = order;
		    ngDialog.open({
			    template: 'partials/popup/refund-dialog-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true,
			    preCloseCallback() {
			    	$scope.admin.initOrderDetails();
			    }
		    });
	    },
	    giveRefundEbt: function (order) {
	    	var $newScope = $scope.$new(true);
	        $newScope.order = order;

	        ngDialog.open({
	            template: '<div><refund-ebt order="order" on-close="closeThisDialog(value)"></refund-ebt></div>',
	            scope: $newScope,
	            plain: true,
	            closeByDocument: true,
	            closeByNavigation: true,
	        }).closePromise
                .then(function(data) {
                    if (data.value && data.value.orderData) {
                        $scope.admin.processOrderData(data.value.orderData);
                    }
                })
                .catch(function(err) {
                    void 0;
                });
	    },
	    assignDeliveries: function () {
		    ngDialog.open({
			    template: 'partials/popup/assign-deliveries-popup.html',
			    controller: 'ModalController',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
		showCancelDeliveryOption: function () {
			return ($scope.admin.adminData.orderDetails.order.state !== 'Cancelled'
			 && $scope.admin.adminData.orderDetails.order.managedDelivery 
			 && !hsManagedDelivery.UNCANCELLABLE_DELIVERY_STATUSES.includes($scope.admin.adminData.orderDetails.order.managedDelivery.status));
		},
		cancelDelivery: function () {
			var reqBody = {
				orderKey: $scope.admin.adminData.orderDetails.order.key,
				isCancelDeliveryRequest: true
			};
			ngDialog.openConfirm({
				data: {
					heading: 'Cancel Delivery',
					subHeading: 'Are you sure you want to cancel this delivery?',
					confirmBtnText: 'Yes',
					cancelBtnText: 'No'
				},
				template: 'partials/popup/confirm-popup.html'
			}).then(function(){
				hsManagedDelivery.requestCancelDelivery(reqBody).then(function(res){
					switch(res.status){
						case 200:
							toastr.success('Delivery cancelled successfully.');
							$scope.admin.initOrderDetails();
							break;
						default:
							toastr.error('Failed to cancel delivery.');
							break;
					}
				});
			}).catch(function (err) {
				toastr.error(err.message || 'Failed to cancel delivery.');
			});
		},
	    scheduleDelivery: function () {
            $scope.admin.doesDeliveryRequirePacking()
                .then(function(requiresPacking) {
                    // We need to allow redeliveries if the order has been completed but wasn't packed
                    // This can happen if an order auto schedules a delivery but the order requires
                    // another delivery after the order has completed.
                    if (requiresPacking && !$scope.admin.adminData.orderDetails.order.packed && 
                        $scope.admin.adminData.orderDetails.order.state !== 'Completed') {
                        throw new Error('Order needs to be packed before delivery can be scheduled.');
                    }
                    return hsAdmin.getBarcodeTrackingFlag();
                })
                .then(function(bagsBarcodesEnabled) {
                    if (bagsBarcodesEnabled && $scope.admin.adminData.orderDetails.order.state !== 'Completed') {

                        if (!$scope.admin.adminData.orderDetails.order.bagCount) {
                            throw new Error('Barcode scanning enabled. Please set bag quantity first.');
                        }

                        if (!Array.isArray($scope.admin.adminData.orderDetails.order.barcodes) ||
                            $scope.admin.adminData.orderDetails.order.barcodes.length !== $scope.admin.adminData.orderDetails.order.bagCount
                        ) {
                            throw new Error('There is an error with barcodes on the order. Please reset bag count to generate barcodes.');
                        }

                        ngDialog.openConfirm({
                            data: {
                                heading: 'Barcode Tracking Enabled',
                                subHeading: 'Warning: If you use DoorDash, you won\'t be able to update bag quantity once the delivery is scheduled.',
                                confirmBtnText: 'Ok',
                            },
                            template: 'partials/popup/confirm-popup.html'
                        })
                            .then(showDeliveryPopup)
                            .catch(function(err) {});
                        return;
                    }
                    showDeliveryPopup();
                })
                .catch(function(err) {
                    void 0;

                    if (err.message) {
                        toastr.error(err.message);
                    } else {
                        toastr.error('Something went wrong.');
                    }
                });

            function showDeliveryPopup() {
                ngDialog.open({
                    template: 'partials/popup/schedule-delivery-popup.html',
                    controller: 'ModalController',
                    scope: $scope,
                    closeByDocument: false,
                    closeByNavigation: true
                });
            }
	    },
        showDelayOrderPopup() {
            return ngDialog.open({
                template: 'partials/popup/order-delay-popup.html',
                controller: 'ModalController',
			    scope: $scope,
			    closeByDocument: true,
			    closeByNavigation: true
            }).closePromise
                .then(function(data) {
                    if (data && data.value && typeof data.value === 'object') {
                        $scope.admin.processOrderData(data.value);
                    }
                });
        },
	    showDeliveryDetails() {
		    ngDialog.open({
			    template: 'partials/popup/order-delivery-details-popup.html',
			    controller: 'ModalController',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    }).closePromise
                .then(function(data) {
                    if (data.value && data.value.order && typeof data.value.order === 'object') {
                        $scope.admin.processOrderData(data.value.order);
                    }
                });
	    },
		shouldShowTBDFulfillmentFee(order) {
			return globalFunctions.hasTBDFulfillmentFees(order.priceList);
		},
		showAgeVerification() {
		    ngDialog.open({
			    template: 'partials/popup/age-verification-popup.html',
			    controller: 'ModalController',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
	    updateNumberOfBags: function (updatePrinterTag) {
		    if (updatePrinterTag) {
			    $scope.updatePrinterTag = true;
		    }

		    return ngDialog.open({
			    template: 'partials/popup/bags-popup.html',
			    controller: 'ModalController',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    }).closePromise
		    	.then(function(data) {
		    		return data.value;
		    	})
		    	.catch(function (err) {
		    		void 0;
		    	});
	    },
	    showTaxPopup: function (order) {
		    var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/tax-details-popup.html',
			    controller: 'ModalController',
			    className: modalClass,
			    data: order
		    });
	    },
	    showAddPrinterPopup: function (updatePrinterTag) {
	    	if (updatePrinterTag) {
	    		$scope.updatePrinterTag = true;
		    }
		    return ngDialog.open({
			    template: 'partials/popup/add-printer-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope
		    }).closePromise
                .then(function (data) {
                    return data.value;
                })
                .catch(function (err) {
                    void 0;
                });
	    },
	    showAddBankAccountPopup: function () {
		    ngDialog.open({
			    template: 'partials/popup/add-bank-account-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    closeByDocument: false,
			    closeByNavigation: true,
			    closeByEscape: false
		    });
	    },
	    filterProducts: function (products, screenWidth) {
		    angular.forEach(products, function (val, key, idx) {
			    if (val.hasOwnProperty('renderEmptyTile')) {
				    products.splice(idx, 1);
			    }
		    });

		    var productLength = products.length;
		    var selectedWidth;
		    var maxGridLength;

		    angular.forEach(screenWidth, function (width, key) {
			    width === true ? selectedWidth = key : '';
		    });

		    switch (selectedWidth) {
			    case 'lg' : {
				    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
				    break;
			    }
			    case 'md' : {
				    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
				    break;
			    }
			    case 'sm' : {
				    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
				    break;
			    }
			    case 'xs' : {
				    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
				    break;
			    }
		    }

		    var objectsToAdd = [];
		    for (var i = 0; i < maxGridLength; i++) {
			    objectsToAdd.push({
				    renderEmptyTile: true
			    });
		    }

		    return products.concat(objectsToAdd);
	    },
	    filterOrders: {
	    	name: '',
	    	timeSlot: 'All',
	    	orderStatus: 'All',
	    	packingStatus: 'All',
            assignedPacker: 'All',
	    	timeSlots: ['All'],
	    	orderStatusList: ['All'],
	    	packingStatusList: ['All'],
            assignedPackersList: ['All'],
		    searchThreshold: 20,
		    orders: [],
		    selectedOrders: [],
		    originalOrders: [],
		    originalHistoryOrders: [],
			orderFilterTypes: {
				TODAY: 'today',
				HISTORY: 'history',
			},
		    filterHistoryOrders() {
	    		if (this.name || this.timeSlot !== "All" || this.orderStatus !== 'All' || this.packingStatus !== 'All') {
	    			void 0;
	    			void 0;
	    			var orders = JSON.parse(JSON.stringify(this.originalHistoryOrders));
	    			var filteredOrders = orders;

	    			void 0;

	    			var filter = {};

				    if ($scope.admin.filterOrders.name) {
				    	filter.userData = {
					        fullName: $scope.admin.filterOrders.name
					    };
				    }

				    if ($scope.admin.filterOrders.timeSlot !== "All") {
				    	filter.deliveryTime = $scope.admin.filterOrders.timeSlot;
				    }

				    if ($scope.admin.filterOrders.orderStatus !== "All") {
					    filter.state = $scope.admin.filterOrders.orderStatus;
				    }

                    if ($scope.admin.filterOrders.packingStatus !== 'All') {
                        filter.packingStatus = $scope.admin.filterOrders.packingStatus;
                    }

			        $scope.admin.orderHistory.orders = $filter('filter')(filteredOrders, filter);
			        $scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.orders.slice(0, $scope.admin.orderHistory.searchThreshold);
			    } else {
                    if ($scope.admin.orderHistory.showOnHoldOrders) {
                        $scope.admin.orderHistory.onHoldOrders = JSON.parse(JSON.stringify($scope.admin.filterOrders.originalHistoryOrders));
                        $scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.onHoldOrders.slice(0, 20);
                    } else {
                        $scope.admin.orderHistory.orders = JSON.parse(JSON.stringify($scope.admin.filterOrders.originalHistoryOrders));
                        $scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.orders.slice(0, 20);
                    }
			    }
		    },
		    filterOrders() {
                if (this.name || this.timeSlot !== "All" || this.packingStatus !== 'All' || this.orderStatus !== 'All'
                    || this.assignedPacker !== 'All'
                ) {
	    			void 0;
	    			var orders = JSON.parse(JSON.stringify(this.originalOrders));
	    			var filteredOrders = orders;

	    			void 0;

				    if ($scope.admin.filterOrders.name) {
					    filteredOrders = $filter('filter')(filteredOrders, {userObj: {fullName: $scope.admin.filterOrders.name}});
				    }

				    if ($scope.admin.filterOrders.timeSlot !== 'All') {
					    filteredOrders = $filter('filter')(filteredOrders, {deliveryTime: $scope.admin.filterOrders.timeSlot});
				    }

				    if ($scope.admin.filterOrders.packingStatus !== 'All') {
					    filteredOrders = $filter('filter')(filteredOrders, {packingStatus: $scope.admin.filterOrders.packingStatus});
				    }

				    if ($scope.admin.filterOrders.orderStatus !== 'All') {
					    filteredOrders = $filter('filter')(filteredOrders, {state: $scope.admin.filterOrders.orderStatus});
				    }

                    if ($scope.admin.filterOrders.assignedPacker !== 'All') {
                        filteredOrders = $filter('filter')(filteredOrders, function(elem) {
                            if ($scope.admin.filterOrders.assignedPacker === 'Not Assigned') {
                                return !elem.packer;
                            }
                            return elem.packer && elem.packer.fullName === $scope.admin.filterOrders.assignedPacker;
                        });
                    }

			        $scope.admin.adminData.selectedOrderType = filteredOrders;
			    } else {
				    $scope.admin.adminData.selectedOrderType = JSON.parse(JSON.stringify($scope.admin.filterOrders.originalOrders));
			    }
		    },
			getOriginalOrdersStatusCount(status, orderFilterType) {
				var count = 0;

				if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.TODAY) {
					count = $scope.admin.filterOrders.originalOrders.filter(function(order) {
						return order.state === status;
					}).length;
				}

				if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.HISTORY) {
					count = $scope.admin.filterOrders.originalHistoryOrders.filter(function(order) {
						return order.state === status;
					}).length;
				}

				return count;
			},
	    },
	    getMonday(d) {
		    d = new Date(d);
		    var day = d.getDay(),
			    diff = d.getDate() - day + (day === 0 ? -6:1); // adjust when day is sunday
		    return new Date(d.setDate(diff));
	    },
	    numberOfOrders: false,
	    numberOfOrdersToday: false,
	    showNewOrderAlert: false,
	    selectedOrder: {},
	    searchQuery: '',
	    searchedQuery: '',
	    createOrder: {
		    placingOrder: false,
		    gotUsers: false,
		    gotProducts: false,
		    showOrderSummary: false,
		    discount: '',
		    originalCategoryOrder: ENV.categoryOrder,
		    categoryOrder: ENV.categoryOrder,
		    subCategoryOrder: ENV.subCategoryOrder,
		    showDiscountBox: false,
            activateTab: function (subCategory, index) {
	          Object.keys($scope.admin.createOrder.data.products).forEach(function(key) {
	            $scope.admin.createOrder.data.products[key].loadTab = false;
	        });
	          if ($scope.admin.createOrder.data.products[subCategory]) {
	            $scope.admin.createOrder.data.products[subCategory].loadTab = true;
	          }
	        },
		    toggleDiscountBox: function () {
		    	this.showDiscountBox = !this.showDiscountBox;
		    },
		    calculateProductPrice: function (priceObj) {
			    return hsCart.calculateProductPrice(priceObj);
		    },
		    calculatePricePerQuantity: function (priceObj) {
			    return hsCart.calculatePricePerQuantity(priceObj);
		    },
		    updateQuantity: function (item, index, updateType) {
			    var quantityBtnSelector = '#quantity-' + index;
			    var updateBtnSelector = '#update-btn-' + index;
			    hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
		    },
		    updateItemInCart: function (item, index) {
			    void 0;
			    void 0;

			    var quantity = $('#quantity-' + index).val();
			    quantity = parseFloat(quantity);

			    var basket = localStorageService.get('adminOrder');
			    item.quantity = quantity;

			    if (basket) {
				    var sameItem = false;
				    basket.forEach(function (basketItem) {
					    if (basketItem.name === item.name) {
						    basketItem.quantity = item.quantity;
						    sameItem = true;
					    }
				    });

				    if (!sameItem) {
					    basket.push(item);
				    }

				    localStorageService.set('adminOrder', basket);
			    } else {
				    var basketArray = [];
				    basketArray.push(item);
				    localStorageService.set('adminOrder', basketArray);
			    }

			    $rootScope.$emit('adminOrderUpdated', true);
		    },
		    email: '',
		    phone: '',
		    name: '',
		    noProductFound: false,
		    step: {
			    selectUser: true,
			    selectProducts: false
		    },
		    eventListeners: {
			    createOrderEventListener: '',
			    routeChangesListener: ''
		    },
		    data: {
			    users: [],
			    orderItemsSummary: {},
			    numberOfItems: 0,
			    selectedUser: {},
			    products: [],
			    originalProducts: [],
			    allProducts: []
		    },
		    updateBasketItems: function() {
		    	var adminOrderBasket = localStorageService.get('adminOrder');
		    	if (adminOrderBasket.length) {
		    		if (ENV.showOrderFormInAdmin) {
		    			angular.forEach($scope.admin.createOrder.data.products, function(data, key) {
						    angular.forEach(data.categories, function (val, key) {
							    val.products.forEach(function(product){
							    	adminOrderBasket.forEach(function (item) {
							    		if (product.name === item.name) {
							    			product.quantity = item.quantity;
									    } else {
							    			product.quantity = 0;
									    }
								    });
							    });
						    });
					    });
				    } else {
					    angular.forEach($scope.admin.createOrder.data.products, function(data, key) {
						    adminOrderBasket.forEach(function (item) {
							    data.homePageProducts.forEach(function(product){
								    if (product.name === item.name) {
									    product.quantity = item.quantity;
								    } else {
								    	product.quantity = 0;
								    }
							    });
							    data.tileProducts.forEach(function(product){
								    if (product.name === item.name) {
									    product.quantity = item.quantity;
								    } else {
								    	product.quantity = 0;
								    }
							    });
							    data.nonTileProducts.forEach(function(product){
								    if (product.name === item.name) {
									    product.quantity = item.quantity;
								    } else {
								    	product.quantity = 0;
								    }
							    });
						    });
					    });
				    }
			    } else {
				    if (ENV.showOrderFormInAdmin) {
					    angular.forEach($scope.admin.createOrder.data.products, function(data, key) {
						    angular.forEach(data.categories, function (val, key) {
							    val.products.forEach(function(product){
								    product.quantity = 0;
							    });
						    });
					    });
				    } else {
					    angular.forEach($scope.admin.createOrder.data.products, function(data, key) {
						    data.homePageProducts.forEach(function(product){
							    product.quantity = 0;
						    });
						    data.tileProducts.forEach(function(product){
							    product.quantity = 0;
						    });
						    data.nonTileProducts.forEach(function(product){
							    product.quantity = 0;
						    });
					    });
				    }
			    }
		    },
		    searchProduct: function (query, clear) {
			    void 0;
			    if (clear) {
				    $scope.admin.createOrder.noProductFound = false;
				    $scope.admin.searchedQuery = '';
				    $scope.searchQuery = '';

				    if (query) {
					    $scope.admin.createOrder.data.products = JSON.parse(JSON.stringify($scope.admin.createOrder.data.originalProducts));
					    $scope.admin.createOrder.updateBasketItems();
				    }
			    } else if (query) {
				    var categoryData = JSON.parse(JSON.stringify($scope.admin.createOrder.data.originalProducts));
				    var searchedData = {};

				    angular.forEach(categoryData, function(data, key) {
				    	var searchedProduct = $filter('multiWordFilter')(data.products, query);
				    	if (searchedProduct.length) {
						    var sortedSubCategories = {};
						    angular.forEach(data.categories, function (val, key) {
							    var products = $filter('multiWordFilter')(val.products, query);
							    if (products.length) {
							    	val.products = products;
								    val.products = $scope.admin.createOrder.fillEmptyOrderProducts(val, 'products');
								    sortedSubCategories[key] = val;
							    }
						    });

						    data.products = $scope.admin.filterProducts(searchedProduct, $rootScope.screenWidth);
						    data.homePageProducts = $scope.admin.filterProducts($filter('multiWordFilter')(data.homePageProducts, query), $rootScope.screenWidth);
						    data.tileProducts = $scope.admin.filterProducts($filter('multiWordFilter')(data.tileProducts, query), $rootScope.screenWidth);
						    data.nonTileProducts = $scope.admin.filterProducts($filter('multiWordFilter')(data.nonTileProducts, query), $rootScope.screenWidth);
						    data.categories = sortedSubCategories;
						    searchedData[key] = data;
					    }
				    });

				    if (Object.keys(searchedData).length){
					    $scope.admin.createOrder.noProductFound = false;

					    Object.values(searchedData).forEach(function (item, index) {
						    item.loadTab = index === 0;
					    });

					    $scope.admin.createOrder.data.products = searchedData;

				    } else {
					    $scope.admin.createOrder.noProductFound = true;
				    }
				    void 0;
				    $scope.admin.createOrder.updateBasketItems();
			    }
		    },
		    init: function () {
			    if (!ENV.placeOrderForUser) {
				    $location.url('/admin/manager-dashboard');
				    return;
			    }
			    $scope.admin.orderHistory.showOnHoldOrders = false;
			    $scope.admin.config.pageFullyLoaded = true;
			    $scope.admin.createOrder.showOrderSummary = false;
			    $scope.admin.createOrder.gotUsers = false;
			    $scope.admin.createOrder.email = '';
			    $scope.admin.createOrder.phone = '';
			    $scope.admin.createOrder.name = '';
			    $scope.admin.createOrder.step = {
				    selectUser: true,
				    selectProducts: false
			    };
			    $scope.admin.createOrder.data = {
				    users: [],
				    orderItemsSummary: [],
				    selectedUser: {},
				    products: [],
				    allProducts: []
			    };
			    localStorageService.set('adminOrder', []);
			    $scope.admin.createOrder.getAllProducts();

			    $scope.admin.createOrder.eventListeners.routeChangesListener = $rootScope.$on("$locationChangeStart", showUnsavedChangesPopup);

			    function showUnsavedChangesPopup(event, next, current) {
				    void 0;
				    void 0;
				    void 0;

				    next = next.replace(window.location.origin, '');
				    event.preventDefault();

				    ngDialog.openConfirm({
					    data: {
						    heading: 'Unsaved Changes',
						    subHeading: 'The changes you made will be lost if you reload or navigate away from this page.',
						    confirmBtnText: 'Confirm',
						    cancelBtnText: 'Cancel'
					    },
					    template: 'partials/popup/confirm-popup.html'
				    }).then(function (confirm) {
					    void 0;
					    $scope.admin.createOrder.eventListeners.routeChangesListener();
					    $location.url(next);
				    }, function (reject) {
					    void 0;
					    return;
				    });
			    }

			    $('.cd-panel.cd-panel--is-visible::after').click(function (e) {
				    $scope.admin.createOrder.showOrderSummary = false;
			    });

			    $scope.admin.createOrder.eventListeners.createOrderEventListener = $rootScope.$on('adminOrderUpdated', function (event, data) {
				    event.stopPropagation();
				    var adminOrder = localStorageService.get('adminOrder');
				    void 0;
				    $scope.admin.createOrder.data.numberOfItems = adminOrder.length;
				    $scope.admin.createOrder.data.orderItemsSummary = globalFunctions.filterProductsByCategory(adminOrder);
			    });

			    $scope.$on('$viewContentLoaded', function (event) {
				    $document.bind('scroll', function () {
					    var windowTop = $(window).scrollTop() + 10;
					    var selectedDiv = $('#all-categories');

					    if (selectedDiv) {
						    var divTop = selectedDiv.offset().top + 50;
						    if (windowTop >= divTop) {
							    $('#all-categories-fixed').css({
								    display: 'block',
								    opacity: 1
							    });
						    } else if (windowTop < divTop) {
							    $('#all-categories-fixed').css({
								    display: 'none',
								    opacity: 0
							    });
						    }
					    }
				    });
			    });
			    $scope.$on('$destroy', function () {
				    $document.unbind('scroll');
				    $scope.admin.createOrder.eventListeners.createOrderEventListener();
				    $scope.admin.createOrder.eventListeners.routeChangesListener();
			    });
		    },
		    initConfirm: function () {
			    if (!ENV.placeOrderForUser) {
				    $location.url('/admin/manager-dashboard');
				    return;
			    }
			    $scope.admin.config.pageFullyLoaded = false;

			    var adminOrderUser = localStorageService.get('adminOrderUser');
			    if (!adminOrderUser) {
				    $location.url('/admin/manager-dashboard');
			    } else {
				    $scope.admin.createOrder.data.selectedUser = adminOrderUser;
				    $scope.admin.config.pageFullyLoaded = true;
			    }

			    $scope.$on('$destroy', function () {
				    localStorageService.remove('adminOrderUser');
			    });
		    },
		    selectUser: function (user) {
			    $scope.admin.createOrder.data.selectedUser = user;
			    $scope.admin.createOrder.step = {
				    selectUser: false,
				    selectProducts: true
			    };
		    },
		    findUser: function (form) {
			    $scope.admin.config.buttonLoading = true;
			    if (form.validate()) {
				    if (!$scope.admin.createOrder.name &&
					    !$scope.admin.createOrder.email &&
					    !$scope.admin.createOrder.phone) {
					    $scope.admin.config.buttonLoading = false;
					    toastr.error('Please provide at least one param to search user with');
					    return;
				    }

				    var apiUrl = ENV.apiEndPoint + '/search/users';

				    if ($scope.admin.createOrder.name) {
					    apiUrl += '?namephrase=' + encodeURIComponent($scope.admin.createOrder.name);
				    }

				    if ($scope.admin.createOrder.email) {
					    apiUrl += '?emailphrase=' + encodeURIComponent($scope.admin.createOrder.email);
				    }

				    if ($scope.admin.createOrder.phone) {
					    apiUrl += '?phonenumber=' + encodeURIComponent($scope.admin.createOrder.phone);
				    }

				    $http.get(apiUrl)
					    .then(function (response) {
						    void 0;
						    if (response.status === 200) {
							    $scope.admin.createOrder.gotUsers = true;
							    $scope.admin.createOrder.data.users = response.data.users;
						    } else {
							    toastr.error('Error finding the user.')
						    }

						    $scope.admin.config.buttonLoading = false;
					    });
			    } else {
				    $scope.admin.config.buttonLoading = false;
			    }
		    },
		    showProductPopup: function (product) {
			    if (product.renderEmptyTile) {
				    return;
			    }
			    var modalClass = '';

			    if (product.hasImage) {
				    modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
			    } else {
				    modalClass = 'ngdialog-theme-default email-capture';
			    }

			    ngDialog.open({
				    template: 'partials/popup/admin-product-item/admin-product-item-popup.html',
				    controller: 'ModalController',
				    className: modalClass,
				    data: product
			    });
		    },
		    toggleOrderSummary: function () {
			    $scope.admin.createOrder.showOrderSummary = !$scope.admin.createOrder.showOrderSummary;
		    },
		    fillEmptyOrderProducts: function (products, property) {
			    var productsToModify = JSON.parse(JSON.stringify(products[property]));
			    var productLength = productsToModify.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach($rootScope.screenWidth, function (width, key) {
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' :
				    case 'md' :
				    case 'sm' : {
					    if (productLength % 2) {
						    maxGridLength = 1;
					    } else {
						    maxGridLength = 0;
					    }
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = 0;
					    break;
				    }
			    }

			    if (maxGridLength) {
				    productsToModify.push({
					    renderEmptyTile: true
				    });
			    }

			    return productsToModify;
		    },
		    getAllProducts: function (searchPage) {
			    $http.get(ENV.apiEndPoint + '/product/list')
				    .then(function (response) {
				    	void 0;
					    var products = response.data.products;
					    var allProducts = [];
					    var sortedData = {};

					    angular.forEach(products, function (product, index) {
						    product.loading = false;
						    product.checked = false;
						    product.quantity = 0;
						    product.showRemoveBtn = false;
						    var productNameWithoutSpaces = $filter('removeSpaces')(product.type);
						    var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.subType);

						    if (product.hasOwnProperty('hasImage') === false) {
							    product.hasImage = true;
						    }

						    allProducts.push(product);

						    //Sorting data based on type, subType
						    if (sortedData[productNameWithoutSpaces]) {
							    if (product.hasOwnProperty('isHidden') && product.isHidden) {
								    sortedData[productNameWithoutSpaces].hiddenProducts.push(product);
							    } else {
								    if (product.hasImage) {
									    sortedData[productNameWithoutSpaces].tileProducts.push(product);
								    } else {
									    sortedData[productNameWithoutSpaces].nonTileProducts.push(product);
								    }

								    sortedData[productNameWithoutSpaces].products.push(product);
							    }

						    } else {
							    sortedData[productNameWithoutSpaces] = {
								    name: product.type,
								    products: [],
								    hiddenProducts: [],
								    tileProducts: [],
								    nonTileProducts: [],
								    categories: {}
							    };

							    if (product.hasOwnProperty('isHidden') && product.isHidden) {
								    sortedData[productNameWithoutSpaces].hiddenProducts.push(product);
							    } else {
								    if (product.hasImage) {
									    sortedData[productNameWithoutSpaces].tileProducts.push(product);
								    } else {
									    sortedData[productNameWithoutSpaces].nonTileProducts.push(product);
								    }

								    sortedData[productNameWithoutSpaces].products.push(product);
							    }
						    }

						    if (sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces]) {
							    if (product.hasOwnProperty('isHidden') && product.isHidden) {
								    sortedData[productNameWithoutSpaces].hiddenProducts.push(product);
							    } else {
								    if (product.hasImage) {
									    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);
								    } else {
									    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
								    }
								    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);
							    }

						    } else {
							    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
								    name: product.subType,
								    products: [],
								    tileProducts: [],
								    nonTileProducts: []
							    };

							    if (product.hasOwnProperty('isHidden') && product.isHidden) {
								    sortedData[productNameWithoutSpaces].hiddenProducts.push(product);
							    } else {
								    if (product.hasImage) {
									    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);
								    } else {
									    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
								    }
								    sortedData[productNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);
							    }
						    }
					    });

					    angular.forEach(sortedData, function (val, key) {
						    if (ENV.limitCreateOrderProducts) {
							    var tileProducts = sortedData[key].tileProducts.slice(0, 10);
							    sortedData[key].nonTileProducts = sortedData[key].tileProducts.slice(10).concat(sortedData[key].nonTileProducts);
							    sortedData[key].tileProducts = tileProducts;
						    }

						    if ($scope.admin.createOrder.categoryOrder[key]) {
							    $scope.admin.createOrder.categoryOrder[key] = sortedData[key];
						    } else {
							    $scope.admin.createOrder.categoryOrder[key] = '';
							    $scope.admin.createOrder.categoryOrder[key] = sortedData[key];
						    }

						    if ($scope.admin.createOrder.subCategoryOrder[key]) {
							    var newOrder = {};
							    angular.forEach($scope.admin.createOrder.subCategoryOrder[key], function (subVal, subKey) {
								    newOrder[subKey] = $scope.admin.createOrder.categoryOrder[key].categories[subKey];
							    });

							    $scope.admin.createOrder.categoryOrder[key].categories = newOrder;
						    }

						    $scope.admin.createOrder.categoryOrder[key].homePageProducts = $scope.admin.createOrder.filterProducts(sortedData[key]);

						    if (ENV.showOrderFormInAdmin) {
							    $scope.admin.createOrder.categoryOrder[key].orderViewProducts = $scope.admin.createOrder.fillEmptyOrderProducts(sortedData[key], 'products');
						    } else {
							    angular.forEach($scope.admin.createOrder.categoryOrder[key].categories, function (subVal, subKey) {
								    subVal.homepageProducts = $scope.admin.createOrder.filterProducts(subVal);
							    });
						    }

						    $rootScope.$on('screenWidth', function (event, data) {
							    //do something with new value 'data'
							    $scope.admin.createOrder.categoryOrder[key].homePageProducts = $scope.admin.createOrder.filterProducts(sortedData[key]);
						    });
					    });

					    angular.forEach($scope.admin.createOrder.categoryOrder, function (val, key) {
						    if (!val) {
							    delete $scope.admin.createOrder.categoryOrder[key];
						    } else if (ENV.limitCreateOrderProducts) {
							    $scope.admin.createOrder.categoryOrder[key] = $scope.admin.createOrder.showCategoryItems($scope.admin.createOrder.categoryOrder[key], $rootScope.screenWidth);

							    $rootScope.$on('screenWidth', function (event, data) {
								    //do something with new value 'data'
								    $scope.admin.createOrder.categoryOrder[key] = $scope.admin.createOrder.showCategoryItems($scope.admin.createOrder.categoryOrder[key], data);
							    });
						    }
					    });

		              if ($scope.admin.createOrder.categoryOrder) {
		                var urlCategory = $location.search().category;
		                if (urlCategory) {
		                  $scope.admin.createOrder.categoryOrder[urlCategory].loadTab = true;
		                } else {
		                  var firstCategory = Object.keys($scope.admin.createOrder.categoryOrder)[0];
		                  $scope.admin.createOrder.categoryOrder[firstCategory].loadTab = true;
		                }
		              }

				    $scope.admin.createOrder.data.products = $scope.admin.createOrder.categoryOrder;
				    $scope.admin.createOrder.data.originalProducts = JSON.parse(JSON.stringify($scope.admin.createOrder.categoryOrder));
				    $scope.admin.createOrder.data.allProducts = allProducts;
				    $scope.admin.config.pageFullyLoaded = true;

			    });
		    },
		    showCategoryItems: function (products, screenWidth) {
			    angular.forEach(products, function (val, key) {
				    switch (key) {
					    case 'tileProducts' :
						    if (products[key].length) {
							    products[key] = $scope.admin.createOrder.fillGrid(products[key], screenWidth);
						    }
						    break;
					    case 'nonTileProducts' :
						    if (products[key].length) {
							    products[key] = $scope.admin.createOrder.fillGrid(products[key], screenWidth);
						    }
						    break;
				    }
			    });

			    return products;
		    },
		    fillGrid: function (products, screenWidth) {
			    for (var j = products.length - 1; j >= 0; --j) {
				    if (products[j].hasOwnProperty('renderEmptyTile')) {
					    products.splice(j, 1);
				    }
			    }

			    var productLength = products.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach(screenWidth, function (width, key) {
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' : {
					    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
					    break;
				    }
				    case 'md' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'sm' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
					    break;
				    }
			    }

			    var objectsToAdd = [];
			    for (var i = 0; i < maxGridLength; i++) {
				    objectsToAdd.push({
					    renderEmptyTile: true
				    });
			    }

			    return products.concat(objectsToAdd);
		    },
		    filterProducts: function (products) {
			    function _processGrid(products) {
				    var productLength = products.length;
				    var selectedWidth;
				    var maxGridLength;

				    angular.forEach($rootScope.screenWidth, function (width, key) {
					    width === true ? selectedWidth = key : '';
				    });

				    switch (selectedWidth) {
					    case 'lg' : {
						    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
						    break;
					    }
					    case 'md' : {
						    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
						    break;
					    }
					    case 'sm' : {
						    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
						    break;
					    }
					    case 'xs' : {
						    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
						    break;
					    }
				    }

				    var objectsToAdd = [];
				    for (var i = 0; i < maxGridLength; i++) {
					    objectsToAdd.push({
						    renderEmptyTile: true
					    });
				    }

				    return products.concat(objectsToAdd);
			    }

			    return _processGrid(products.products);
		    },
		    removeItem: function (item) {
			    var adminOrder = localStorageService.get('adminOrder');
			    var itemIndex = 0;

			    adminOrder.forEach(function (product, idx) {
				    if (product.name === item.name) {
					    itemIndex = idx;
				    }
			    });

			    adminOrder.splice(itemIndex, 1);

			    localStorageService.set('adminOrder', adminOrder);

			    item.quantity = 0;
			    item.showRemoveBtn = false;
			    $rootScope.$emit('adminOrderUpdated', true);
			    $scope.admin.createOrder.updateBasketItems();
		    },
		    placeOrder: function () {
			    $scope.admin.createOrder.placingOrder = true;
			    var adminOrder = localStorageService.get('adminOrder');
			    void 0;
			    if (adminOrder.length === 0) {
				    toastr.error('Please add some items to place the order');
				    $scope.admin.createOrder.showOrderSummary = false;
				    $scope.admin.createOrder.placingOrder = false;
			    } else {
				    /**
				     * @todo: Add support to choose Date and time, when enabled for other clients.
				     */
				    var orderObj = {
					    userEmail: $scope.admin.createOrder.data.selectedUser.email,
					    order: {
						    address: $scope.admin.createOrder.data.selectedUser.address,
						    fulfillmentMethod: 'delivery',
						    instruction: $scope.admin.createOrder.data.selectedUser.instructions || "",
						    items: adminOrder.map(function (item) {
							    return {
								    name: item.name,
								    quantity: item.quantity,
								    instructions: item.instructions || ""
							    }
						    })
					    }
				    };

				    if (this.discount) {
				    	orderObj.order.discount = parseFloat(this.discount);
				    }

				    void 0;
				    hsAdmin.createOrderForUser(orderObj)
					    .then(function (res) {
						    void 0;
						    if (res.status === 200) {
							    toastr.success('Order placed successfully.');
							    localStorageService.set('adminOrderUser', $scope.admin.createOrder.data.selectedUser);
							    $scope.admin.createOrder.eventListeners.routeChangesListener();
							    localStorageService.remove('adminOrder');
							    $location.url('/admin/create-order/confirm');
							    $scope.admin.createOrder.placingOrder = false;
						    } else {
							    toastr.error('Error placing order. Please try again.');
							    $scope.admin.createOrder.placingOrder = false;

						    }
					    });
			    }
		    },
		    productData: []
	    },
	    adminData: {
		    selectedLocation: {},
		    allLocations: {},
		    allProducts: [],
            tips: {
                csvHeaders: ['Customer Name', 'Date', 'Time', 'Fulfillment', 'Packer', 'Delivery Rep', 'Tip Amount'],
                ordersToExport() {
                    var exportData = [];
                    var tableData = $filter('filter')($scope.admin.adminData.tableParams.settings().dataset, $scope.admin.adminData.tableParams.filter());
                    tableData =  $filter('orderBy')(tableData, $scope.admin.adminData.tableParams.orderBy());
                    for (var order of tableData) {
                        exportData.push({
                            "Customer Name": order.fullName,
                            "Date": order.deliveryDate,
                            "Time": order.deliveryTime,
                            "Fulfillment": order.fulfillmentMethod,
                            "Packer": order.packerName,
                            "Delivery Rep": order.driverName,
                            "Tip Amount": order.tip
                        });
                    }
                    return exportData;
                }
            },
		    checkedPacker: false,
		    ngTableParams: {},
		    showPackerPopup(update) {
			    hsAdmin.getLocation()
				    .then(function(res) {
					    if (res.status === 200) {
						    void 0;
						    var allPackers = res.data.staff.filter(function (staff) {
							    return staff.roles.indexOf('Order Picker') !== -1;
						    });

						    if (allPackers.length) {
							    $scope.packers = allPackers || [];
							    ngDialog.open({
								    template        : 'partials/popup/admin-assign-packer.html',
								    controller      : 'ModalController',
								    className       : 'ngdialog-theme-default',
								    showClose       : false,
								    closeByDocument : false,
								    closeByEscape   : true,
								    closeByNavigation: true,
								    scope           : $scope,
								    name            : 'assign-packer',
								    id              : 'assign-packer',
								    preCloseCallback(success) {
									    if (success) {
										    $scope.admin.adminData.checkedPacker = true;
										    setTimeout(function () {
											    $scope.admin.initOrderDetails();
										    }, 300);
									    } else {
										    $scope.admin.adminData.checkedPacker = true;

										    if (!update) {
											    $scope.admin.togglePackingPreview();
										    }
									    }
								    }
							    });

						    } else {
							    $scope.admin.adminData.checkedPacker = true;
							    $scope.admin.config.showPackingPreview = true;
							    toastr.error("No packers available.")
						    }
					    } else  {
						    toastr.error("Couldn't get list of packers. Please try again.")
					    }
				    });
		    },
		    showAddItemPopup(replaceItem, type) {
	            $scope.replaceItem = replaceItem || false;
                var typeMap = {
                    replace: {
                        title: 'Replace Item',
                        placeholder: 'Search For Replacement',
                    },
                    add: {
                        title: 'Add Item',
                        placeholder: 'Search Products',
                    },
                };
                var type = type in typeMap ? type : 'add';
                var popupData = typeMap[type.toLowerCase()];
			    ngDialog.open({
				    template        : 'partials/popup/add-item-to-order-popup.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default add-item-to-order-dialog',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : true,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'add-item-to-order',
				    id              : 'add-item-to-order',
                    data: {
                        matchAllWords: true,
                        title: popupData.title,
                        searchPlaceHolder: popupData.placeholder,
                    },
				    preCloseCallback(val) {
					    if (replaceItem && val && val.replaced) {
						    void 0;
					    } else if (val && val.type === 'order-updated'){
						    $scope.admin.processOrderData(val.data);
					    }
				    }
				});
		    },
		    todaysOrders: {
			    All: [],
			    Received: [],
			    InProgress: [],
			    NotPacked: [],
			    Processed: [],
			    OutForDelivery: [],
			    Completed: [],
			    Cancelled: [],
			    CompleteAll: []
		    },
		    orders: {
			    All: [],
			    Received: [],
			    InProgress: [],
			    NotPacked: [],
			    Processed: [],
			    OutForDelivery: [],
			    Completed: [],
			    Cancelled: [],
			    CompleteAll: []
		    },
		    export: {
                CSVHeaders: ['Customer Name', 'Status', 'Date', 'Time', 'Fulfillment Method', 'Driver', 'Bags', 'Address', 'Email', 'Phone', 'Instructions', 'Total'],
                fileName: '',
                updateOrdersForExport(ordersList) {
                    var ordersToExport = [];
                    var orderProperty = $scope.admin.selectedFilter.property || $scope.admin.orderFilter.DELIVERY_TIME.property;
                    
                    ordersList = $filter('orderBy')(ordersList, orderProperty);
                    
                    for (var order of ordersList) {
                        if (order.userObj) {
                            order.fullName = order.userObj.firstName + ' '+ order.userObj.lastName;
                            order.phone = order.userObj.phoneNumber;
                            order.email = order.userObj.email;
                        } else if (order.userData) {
                            order.fullName = order.userData.firstName + ' ' + order.userData.lastName;
                            order.phone = order.userData.phoneNumber;
                            order.email = order.userData.email;
                        } else {
                            order.fullName = '';
                            order.phone = '';
                            order.email = '';
                        }
                        
                        if (order.deliveryAddress) {
                            order.fullAddress = order.deliveryAddress.street;
                            order.fullAddress += order.deliveryAddress.aptUnit ? ', ' + order.deliveryAddress.aptUnit + ', ': ', ';
                            order.fullAddress += order.deliveryAddress.city + ', ';
                            order.fullAddress += order.deliveryAddress.state + ', ';
                            order.fullAddress += order.deliveryAddress.zip;
                        }
                        
                        if (order.hasOwnProperty('driver')) {
                            order.driverName = order.driver.fullName;
                        } else {
                            order.driverName = '-';
                        }
                        
                        ordersToExport.push({
                            'Customer Name': order.fullName || '',
                            'Status': order.state || '',
                            "Date" : order.deliveryDate || '',
                            'Time': order.deliveryTime || '',
                            'Fulfillment Method': order.fulfillmentMethod || '',
                            'Driver': order.driverName || '',
                            'Bags': order.bagCount || '-',
                            'Address': order.fullAddress || '',
                            'Email': order.email || '',
                            'Phone': order.phone || '',
                            'Instructions': order.deliveryInstructions || '',
                            'Total': order.total || '',
                        });
                    }
                    return ordersToExport;
                },
                orders: function() {
                    return $scope.admin.adminData.export.updateOrdersForExport($scope.admin.adminData.selectedOrderType);
                },
                orderHistory: function() {
                    return $scope.admin.adminData.export.updateOrdersForExport($scope.admin.orderHistory.orders);
                },
		    },
            exportItems: {
                CSVHeaders: ['UPC/PLU', 'Display Name', 'Category', 'Subcategory', 'Unit', 'Average Weight', 'Units Ordered', 'Quantity (LB)'],
				PDFHeadersMap: {
					upc: 'UPC/PLU', 
					displayName: 'Display Name', 
					type: 'Category', 
					subType: 'Subcategory', 
					unit: 'Unit', 
					avgWeight: 'Average Weight', 
					unitsOrdered: 'Units Ordered', 
					qty:  'Quantity (LB)'
				},
                fileName: '',
				pdfReportData: [],
                itemsForExport(ordersList) {
                    var itemsExport = {};
                    var itemsCSV = [];
					var itemsPDF = [];

                    ordersList.forEach(function(order) {
                        if (['Cancelled'].includes(order.state)) return;

                        var itemsToAdd = JSON.parse(JSON.stringify(order.items)); 
                        for (var j=0; j < itemsToAdd.length; j++) {
                            var it = itemsToAdd[j];
                            var id = it.name + it.instructions;
                            var displayArray = [];

                            if (it.selectedModifiers) {
                                Object.values(it.selectedModifiers).forEach(function(mod) {
                                    if (mod.modifierType === 'product') {
                                        var modItem = {
                                            name: mod.name,
                                            displayName: mod.displayName,
                                            type: it.type,
                                            subType: it.type,
                                            quantity: it.quantity,
                                            upc: mod.upc || '',
                                            unit: 'count',
											instructions: it.instructions
                                        }
                                        itemsToAdd.push(modItem);
                                    } else {
                                        id += mod.name;
                                        displayArray.push(mod.displayName);
                                    }
                                })
                            }

							it.pdfDisplayName = it.displayName;
							it.pdfInstructions = it.instructions;
							it.pdfModifiers = displayArray;

							var displayArrayString = displayArray.join('\n');
							if (hsUtils.isNonEmptyString(displayArrayString)) {
								it.displayName += ('\n\n' + displayArrayString);
							}

							if (hsUtils.isNonEmptyString(it.instructions)) {
								it.displayName += ('\n\n' + it.instructions);
							}

                            if (!itemsExport[id]) {
                                itemsExport[id] = it;
                            } else {
                                itemsExport[id].quantity += it.quantity;
                            }
                        }
                    });

                    Object.keys(itemsExport).forEach(function(itemName) {
                        var item = itemsExport[itemName];
                        var qty = null;
                        var unitsOrdered = item.quantity;
                        if (item.sellByQty) {
                            qty = (item.avgWeight * item.quantity).toFixed(2);
                        } else if (!item.sellByQty && item.unit === 'lb') {
                            qty = item.quantity;
                            unitsOrdered = '';
                        }
                        itemsCSV.push({
                            'UPC/PLU': item.upc || '',
                            'Display Name': item.displayName || '',
                            'Category': hsUtils.getItemType(item),
                            'Subcategory': hsUtils.getItemSubType(item),
                            'Unit': item.unit || '',
                            'Average Weight': item.avgWeight || '',
                            'Units Ordered': unitsOrdered || '',
                            'Quantity (LB)': qty,
                        });
						itemsPDF.push({
							upc: item.upc || '',
                            displayName: item.pdfDisplayName || '',
							instructions: item.pdfInstructions || '',
							modifiers: item.pdfModifiers || [],
                            type: hsUtils.getItemType(item),
                            subType: hsUtils.getItemSubType(item),
                            unit: item.unit || '',
                            avgWeight: item.avgWeight || '',
                            unitsOrdered: unitsOrdered || '',
                            qty: qty,
						});
                    });

					itemsPDF = itemsPDF.sort(function(a, b) {
						if (a.type > b.type) return 1; 
						if (a.type < b.type) return -1; 

						if (a.subType > b.subType) return 1; 
						if (a.subType < b.subType) return -1; 

						return 0;
					});

					$scope.admin.adminData.exportItems.pdfReportData = itemsPDF;
                    return itemsCSV;
                },
                orders: function() {
                    return $scope.admin.adminData.exportItems.itemsForExport($scope.admin.adminData.selectedOrderType);
                },
                orderHistoryItems: function() {
                    return $scope.admin.adminData.exportItems.itemsForExport($scope.admin.orderHistory.orders);
                },
            },
		    selectedOrderStatus: '',
		    selectedOrderType: [],
		    orderDetails: {
			    order: {},
			    userData: {},
			    backUrl: '',
				enableCustomFulfillmentTimes: false
		    },
		    fulfillOrderStatus: true,
		    unapprovedUsers: []
	    },
	    productData: {
	    	unitTypes: ['lb', 'count', 'bunch'],
			updatedProductImage: null,
			uploadedFiles: null,
            availableHours: function () {
                var options = [];
                for (var i = 0; i < 24; i++) {
                    if (i < 10) {
                        options.push('0' + i);
                    } else {
                        options.push('' + i);
                    }
                }
                return options;
            },
            availableMin: function () {
                var options = [];
                for (var i = 0; i < 60; i++) {
                    if (i < 10) {
                        options.push('0' + i);
                    } else {
                        options.push('' + i);
                    }
                }
                return options;
            },
            availableStartHour: null,
            availableStartMin: null,
            availableStartHourIndex: null,
            availableEndHour: null,
            availableEndMin: null,
            editAvailableTime: null,
            isAvailableAllTimes : true,
            sortAvailableTimeFunction(a,b) {
                var aStartHour = parseInt(a.startTime.split(':')[0]);
                var aStartMin = parseInt(a.startTime.split(':')[1])
                var bStartHour = parseInt(b.startTime.split(':')[0]);
                var bStartMin = parseInt(b.startTime.split(':')[1])
                if (aStartHour === bStartHour) {
                    return aStartMin - bStartMin;
                } else {
                    return aStartHour - bStartHour;
                }
            },
            isEditingAvailableTime() {
                return typeof $scope.admin.productData.editAvailableTime === 'number';
            },
            resetAvailableTimes() {
                $scope.admin.productData.availableStartHour = null;
                $scope.admin.productData.availableStartMin = null;
                $scope.admin.productData.availableEndHour = null;
                $scope.admin.productData.availableEndMin = null;
                $scope.admin.productData.editAvailableTime = null;
            },
            validateAvailableTimes() {
                if($scope.admin.productData.availableStartHour === $scope.admin.productData.availableEndHour) {
                    if($scope.admin.productData.availableStartMin < $scope.admin.productData.availableEndMin) {
                        return true;
                    } else {
                        toastr.error("Invalid Times.  Please try again.");
                        return false;
                    }
                } else if ($scope.admin.productData.availableStartHour < $scope.admin.productData.availableEndHour) {
                    return true;
                } else {
                    toastr.error("Invalid Times.  Please try again.");
                    return false;
                }
            },
			areSameAvailableTimes(oldTime, newTime) {
				if (typeof oldTime !== "object" || typeof newTime !== "object"
					|| !oldTime.hasOwnProperty('startTime') || !oldTime.hasOwnProperty('endTime')
					|| !newTime.hasOwnProperty('startTime') || !newTime.hasOwnProperty('endTime'))
				{
					return false;
				}
				return oldTime.startTime === newTime.startTime && oldTime.endTime === newTime.endTime;
			},
			hasAvailableTimesChanged(newAvailableTimes) {
				if (newAvailableTimes.length !== $scope.admin.originalProductData.product.availableTimes.length) {
					return true;
				}

				if (!newAvailableTimes.length && !$scope.admin.originalProductData.product.availableTimes.length) {
					return false;
				}

				var newAvailableTimesLength = newAvailableTimes.length;
				for (var i = 0; i < newAvailableTimesLength; i++) {
					if (!$scope.admin.productData.areSameAvailableTimes($scope.admin.originalProductData.product.availableTimes[i], newAvailableTimes[i])) {
						return true;
					}
				}
				return false;
			},
            toggleEditAvailableTime(index) {
                if (!$scope.admin.productData.isEditingAvailableTime()) {
                    var hourOptions = $scope.admin.productData.availableHours();
                    var availTime = $scope.admin.productData.product.availableTimes[index];

                    $scope.admin.productData.editAvailableTime = index;
                    $scope.admin.productData.availableStartHour = availTime.startTime.split(':')[0];
                    $scope.admin.productData.availableStartHourIndex = hourOptions.indexOf($scope.admin.productData.availableStartHour);
                    $scope.admin.productData.availableStartMin = availTime.startTime.split(':')[1];
                    $scope.admin.productData.availableEndHour = availTime.endTime.split(':')[0];
                    $scope.admin.productData.availableEndMin = availTime.endTime.split(':')[1];
                } else {
                    $scope.admin.productData.resetAvailableTimes();
                }
            },
            addAvailableTime() {
                if ($scope.admin.productData.availableStartHour && $scope.admin.productData.availableStartMin 
                    && $scope.admin.productData.availableEndHour && $scope.admin.productData.availableEndMin
                    && $scope.admin.productData.validateAvailableTimes()) {
                    var availableTime = {
                        startTime: $scope.admin.productData.availableStartHour + ':' + $scope.admin.productData.availableStartMin,
                        endTime: $scope.admin.productData.availableEndHour + ':' + $scope.admin.productData.availableEndMin,
                    };
                    if (!$scope.admin.productData.product.availableTimes) {
                        $scope.admin.productData.product.availableTimes = [];
                    }
                    $scope.admin.productData.product.availableTimes.push(availableTime);
                    $scope.admin.productData.product.availableTimes.sort($scope.admin.productData.sortAvailableTimeFunction);
                    $scope.admin.productData.resetAvailableTimes();
                }
            },
            updateAvailableTime() {
                if ($scope.admin.productData.availableStartHour && $scope.admin.productData.availableStartMin 
                    && $scope.admin.productData.availableEndHour && $scope.admin.productData.availableEndMin
                    && $scope.admin.productData.validateAvailableTimes()) {
                    var availableTime = {
                        startTime: $scope.admin.productData.availableStartHour + ':' + $scope.admin.productData.availableStartMin,
                        endTime: $scope.admin.productData.availableEndHour + ':' + $scope.admin.productData.availableEndMin,
                    };
                    $scope.admin.productData.product.availableTimes.splice($scope.admin.productData.editAvailableTime, 1, availableTime);
                    $scope.admin.productData.product.availableTimes.sort($scope.admin.productData.sortAvailableTimeFunction);
                    $scope.admin.productData.resetAvailableTimes();
                }
            },
            removeAvailableTime(index) {
                $scope.admin.productData.product.availableTimes.splice(index, 1);
            },
            selectAvailableStart() {
                var hourOptions = $scope.admin.productData.availableHours();
                $scope.admin.productData.availableStartHourIndex = hourOptions.indexOf($scope.admin.productData.availableStartHour);
            },
		    unitEditable : false,
	    	showGridView: true,
		    toggleGridView() {
	    		this.showGridView = !this.showGridView;
	    		$location.search('gridView', this.showGridView.toString());
		    },
		    tableParams: {},
		    allProducts: [],
		    outOfStockProducts: [],
			autoAddedProducts: [],
		    selectedProduct: {},
		    originalCategorizedProducts: [],
		    categorizedProducts: [],
		    infiniteScrollProducts: [],
		    product: {
			    name: '',
			    displayName: '',
			    type: '',
			    subType: '',
			    unit: '',
			    price: '',
			    unitQuantity: 1,
			    organic: false,
			    inStock: true,
			    brand: '',
			    ingredients: '',
				marketingCopy: '',
			    disclaimer: '',
			    isAlcohol: false,
				skipScan: false,
			    minQuantity: 0,
			    maxQuantity: 0,
			    taxRate: 0,
				modifiers: [],
                bottleFee: 0,
				sortOrderCustom: null,
				posData: {
					department: '',
					subDepartment: ''
				}
		    },
			modifierForm: {
				isLoading: false,
				selectedModifier: {},
				template: hsModifiers.TEMPLATES.LIMITED_EDIT_MODIFIER, 
				syncPriceListsPopup: {
					elementId: 'sync-edit-modifier-from-product-details',
					dataToPropagate: null
				},
				isVisible: function() {
					return hsUtils.isNonEmptyObject($scope.admin.productData.modifierForm.selectedModifier);
				},
				showModifierForm: function(modifier) {
					$scope.admin.productData.modifierForm.selectedModifier = modifier;
				},
				hideModifierForm: function() {
					$scope.admin.productData.modifierForm.selectedModifier = {};
				},
				handleSave: function(saveData) {
					if (!hsUtils.isObject(saveData.modifierData)) {
						toastr.error('Something went wrong');
						throw 'Invalid save data: ' + saveData;
					}

					$scope.admin.productData.modifierForm.isLoading = true;

					var modifierData = saveData.modifierData;
					return hsModifiers.createModifier(modifierData, true)
						.then(function(res) {
							for (var i = 0; i < $scope.admin.productData.product.modifiers.length; i++) {
								if ($scope.admin.productData.product.modifiers[i].name === res.name) {
									$scope.admin.productData.product.modifiers[i] = res;
								}
							}
							$scope.admin.productData.modifierForm.syncPriceListsPopup.dataToPropagate = modifierData;
							$scope.admin.productData.modifierForm.openSyncPriceListsPopupOrContinue();
						})
						.catch(function(err) {
							void 0;
							toastr.error("Something went wrong. Please try again.");
							$scope.admin.productData.modifierForm.syncPriceListsPopup.dataToPropagate = null;
						})
						.finally(function() {
							$scope.admin.productData.modifierForm.isLoading = false;
						});
				},
				propagateUpdateToTarget: function(target) {
					return hsModifiers.createModifier($scope.admin.productData.modifierForm.syncPriceListsPopup.dataToPropagate, true, target);
				},
				openSyncPriceListsPopupOrContinue: function() {
					if (hsAdmin.shouldShowSyncPriceListsPopup()) {
						$('#' + $scope.admin.productData.modifierForm.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
							$scope.admin.productData.modifierForm.handleUpdateCompletion();
							$scope.$apply();
						});
						$('#' + $scope.admin.productData.modifierForm.syncPriceListsPopup.elementId).modal('show');
					} else {
						$scope.admin.productData.modifierForm.handleUpdateCompletion();
					}
				},
				handleUpdateCompletion: function() {
					$scope.admin.productData.modifierForm.selectedModifier = {};
				},
			},
		    showProductDetails(product) {
                ngDialog.open({
                    template: '/partials/admin/product/product-details.html',
                    controller:'adminCtrl',
                    className: 'ngdialog-theme-default ngdialog-full-width',
                    closeByEscape: false,
                    data: {
                        product: product,
                        allProducts: $scope.admin.productData.allProducts,
						showGridView: $scope.admin.productData.showGridView,
                    }
                }).closePromise.then(function(data) {
                    if (data.value && data.value.product && typeof $scope.admin.rebuildProductCategories === 'function') {
                        $scope.admin.rebuildProductCategories(data.value.product);
                    }
					if (data.value && data.value.product && data.value.callback && typeof data.value.callback === "function") {
						data.value.callback(data.value.product);
					}
                });
		    },
            getProductsFromPageType(pageType) {
                var outOfStockPage = pageType === 'outOfStockPage';
                var inactiveProductsPage = pageType === 'inactiveProductsPage';
                var homepageProductsPage = pageType === 'homepageProductsPage';
				var autoAddedProductsPage = pageType === 'autoAddedPage';
                var products;
                var productAvailability;
                if (outOfStockPage) {
                    products = $scope.admin.productData.outOfStockProducts;
                    productAvailability = 'outOfStock';
                } else if (inactiveProductsPage) {
                    products = $scope.admin.productData.inactiveProducts;
                    productAvailability = 'inactive';
                } else if (homepageProductsPage) {
                    products = $scope.admin.productData.homepageProducts;
                    productAvailability = 'homepage';
                } else if (autoAddedProductsPage) {
                    products = $scope.admin.productData.autoAddedProducts;
                    productAvailability = 'autoAdded';
                } else {
                    products = $scope.admin.productData.categorizedProducts;
                    productAvailability = 'all';
                }
                return {
                    products: products,
                    productAvailability: productAvailability,
                };
            },
		    activateTab: function (subCategory, index, pageType) {
                var productsObj = $scope.admin.productData.getProductsFromPageType(pageType);
                var products = productsObj.products;
                var productAvailability = productsObj.productAvailability;
                $location.search('category', products[index].id);
                products.forEach(cat => cat.loadTab = false);
                products[index].loadTab = true;
                $scope.admin.initInfiniteScroll(products, productAvailability);
		    },
            selectItemIsActive: function (value) {
                $scope.admin.productData.product.isInactive = !value;
            },
            exportProducts: {
                csvHeaders: [
                    'Homesome Name',
                    'UPC/PLU',
                    'Name',
                    'Category',
                    'Sub Category',
                    'Size',
                    'Price',
                    'Unit',
                    'Unit Quantity',
                    'In Stock?',
                    'Inactive?',
                    'Image Exists?',
                    'Organic?',
                    'Brand',
                    'Bottle Fee',
                    'Alcohol?',
                    'Pickup Only?',
                    'Tax Rate',
                    'Receipt Alias',
                    'Use Syndigo Data',
                    'POS Linked Item Code',
                    'Available Days',
                    'Available Times',
                    'Location In Store',
                ],
                getFilename(pageType) {
                    var type = '';
					if (pageType === 'allProductsPage') {
						type = 'all';
					} else if (pageType === 'outOfStockPage') {
                        type = 'out-of-stock';
                    } else if (pageType === 'inactiveProductsPage') {
                        type = 'inactive';	
					} else if (pageType === 'autoAddedPage') {
                        type = 'auto-added';
					} else if (pageType === 'homepageProductsPage') {
                        type = 'homepage';
                    }
                    var formattedDate = globalFunctions.formatDate(new Date(), '-');
                    var filename = [type, 'products', formattedDate].join('-');
                    return filename + '.csv';
                },
                productsToExport() {
                    var exportData = [];
                    var tableData = $filter('filter')(
                        $scope.admin.productData.tableParams.settings().dataset,
                        $scope.admin.productData.tableParams.filter()
                    );
                    tableData = $filter('orderBy')(tableData, $scope.admin.productData.tableParams.orderBy());
                    tableData.forEach(function (product) {
                        exportData.push({
                            'Homesome Name': '-' + product.name + '-',
                            'UPC/PLU': '-' + product.upc + '-',
                            'Name': product.displayName,
                            'Category': product.type,
                            'Sub Category': product.subType,
                            'Size': $scope.admin.calculateUnitQuantity(product),
                            'Price': product.price,
                            'Unit': product.unit,
                            'Unit Quantity': product.unitQuantity,
                            'In Stock?': product.inStock,
							'Inactive?': product.isInactive,
							'Image Exists?': !!product.imageExists,
                            'Organic?': !!product.organic,
                            'Brand': product.brand,
                            'Bottle Fee': product.bottleFee || 0,
                            'Alcohol?': !!product.isAlcohol,
                            'Pickup Only?': !!product.isPickupOnly,
                            'Tax Rate': product.taxRate || 0,
                            'Receipt Alias': product.receiptAlias || '',
                            'Use Syndigo Data': !!product.useSyndigoData,
                            'POS Linked Item Code': product.POSLinkedItem,
                            'Available Days': getAvailableDays(product),
                            'Available Times': getAvailableTimes(product),
                            'Location In Store': getLocationInStore(product),
                        });
                    });
                    return exportData;

                    function getAvailableDays(product) {
                        if (!hsUtils.isNonEmptyArray(product.availableDays)) return '';
                        return product.availableDays.join(',');
                    }

                    function getAvailableTimes(product) {
                        if (!hsUtils.isNonEmptyArray(product.availableTimes)) return '';
                        return product.availableTimes.map(function(t) {
                            return t.startTime + '-' + t.endTime;
                        }).join(',');
                    }

                    function getLocationInStore(product) {
                        if (!hsUtils.isNonEmptyObject(product.locationInStore)) return '';
                        return Object.entries(product.locationInStore).map(function(e) {
                            return hsUtils.isNonEmptyString(e[1]) ? e.join(':') : null;
                        }).filter(function(e) { return !!e; }).join(',');
                    }
                },
            },
	    },
	    backToProducts: function () {
		    $location.url(this.productBackUrl);
	    },
	    selectedFilter: {},
	    orderGroups: {},
	    orderFilter: {
		    DELIVERY_TIME : {
			    property            : 'deliveryTimeMsec',
			    displayName         : 'Delivery Time'
		    },
		    ORDER_NUMBER: {
			    property: 'number',
			    displayName: 'Order Number'
		    },
		    PACKED: {
			    property: 'packed',
			    displayName: 'Packed Status'
		    },
		    ORDER_TYPE: {
			    property: 'fulfillmentMethod',
			    displayName: 'Order Type'
		    }
	    },
	    orderStatusBtnClass: {
		    "Processed": 'btn-tertiary',
		    "Out For Delivery": 'btn-tertiary',
		    "Completed": 'btn-secondary',
		    "Cancelled": 'btn-outline-primary',
            "Reactivate Order": 'btn-primary'
	    },
	    orderStatus: {
		    Received: {
			    processed: "Processed",
			    outForDelivery: "Out For Delivery",
			    completed: "Completed",
			    cancelled: "Cancelled"
		    },
		    InProgress: {
			    processed: "Processed",
			    cancelled: "Cancelled"
		    },
		    Processed: {
		    	outForDelivery: "Out For Delivery",
			    completed: "Completed",
			    cancelled: "Cancelled"
		    },
		    CompleteAll: {
			    completed: "Completed",
			    cancelled: "Cancelled"
		    },
		    OutForDelivery: {
		    	completed: "Completed",
		    	cancelled: "Cancelled"
		    },
            Cancelled: {
                reactivateOrder: "Reactivate Order"
            },
            Completed: {
                reactivateOrder: "Reactivate Order"
            }
	    },
	    orderHistory: {
		    ordersLoaded: false,
		    searchThreshold: 15,
		    selectedOrders: [],
		    orders: [],
		    aggregatedData: {},
		    showOnHoldOrders: false,
		    loadMore() {
			    void 0;
			    if (this.selectedOrders.length < this.orders.length) {
			    	void 0;
				    this.searching = true;
                    var onHoldOrders = $scope.admin.orderHistory.onHoldOrders || [];
                    var orders = $scope.admin.orderHistory.showOnHoldOrders
                        ? onHoldOrders
                        : $scope.admin.orderHistory.orders;

				    var length = $scope.admin.orderHistory.selectedOrders.length;
				    var maxLength = length + $scope.admin.orderHistory.searchThreshold;
				    if (maxLength > orders.length) {
					    maxLength = orders.length;
				    }
				    for (var i = length; i < maxLength; i++) {
					    if (orders[i]) {
						    $scope.admin.orderHistory.selectedOrders.push(orders[i]);
					    }
				    }
				    void 0;

				    this.searching = false;
			    }
		    },
		    startDate: {
			    model: new Date(),
			    weeklyModel: new Date(),
			    monthlyModel: new Date(),
			    format: 'MM-dd-yyyy',
			    monthlyFormat: 'MM-yyyy',
			    dateOptions: {
				    showWeeks: false,
				    formatYear: 'yy',
				    maxDate: new Date(2030, 5, 22),
				    minDate: new Date((new Date().getFullYear(), new Date().getMonth(), new Date().getDate() - 7)),
				    startingDay: 1,
				    showClear: false,
			    },
			    weeklyDateOptions: {
				    showWeeks: false,
				    datepickerMode: 'day',
				    formatYear: 'yy',
				    maxDate: new Date(2030, 5, 22),
				    minDate: new Date((new Date().getFullYear(), new Date().getMonth(), new Date().getDate() - 7)),
				    startingDay: 1,
				    showClear: false,
				    dateDisabled(data) {
					    var date = data.date,
						    mode = data.mode;
					    return mode === 'day' && (date.getDay() !== 1);
				    }
			    },
			    monthlyDateOptions: {
				    showWeeks: false,
				    datepickerMode: 'month',
				    formatYear: 'yy',
				    maxDate: new Date(2030, 5, 22),
				    minDate: new Date((new Date().getFullYear(), new Date().getMonth(), new Date().getDate() - 7)),
				    startingDay: 1,
				    minMode: 'month',
				    showClear: false,
				    dateDisabled(data) {
					    var date = data.date,
						    mode = data.mode;
					    return mode === 'day' && (date.getDay() !== 1);
				    }
			    },
			    opened: false,
			    open: function () {
				    $scope.admin.orderHistory.startDate.opened = !$scope.admin.orderHistory.startDate.opened;
			    }
		    },
		    endDate: {
			    model: new Date(),
			    format: 'MM-dd-yyyy',
			    dateOptions: {
				    showWeeks: false,
				    formatYear: 'yy',
				    maxDate: new Date(2030, 5, 22),
				    minDate: new Date(),
				    startingDay: 1,
				    showClear: false
			    },
			    opened: false,
			    open: function () {
				    $scope.admin.orderHistory.endDate.opened = !$scope.admin.orderHistory.endDate.opened;
			    }
		    },
	    },
	    datePicker: {
		    model: new Date(),
		    format: 'MM-dd-yyyy',
		    dateOptions: {
			    showWeeks: false,
			    formatYear: 'yy',
			    maxDate: new Date(2020, 5, 22),
			    minDate: new Date((new Date().getFullYear(), new Date().getMonth(), new Date().getDate() - 7)),
			    startingDay: 1,
			    showClear: false
		    },
		    opened: false,
		    open: function () {
			    $scope.admin.datePicker.opened = !$scope.admin.datePicker.opened;
		    }
	    },
	    // The Entity that represents the user's address
	    address: {
		    street1: "",
		    street2: "",
		    city: "",
		    state: "",
		    zip: "",
		    country: ""
	    },
	    // Object used to control notifications on the View
	    notification: {
		    isAddressEdit: true,
		    isAddressError: false,
		    isVerificationLoading: false,
		    isRegisterAddrLoading: false,
		    errMessage: "",
		    reset: function () {
			    this.isAddressError = false;
			    this.isVerificationLoading = false;
			    this.isRegisterAddrLoading = false;
			    this.errMessage = "";
		    }
	    },
	    printers: [],
	    printersExtended: [],
	    categoryFilters: [],
	    salesReport : {
			csv: {
				header: ['', ''],
				order: ['col1', 'col2'],
				getFilename(reportType) {
					var date;
					if (reportType === 'daily') {
						date = $scope.admin.orderHistory.startDate.model;
					} else if (reportType === 'weekly') {
						date = $scope.admin.orderHistory.startDate.weeklyModel;
					} else if (reportType === 'monthly') {
						date = $scope.admin.orderHistory.startDate.monthlyModel;
					}
					var formattedDate = globalFunctions.formatDate(date, '-');
					var filename = ['sales_report', reportType, formattedDate].join('_');
					return filename + '.csv';
				},
				getCsvData() {
					function createCsvDataSet(data, displayNameToKeyMap, multiplier) {
						return Object.keys(displayNameToKeyMap).map((fieldName) => {
							var key = displayNameToKeyMap[fieldName];
							var value = key in data 
								? $filter('number')(multiplier * data[key], 2)
								: '';
							return { col1: fieldName, col2: value };
						});
					}
					
					var csvRevenueFieldNameToReportKeys = {
						'Revenue': '',
						'Net Sales': 'netSales',
						'Sales Tax': 'tax',
						'Delivery Fees': 'orderFeeCollected',
						'Service Fees': 'serviceFee',
						'Bag Fees': 'bagFee',
						'Bottle Fees': 'bottleFee',
						'Tips': 'tips',
						'Gross Sales': 'grossSales',
						'': '',
					};

					var csvExpensesFieldNameToReportKeys = {
						'Expenses': '',
						'Payment Fees': 'fees',
						'Delivery Cost (3rd Party)': 'delivery3rdPartyCost',
						'Refunds Issued': 'refunds',
						'Discounts': 'discount',
					};
					
					if (ENV.legal.legalName === 'Erewhon') {
						csvExpensesFieldNameToReportKeys['Paid With Points'] = 'paidWithPoints';
					}

					csvExpensesFieldNameToReportKeys['Tips Paid'] = 'delivery3rdPartyTips';
					csvExpensesFieldNameToReportKeys['Total Expenses'] = 'totalExpenses';
					csvExpensesFieldNameToReportKeys[''] = '';
					
					var reportData = $scope.admin.salesReport.report;
					var revenue = createCsvDataSet(reportData, csvRevenueFieldNameToReportKeys, 1);
					var expenses = createCsvDataSet(reportData, csvExpensesFieldNameToReportKeys, -1);
					var totalEarnings = createCsvDataSet(reportData, { 'Net Deposits': 'netEarnings' }, 1);

					return []
						.concat(revenue)
						.concat(expenses)
						.concat(totalEarnings);
				},
			},
			report: {},
		    showBreakdownPopup() {
			    ngDialog.open({
				    template        : 'partials/popup/sales-report-breakdown.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default',
				    showClose       : true,
				    closeByDocument : true,
				    closeByEscape   : true,
				    closeByNavigation: true,
				    data            : $scope.admin.salesReport.report,
				    name            : 'breakdown-popup',
				    id              : 'breakdown-popup',
				    /*preCloseCallback(success) {
					    if (success) {
						    $scope.admin.initDailySales();
					    }
				    }*/
			    });
		    }
	    },
	    staff : {
	    	staffers: [],
		    add() {
			    ngDialog.open({
				    template        : 'partials/popup/admin-add-staffer.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : true,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'add-driver',
				    id              : 'add-driver',
				    preCloseCallback(success) {
					    if (success) {
						    $scope.admin.staff.init();
					    }
				    }
			    });
		    },
		    remove(staffer, type) {
	    		var data = {
	    			staffData: {
	    				id: staffer.id,
					    operationType: 'Delete'
				    }
			    };

	    		void 0;
	    		hsAdmin.updateStaffer(data)
				    .then(function(res) {
					    if (res.status === 200) {
						    toastr.success("Staff member deleted successfully.");
						    $scope.admin.staff.init();
					    } else {
						    toastr.error("Couldn't get list of staff. Please try again.");
					    }
				    });
		    },
		    init() {
			    void 0;
			    if ($rootScope.currentUser.isAdminRestricted) {
			    	$location.url('/admin/location');
			    	return;
			    }

			    hsAdmin.getLocation()
				    .then(function(res) {
					    if (res.status === 200) {
						    void 0;
						    $scope.admin.staff.staffers = res.data.staff;
						    $scope.admin.config.pageFullyLoaded = true;
					    } else {
						    toastr.error("Couldn't get list of staffers. Please try again.")
					    }
				    });
		    },
		    initDashboard() {
			    if ($rootScope.currentUser.isAdminRestricted) {
				    $location.url('/admin/location');
				    return;
			    }
		    }
	    },
	    users: {
	    	csv: {
                headers: [
                    'Name',
                    'Email',
                    'Phone Number',
                    'Address',
                    'Num of Order',
                    'First Order Date',
                    'Last Order Date',
                    'Last Order Store',
                    'Avg. Order',
                    'Total Spend',
                    'Signed Up Date',
                    'Admin',
                ],
                usersToExport() {
                    var exportData = [];
                    var tableData = $filter('filter')(
                        $scope.admin.users.tableParams.settings().dataset,
                        $scope.admin.users.tableParams.filter()
                    );
                    tableData = $filter('orderBy')(tableData, $scope.admin.users.tableParams.orderBy());
                    for (var user of tableData) {
                        exportData.push({
                            'Name': user.fullName,
                            'Email': user.email,
                            'Phone Number': user.phoneNumber,
                            'Address': user.fullAddress,
                            'Num of Order': user.stats.numberOfOrders,
                            'First Order Date': $scope.admin.users.csv.formatOrderDate(user.stats.firstOrderDate),
                            'Last Order Date': $scope.admin.users.csv.formatOrderDate(user.stats.lastOrderDate),
                            'Last Order Store': user.stats.lastLocation,
                            'Avg. Order': parseFloat(user.stats.avgOrder.toFixed(2)),
                            'Total Spend': parseFloat(user.stats.totalSpend.toFixed(2)),
                            'Signed Up Date': $filter('date')(user.timeCreated),
                            'Admin': user.isAdmin ? (user.isAdminRestricted ? 'Restricted' : 'Full') : '',
                        });
                    }
                    return exportData;
                },
                formatOrderDate(fullDate) {
                    var d = new Date(fullDate);
                    if (d instanceof Date && !isNaN(d)) {
                        return globalFunctions.formatDate(d);
                    }
                    return '';
                },
            },
	    	allUsers: [],
		    tableParams: {},
	    	initAllUsers() {
	    		$http.get(ENV.apiEndPoint + '/users')
				    .then(function (res) {
				    	void 0;
				    	var users = res.data.users;
				    	users.forEach(function(user) {
				    		user.fullName = user.firstName + ' ' + user.lastName;
			                user.fullAddress = '';

				    		if (user.address) {
							    user.fullAddress = user.address.street;
							    if (user.address.aptUnit !== '') {
								    user.fullAddress += ', ' + user.address.aptUnit + ', ';
							    } else {
							    	user.fullAddress += ',';
							    }

							    user.fullAddress += ' ' + user.address.city;
							    user.fullAddress += ' ' + user.address.state;
							    user.fullAddress += ' ' + user.address.zip;

							    delete user.address;
						    }
                            if (user.isAdmin) {
                                user.adminType = (user.isAdminRestricted ? 'Restricted' : '') + ' Admin';
                            }

				    		delete user.address;
					    });
				    	void 0;

				    	$scope.admin.users.allUsers = users;

					    $scope.admin.users.tableParams = new NgTableParams({
						    count: globalFunctions.ngTableConfig.count
					    }, {
						    counts: globalFunctions.ngTableConfig.counts,
						    dataset: users
					    });

					    $scope.admin.config.pageFullyLoaded = true;
				    });
            },
			userEditing: null,
            openUserPopup(user) {
                if (!hsUtils.isObject(user)
                    || !$rootScope.currentUser || !$rootScope.currentUser.isAdmin || $rootScope.currentUser.isAdminRestricted
                ) {
                    return;
                }

                $scope.admin.userEditing = JSON.parse(JSON.stringify(user));
				$('#admin-user-details').modal('toggle');
				$('#admin-user-details').on('hide.bs.modal', function (e) {
					$scope.admin.userEditing = null;
					$scope.$apply();
				});
            },
	    },
	    orderManager: {
	    	error: "",
		    selectAllOrders: false,
		    resumeBulkPacking: false,
		    selectedOrders: [],
		    selectedOrdersObj: [],
		    assignDelivery() {
			    ngDialog.open({
				    template        : 'partials/popup/admin-assign-driver.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default assign-driver',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    scope           : $scope,
				    name            : 'assignDelivery',
				    id              : 'assignDelivery',
				    preCloseCallback: function(success) {
				    	if (success) {
				    		$scope.admin.initOrderDashboard();
					    }
				    }
			    });
		    },
            assignPacker() {
                ngDialog.open({
                    template        : 'partials/popup/admin-assign-packer-bulk.html',
                    controller      : 'ModalController',
                    className       : 'ngdialog-theme-default assign-driver',
                    showClose       : false,
                    closeByDocument : false,
                    closeByEscape   : false,
                    scope           : $scope,
                    name            : 'assignPacker',
                    id              : 'assignPacker',
                }).closePromise
                    .then(function(data) {
                        if (data && data.value === 'reload') {
                            $scope.admin.initOrderDashboard();
                        }
                    });
            },
		    bulkPacking() {
			    ngDialog.open({
				    template        : 'partials/popup/bulk-packing.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default bulk-packing',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    scope           : $scope,
				    name            : 'bulkPacking',
				    id              : 'bulkPacking',
				    /*preCloseCallback: function(value) {
					    if (confirm('Are you sure you want to close without saving your changes?')) {
					        localStorageService.remove('bulkPacking');
					        $route.reload();
						    return true;
					    }

					    return false;
				    }*/
			    });
		    },
		    selectOrder(event, order) {
		    	event.stopPropagation();
		    	if (order.checked) {
		    		$scope.admin.orderManager.selectedOrders.push(order.key);
		    		$scope.admin.orderManager.selectedOrdersObj.push(order);
			    } else {
				    $scope.admin.orderManager.selectedOrders.splice($scope.admin.orderManager.selectedOrders.indexOf(order.key), 1);
				    $scope.admin.orderManager.selectedOrdersObj = $scope.admin.orderManager.selectedOrdersObj
					    .filter(function(selectedOrder) {
					    	return selectedOrder.key !== order.key;
					    });
			    }

		    	$scope.admin.orderManager.selectAllOrders = $scope.admin.adminData.orders[$scope.admin.adminData.selectedOrderStatus].length === $scope.admin.orderManager.selectedOrders.length;

			    $scope.admin.orderManager.updateBulkPackingLocalStorage();
		    },
		    toggleAllOrders() {
			    $scope.admin.adminData.orders[$scope.admin.adminData.selectedOrderStatus]
				    .forEach(function(order) {
				    	order.checked = $scope.admin.orderManager.selectAllOrders;
				    	if (order.checked) {
				    		$scope.admin.orderManager.selectedOrders.push(order.key);
				    		$scope.admin.orderManager.selectedOrdersObj.push(order);
					    }
				    });

			    if (!$scope.admin.orderManager.selectAllOrders) {
				    $scope.admin.orderManager.selectedOrders = [];
				    $scope.admin.orderManager.selectedOrdersObj = [];
			    }

			    $scope.admin.orderManager.updateBulkPackingLocalStorage();
		    },
		    updateBulkPackingLocalStorage() {
	    		$scope.admin.orderManager.error = "";
			    var bulkPacking = localStorageService.get('bulkPacking') || {};

			    bulkPacking.selectedOrders = $scope.admin.orderManager.selectedOrders;
			    bulkPacking.selectedOrdersObj = $scope.admin.orderManager.selectedOrdersObj;
			    bulkPacking.allItems = [];
			    if (!bulkPacking.packedItems) {
			    	bulkPacking.packedItems = [];
			    }
			    $scope.admin.adminData.orders[$scope.admin.adminData.selectedOrderStatus]
				    .forEach(function(order) {
					    if (order.checked) {
					    	order.items.forEach(function(item) { item.orderKey = order.key});
						    bulkPacking.allItems = bulkPacking.allItems.concat(order.items);
					    }
				    });

			    localStorageService.set('bulkPacking', bulkPacking);
		    }
	    },
	    addProduct: {
		    addNewKey : 'Add New',
		    categories: [],
		    subCategories: {},
		    selectedSubCategories: [],
		    product: {
			    name: '',
			    type: '',
			    typeBox: '',
			    subType: '',
			    subTypeBox: '',
			    price: 1,
			    organic: false
		    },
		    capitalize(value, property) {
			    var text = value.trim().split(' ');
			    text = text.map(function(s) {
				    return s.charAt(0).toUpperCase() + s.slice(1);
			    });
			    $scope.admin.addProduct.product[property] = text.join(' ');
		    },
		    add(form) {
			    if (form.validate()) {
				    $scope.admin.config.buttonLoading = true;
				    var productData = $scope.admin.addProduct.product;
				    var reqObj = {
					    product: {
						    name: guid.v4(),
						    displayName: productData.name,
						    organic: productData.organic,
						    price: parseFloat(productData.price),
						    type: productData.type,
						    subType: productData.subType,
						    unit: 'count',
						    cost: 0,
						    unitQuantity: 1,
						    ingredients: '',
							marketingCopy: '',
						    nutritionLabel: '',
						    attributes: [],
						    hasImage: false,
						    qbName: false
					    }
				    };

				    if (productData.type === $scope.admin.addProduct.addNewKey) {
					    reqObj.product.type = productData.typeBox;
				    }

				    if (productData.subType === $scope.admin.addProduct.addNewKey) {
					    reqObj.product.subType = productData.subTypeBox;
				    }

				    void 0;

				    hsAdmin.addProduct(reqObj)
					    .then(function (response) {
						    void 0;
						    if (response.status === 200) {
							    hsAdmin.createAddProductList({})
								    .then(function(res) {
								    	if (res.status === 200) {
										    toastr.success('Product Added successfully.');
										    $scope.admin.addProduct.product = {
											    name: '',
											    type: '',
											    typeBox: '',
											    subType: '',
											    subTypeBox: '',
											    price: 1,
											    organic: false
										    };

										    $scope.admin.addProduct.init();
									    } else {
										    toastr.success('Error adding product.');
									    }
								    });
						    } else {
							    toastr.success('Error adding product.');
						    }

						    $scope.admin.config.buttonLoading = false;
					    });
			    }
		    },
		    selectOrganicType(value) {
			    $scope.admin.addProduct.product.organic = value;
		    },
		    typeChanged() {
			    if ($scope.admin.addProduct.product.type === $scope.admin.addProduct.addNewKey) {
				    $scope.admin.addProduct.selectedSubCategories = [$scope.admin.addProduct.addNewKey];
			    } else {
				    $scope.admin.addProduct.selectedSubCategories =
					    $scope.admin.addProduct.subCategories[$scope.admin.addProduct.product.type].concat($scope.admin.addProduct.addNewKey);
			    }

			    $scope.admin.addProduct.product.subType = $scope.admin.addProduct.selectedSubCategories[0];
		    },
		    init() {
			    void 0;
			    $http.get(ENV.apiEndPoint + '/product/list')
				    .then(function (res) {
					    if (res.status === 200) {
						    var products = res.data.products;
						    var categories = {};
						    angular.forEach(products, function (product) {
							    if (!categories[product.type]) {
								    categories[product.type] = [];
							    }

							    if (categories[product.type].indexOf(product.subType) === -1) {
								    categories[product.type].push(product.subType);
							    }
						    });

						    var categoryKeys = Object.keys(categories);
						    $scope.admin.addProduct.categories = categoryKeys.concat([$scope.admin.addProduct.addNewKey]);
						    $scope.admin.addProduct.subCategories = categories;
						    $scope.admin.addProduct.selectedSubCategories = categories[categoryKeys[0]].concat([$scope.admin.addProduct.addNewKey]);
						    $scope.admin.config.pageFullyLoaded = true;
					    }
				    });

		    }
	    },
        updatePartySize() {
            var $newScope = $scope.$new(true);
            $newScope.order = $scope.admin.adminData.orderDetails.order;

            ngDialog.open({
                template: '<div><table-side-party-size '
                    + 'admin="true" '
                    + 'order="order" '
                    + 'on-close="closeThisDialog(updatedOrder)" '
                    + '</table-side-party-size></div>',
                className: 'ngdialog-theme-default',
                plain: true,
                scope: $newScope,
            }).closePromise
                .then(function(data) {
                    if (data.value && typeof data.value === 'object') {
                        $scope.admin.processOrderData(data.value);
                    }
                })
                .catch(function(err) {
                    void 0;
                });
        },
        updateTableNumber() {

            var $newScope = $scope.$new(true);
            $newScope.tableNumber = {
                fromValidation: {
                    name: 'tableNumber',
                    rules: VALIDATORS.TABLE_NUMBER,
                },
                inputValue: $scope.admin.adminData.orderDetails.order.tableNumber,
                onSubmit: onSubmit,
                loading: false,
                error: '',
            };

            ngDialog.open({
                template: '<div><admin-action-form '
                    + 'title="Update Table Number" '
                    + 'sub-title="Enter Table Number" '
                    + 'btn-text="Update" '
                    + 'form-validation="tableNumber.fromValidation" '
                    + 'handle-submit="tableNumber.onSubmit(formData, value, closeThisDialog)" '
                    + 'input-val="tableNumber.inputValue" '
                    + 'is-loading="tableNumber.loading" '
                    + 'error-message="tableNumber.error" '
                    + '</admin-action-form></div>',
                className: 'ngdialog-theme-default',
                plain: true,
                scope: $newScope,
            });

            function onSubmit(formData, value, closeThisDialog) {

                if (formData.validate()) {
                    $newScope.tableNumber.loading = true;
                    var data = {
                        key: $scope.admin.adminData.orderDetails.order.key,
                        tableNumber: parseInt(value),
                    };

                    hsAdmin.updateOrderDetails({ order: data })
                        .then(function(res) {
                            if (res.status === 200) {
                                toastr.success('Updated table number.');
                                $scope.admin.processOrderData(res.data);
                                closeThisDialog();
                                return;
                            }
                            void 0;
                            $newScope.tableNumber.error = 'Failed to update table number.';
                            toastr.error($newScope.tableNumber.error);
                        })
                        .catch(function(err) {
                            void 0;
                            $newScope.tableNumber.error = 'Something whent wrong.';
                            toastr.error($newScope.tableNumber.error);
                        })
                        .finally(function() {
                            $newScope.tableNumber.loading = false;
                        });
                }
            }
        },
	    addTip(type) {
		    ngDialog.open({
			    template: 'partials/popup/add-tip-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default',
			    data: {
			    	order: $scope.admin.adminData.orderDetails.order,
				    admin: true,
                    type: type
			    },
			    preCloseCallback() {
			    	$scope.admin.initOrderDetails();
			    }
		    });
	    },
        isSeparateTips() {
            return typeof $scope.admin.adminData.orderDetails.order.shopperTip === 'number';
        },
        canUpdateDeliveryDateTime() {
            
            if($scope.admin.adminData.orderDetails.order.state === 'Completed'
			|| $scope.admin.adminData.orderDetails.order.state === 'Cancelled') {
                return false;
            }
                
            if ($scope.admin.adminData.orderDetails.order.managedDelivery) {
            	return hsUtils.isDeliveryInTerminalState($scope.admin.adminData.orderDetails.order.managedDelivery);
            }
        
            return true;
        },
        updateDeliveryDateTime() {
            var $newScope = $scope.$new(true);
            $newScope.order = $scope.admin.adminData.orderDetails.order;

            ngDialog.open({
                template: '<div><update-date-time '
                    + 'order="order" '
                    + 'admin="true" '
                    + 'enable-custom-fulfillment-times="' + $scope.admin.adminData.orderDetails.enableCustomFulfillmentTimes  + '" '
                    + 'on-close="closeThisDialog()" '
                    +' </update-date-time></div>',
                plain: true,
                className: 'ngdialog-theme-default auto-size-dialog',
                scope: $newScope,
                name: 'fullscreen',
            }).closePromise.then(function() {
                $scope.admin.initOrderDetails();
            })
            .catch(function(err) {
                void 0;
            });
        },
	    resendReceipt() {
		    ngDialog.open({
			    template: 'partials/popup/resend-order-receipt.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default',
			    data: {
			    	order: $scope.admin.adminData.orderDetails.order,
				    admin: true,
					sendConfirmation: false
			    }
		    });
	    },
		resendConfirmation(){
			ngDialog.open({
				template: 'partials/popup/resend-order-receipt.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default',
			    data: {
			    	order: $scope.admin.adminData.orderDetails.order,
				    admin: true,
					sendConfirmation: true
			    }
			})
		},
	    addBottleFee() {
		    ngDialog.open({
			    template: 'partials/popup/admin-bottle-fee-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default',
			    scope: $scope,
			    preCloseCallback() {
			    	$scope.admin.initOrderDetails();
			    }
		    });
	    },
	    openPrintTagPopup: function (bagCount) {
	    	if ($scope.admin.printers.length) {
                $scope.admin.printersExtended = $scope.admin.printers.map(function (printer) {
                    return {
                        printerIP: printer.ip,
                        printerName: printer.name,
                        print: true,
                        quantity: 1,
                    };
                });

	    		void 0;
	    		if (!$scope.admin.adminData.orderDetails.order.bagCount && !bagCount
					&& !globalFunctions.isOrderInTerminalState($scope.admin.adminData.orderDetails.order))
				{
	    			$scope.admin.updateNumberOfBags(true)
                        .then(function (res) {
                            if (res === 'success') {
                                showPrintPopup();
                            }
                        });
			    } else {
                    showPrintPopup();
			    }
		    } else {
	    		$scope.admin.getPrinters(function (error, printers) {
	    			if (!error) {
	    				if (printers.length) {
	    				    $scope.admin.openPrintTagPopup();
					    } else {
	    					$scope.admin.showAddPrinterPopup(true)
                                .then(function () {
                                    if ($scope.admin.printers.length) {
                                        $scope.admin.openPrintTagPopup();
                                    }
                                });
					    }
				    }
			    });
		    }

            function showPrintPopup() {
                var $newScope = $scope.$new(true);
                $newScope.onPrint = function(selectedPrinters) {
                    $scope.admin.print(selectedPrinters);
                };
                $newScope.printers = $scope.admin.printers;

                ngDialog.open({
                    template: '<print-tags '
                        + 'on-close="closeThisDialog()" '
                        + 'on-print="onPrint(selectedPrinters)" '
                        + 'printers="printers" '
                        + '></print-tags>',
                    className: 'ngdialog-theme-default',
                    plain: true,
                    scope: $newScope,
                });
            }
	    },
	    getPrinters: function (callback) {
		    $http.get(ENV.apiEndPoint + '/location')
			    .then(function (res) {
				    if (res.status === 200){
					    void 0;
					    $scope.admin.printers = res.data.tagPrinters;
					    callback(false, res.data.tagPrinters);
				    } else {
					    toastr.error('Error Retrieving Printers');
					    callback(true, []);
				    }
			    })
	    },
	    print: function (selectedPrinters) {
		    var index = 0;
            selectedPrinters = selectedPrinters ? selectedPrinters : $scope.admin.printersExtended;

            void 0;

		    function onPrintDone() {
			    index++;
			    if (index >= selectedPrinters.length) {
				    // all done
				    return;
			    } else {
				    printOrderTags();
				    return;
			    }
		    }

		    function printOrderTags() {
			    if (selectedPrinters.length <= 0) {
				    onPrintDone();
				    return;
			    }

			    var printer = selectedPrinters[index];
                $scope.admin.printOrderTags(printer, function (err) {
                    if (err) {
                        toastr.error(err);
                    } else {
                        toastr.success('Tag printed successfully');
                    }
                    onPrintDone();
                });
		    }

		    printOrderTags();
		    toastr.success('Printing Tags, Please Wait');
	    },
	    printOrderTags: function(printerObj, callback) {
		    var orderObj = $scope.admin.adminData.orderDetails.order;
		    var userObj = $scope.admin.adminData.orderDetails.userData;
		    var copies = orderObj.bagCount ? orderObj.bagCount : 1;

            var barcodes = null;

            // Not going to print using barcodes if bag count doesn't match barcodes count because barcodes are matched to
            // bag numbers. This should be taken care by the backend.
            if (Array.isArray(orderObj.barcodes) && orderObj.barcodes.length === copies) {
                barcodes = $scope.admin.adminData.orderDetails.order.barcodes.slice().sort(function(a, b) {
                    var numA = parseInt(a.split('-').slice(-1)[0]);
                    var numB = parseInt(b.split('-').slice(-1)[0]);
                    if (numA < numB) return -1;
                    if (numB < numA) return 1;
                    return 0;
                });
            }

		    void 0;

		    var ePosDev = new epson.ePOSDevice();
		    var copiesPrinted = 0;

		    ePosDev.connect(printerObj.printerIP, null, function (result) {

		    	if (result === 'ERROR_TIMEOUT') {
		    		return callback('Timeout connecting to the printer: ' + (printerObj.printerName || printerObj.printerIP));
		    	}

			    void 0;

			    var deviceId = 'local_printer';
			    var options = {
				    'crypto': true,
				    'buffer': true
			    };

			    void 0;

			    if (result == 'OK' || result == 'SSL_CONNECT_OK') {

				    if (result !== 'SSL_CONNECT_OK') {
					    options.crypto = false;
				    }

				    void 0;

				    //Retrieves the Printer object
				    ePosDev.createDevice(deviceId, ePosDev.DEVICE_TYPE_PRINTER, options,
					    function (deviceObj, errorCode) {
						    if (deviceObj === null) {
							    //Displays an error message if the system fails to retrieve the Printer object
							    void 0;
							    return callback('Print error: No device object');
						    }

						    var printer = deviceObj;

						    //Registers the print complete event
						    printer.onreceive = function (response) {
							    if (response.success) {
								    void 0;

								    copiesPrinted++;

								    if (copiesPrinted >= copies) {

									    ePosDev.deleteDevice(printer, function (err) {
										    // at the end
										    void 0;
										    ePosDev.disconnect();
										    callback();
									    });

									    return;

								    } else {
									    printWorker();
								    }
							    } else {
								    void 0;
								    return callback('Error printing tags');
							    }
						    };

						    void 0;

						    function printWorker() {

							    printer.addTextSmooth(true);

							    printer.addTextStyle(false, false, true, printer.COLOR_1);
							    printer.addTextSize(2, 2);
							    printer.addTextAlign(printer.ALIGN_CENTER);
							    printer.addTextFont(printer.FONT_A);
							    printer.addFeedLine(4);
							    printer.addText(userObj.firstName + ' ' + userObj.lastName.substring(0, 1));
							    printer.addFeedLine(2);
							    printer.addText(userObj.phoneNumber);

                                if (orderObj.deliveryDate) {
                                    var timeString = "";
                                    if (orderObj.fulfillmentMethod === "delivery") {
										timeString = "Delivery Date " + orderObj.deliveryDate
									} else {
										timeString = "Pick Up Date " + orderObj.deliveryDate;
									}

									printer.addTextFont(printer.FONT_B);
								    printer.addTextStyle(false, false, false, printer.COLOR_1);
									printer.addFeedLine(2);
									printer.addText(timeString);
                                }
								
								if (orderObj.deliveryTime) {
									
									var timeString = "";

									if (orderObj.fulfillmentMethod === "delivery") {
										timeString = "Delivery Time " + orderObj.deliveryTime;
									} else {
										timeString = "Pick Up Time " + orderObj.deliveryTime;
									}

									printer.addTextFont(printer.FONT_B);
								    printer.addTextStyle(false, false, false, printer.COLOR_1);
									printer.addFeedLine(3);
									printer.addText(timeString);
								}

							    if (orderObj.deliveryAddress && orderObj.deliveryAddress.street && orderObj.deliveryAddress.city &&
								    orderObj.deliveryAddress.city && orderObj.deliveryAddress.state && orderObj.deliveryAddress.zip) {
									
									printer.addFeedLine(3);
								    printer.addTextFont(printer.FONT_B);
								    printer.addTextStyle(false, false, false, printer.COLOR_1);
								    printer.addText(orderObj.deliveryAddress.street);

								    if (orderObj.deliveryAddress.aptUnit) {
									    printer.addFeedLine(2);
									    printer.addText(orderObj.deliveryAddress.aptUnit);
								    }

								    printer.addFeedLine(2);
								    printer.addText(orderObj.deliveryAddress.city + ', ' + orderObj.deliveryAddress.state + ' ' +
									    orderObj.deliveryAddress.zip);
							    }

							    printer.addFeedLine(3);
							    printer.addTextFont(printer.FONT_A);
							    var bagNumber = copiesPrinted + 1;
                                printer.addText('Bag ' + bagNumber + ' of ' + copies);

                                if (barcodes) {
                                    printer.addFeedLine(3);
                                    printer.addBarcode(
                                        '{B' + barcodes[copiesPrinted],
                                        printer.BARCODE_CODE128,
                                        printer.HRI_BELOW,
                                        printer.FONT_A,
                                        3,      // width - default 3, specifies the width of a single module in dots.
                                        162     // height - default 162, specifies the height of the barcode in dots.
                                    );
                                }

                                if ($scope.admin.adminData.orderDetails.order.containsAlcohol) {
                                    printer.addFeedLine(3);
                                    printer.addText('AGE VERIFICATION REQUIRED');
                                }
							    // printer.addText('Fulfillment Time: ' + orderObj.deliveryTime);
							    printer.addFeedLine(4);
							    printer.addCut(printer.CUT_FEED);

							    void 0;
							    printer.send();
						    }

						    printWorker();
					    });
			    } else {
				    void 0;
				    callback('Error connecting to the printer');
			    }
		    });
	    },
		getFilteredProductDashboard() {
			void 0;

			if (ENV.enablePriceList) {
				var priceList = $rootScope.adminFilterPriceList;
				if (priceList.name === 'AllPriceLists') {
					priceList = $rootScope.authorizedPriceLists[1];
					$rootScope.adminFilterPriceList = $rootScope.authorizedPriceLists[1]
				}
				
				if (priceList) {
			        $scope.admin.selectedPriceList = priceList;
					localStorageService.set('adminSelectedPriceList', priceList);
			    } else {
			    	$scope.admin.selectAdminPricelist();
			    }
		    }
		},
	    initProductManager() {
			void 0;

			if (!$rootScope.authorizedPriceLists) {
				this.initManagerDashboard().then(function() {
					$scope.admin.getFilteredProductDashboard();
				});
			} else {
				this.getFilteredProductDashboard();
			}

	    	
	    },
	    getOrderActions: function (status, row) {
            var statusObj = JSON.parse(JSON.stringify(this.orderStatus[status]));
            switch (row) {
                case 1:
                    delete statusObj['cancelled'];
                    delete statusObj['completed'];
                    delete statusObj['reactivateOrder'];
                    if (($scope.admin.adminData.orderDetails.order.fulfillmentMethod !== 'delivery'
                        || $scope.admin.adminData.orderDetails.order.managedDelivery)
                        && statusObj && statusObj.hasOwnProperty('outForDelivery')) {
                        delete statusObj['outForDelivery'];
                    }
                    $scope.admin.hasOrderActionsTopRow = Object.keys(statusObj).length > 0;
                    break;
                case 2: 
                    delete statusObj['outForDelivery'];
                    delete statusObj['processed'];
                    if ($rootScope.currentUser.isAdminRestricted && !ENV.canRestrictedAdminCancelOrder) {
                        delete statusObj['cancelled'];
                    }
                    if ($rootScope.currentUser.isAdminRestricted && !ENV.canRestrictedAdminCompleteOrder) {
                        delete statusObj['completed'];
                    }
                    if ($rootScope.currentUser.isAdminRestricted) {
                        delete statusObj['reactivateOrder'];
                    }
                    $scope.admin.hasOrderActionsBottomRow = Object.keys(statusObj).length > 0;
                    break;
                default:
                    break;
            }
		    return statusObj;
        },
		shouldShowSelectedOrderActions(order) {
			return Object.keys($scope.admin.getSelectedOrderActions(order)).length > 0;
		},
		getSelectedOrderActions: function (order) {
			var status = order.state === 'Out For Delivery' ? 'OutForDelivery' : order.state;
			var statusObj = JSON.parse(JSON.stringify($scope.admin.orderStatus[status]));
			if ($rootScope.currentUser.isAdminRestricted && !ENV.canRestrictedAdminCancelOrder) {
				delete statusObj['cancelled'];
			}
			if ($rootScope.currentUser.isAdminRestricted && !ENV.canRestrictedAdminCompleteOrder) {
				delete statusObj['completed'];
			}
			if (order.fulfillmentMethod !== 'delivery' || order.managedDelivery) {
				delete statusObj['outForDelivery'];
			}
			// never show reactivate for selected orders
			delete statusObj['reactivateOrder'];

			return statusObj;
		},
	    initManagerDashboard: function () {
			void 0;
			
		    var isAdminLocationSelected = localStorageService.get('adminLocationSelected');
			
			var user;
			if ($rootScope.currentUser) {
				user = $rootScope.currentUser;
			} else {
				user = localStorageService.get('user');
			}
			
			var adminPriceLists;
			if (user.adminPriceLists && Array.isArray(user.adminPriceLists)) {
				adminPriceLists = user.adminPriceLists;
			} else {
				adminPriceLists = [];
			}

			void 0;

			if (isAdminLocationSelected) {
				var location = localStorageService.get('location');
				
				void 0;
				$scope.admin.adminData.allLocations = $rootScope.currentUser.adminLocations;
				$scope.admin.adminData.selectedLocation = location.selectedLocation;
			
				if (ENV.enablePriceList && location.selectedLocation.hasOwnProperty('priceLists')) {

					var defaultPriceList = location.selectedLocation.priceLists.filter(function(pricelist) {
						return pricelist.default === true;
					});
					localStorageService.set('adminSelectedPriceList', defaultPriceList[0]);

					var allPriceLists = location.selectedLocation.priceLists;
					var authorizedPriceLists = globalFunctions.getAuthorizedPriceLists(adminPriceLists, allPriceLists, true);
					void 0;

					$rootScope.adminFilterPriceList = authorizedPriceLists[0];
					$rootScope.authorizedPriceLists = authorizedPriceLists;
				}

			} else if (!$rootScope.ENV.enableLocations && $rootScope.ENV.enablePriceList) {

				return globalFunctions.getSelectedLocation().then(function(selectedLocation) {
					$scope.admin.adminData.allLocations = $rootScope.currentUser.adminLocations;
					$scope.admin.adminData.selectedLocation = selectedLocation;
				
					if (selectedLocation.priceLists) {

						var defaultPriceList = selectedLocation.priceLists.filter(function(pricelist) {
							return pricelist.default === true;
						});
						localStorageService.set('adminSelectedPriceList', defaultPriceList[0]);

						var allPriceLists = selectedLocation.priceLists;
						var authorizedPriceLists = globalFunctions.getAuthorizedPriceLists(adminPriceLists, allPriceLists, true)
						void 0;

						$rootScope.adminFilterPriceList = authorizedPriceLists[0];
						$rootScope.authorizedPriceLists = authorizedPriceLists;
					}
				});
			}
			return $q.resolve(null);
	    },
	    selectAdminLocation: function () {
		    globalFunctions.showAdminLocationsPopup(function (err, success) {
			    if (success) {
				    $route.reload();
			    }
		    });
	    },
	    selectAdminPricelist: function (pageName) {
		    globalFunctions.showAdminPriceListPopup(pageName, function (err, success) {
			    if (success) {
				    $route.reload();
			    }
		    });
	    },
	    showProductPopup: function (product) {
		    var modalClass = '';
		    product.adminAddingItemToOrder = true;

		    if (product.hasImage) {
			    modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
		    } else {
			    modalClass = 'ngdialog-theme-default email-capture';
		    }

		    ngDialog.open({
			    template: 'partials/popup/admin-product-item/admin-product-item-popup.html',
			    controller: 'ModalController',
			    className: modalClass,
			    data: product,
			    scope: $scope
		    });
	    },
	    initUserDashboard: function () {
		    void 0;
		    hsAdmin.getUnapprovedUsers()
			    .then(function (res) {
				    void 0;
				    if (res.status === 200) {
					    $scope.admin.adminData.unapprovedUsers = res.data.users;
				    } else {
					    $scope.admin.adminData.unapprovedUsers = [];
				    }

				    $scope.admin.config.pageFullyLoaded = true;
			    });
	    },
	    approveUser: function (user) {
		    void 0;

		    var data = {
			    targetUser: {
				    emailId: user.email,
				    canPlaceOrder: true
			    }
		    };

		    hsAdmin.approveUser(data)
			    .then(function (res) {
				    if (res.status === 200) {
					    toastr.success("User approved Successfully");
					    $scope.admin.initUserDashboard();
				    } else {
					    toastr.error("Error Approving User");
				    }
			    });
	    },
	    initReportsDashboard() {
	    	if (!ENV.showReports.sales) {
	    		$location.url('/admin/manager-dashboard');
	    		return;
		    }
	    },
		initViewDashboards() {
			if (!$scope.admin.isOrdersDashboardEnabled()) {
				$location.url('/admin/manager-dashboard');
			}
		},
		initLoyaltyDashboards() {
			if (!$scope.admin.showLoyaltyDashboard()) {
				$location.url('/admin/manager-dashboard');
			}
		},
		homesomeEmails: ['@homesome.com', '@gethomesome.com', '@phontabulous.com'],
		isHomesomeAccount: function () {
			var currentUserEmail = $rootScope.currentUser.email;
			for (var email of $scope.admin.homesomeEmails) {
				if (currentUserEmail.endsWith(email)) {
					return true;
				}
			}
			return false;
		},
        isFullAdmin: function () {
			return $rootScope.currentUser.isAdmin && !$rootScope.currentUser.isAdminRestricted;
		},
	    processSalesReportData(dateObj, type) {
		    hsAdmin.getSalesReport(dateObj, type)
			    .then(function(res) {
				    void 0;
				    if (res.status === 200) {
					    void 0;
					    res.data.totalExpenses = res.data.fees + res.data.delivery3rdPartyCost + res.data.refunds
                            + res.data.discount + + res.data.paidWithPoints + res.data.delivery3rdPartyTips;
					    res.data.netEarnings = parseFloat((res.data.grossSales - res.data.totalExpenses).toFixed(2));

					    res.data.breakdownTotal = 0;
					    res.data.breakdownTotalQuantity = 0;

					    var categoryOrder = false;
					    void 0;


					    // ENV.categoryOrder = {};
					    // checking if category Order exist;
					    if (Object.keys(ENV.categoryOrder).length) {
						    categoryOrder = JSON.parse(JSON.stringify(ENV.categoryOrder));
						    void 0;
					    }

					    angular.forEach(res.data.breakdown, function(val, key) {
						    var normalizedKey = $filter('removeSpaces')(key);
						    categoryOrder[normalizedKey] = val;

						    val.category = key;
						    res.data.breakdownTotal += val.total;
						    res.data.breakdownTotalQuantity += val.quantity;
					    });

					    // Fixing total to two decimal points
					    res.data.breakdownTotal = parseFloat(res.data.breakdownTotal.toFixed(2));
					    void 0;

					    // Removing Empty Categories
					    if (categoryOrder) {
						    res.data.breakdown = _.pickBy(categoryOrder);
					    }

					    void 0;

					    // Adding view Details Url for each order and full Name property if name exist
					    if (res.data.orders) {
						    res.data.orders.forEach(function (order) {
							    order.viewDetailsUrl = '/admin/order?orderId=' + encodeURIComponent(order.key) + '&userId='
								    + order.userId + '&backUrl=' + encodeURIComponent($location.url());

							    if (order.userObj) {
								    order.userObj.fullName = order.userObj.firstName + ' ' + order.userObj.lastName;
								    order.fullName = order.userObj.firstName + ' ' + order.userObj.lastName;
							    } else {
								    order.fullName = '-'
							    }
						    });
					    }

						$scope.admin.salesReport.report = res.data;
					    $scope.admin.orderHistory.orders = res.data.orders;
					    $scope.admin.orderHistory.ordersLoaded = true;
				    } else {
					    void 0;
				    }
			    });
	    },
	    updateMonthlySalesReport() {
	    	var date = new Date($scope.admin.orderHistory.startDate.monthlyModel);

	    	$location.search('date', date.getMonth() + 1 + '-' + date.getFullYear());

	    	void 0;
	    	this.initMonthlySales();
	    },
	    initMonthlySales() {
		    $scope.admin.orderHistory.ordersLoaded = false;
		    var dateParam = $location.search().date;
		    var date;
		    var dateModel;
		    var dateObj = {
			    month: 0,
			    year: 0
		    };
		    if (dateParam) {
			    date = dateParam.split('-');

			    dateObj = {
				    month: Number(date[0] - 1),
				    year: Number(date[1])
			    };
			    
			    void 0;

			    dateModel = new Date(date[1], date[0] - 1);
		    } else {
			    void 0;
			    date = new Date();
			    $location.search('date', date.getMonth() + 1 + '-' + date.getFullYear());

			    dateObj = {
				    month: date.getMonth(),
				    year: date.getFullYear()
			    };

			    void 0;

			    dateModel = date;
		    }

		    void 0;

		    this.orderHistory.startDate.monthlyDateOptions.maxDate = new Date();
		    this.orderHistory.startDate.monthlyModel = dateModel;

		    this.processSalesReportData(dateObj, 'monthly');
	    },
	    updateWeeklySalesReport() {
	    	var date = new Date($scope.admin.orderHistory.startDate.weeklyModel);

	    	$location.search('date', date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear());

	    	void 0;
	    	this.initWeeklySales();
	    },
	    initWeeklySales() {
	    	$scope.admin.orderHistory.ordersLoaded = false;
		    var dateParam = $location.search().date;
		    var date;
		    var dateModel;
		    var dateObj = {
		    	day: 0,
		    	month: 0,
		    	year: 0
		    };

		    if (dateParam) {
			    date = dateParam.split('-');
			    dateModel = new Date(date[2], date[0] - 1, date[1]);
			    if (dateModel.getDay() !== 1) {
			    	dateModel = this.getMonday(dateModel);
				    $location.search('date', dateModel.getMonth() + 1 + '-' + dateModel.getDate() + '-' + dateModel.getFullYear());
			    }

			    dateObj = {
				    day: dateModel.getDate(),
				    month: dateModel.getMonth(),
				    year: dateModel.getFullYear()
			    };

			    void 0;
		    } else {
			    date = this.getMonday(new Date());
			    $location.search('date', date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear());

			    dateObj = {
				    day: date.getDate(),
				    month: date.getMonth(),
				    year: date.getFullYear()
			    };
			    
			    void 0;

			    dateModel = date;
		    }
		    
		    void 0;

		    this.orderHistory.startDate.dateOptions.maxDate = new Date();
		    this.orderHistory.startDate.weeklyModel = dateModel;

		    this.processSalesReportData(dateObj, 'weekly');
	    },
	    updateDailySalesReport() {
	    	var date = new Date($scope.admin.orderHistory.startDate.model);

	    	$location.search('date', date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear());

	    	void 0;
	    	this.initDailySales();
	    },
	    initDailySales() {
	    	$scope.admin.orderHistory.ordersLoaded = false;
		    var dateParam = $location.search().date;
		    var date;
		    var dateModel;
		    var dateObj = {
		    	day: 0,
		    	month: 0,
		    	year: 0
		    };
		    if (dateParam) {
			    date = dateParam.split('-');

			    dateObj = {
				    day: Number(date[1]),
				    month: Number(date[0] - 1),
				    year: Number(date[2])
			    };

			    dateModel = new Date(date[2], date[0] - 1, date[1]);
		    } else {
			    void 0;
			    date = new Date();
			    $location.search('date', date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear());

			    dateObj = {
				    day: date.getDate(),
				    month: date.getMonth(),
				    year: date.getFullYear()
			    };

			    void 0;

			    dateModel = date;
		    }

		    void 0;

		    this.orderHistory.startDate.dateOptions.maxDate = new Date();
		    this.orderHistory.startDate.model = dateModel;

		    this.processSalesReportData(dateObj, 'daily');
	    },
	    initProductDashboard: function (pageType) {
		    void 0;
		    var showGridView = $location.search().gridView;
		    if (showGridView) {
		    	$scope.admin.productData.showGridView = showGridView === 'true';
		    } else {
			    $location.search('gridView', this.productData.showGridView.toString());
		    }
            this.getHasMultipleTaxRates();
		    this.getAllProducts(true, false, false, pageType, true);
	    },
		copyProductUrlToClipboard: function(product) {
			globalFunctions.copyProductUrlToClipboard(product, true);
		},
	    initProductDetails: function (product, allProducts, showGridView) {
		    void 0;

			$scope.admin.showGridView = showGridView;

            if (!product || !allProducts) {
                $location.url('/admin/products/all?gridView=true');
            }
            var types = {};
            var subTypes = {};
            var units = {};

            for (var i = 0; i < allProducts.length; i++) {
                types[allProducts[i].type] = allProducts[i].type;
                subTypes[allProducts[i].subType] = allProducts[i].subType;
                units[allProducts[i].unit] = allProducts[i].unit;
            }

            function sort(a, b) {
                var al = a.toLowerCase();
                var bl = b.toLowerCase();
                if (al < bl) return -1;
                if (al > bl) return 1;
                return 0;
            }

            $scope.admin.productData.autocomplete = {
                types: Object.keys(types).sort(sort),
                subTypes: Object.keys(subTypes).sort(sort),
                units: Object.keys(units).sort(sort),
            };
            $scope.admin.productData.product = Object.assign({}, product);
            if (product.type === 'Fruits & Vegetables' && $scope.admin.productData.unitTypes.indexOf(product.unit) !== -1) {
                $scope.admin.productData.unitEditable = true;
            } else {
                $scope.admin.productData.unitEditable = false;
            }

            if(product.hasOwnProperty('isAlcohol')) {
				$scope.admin.productData.product.isAlcohol = product.isAlcohol;
			} else {
				$scope.admin.productData.product.isAlcohol = false;
			}

            if(product.hasOwnProperty('skipScan')) {
				$scope.admin.productData.product.skipScan = product.skipScan;
			} else {
				$scope.admin.productData.product.skipScan = false;
			}

            $scope.admin.productData.product.hasMultipleTaxRates = $rootScope.hasMultipleTaxRates;

            if(product.hasOwnProperty('taxRate')) {
                $scope.admin.productData.product.taxRate = parseFloat(($scope.admin.productData.product.taxRate*100).toFixed(4));
            }

			if (product.hasOwnProperty('posData')) {
				$scope.admin.productData.product.posData = product.posData;
			} else {
				$scope.admin.productData.product.posData = {};
			}

            void 0;
			$scope.admin.config.pageFullyLoaded = true;
			$scope.admin.config.disableIngredientsEdit = true;
			$scope.admin.config.disableMarketingCopyEdit = true;
			$scope.admin.config.disableTaxUpdate = true;
			$scope.admin.getProductFields(product.name)
			.catch(function() {
				toastr.error('Error fetching product information.');
			})
			.finally(function() {
				$scope.admin.originalProductData = {
					product: Object.assign({}, $scope.admin.productData.product)
				}
				$scope.admin.originalProductData.product.availableTimes = product.availableTimes ? [].concat(product.availableTimes) : [];
				$scope.admin.config.disableIngredientsEdit = false;
				$scope.admin.config.disableMarketingCopyEdit = false;
				$scope.admin.config.disableTaxUpdate = false;
			});
			$(function () {
				$('[data-toggle="tooltip"]').tooltip()
			});
		},
		setTaxRate: function() {
			var isTaxable = $scope.admin.productData.product.isTaxable;
			var originalTaxRate = $scope.admin.originalProductData.product.taxRate || 0;
			var location = globalFunctions.getSelectedLocationFromStorage();
			if (!isTaxable) {
				$scope.admin.productData.product.taxRate = 0;
			} else {
				if (originalTaxRate > 0) {
					$scope.admin.productData.product.taxRate = originalTaxRate;
				} else {
					$scope.admin.productData.product.taxRate = parseFloat((location.taxRate*100).toFixed(4));
				}
			}
		},
		attachUploadedFile: function() {
			try {
				var newImage = $scope.admin.productData.uploadedFiles[0];
				document.getElementById('productImage').src = URL.createObjectURL(newImage);
				$scope.admin.productData.updatedProductImage = newImage;
				if ($scope.admin.showGridView) {
					document.getElementById($scope.admin.productData.product.name).src = URL.createObjectURL(newImage);
				}
			} catch (error) {
				toastr.error("Error uploading image. Please try again.");	
			}
			
			$scope.admin.productData.uploadedFiles = null;	
		},
		updateProductImage: function() {
			if ($rootScope.screenWidth.xs) {
				return;
			}

			var uploadImgPopup = document.getElementById("uploadImage");
			
			uploadImgPopup.click();
		},
	    showProductDetails: function (product) {
		    void 0;
		    void 0;
		    $location.url('/admin/products/update?productName=' + product.name + '&backUrl=' + $location.url());
	    },
        getHasMultipleTaxRates: function () {
            globalFunctions.getSelectedLocation().then(function (location) {
                $rootScope.hasMultipleTaxRates = Boolean(location.hasMultipleTaxRates);
            });
        },
		fieldsWithDataSources: [
			'isInStock', 
			'displayName', 
			'brand', 
			'isInactive', 
			'mainImage',
			'type',
			'subType',
			'disclaimer',
			'ingredients',
			'marketingCopy'
		],
		setDataSources: function(newProductData) {
			var originalProductData = $scope.admin.originalProductData.product;
			var fieldsWithDataSources = $scope.admin.fieldsWithDataSources;
			var dataSources = {};
			var userEmail = $rootScope.currentUser.email;

			for (var field of fieldsWithDataSources) {
				if (newProductData.hasOwnProperty(field) && 
						(!originalProductData.hasOwnProperty(field) || newProductData[field] !== originalProductData[field])) {
					dataSources[field] = {
						source: userEmail,
					};
				}
			}
			return dataSources;
		},
	    updateProduct: function (form, closeThisDialog) {
		    if (form.validate()) {
			    $scope.admin.config.buttonLoading = true;
			    var productData = {
				    product: {
					    name: this.productData.product.name,
					    displayName: this.productData.product.displayName,
					    price: parseFloat(this.productData.product.price),
					    organic: this.productData.product.organic,
					    unit: this.productData.product.unit,
					    unitQuantity: this.productData.product.unitQuantity,
                        unitIncrement: this.productData.product.unitIncrement,
					    type: this.productData.product.type,
					    subType: this.productData.product.subType,
					    isInStock: this.productData.product.isInStock,
					    isAlcohol: this.productData.product.isAlcohol,
						skipScan: this.productData.product.skipScan,
					    brand: this.productData.product.brand,
					    ingredients: this.productData.product.ingredients,
						marketingCopy: this.productData.product.marketingCopy,
					    disclaimer: this.productData.product.disclaimer,
					    minQuantity: parseFloat(this.productData.product.minQuantity),
					    maxQuantity: parseFloat(this.productData.product.maxQuantity),
                        isTaxable: this.productData.product.isTaxable,
                        taxRate: parseFloat((this.productData.product.taxRate/100).toFixed(6)),
                        isPickupOnly: this.productData.product.isPickupOnly,
                        upc: this.productData.product.upc,
                        isInactive: this.productData.product.isInactive,
                        isTableSideOnly: this.productData.product.isTableSideOnly,
                        sellByQty: this.productData.product.sellByQty,
						useSyndigoData: this.productData.product.useSyndigoData,
						ebtSnapEligible: this.productData.product.ebtSnapEligible,
                        bottleFee: parseFloat(this.productData.product.bottleFee),
						sortOrderCustom: this.parseSortOrderCustomValue(this.productData.product.sortOrderCustom),
						posData: this.productData.product.posData,
						additionalDeliveryFee: parseFloat(this.productData.product.additionalDeliveryFee)
				    }
			    };

                if (this.productData.isAvailableAllTimes) {
                    productData.product.availableTimes = [];
                } else {
                    productData.product.availableTimes = this.productData.product.availableTimes;
                }

                if (this.productData.product.sellByQty) {
                    productData.product.avgWeight = this.productData.product.avgWeight;
                }

				if (this.productData.product.hasOwnProperty('isAutoAdded') && this.productData.product.isAutoAdded) {
					productData.product.wasReviewed = true;
				}

				if ($scope.admin.productData.updatedProductImage) {

					var imageFormData = new FormData();
					imageFormData.append('file', $scope.admin.productData.updatedProductImage);
					imageFormData.append('productName', $scope.admin.productData.product.name);
					var error = false;

					hsAdmin.updateProductImage(imageFormData)
						.then(function (response) {
							if (response.status === 200) {
								productData.product.mainImage = response.data.mainImage;
								productData.product.dataSources = $scope.admin.setDataSources(productData.product);
								return hsAdmin.updateProduct(productData)
									.then(function (response) {
										if (response.status === 200) {
											toastr.success('Product updated successfully. It may take a few minutes for the changes to apply.');

											$scope.admin.syncProductPopup.dataToPropagate = JSON.parse(JSON.stringify(productData));
											$scope.admin.syncProductPopup.openPopupOrContinue(closeThisDialog);

											if (productData.product.hasOwnProperty('taxRate')) {
												productData.product.taxRate = parseFloat((productData.product.taxRate*100).toFixed(4));
											}
											$scope.admin.originalProductData = {
												product: Object.assign({}, productData.product)
											};
										} else {
											toastr.error('Error updating product.');
											$scope.admin.syncProductPopup.dataToPropagate = null;
											error = true;
										}
									});
							} else if (response.status === 413) {
								toastr.error(hsUtils.getMessageFromError(response.data, 'Image size is too large.'));
							} else {
								if (!error) {
									toastr.error('Error updating product.');
								}
							}
							$scope.admin.config.buttonLoading = false;
						});
				} else {
					var dataSources = $scope.admin.setDataSources(productData.product);
					if (Object.keys(dataSources).length) {
						productData.product.dataSources = dataSources;
					}
					hsAdmin.updateProduct(productData)
				    .then(function (response) {
					    void 0;
					    if (response.status === 200) {
						    toastr.success('Product updated successfully.');

							$scope.admin.syncProductPopup.dataToPropagate = JSON.parse(JSON.stringify(productData));
							$scope.admin.syncProductPopup.openPopupOrContinue(closeThisDialog);

							if (productData.product.hasOwnProperty('taxRate')) {
								productData.product.taxRate = parseFloat((productData.product.taxRate*100).toFixed(4));
							}
							$scope.admin.originalProductData = {
								product: Object.assign({}, productData.product)
							};
					    } else {
						    toastr.error('Error updating product.');
							$scope.admin.syncProductPopup.dataToPropagate = null;
					    }

					    $scope.admin.config.buttonLoading = false;
				    });
				}
		    }
	    },
		parseSortOrderCustomValue: function (val) {
			if (!hsUtils.isNonEmptyString(val)) {
				return null;
			}
			return parseInt(val);
		},
		condenseProductData: function (product) {
			var condensedObj = globalFunctions.intersectObjects($scope.admin.originalProductData.product, product);
			if (condensedObj.availableTimes) {
				if (!$scope.admin.productData.hasAvailableTimesChanged(condensedObj.availableTimes)) {
					delete condensedObj.availableTimes;
				}
			}
			condensedObj.name = product.name;
			$scope.admin.sanitizeSyncProductData(condensedObj);
			return condensedObj;
		},
		sanitizeSyncProductData: function(productData) {
			var numberKeys = ["price", "minQuantity", "maxQuantity", "taxRate", "bottleFee"];
			Object.keys(productData).forEach(function(key) {
				if (numberKeys.includes(key)) {
					if (key === "taxRate") {
						productData[key] = parseFloat((productData[key]/100).toFixed(6));
					} else {
						productData[key] = parseFloat(productData[key]);
					}
				}
			});
		},
	    calculateProductPrice: function (priceObj) {
		    return hsCart.calculateProductPrice(priceObj);
	    },
	    calculatePricePerQuantity: function (priceObj, perWord) {
		    return hsCart.calculatePricePerQuantity(priceObj, perWord);
	    },
	    calculateUnitQuantity: function (priceObj) {
		    return hsCart.calculateUnitQuantity(priceObj);
	    },
	    getOrderBtnClass: function (key) {
		    switch (key) {
			    case 'All':
				    return 'btn-primary';
			    case 'Received':
				    return 'btn-info';
			    case 'Processed':
				    return 'btn-warning';
			    case 'OutForDelivery':
				    return 'btn-info';
			    case 'Completed':
				    return 'btn-tertiary';
			    case 'NotPacked':
				    return 'btn-secondary';
			    case 'Cancelled':
				    return 'btn-danger';
			    default:
				    return 'btn-primary';
		    }
	    },
	    showOrderType: function (key) {
		    switch (key) {
			    case 'All':
				    return true;
			    case 'Received':
				    return true;
			    case 'Processed':
				    return true;
			    case 'OutForDelivery':
				    return true;
			    case 'Completed':
				    return ENV.enableOrderDate ? true : false;
			    case 'NotPacked':
				    return ENV.isRestaurant ? false : true;
			    case 'Cancelled':
				    return ENV.isRestaurant ? true : false;
			    default:
				    return false;
		    }
	    },
	    updateCreditCard: function (form) {
		    $scope.admin.config.updateCCError = '';
		    if (form.validate()) {
			    void 0;
			    $scope.admin.config.updateCCButtonLoading = true;

			    var exp = form.ccExpiry.$modelValue;
			    var ccData = {
				    ccNumber: form.ccNumber.$modelValue,
				    expMonth: exp.month,
				    expYear: exp.year,
				    cvc: form.ccCvc.$modelValue
			    };

			    if (ccData.expYear < 2000) {
				    ccData.expYear = ccData.expYear + 2000;
			    }

			    Stripe.card.createToken({
				    number: ccData.ccNumber,
				    cvc: ccData.cvc,
				    exp_month: ccData.expMonth,
				    exp_year: ccData.expYear
			    }, function (status, res) {
				    void 0;
				    void 0;
				    if (res.error) {
					    toastr.error('Error validating Payment Method.');
					    $scope.admin.config.updateCCError = "Something went wrong validating your payment method. Please try again";
					    $scope.admin.config.updateCCButtonLoading = false;
				    } else {

					    var ccObj = {
						    user: hsAuth.getUserAuthObj(),
						    paymentMethod: {
							    token: res.id,
							    cardLast4: res.card.last4,
							    cardBrand: res.card.brand
						    }
					    };

					    hsCart.addCreditCard(ccObj)
						    .then(function (response) {
							    void 0;
							    if (response.status === 200) {
								    $scope.admin.toggleUpdateCC();
								    $scope.admin.config.updateCCButtonLoading = false;
								    toastr.success('Payment Method Updated Successfully.');
								    $scope.admin.syncCart(true);
							    } else {
								    toastr.success('Error validating your payment method.');
								    $scope.admin.config.updateCCError = "Something went wrong validating your payment method. Please try again";
								    $scope.admin.config.updateCCButtonLoading = false;
							    }
						    });
				    }
			    });
		    }
	    },
	    updateAddress: function (form, address) {
		    $scope.admin.config.updateAddressError = '';
            $scope.$broadcast('validateAddress-admin-order-details-update-address', function(isValid) {
                if (!isValid) {
                    return;
                }

			    void 0;
			    $scope.admin.config.updateAddressButtonLoading = true;

			   var addressObj = {
				    order: {
					    key             : $scope.admin.adminData.orderDetails.order.key,
					    deliveryAddress : {
						    street: address.street,
						    aptUnit: address.aptUnit,
						    city: address.city,
						    state: address.state,
						    zip: address.zip
					    }
				    }
			    };

			   void 0;

			    hsAdmin.updateOrderAddress(addressObj)
				    .then(function (response) {
					    void 0;
					    if (response.status === 200) {
						    $scope.admin.toggleUpdateAddress();
						    $scope.admin.config.updateAddressButtonLoading = false;
						    $scope.admin.initOrderDetails();
						    toastr.success('Address Updated Successfully');
					    } else if (response.status === 403) {
						    toastr.error('Error Updating Address');
						    $scope.admin.config.updateAddressError = "Cannot change address at the moment. Please try again later.";
						    $scope.admin.config.updateAddressButtonLoading = false;
					    } else {
						    toastr.error('Error Updating Address');
						    $scope.admin.config.updateAddressError = "Something went wrong updating your address. Please try again";
						    $scope.admin.config.updateAddressButtonLoading = false;
					    }
				    });

            });
	    },
	    togglePackingPreview: function () {
		    $scope.admin.config.showPackingPreview = !$scope.admin.config.showPackingPreview;

		    if ($scope.admin.config.showPackingPreview) {
			    if (ENV.assignPackerDriver && !$scope.admin.adminData.orderDetails.order.packer) {
				    $scope.admin.adminData.showPackerPopup(false);
			    }
			    
			    $scope.admin.config.showChangeLog = false;
		    }

		    this.adminData.orderDetails.order.items.map(function (item) {
			    item.showUpdateQuantityBtn = false;
		    });
	    },
	    navigateToOrderDashboard: function (key, date, isUpdating, isTodayDashboard) {
	    	this.orderManager.selectAllOrders = false;
		    if (isTodayDashboard) {
			    var todayDate = new Date();
			    var todayDateString = (todayDate.getMonth() + 1) + '-' + todayDate.getDate() + '-' + todayDate.getFullYear();

			    var url = '/admin/dashboard/orders?date=' + todayDateString + '&orderStatus=' + key;
			    $location.url(url);
		    } else if (isUpdating) {
			    $location.search({
				    'date': date,
				    'orderStatus': key
			    });
			    $scope.admin.initOrderDashboard();
		    } else {
			    var url = '/admin/dashboard/orders?date=' + date + '&orderStatus=' + key;
			    $location.url(url);
		    }
	    },
	    markAllAsComplete: function () {
		    void 0;
		    var orderStatusToMarkAsComplete = ["Received"];

		    $scope.bulkUpdateSuccess = true;
		    orderStatusToMarkAsComplete.forEach(function (orderStatus) {
			    var orderDetailsCollection = $scope.admin.adminData.orders[orderStatus];
			    orderDetailsCollection.forEach(function (orderDetails) {
				    $scope.admin.updateOrderStatus(orderDetails, "Completed", true);
			    })
		    });
		    ngDialog.close();
		    if (!$scope.bulkUpdateSuccess) {
			    toastr.error('Error updating bulk order');
		    } else {
			    toastr.success('Bulk update sucessful');
			    //TODO: This is a big hack to just show that all orders have been updated and reflect the counter accordingly. Here are steps to fix:
			    //1. use callbacks for update order.
			    //2. ensure the callbacks are retroactively used everywhere else.
			    //3. remove the interval viewContentLoaded code, execute code using init methods and not viewContentLoaded with a setinterval timeout.
			    $scope.admin.adminData.orders["Completed"] = $scope.admin.adminData.orders["All"];
			    $scope.admin.adminData.orders["Received"] = [];
			    $scope.admin.adminData.orders["NotPacked"] = [];
			    $scope.admin.adminData.orders["Processed"] = [];
		    }

	    },
	    updateOrderStatus: function (order, orderStatus, bulkUpdate, isQuickAction) {
		    void 0;
            if (orderStatus === 'Reactivate Order') {
                $scope.admin.reactivateOrder(order);
            } else if (orderStatus === 'Cancelled') {
			    return ngDialog.openConfirm({
				    data: {
					    heading: 'Confirm order cancellation',
					    subHeading: 'Are you sure you want to cancel this order?',
					    confirmBtnText: 'Confirm',
					    cancelBtnText: 'Cancel'
				    },
				    template: 'partials/popup/confirm-popup.html'
			    }).then(function (confirm) {
				    void 0;
				    order.loading = true;

				    var postData = {
					    order: {
						    key: order.key,
						    status: orderStatus
					    }
				    };

				    return hsAdmin.updateOrderStatus(postData)
					    .then(function (response) {
						    void 0;
						    if (response.status === 200) {
                                toastr.success('Updated order status successfully');
                                $scope.admin.processOrderData(response.data, isQuickAction);
                            } else if (response.status === 402) {
                                $scope.admin.forceOrderCancellation(order, orderStatus, bulkUpdate);
                            } else if (response.status === 403) {
                                toastr.error('Order cannot be cancelled anymore');
                            } else {
                                toastr.error('Error updating order status');
                            }

                            order.loading = false;
                            order.showUpdateStatusBtn = false;
                            return response;
                        });
			    }, function (reject) {
				    void 0;
				    return;
			    });
		    } else {
			    order.loading = true;

			    var postData = {
				    order: {
					    key: order.key,
					    status: orderStatus
				    }
			    };
                return $scope.admin.doesProcessedOrderRequirePacking()
                    .then(function(requiresPacking) {
                        if (requiresPacking && !order.packed) {
                            throw new Error('Order needs to be packed before status can be changed.');
                        }
                        return hsAdmin.updateOrderStatus(postData)
                    })
				    .then(function (response) {
					    void 0;
					    if (response.status === 200) {
						    order.showUpdateStatusBtn = false;
                            $scope.admin.showActionMenu = false;

						    if (!bulkUpdate) {
							    toastr.success('Updated order status successfully');
                                $scope.admin.processOrderData(response.data, isQuickAction);
						    }
					    } else {
						    if (!bulkUpdate) {
							    order.showUpdateStatusBtn = false;
                                toastr.error('Error updating order status');
						    }
						    if (bulkUpdate) {
							    $scope.bulkUpdateSuccess = false;
                            }
					    }
                        return response;
				    })
                    .catch(function(err) {
                        void 0;
                        if (err.message) {
                            toastr.error(err.message);
                        }
                    })
                    .finally(function() {
                        order.loading = false;
                    });
		    }
	    },
		updateFilteredOrderStatus: function (order, newStatus, orderFilterType) {
			return $scope.admin.updateOrderStatus(order, newStatus, null, true)
				.then(function (response) {
					if (!response) {
						if (newStatus !== 'Cancelled') {
							// toast error only needed when order type is not canceled
							toastr.error('Error updating order status');
						}
						return;
					} 
					
					if (response.status === 200) {

						// multiple "original order" lists exist for today/history so we need to use the correct one
						var originalOrderList;
						if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.TODAY) {
							originalOrderList = $scope.admin.filterOrders.originalOrders;
						} else if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.HISTORY) {
							originalOrderList = $scope.admin.filterOrders.originalHistoryOrders;
						} else {
							void 0;
							toastr.error('Error updating order, please refresh the page');
							return;
						}

						var originalOrder = originalOrderList.find(function (originalOrder) {
							return originalOrder.id === order.id;
						});
						var previousStatus = originalOrder.state;
						originalOrder.state = response.data.state;

						// need to update orderStatus and orderStatusList so filter tools are updated appropriately
						if(!$scope.admin.filterOrders.orderStatusList.includes(newStatus)) {
							$scope.admin.filterOrders.orderStatusList.push(newStatus);
						}

						var prevStatusOrderCount = $scope.admin.filterOrders.getOriginalOrdersStatusCount(previousStatus, orderFilterType);

						if (prevStatusOrderCount === 0) {
							$scope.admin.filterOrders.orderStatus = 'All';
							var prevStatusIndex = $scope.admin.filterOrders.orderStatusList.indexOf(previousStatus);
							if (prevStatusIndex !== -1) {
								$scope.admin.filterOrders.orderStatusList.splice(prevStatusIndex, 1);
							}
						}
						
						if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.TODAY) {
							// need to update adminData.orders so buttons on top of today page reflect updates
							// (not necessary when updating HISTORY)
							var cleanedPrevStatus = previousStatus.replace(/\s/g, '');
							var cleanedNewStatus = newStatus.replace(/\s/g, '');
	
							var adminDataOrderIndex = $scope.admin.adminData.orders[cleanedPrevStatus].findIndex(function(adminDataOrder) {
								return adminDataOrder.id === order.id;
							});

							if (adminDataOrderIndex !== -1) {
								var oldOrder = $scope.admin.adminData.orders[cleanedPrevStatus].splice(adminDataOrderIndex, 1);
								oldOrder.state = response.data.state;
								$scope.admin.adminData.orders[cleanedNewStatus].push(oldOrder);
							}
						}
					
						// need to call filterOrders()/filterHistoryOrders() so filtered order list is updated
						if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.TODAY) {
							$scope.admin.filterOrders.filterOrders();
						} else if (orderFilterType === $scope.admin.filterOrders.orderFilterTypes.HISTORY) {
							$scope.admin.filterOrders.filterHistoryOrders();
						} else {
							void 0;
							toastr.error('Error updating order, please refresh the page');
							return;
						}

						return;
					}

				}).catch(function (err) {
					void 0;
					if (err.message) {
						toastr.error(err.message);
					}
				});
		},
        reactivateOrder: function (order) {
            if (order.amountChargedEbtSnap) {
                return ngDialog.openConfirm({
                    data: {
                        heading: 'EBT Order',
                        subHeading: 'This order was paid with EBT, and can not be reactivated.',
                        confirmBtnText: 'Ok',
                    },
                    template: 'partials/popup/confirm-popup.html',
                });
            }
            var confirmData = {};
            if (order.state === 'Completed') {
                confirmData = {
                    heading: 'Confirm',
                    subHeading:
                        'This will open the order, make it editable.  ' +
                        'Current credit card charge will be fully refunded and ' +
                        'a new authorization will be placed on customer credit ' +
                        'card. You will need to process the order and complete it ' +
                        'as usual in order to charge the customer. Please Confirm if you ' +
                        'would like to proceed.',
                };
            } else {
                confirmData = {
                    heading: 'Confirm',
                    subHeading:
                        'This will open the order again, make it editable. ' +
                        'A new authorization will be placed on customer credit ' +
                        'card. You will need to process the order and complete it ' +
                        'as usual in order to charge the customer. Please Confirm if you ' +
                        'would like to proceed.',
                };
            }
            ngDialog
                .openConfirm({
                    data: {
                        heading: confirmData.heading,
                        subHeading: confirmData.subHeading,
                        confirmBtnText: 'Confirm',
                        cancelBtnText: 'Cancel',
                    },
                    template: 'partials/popup/confirm-popup.html',
                })
                .then(
                    function (confirm) {
                        order.loading = true;

                        var postData = {
                            order: {
                                key: order.key,
                                status: 'Reactivate Order',
                            },
                        };

                        return hsAdmin.updateOrderStatus(postData).then(function (response) {
                            void 0;
                            if (response.status === 200) {
                                order.loading = false;
                                order.showUpdateStatusBtn = false;
								delete $scope.admin.config.hasRenderedPackingCompletedFlowDialog;
                                toastr.success('Updated order status successfully');
                                $scope.admin.processOrderData(response.data);
                            } else {
                                order.loading = false;
                                order.showUpdateStatusBtn = false;
                                toastr.error('Error updating order status');
                            }
                            return response;
                        });
                    }
                ).catch(function (reject) {
                    void 0;
                    return;
                });
        },
	    forceOrderCancellation: function (order, orderStatus, bulkUpdate) {
		    ngDialog.openConfirm({
			    data: {
				    heading: 'The delivery rep is on the way to pick up the order. Cancellation Fees will apply to the customer credit card.',
				    subHeading: 'Would you like to proceed with cancellation?',
				    confirmBtnText: 'Yes',
				    cancelBtnText: 'No'
			    },
			    template: 'partials/popup/confirm-popup.html'
		    }).then(function (confirm) {
			    var postData = {
				    order: {
					    key: order.key,
					    status: orderStatus,
					    force: true,
				    }
			    };

			    hsAdmin.updateOrderStatus(postData)
				    .then(function (response) {
					    if (response.status === 200) {
						    toastr.success('Updated order status successfully');
						    $scope.admin.initOrderDetails();
					    } else if (response.status === 402) {
						    $scope.admin.forceOrderCancellation(order, orderStatus, bulkUpdate);
					    } else if (response.status === 403) {
						    toastr.error('Order cannot be cancelled anymore');
					    } else {
						    toastr.error('Error updating order status');
					    }

					    order.loading = false;
					    order.showUpdateStatusBtn = false;
				    });
		    }, function (reject) {
			    void 0;
			    return;
		    });
	    },
	    updateOrdersByDateRange: function (dateType) {
		    switch (dateType) {
			    case 'startDate' :
				    var startDateObj = new Date($scope.admin.orderHistory.startDate.model);
				    var date = startDateObj.getMonth() + 1 + '-' + startDateObj.getDate() + '-' + startDateObj.getFullYear();
				    $scope.admin.orderHistory.endDate.dateOptions.minDate = startDateObj;

				    if (startDateObj > $scope.admin.orderHistory.endDate.model) {
					    $scope.admin.orderHistory.endDate.model = startDateObj;
					    $location.search('endDate', date);
				    }

				    $location.search('startDate', date);
				    break;
			    case 'endDate' :
				    void 0;
				    var endDateObj = new Date($scope.admin.orderHistory.endDate.model);
				    var date = endDateObj.getMonth() + 1 + '-' + endDateObj.getDate() + '-' + endDateObj.getFullYear();
				    $location.search('endDate', date);
				    break;
		    }

		    // this.initOrderHistoryDashboard();
	    },
		setFilterOrders: function(ordersArray, timeSlots) {
			$scope.admin.filterOrders.originalHistoryOrders = ordersArray;
			$scope.admin.filterOrders.timeSlots = ['All'].concat(timeSlots.sort());
			$scope.admin.filterOrders.filterHistoryOrders();

			$scope.admin.adminData.tableParams = new NgTableParams({
				count: globalFunctions.ngTableConfig.count
			}, {
				counts: globalFunctions.ngTableConfig.counts,
				dataset: ordersArray
			});
		},
		setOrderDetailsView: function (order, timeSlots) {
			order.viewDetailsUrl = '/admin/order?orderId=' + encodeURIComponent(order.key) + '&userId='
				+ order.userId + '&backUrl=' + encodeURIComponent($location.url());

			if (order.userData) {
				order.userData.fullName = order.userData.firstName + ' ' + order.userData.lastName;
				order.phone = order.userData.phoneNumber;
				order.fullName = order.userData.firstName + ' ' + order.userData.lastName;
				order.email = order.userData.email;
			} else {
				order.fullName = '';
				order.phone = '';
				order.email = '';
			}

			if (!timeSlots.includes(order.deliveryTime)) {
				timeSlots.push(order.deliveryTime);
			}

			if (!$scope.admin.filterOrders.orderStatusList.includes(order.state)) {
				$scope.admin.filterOrders.orderStatusList.push(order.state);
			}

			if (!$scope.admin.filterOrders.packingStatusList.includes(order.packingStatus)) {
				$scope.admin.filterOrders.packingStatusList.push(order.packingStatus);
			}

			if (order.hasOwnProperty('packer')) {
				order.packerName = order.packer.fullName;
			} else {
				order.packerName = '-';
			}
			if (order.hasOwnProperty('driver')) {
				order.driverName = order.driver.fullName;
			} else {
				order.driverName = '-';
			}

			if (order.deliveryAddress) {
				order.fullAddress = order.deliveryAddress.street;
				order.fullAddress += order.deliveryAddress.aptUnit ? ', ' + order.deliveryAddress.aptUnit + ', ' : ', ';
				order.fullAddress += order.deliveryAddress.city + ', ';
				order.fullAddress += order.deliveryAddress.state + ', ';
				order.fullAddress += order.deliveryAddress.zip;
			}
		},
		getFilteredOrderHistory: function(dateObj, priceListDetails) {
			void 0;
			void 0;

			var getOrderHistoryList = hsAdmin.getOrderHistoryList(dateObj, priceListDetails);
			var getLocations = hsApi.getLocationsV2();

			$q.all([getOrderHistoryList, getLocations])
				.then(function(responses) {
					var orderHistoryResponse = responses[0];
					var locationsResponse = responses[1];

					if (orderHistoryResponse.status === 200) {

						var timeSlots = [];
						orderHistoryResponse.data.orders.forEach(function (order) {
							$scope.admin.setOrderDetailsView(order, timeSlots);
						});
						$scope.admin.orderTimeSlots = timeSlots;
						var onHoldTimeSlots = [];
						orderHistoryResponse.data.onHoldOrders.forEach(function (order) {
							$scope.admin.setOrderDetailsView(order, onHoldTimeSlots);
						});
						$scope.admin.onHoldOrderTimeSlots = onHoldTimeSlots;

						$scope.admin.adminData.export.fileName = $scope.admin.getCsvFileName('orders_', dateObj);
						$scope.admin.adminData.exportItems.fileName = $scope.admin.getCsvFileName('ordersItems_', dateObj);

						$scope.admin.orderHistory.orders = orderHistoryResponse.data.orders;
						
						for (var order of $scope.admin.orderHistory.orders) {
							order.userObj = order.userObj || order.userData;
							order.sortedItems = globalFunctions.filterProductsByCategory(order.items);
							if (hsUtils.isNonEmptyArray(locationsResponse)) {
								locationsResponse.forEach(function(location) {
									if (location.uniqueName === order.location) {
										order.locationObj = location;
									}
								});
							}
						}

						$scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.orders.slice(0, 20);
						$scope.admin.orderHistory.aggregatedData = orderHistoryResponse.data.aggregateData;
						$scope.admin.orderHistory.onHoldOrders = orderHistoryResponse.data.onHoldOrders;
						for (var order of $scope.admin.orderHistory.onHoldOrders) {
							order.userObj = order.userObj || order.userData;
							order.sortedItems = globalFunctions.filterProductsByCategory(order.items);
							if (hsUtils.isNonEmptyArray(locationsResponse)) {
								for (var location of locationsResponse) {
									if (location.uniqueName === order.location) {
										order.locationObj = location;
										break;
									}
								}
							}
						}
						
						$scope.admin.setFilters();

						$scope.admin.orderHistory.ordersLoaded = true;
					} else {
						$scope.admin.orderHistory.selectedOrders = [];
						$scope.admin.orderHistory.orders = [];
						$scope.admin.orderHistory.ordersLoaded = true;
						$scope.admin.orderHistory.onHoldOrders = [];
					}
					$scope.hsConversations = hsConversations;
					$scope.admin.initOrderConversationIndex();
					$scope.admin.adminData.exportItems.orderHistoryItems();
				});
		},
		getCsvFileName: function(prefix, dateObj) {
			var fileName = prefix;
			fileName += (dateObj.startDate.month + 1) + '-' + dateObj.startDate.day + '-' + dateObj.startDate.year + '_';
			fileName += (dateObj.endDate.month + 1) + '-' + dateObj.endDate.day + '-' + dateObj.endDate.year;
			fileName += '.csv';

			return fileName;
		},
	    initOrderHistoryDashboard: function () {

			void 0;

		    this.orderHistory.ordersLoaded = false;
			$scope.admin.adminData.exportItems.pdfReportData = [];
		    var startDateParam = $location.search().startDate;
		    var endDateParam = $location.search().endDate;

		    if (startDateParam && endDateParam) {
			    var startDateObj = startDateParam.split('-');
			    var endDateObj = endDateParam.split('-');

			    var startDate = new Date(startDateObj[2], startDateObj[0] - 1, startDateObj[1]);
			    var endDate = new Date(endDateObj[2], endDateObj[0] - 1, endDateObj[1]);

			    this.orderHistory.startDate.model = startDate;
			    if (startDate > endDate) {
				    $scope.admin.orderHistory.endDate.model = startDate;
				    $location.search('endDate', startDateParam);
			    } else {
				    $scope.admin.orderHistory.endDate.model = endDate;
			    }
			    this.orderHistory.endDate.dateOptions.minDate = startDate;

		    } else {
			    void 0;
			    var date = new Date();
			    date = date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear();

			    $location.search('startDate', date);
			    $location.search('endDate', date);
		    }

		    var dateObj = {
			    startDate: {
				    day: this.orderHistory.startDate.model.getDate(),
				    month: this.orderHistory.startDate.model.getMonth(),
				    year: this.orderHistory.startDate.model.getFullYear()
			    },
			    endDate: {
				    day: this.orderHistory.endDate.model.getDate(),
				    month: this.orderHistory.endDate.model.getMonth(),
				    year: this.orderHistory.endDate.model.getFullYear()
			    }
		    };

			var adminSelectedLocation = localStorageService.get('location');

			var priceListDetails = globalFunctions.getPriceListDetails();

	    	if (ENV.enablePriceList && (adminSelectedLocation || !ENV.enableLocations)) {
			    var adminSelectedPriceList = $rootScope.adminFilterPriceList;
			    if (adminSelectedPriceList) {
					$scope.admin.selectedPriceList = adminSelectedPriceList;
					priceListDetails.filterByPriceList = true;
					priceListDetails.priceList = adminSelectedPriceList.uniqueName;
					$scope.admin.priceListFilterCriteria = priceListDetails;
					this.getFilteredOrderHistory(dateObj, priceListDetails);
			    } else {
					$scope.admin.initManagerDashboard().then(function() {
						$scope.admin.selectedPriceList = $rootScope.adminFilterPriceList;
						priceListDetails.filterByPriceList = true;
						priceListDetails.priceList = $rootScope.adminFilterPriceList.uniqueName;
						$scope.admin.priceListFilterCriteria = priceListDetails;
						$scope.admin.getFilteredOrderHistory(dateObj, priceListDetails);
					});
				}
		    } else {
				this.getFilteredOrderHistory(dateObj, priceListDetails);
			}
	    },
	    toggleOrders: function() {
	        $scope.admin.orderHistory.showOnHoldOrders = !($scope.admin.orderHistory.showOnHoldOrders);
	        $scope.admin.setFilters();
	    },
	    setFilters: function() {
	        if ($scope.admin.orderHistory.showOnHoldOrders) {
	            $scope.admin.setFilterOrders($scope.admin.orderHistory.onHoldOrders, $scope.admin.onHoldOrderTimeSlots);
	            $scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.onHoldOrders.slice(0, 20);
	        } else {
	            $scope.admin.setFilterOrders($scope.admin.orderHistory.orders, $scope.admin.orderTimeSlots);
	            $scope.admin.orderHistory.selectedOrders = $scope.admin.orderHistory.orders.slice(0, 20);
	        }
	    },
	    updateOrdersByDate: function (date, reload) {
		    this.numberOfOrders = false;
		    var selectedDate = new Date(date);
		    var dateObj = {
			    day: selectedDate.getDate(),
			    month: selectedDate.getMonth(),
			    year: selectedDate.getFullYear()
		    };

		    if (reload) {
			    var dateParam = dateObj.month + 1 + '-' + dateObj.day + '-' + dateObj.year;
			    $location.search('date', dateParam);
			    $scope.admin.initOrderDashboard();
		    } else {
			    $scope.admin.getDashboardItems(dateObj);
		    }
	    },
	    viewOrderDetails: function (order) {
		    $location.url('/admin/order?orderId=' + encodeURIComponent(order.key) + '&userId='
			    + order.userId + '&backUrl=' + encodeURIComponent($location.url()));
	    },
		getFilteredDashboardItems: function(){
			var adminSelectedLocation = localStorageService.get('location');
			var priceListDetails = globalFunctions.getPriceListDetails()
			
	    	if ($rootScope.ENV.enablePriceList && (adminSelectedLocation || !$rootScope.ENV.enableLocations)) {
				var adminSelectedPriceList = $rootScope.adminFilterPriceList;
			    $scope.admin.selectedPriceList = adminSelectedPriceList;
				$scope.admin.priceListFilterCriteria = priceListDetails;
				priceListDetails.filterByPriceList = true;
				priceListDetails.priceList = adminSelectedPriceList.uniqueName;
			}

		    if ($rootScope.ENV.enableOrderDate) {
			    this.initTodayDashboard(priceListDetails);
		    } else {
			    this.initDashboard();
		    }
		},
	    initDashboardItems: function () {
			void 0;

			if (!$rootScope.adminFilterPriceList) {
				this.initManagerDashboard().then(function() {
					$scope.admin.getFilteredDashboardItems();
				});
			} else {
				$scope.admin.getFilteredDashboardItems();
			}
	    },
	    initTodayDashboard: function (priceListDetails) {
			if (!priceListDetails) {
				priceListDetails = globalFunctions.getPriceListDetails()
			}
            var self = this;
            hsAuth.getUpdatedUser().then(function(resp) {
                var user = resp && resp.data;
                if (user) {
                    localStorageService.set('user', user);
                }
                void 0;
                self.getTodaysOrders(true, priceListDetails);
                $scope.$on('$viewContentLoaded', function (event) {
                    // code that will be executed ...
                    // every time this view is loaded
                    $scope.admin.config.isDashboardPage = true;
                    $rootScope.$on("$routeChangeStart", function (event, next, current) {
                        //..do something  //if you don't want event to bubble up
                        $scope.admin.config.isDashboardPage = false;
                    });
                });
            });
	    },
	    getTodaysOrders: function (isDashboardPage, priceListDetails) {
			if (!priceListDetails) {
				priceListDetails = globalFunctions.getPriceListDetails()
			}
			var getOrderList = hsAdmin.getOrderList(null, true, priceListDetails);
			var getLocations = hsApi.getLocationsV2();

			$q.all([getOrderList, getLocations])
			    .then(function (responses) {
					var orderListResponse = responses[0];
					var locationsResponse = responses[1];

				    switch (orderListResponse.status) {
					    case 200:
						    var orders = {
							    All: [],
							    Received: [],
							    InProgress: [],
							    NotPacked: [],
							    Processed: [],
							    OutForDelivery: [],
							    Completed: [],
							    Cancelled: [],
							    CompleteAll: []
						    };

						    if ($scope.admin.orderHistory.showOnHoldOrders) {
						        orderListResponse.data.orders = orderListResponse.data.onHoldOrders;
						    }
						    orders.All = orderListResponse.data.orders || [];
						    orderListResponse.data.orders.forEach(function (order) {
							    order.loading = false;
							    order.viewDetailsUrl = '/admin/order?orderId=' + encodeURIComponent(order.key) + '&userId='
								    + order.userId + '&backUrl=' + encodeURIComponent($location.url());
							    order.showUpdateStatusBtn = false;
							    if (!order.fulfillmentMethod) {
								    order.fulfillmentMethod = 'delivery';
							    }

								order.userObj = order.userObj || order.userData;
								order.sortedItems = globalFunctions.filterProductsByCategory(order.items);
								if (hsUtils.isNonEmptyArray(locationsResponse)) {
									locationsResponse.forEach(function(location) {
										if (location.uniqueName === order.location) {
											order.locationObj = location;
										}
									});
								}

							    if (order.userObj) {
								    order.userObj.fullName = order.userObj.firstName + ' '+ order.userObj.lastName;
							    }

							    if ($scope.admin.filterOrders.packingStatusList.indexOf(order.packingStatus) === -1) {
								    $scope.admin.filterOrders.packingStatusList.push(order.packingStatus);
							    }

							    if ($scope.admin.filterOrders.timeSlots.indexOf(order.deliveryTime) === -1) {
								    $scope.admin.filterOrders.timeSlots.push(order.deliveryTime);
							    }

							    if (!order.packed
								    && order.state !== 'Completed'
								    && order.state !== 'Cancelled') {
								    orders.NotPacked.push(order);
							    }

							    orders[order.state.replace(/ /g, '')].push(order);

							    if (order.state !== 'Completed' && order.state !== 'Cancelled'
								    && order.fulfillmentMethod === 'delivery' && order.groupId) {
								    if (!$scope.admin.orderGroups[order.groupId]) {
									    $scope.admin.orderGroups[order.groupId] = false;
								    }
							    }
						    });


						    $scope.admin.adminData.todaysOrders = orders;

						    if (isDashboardPage) {
							    $scope.admin.adminData.orders = orders;
							    $scope.admin.adminData.selectedOrderType = orders[$location.search().orderStatus];

							    if ($location.search().orderStatus) {
								    $scope.admin.filterOrders.originalOrders = orders[$location.search().orderStatus];

								    if ($scope.admin.filterOrders.name
									    || $scope.admin.filterOrders.timeSlot
									    || $scope.admin.filterOrders.packingStatus) {
									    $scope.admin.filterOrders.filterOrders();
								    }
							    }
						    }



						    var numberOfOrdersToday = $scope.admin.adminData.todaysOrders.Received.length;

						    if ($scope.admin.numberOfOrdersToday === false) {
							    $scope.admin.numberOfOrdersToday = numberOfOrdersToday;
						    }

						    if (numberOfOrdersToday > $scope.admin.numberOfOrdersToday) {
							    $scope.admin.playAudioAlert();
							    toastr.success('New Order Received.');
							    $scope.admin.numberOfOrdersToday = numberOfOrdersToday;
						    }

						    $scope.admin.config.pageFullyLoaded = true;
						    break;
					    case 401:
						    hsAuth.logoutUser('/login?redirect=' + $location.path());
						    break;
					    default:
						    $scope.admin.config.pageFullyLoaded = true;
						    break;
				    }
			    })
			    .catch(function (error) {
				    void 0;
				    $scope.admin.config.pageFullyLoaded = true;
				    if (!$rootScope.isInternetEnabled && !$rootScope.showInternetConnectionWarning) {
					    $rootScope.showInternetConnectionWarning = true;
				    }
			    });
	    },
		getFilteredDashboard: function(dateObj, priceListDetails, isUpdating, isOrderDashboard) {
			if ($rootScope.ENV.enableOrderDate) {
			    $scope.$on('$viewContentLoaded', function (event) {
				    // code that will be executed ...
				    // every time this view is loaded

				    $scope.admin.config.isDashboardPage = true;

				    $rootScope.$on("$routeChangeStart", function (event, next, current) {
					    //..do something  //if you don't want event to bubble up
				    });
			    });

			    $scope.admin.getTodaysOrders(true, priceListDetails);
			    $scope.admin.getDashboardItems(dateObj, null, isUpdating, true, false, isOrderDashboard, priceListDetails);

		    } else {
			    $scope.$on('$viewContentLoaded', function (event) {

				    // code that will be executed ...
				    // every time this view is loaded
				    $scope.admin.config.dashboardConfig.dateObj = null;
				    $scope.admin.config.dashboardConfig.orderStatus = null;
				    $scope.admin.config.dashboardConfig.isUpdating = isUpdating;
				    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
				    $scope.admin.config.dashboardConfig.isOrderDetailsPage = false;

				    $rootScope.$on("$routeChangeStart", function (event, next, current) {
					    //..do something  //if you don't want event to bubble up
					    $scope.admin.config.dashboardConfig.dateObj = null;
					    $scope.admin.config.dashboardConfig.orderStatus = null;
					    $scope.admin.config.dashboardConfig.isUpdating = false;
					    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
					    $scope.admin.config.dashboardConfig.isOrderDetailsPage = false;
				    });
			    });

			    $scope.admin.getDashboardItems(dateObj, null, isUpdating, true, false, isOrderDashboard, priceListDetails);
		    }
		},
	    initDashboard: function (isUpdating, isOrderDashboard) {
		    void 0;

			var adminSelectedLocation = localStorageService.get('location');
			var priceListDetails = globalFunctions.getPriceListDetails()

			var selectedDate = new Date(this.datePicker.model);
		    var dateObj = {
			    day: selectedDate.getDate(),
			    month: selectedDate.getMonth(),
			    year: selectedDate.getFullYear()
		    };

			void 0;
		    void 0;

			if (ENV.enablePriceList && (adminSelectedLocation || !ENV.enableLocations)) {
			    var adminSelectedPriceList = $rootScope.adminFilterPriceList;
			    if (adminSelectedPriceList) {
					$scope.admin.selectedPriceList = adminSelectedPriceList;
					$scope.admin.priceListFilterCriteria = priceListDetails;
					priceListDetails.filterByPriceList = true;
					priceListDetails.priceList = adminSelectedPriceList.uniqueName;
					this.getFilteredDashboard(dateObj, priceListDetails, isUpdating, isOrderDashboard);
			    } else {
					$scope.admin.initManagerDashboard().then(function() {
						$scope.admin.selectedPriceList = $rootScope.adminFilterPriceList;
						$scope.admin.priceListFilterCriteria = priceListDetails;
						priceListDetails.filterByPriceList = true;
						priceListDetails.priceList = $rootScope.adminFilterPriceList.uniqueName;
						$scope.admin.getFilteredDashboard(dateObj, priceListDetails, isUpdating, isOrderDashboard);
					});
				}
		    } else {
				this.getFilteredDashboard(dateObj, priceListDetails, isUpdating, isOrderDashboard);
			}
	    },
		getFilteredOrderDashboard (dateObj, priceListDetails, orderStatus) {
			this.datePicker.model = new Date(dateObj.year, dateObj.month, dateObj.day);

		    if ($rootScope.ENV.enableOrderDate) {
			    $scope.$on('$viewContentLoaded', function (event) {
				    // code that will be executed ...
				    // every time this view is loaded
				    var modelDate = new Date($scope.admin.datePicker.model);
				    var modelDateString = JSON.stringify(modelDate.getDate() + '-' + modelDate.getMonth() + '-' + modelDate.getFullYear());

				    var todayDate = new Date();
				    var todayDateString = JSON.stringify(todayDate.getDate() + '-' + todayDate.getMonth() + '-' + todayDate.getFullYear());

				    if (modelDateString === todayDateString) {
					    $scope.admin.config.isDashboardPage = true;
				    } else {
					    $scope.admin.config.isDashboardPage = false;
				    }

				    $rootScope.$on("$routeChangeStart", function (event, next, current) {
					    //..do something  //if you don't want event to bubble up
					    $scope.admin.config.isDashboardPage = false;
				    });
			    });

			    $scope.admin.getDashboardItems(dateObj, orderStatus, false, true, false, true, priceListDetails);

		    } else {
			    $scope.$on('$viewContentLoaded', function (event) {
				    // code that will be executed ...
				    // every time this view is loaded
				    $scope.admin.config.dashboardConfig.dateObj = dateObj;
				    $scope.admin.config.dashboardConfig.orderStatus = orderStatus;
				    $scope.admin.config.dashboardConfig.isUpdating = false;
				    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
				    $scope.admin.config.dashboardConfig.isOrderDetailsPage = false;

				    $rootScope.$on("$routeChangeStart", function (event, next, current) {
					    //..do something  //if you don't want event to bubble up
					    $scope.admin.config.dashboardConfig.dateObj = null;
					    $scope.admin.config.dashboardConfig.orderStatus = null;
					    $scope.admin.config.dashboardConfig.isUpdating = false;
					    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
					    $scope.admin.config.dashboardConfig.isOrderDetailsPage = false;
				    });
			    });

			    $scope.admin.getDashboardItems(dateObj, orderStatus, false, true, false, true, priceListDetails);
		    }

		    $scope.admin.checkFulfillOrderStatus();
			$scope.hsConversations = hsConversations;
			$scope.admin.initOrderConversationIndex();
		},
	    initOrderDashboard: function () {
		    void 0;
			
			$scope.admin.adminData.exportItems.pdfReportData = [];
			var adminSelectedLocation = localStorageService.get('location');
			var priceListDetails = globalFunctions.getPriceListDetails();

			var orderStatus = $location.search().orderStatus;
		    var dateParam = $location.search().date;

		    if (orderStatus && dateParam) {
			    dateParam = dateParam.split('-');
		    } else {
			    $location.url('/admin/dashboard');
		    }

		    var date = new Date(dateParam[2], dateParam[0] - 1, dateParam[1]);

		    var dateObj = {
			    day: date.getDate(),
			    month: date.getMonth(),
			    year: date.getFullYear()
		    };

	    	if (ENV.enablePriceList && (adminSelectedLocation || !ENV.enableLocations)) {
			    var adminSelectedPriceList = $rootScope.adminFilterPriceList;
			    if (adminSelectedPriceList) {
					$scope.admin.selectedPriceList = adminSelectedPriceList;
					$scope.admin.priceListFilterCriteria = priceListDetails;
					priceListDetails.filterByPriceList = true;
					priceListDetails.priceList = adminSelectedPriceList.uniqueName;
					this.getFilteredOrderDashboard(dateObj, priceListDetails, orderStatus);
			    } else {
					$scope.admin.initManagerDashboard().then(function() {
						$scope.admin.selectedPriceList = $rootScope.adminFilterPriceList;
						$scope.admin.priceListFilterCriteria = priceListDetails;
						priceListDetails.filterByPriceList = true;
						priceListDetails.priceList = $rootScope.adminFilterPriceList.uniqueName;
						$scope.admin.getFilteredOrderDashboard(dateObj, priceListDetails, orderStatus);
					});
				}
		    } else {
				this.getFilteredOrderDashboard(dateObj, priceListDetails, orderStatus);
			}
	    },
	    checkFulfillOrderStatus: function () {
		    var fulfillOrderStatusRequest = $http.get(ENV.apiEndPoint + '/location');
		    void 0;
		    $q.all([fulfillOrderStatusRequest])
			    .then(function (response) {
				    void 0;
				    void 0;
				    $scope.admin.adminData.fulfillOrderStatus = response[0].data.canFulfillOrderToday;
			    })
			    .catch(function (response) {
				    void 0;
				    void 0;
			    });
	    },
	    updateCanFulfillOrderToday: function (isPausingOrder) {
		    ngDialog.openConfirm({
			    data: {
				    heading: 'Confirm ' + (isPausingOrder ? 'Pause' : 'Resume') + ' orders',
				    subHeading: 'Are you sure you want to ' + (isPausingOrder ? 'pause' : 'resume') + ' orders?',
				    confirmBtnText: 'Confirm',
				    cancelBtnText: 'Cancel'
			    },
			    template: 'partials/popup/confirm-popup.html'
		    }).then(function (confirm) {
			    void 0;
			    var apiUrl = ENV.apiEndPoint + "/location";

			    //lets get the order status
			    $scope.admin.checkFulfillOrderStatus();
			    var data = {
				    canFulfillOrderToday: !$scope.admin.adminData.fulfillOrderStatus
			    };

			    $http.put(apiUrl, data)
				    .then(function (response) {
					    void 0;
					    if (response.status === 200) {
						    //lets get the order status
						    $scope.admin.adminData.fulfillOrderStatus = !$scope.admin.adminData.fulfillOrderStatus;
						    $scope.admin.checkFulfillOrderStatus();
						    if ($scope.admin.adminData.fulfillOrderStatus) {
							    toastr.success('Online orders are now accepted.');
						    }
						    if (!$scope.admin.adminData.fulfillOrderStatus) {
							    toastr.success('Online orders are no longer accepted.');
						    }

					    } else {
						    void 0;
						    if (isPausingOrder) {
							    toastr.error("Error Pausing the Orders. Please try again.");
						    } else {
							    toastr.error("Error Resuming the Orders. Please try again.");
						    }
					    }
				    });
		    }, function (reject) {
			    void 0;
			    return;
		    });
	    },
	    getDashboardItems: function (dateObj, orderStatus, isUpdating, processNewOrderAlert, isOrderDetailsPage, isOrderDashboard, priceListDetails) {
			
			if (!priceListDetails) {
				priceListDetails = globalFunctions.getPriceListDetails()
			}

		    void 0;
		    void 0;
		    $scope.currentDateSelected = dateObj;
		    void 0;

		    if (!ENV.enableOrderDate) {
			    dateObj = false;
		    }

			var getOrderList = hsAdmin.getOrderList(dateObj, false, priceListDetails);
			var getLocations = hsApi.getLocationsV2();

			$q.all([getOrderList, getLocations])
			    .then(function (responses) {
					var orderListResponse = responses[0];
					var locationsResponse = responses[1];

				    $scope.admin.adminData.orders = {
					    All: [],
					    Received: [],
					    InProgress: [],
					    NotPacked: [],
					    Processed: [],
					    OutForDelivery: [],
					    Completed: [],
					    Cancelled: [],
					    CompleteAll: []
				    };

				    if ($scope.admin.orderHistory.showOnHoldOrders) {
				        orderListResponse.data.orders = orderListResponse.data.onHoldOrders;
				    }
				    var bulkPacking = localStorageService.get('bulkPacking');
				    if (bulkPacking) {
				    	if (bulkPacking.hasOwnProperty('packedItems')) {
				    	    $scope.admin.orderManager.resumeBulkPacking = bulkPacking.packedItems.length > 0;
					    }
				    	orderListResponse.data.orders.forEach(function(order) {
				    		order.checked = bulkPacking.selectedOrders.indexOf(order.key) !== -1;
					    });
				    }

				    orderListResponse.data.orders.forEach(function (order) {
					    if (!bulkPacking) {
						    order.checked = false;
					    }
					    order.loading = false;
					    order.showUpdateStatusBtn = false;
					    order.viewDetailsUrl = '/admin/order?orderId=' + encodeURIComponent(order.key) + '&userId='
						    + order.userId + '&backUrl=' + encodeURIComponent($location.url());
					    if (!order.fulfillmentMethod) {
						    order.fulfillmentMethod = 'delivery';
					    }

						order.userObj = order.userObj || order.userData;
						order.sortedItems = globalFunctions.filterProductsByCategory(order.items);
						if (hsUtils.isNonEmptyArray(locationsResponse)) {
							locationsResponse.forEach(function(location) {
								if (location.uniqueName === order.location) {
									order.locationObj = location;
								}
							});
						}

                        if (order.userObj) {
                            order.userObj.fullName = order.userObj.firstName + ' '+ order.userObj.lastName;
                            order.fullName = order.userObj.firstName + ' '+ order.userObj.lastName;
                            order.phone = order.userObj.phoneNumber;
                            order.email = order.userObj.email;
                            order.items.forEach(function(item) {
                                item.userObj = order.userObj;
                            });
                        } else {
                            order.fullName = '';
                            order.phone = '';
                            order.email = '';
                        }

					    if (!$scope.admin.filterOrders.orderStatusList.includes(order.state)) {
						    $scope.admin.filterOrders.orderStatusList.push(order.state);
					    }

					    if (!$scope.admin.filterOrders.packingStatusList.includes(order.packingStatus)) {
						    $scope.admin.filterOrders.packingStatusList.push(order.packingStatus);
					    }

                        if (order.packer) {
                            if (!$scope.admin.filterOrders.assignedPackersList.includes(order.packer.fullName)) {
                                $scope.admin.filterOrders.assignedPackersList.push(order.packer.fullName);
                            }
                        } else {
                            if (!$scope.admin.filterOrders.assignedPackersList.includes('Not Assigned')) {
                                $scope.admin.filterOrders.assignedPackersList.push('Not Assigned');
                            }
                        }

                        if (order.packer && !$scope.admin.filterOrders.assignedPackersList.includes(order.packer.fullName)) {
                            $scope.admin.filterOrders.assignedPackersList.push(order.packer.fullName);
                        }

					    if (!$scope.admin.filterOrders.timeSlots.includes(order.deliveryTime)) {
						    $scope.admin.filterOrders.timeSlots.push(order.deliveryTime);
					    }

					    if (!order.packed
						    && order.state !== 'Completed'
						    && order.state !== 'Cancelled') {
						    $scope.admin.adminData.orders.NotPacked.push(order);
					    }

					    $scope.admin.adminData.orders[order.state.replace(/ /g, '')].push(order);

					    if (order.state !== 'Completed' && order.state !== 'Cancelled'
						    && order.fulfillmentMethod === 'delivery' && order.groupId) {
						    if (!$scope.admin.orderGroups[order.groupId]) {
							    $scope.admin.orderGroups[order.groupId] = false;
						    }
					    }

                        if (order.deliveryAddress) {
                            order.fullAddress = order.deliveryAddress.street;
                            order.fullAddress += order.deliveryAddress.aptUnit ? ', ' + order.deliveryAddress.aptUnit + ', ': ', ';
                            order.fullAddress += order.deliveryAddress.city + ', ';
                            order.fullAddress += order.deliveryAddress.state + ', ';
                            order.fullAddress += order.deliveryAddress.zip;
                        }
				    });

				    if(isOrderDashboard) {
					    $scope.admin.adminData.export.fileName = 'orders_' + (dateObj.month + 1) + '-' + dateObj.day + '-' + dateObj.year;
					    $scope.admin.adminData.export.fileName += '.csv';
                        void 0;

                        $scope.admin.adminData.exportItems.fileName = 'ordersItems_' + (dateObj.month + 1) + '-' + dateObj.day + '-' + dateObj.year;
					    $scope.admin.adminData.exportItems.fileName += '.csv';
				    }

				    $scope.admin.adminData.orders.All = orderListResponse.data.orders || [];
				    if (processNewOrderAlert) {
					    var numberOfOrders = $scope.admin.adminData.orders.Received.length;

					    if ($scope.admin.numberOfOrders === false) {
						    $scope.admin.numberOfOrders = numberOfOrders;
					    }

					    if (numberOfOrders > $scope.admin.numberOfOrders) {
						    $scope.admin.playAudioAlert();
						    toastr.success('New Order Received.');
						    $scope.admin.numberOfOrders = numberOfOrders;
					    }
				    }

				    $scope.admin.adminData.selectedOrderStatus = orderStatus;
				    $scope.admin.adminData.selectedOrderType = $scope.admin.adminData.orders[orderStatus];

				    if (orderStatus) {
					    $scope.admin.filterOrders.originalOrders = $scope.admin.adminData.orders[orderStatus];
					    if ($scope.admin.filterOrders.name
						    || $scope.admin.filterOrders.timeSlot
						    || $scope.admin.filterOrders.packingStatus) {
						    $scope.admin.filterOrders.filterOrders(true);
					    }
				    }
					$scope.admin.adminData.exportItems.orders();
				    $scope.admin.config.pageFullyLoaded = true;
			    })
			    .catch(function (error) {
				    void 0;
				    $scope.admin.config.pageFullyLoaded = true;
			    })
	    },
	    playAudioAlert: function (dismissAlert) {
		    if (!this.showNewOrderAlert) {
			    $scope.admin.showNewOrderAlert = true;
			    setTimeout(function () {
				    var OrderRing = document.getElementById('alert-sound');
				    OrderRing.src = '../../sounds/new-order.mp3';
				    OrderRing.loop = true;
				    OrderRing.play();
			    }, 0);
		    }

		    if (dismissAlert) {
			    var OrderRing = document.getElementById('alert-sound');
			    OrderRing.loop = false;
			    OrderRing.pause();
			    $scope.admin.showNewOrderAlert = false;
		    }
	    },
	    generateExportCSV: function (orderDetails) {
		    $scope.csvHeaderFields = {
			    "customer": "Customer",
			    "item name": "Line: Item Name",
			    "bill to city": "Bill To City",
			    "bill to country/region": "Bill To Country/Region",
			    "bill to line 1": "Bill To Line 1",
			    "bill to line 2": "Bill To Line 2",
			    "bill to line 3": "Bill To Line 3",
			    "bill to note": "Bill To Note",
			    "bill to state/province": "Bill To State/Province",
			    "bill to zip/postal": "Bill To Zip/Postal",
			    "class name": "Class Name",
			    "currency": "Currency",
			    "customer message": "Customer Message",
			    "due date": "Due Date",
			    "email later": "Email Kater",
			    "exchange rate": "Exchange Rate",
			    "fob": "FOB",
			    "amount": "Line: Amount",
			    "class name2": "Line: Class Name",
			    "description": "Line: Description",
			    "mark as closed": "Line: Mark As Closed",
			    "other 1": "Line: Other 1",
			    "other 2": "Line: Other 2",
			    "price": "Line: Price",
			    "quantity": "Line: Quantity",
			    "sales tax code": "Line: Sales Tax Code",
			    "mark as closed2": "Mark As Closed",
			    "memo": "Memo",
			    "other": "Other",
			    "po number": "PO Number",
			    "print later": "Print Later",
			    "sales order number": "Sales Order Number",
			    "sales rep": "Sales Rep",
			    "sales tax item": "Sales Tax Item",
			    "ship date": "Ship Date",
			    "ship method name": "Ship Method Name",
			    "template name": "Template Name",
			    "terms name": "Terms Name",
			    "transaction date": "Transaction Date",
			    "update sales order": "Update Sales Order"
		    };
		    $q.all([orderDetails])
			    .then(function (response) {
				    // console.log("-------", response[0]["data"],"-----------");
				    // console.log("-------", response[1]["data"],"------------");
				    response[0].data.items.forEach(function (item) {
					    var customerName = response[0]["data"]["userObj"]["firstName"] + " " + response[0]["data"]["userObj"]["lastName"];
					    var itemName = item["displayName"];
					    var city = response[0]["data"]["userObj"]["address"]["city"];
					    var country = "US"; //hardcode.
					    var line1 = response[0]["data"]["userObj"]["address"]["street"];
					    var line2 = response[0]["data"]["userObj"]["address"]["aptUnit"];
					    var state = response[0]["data"]["userObj"]["address"]["state"];
					    var zipcode = response[0]["data"]["userObj"]["address"]["zip"];
					    var className = ""; //hardcode
					    var currency = "USD";
					    var customerMessage = "";
					    var dueDate = ""; //response[0]["data"]["deliveryDate"] + " " + response[0]["data"]["deliveryTime"];
					    var emailLater = true;
					    var exchangeRate = 1;
					    var fob = "";//response[0]["data"]["fulfillmentMethod"];
					    var amount = item["price"];
					    var className2 = "";
					    var description = item["displayName"];
					    var itemMarkAsClosed = true;
					    var other1 = "";
					    var other2 = "";
					    var itemizedPrice = item["itemizedPrice"];
					    var quantity = item["quantity"];
					    var salesTaxCode = "";
					    var transactionMarkAsClosed = true;
					    var memo = "";
					    var other3 = "";
					    var purchaseOrderNumber = "";//response[0]["data"]["number"];
					    var printLater = true;
					    var salesOrderNumber = response[0]["data"]["number"];
					    var salesRep = "online";
					    var salesTaxItem = "";
					    var shipDate = "";
					    var shipMethodName = "";
					    var templateName = "";
					    var termsName = "";
					    var transactionDate = response[0]["data"]["timeCreated"];
					    var updateSalesOrder = true;

					    $scope.csvValueFields.push(
						    {
							    "customer": customerName,
							    "item name": itemName,
							    "bill to city": city,
							    "bill to country/region": country,
							    "bill to line 1": line1,
							    "bill to line 2": line2,
							    "bill to line 3": "",
							    "bill to note": "",
							    "bill to state/province": state,
							    "bill to zip/postal": zipcode,
							    "class name": className,
							    "currency": currency,
							    "customer message": customerMessage,
							    "due date": dueDate,
							    "email later": emailLater,
							    "exchange rate": exchangeRate,
							    "fob": fob,
							    "amount": amount,
							    "class name2": className2,
							    "description": description,
							    "mark as closed": itemMarkAsClosed,
							    "other 1": other1,
							    "other 2": other2,
							    "price": itemizedPrice,
							    "quantity": quantity,
							    "sales tax code": salesTaxCode,
							    "mark as closed2": transactionMarkAsClosed,
							    "memo": memo,
							    "other": other3,
							    "po number": purchaseOrderNumber,
							    "print later": printLater,
							    "sales order number": salesOrderNumber,
							    "sales rep": salesRep,
							    "sales tax item": salesTaxItem,
							    "ship date": shipDate,
							    "ship method name": shipMethodName,
							    "template name": templateName,
							    "terms name": termsName,
							    "transaction date": transactionDate,
							    "update sales order": updateSalesOrder
						    }
					    );

				    });

			    })
			    .catch(function (response) {
				    void 0;
			    });

	    },
	    initOrderDetails: function (update, printOrderTags) {
		    void 0;
		    void 0;
		    var orderId = $location.search().orderId;
		    var userId = $location.search().userId;
		    this.adminData.orderDetails.backUrl = $location.search().backUrl || '/admin/dashboard';
		    void 0;

		    $scope.$on('$viewContentLoaded', function (event) {
			    $document.bind('scroll', function () {
				    var windowTop = $(window).scrollTop() + 10;
				    var selectedDiv = $('#order-details');

				    if (selectedDiv) {
					    var divTop = selectedDiv.offset().top;
					    if (windowTop >= divTop) {
						    $('#order-details-fixed').fadeIn(100);
					    } else if (windowTop < divTop) {
						    $('#order-details-fixed').fadeOut(100);
					    }
				    }
			    });

			    if ($rootScope.ENV.enableOrderDate) {

				    $scope.admin.config.isDashboardPage = false;
				    $scope.admin.getTodaysOrders();

			    } else {
				    var selectedDate = new Date();
				    var dateObj = {
					    day: selectedDate.getDate(),
					    month: selectedDate.getMonth(),
					    year: selectedDate.getFullYear()
				    };

				    void 0;

				    $scope.admin.getDashboardItems(dateObj, null, false, true, true);

				    $scope.admin.config.dashboardConfig.dateObj = null;
				    $scope.admin.config.dashboardConfig.orderStatus = null;
				    $scope.admin.config.dashboardConfig.isUpdating = false;
				    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
				    $scope.admin.config.dashboardConfig.isOrderDetailsPage = true;

				    $rootScope.$on("$routeChangeStart", function (event, next, current) {
					    //..do something  //if you don't want event to bubble up
					    $scope.admin.config.dashboardConfig.dateObj = null;
					    $scope.admin.config.dashboardConfig.orderStatus = null;
					    $scope.admin.config.dashboardConfig.isUpdating = false;
					    $scope.admin.config.dashboardConfig.processNewOrderAlert = true;
					    $scope.admin.config.dashboardConfig.isOrderDetailsPage = false;
				    });
			    }

			});
			
			var itemAddedToOrderEventListener = $rootScope.$on('itemAddedToOrder', function(event, val) {
				event.stopPropagation();
				void 0;
				if (val.type === 'order-updated') {
					$scope.admin.processOrderData(val.data);
				}
			});

		    $scope.$on('$destroy', function () {
				$document.unbind('scroll');
				itemAddedToOrderEventListener();
		    });

		    var getOrderDetails = hsAdmin.getOrderDetails(encodeURIComponent(orderId));
		    var getLocations = hsApi.getLocations();

		    $scope.admin.generateExportCSV(getOrderDetails);

		    $q.all([getOrderDetails, getLocations])
			    .then(function (response) {
                    var orderResp = response[0];
                    var locationResp = response[1];
				    if (orderResp.status === 200) {

						// We don't want to show the chat without having resolved this information.
                        $scope.admin.processOrderData(orderResp.data);
						$q.all([$scope.admin.setAutoSendChatMessage(), $scope.admin.setPackerRequiredForConversation()]).then(function() {
							$scope.admin.setShowChatFlag();
						});

						if (orderResp.data.packed && ENV.enablePackingCompletedFlow) {
							$scope.admin.config.hasRenderedPackingCompletedFlowDialog = true;
						}

					    if (locationResp.status === 200) {
					    	void 0;
						    locationResp.data.forEach(function(location) {
						    	if (location.uniqueName === orderResp.data.location) {
									$scope.admin.adminData.orderDetails.enableCustomFulfillmentTimes =
										$scope.admin.getEnableCustomFullfillmentTimes(
											location,
											orderResp.data
										);
								    orderResp.data.locationObj = location;
							    }
						    });
                        }
                        
					    if (update) {
						    $rootScope.$emit('orderDataUpdated', orderResp.data);
					    }

					    if (printOrderTags) {
					    	$scope.admin.print();
					    }
				    } else {
					    $location.url('/admin/dashboard');
				    }
			    })
			    .catch(function (response) {
				    void 0;
			    });

            if ($scope.admin.allowedToScan() && !window.Dynamsoft) {
                $.getScript('https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.2.5/dist/dbr.js', function() {
                    if (window.Dynamsoft) {
                        Dynamsoft.DBR.BarcodeReader.organizationID = '100578442';
                    }
                });
            }
        },
		getEnableCustomFullfillmentTimes(location, orderData) {
			var value = false;
			if (location && location.priceLists) {
				for (var priceList of location.priceLists) {
					if (priceList.uniqueName === orderData.priceList) {
						value = hsUtils.isBoolean(priceList.enableCustomFulfillmentTimes)
							&& priceList.enableCustomFulfillmentTimes;
						return value;
					}
				}
			}

			return value;
		},
        processOrderData(orderData, skipPackerPopup) {
            if (orderData.userObj) {
                // orderData from initOrderDetails contains this userData obj.
                $scope.admin.adminData.orderDetails.userData = orderData.userObj;
            } else if ($scope.admin.adminData.orderDetails.userData) {
                // Needed since response from PUT /order/item does not include userData obj.
                // Otherwise, will result in user info section on order details not to render correctly
                orderData.userObj = $scope.admin.adminData.orderDetails.userData;
            }
            void 0;

            $scope.admin.changeLogItems = ['All'];
            if (orderData.fulfillmentMethod === 'shipping') {
                orderData.shipments.forEach(function (ship) {
                    ship.printUrl = "javascript: w=window.open(" + ship.labelUrl + "); w.print();";
                });
            }
            orderData.items.forEach(function (item) {
                if (!item.hasOwnProperty('hasImage')) {
                    item.hasImage = true;
                }
                item.isUpdating = false;
                item.showUpdateBtn = false; 
                item.showUpdateQuantityBtn = false;
            });

            orderData.sortedItems = globalFunctions.filterProductsByCategory(orderData.items);

            if ($scope.admin.categoryFilters.length === 0) {
                angular.forEach(orderData.sortedItems, function(val) {
                    val.checked = true;
                });
            }

            orderData.changeLog.forEach(function(item) {
                item.date = new Date(item.time.year, item.time.month, item.time.date, item.time.hours, item.time.minutes);
            });

            angular.forEach(orderData.changeLogItemized, function(val, key) {
                $scope.admin.changeLogItems.push(key);
                val.forEach(function(item) {
                    item.date = new Date(item.time.year, item.time.month, item.time.date, item.time.hours, item.time.minutes);
                });
            });

            orderData.changeLogItemized.All = orderData.changeLog;
            orderData.loading = false;
            orderData.showUpdateStatusBtn = false;
            orderData.showUpdateQuantityBtn = false;

            $scope.admin.adminData.orderDetails.order = orderData;
            $scope.admin.adminData.orderDetails.order.totalQuantity = orderData.items.reduce(function (value, item) {
                return value + item.quantity;
            }, 0);

            var isOrderCompleted = $scope.admin.adminData.orderDetails.order.state === 'Completed';
            var isOrderCancelled = $scope.admin.adminData.orderDetails.order.state === 'Cancelled';
            if (
                $scope.admin.adminData.orderDetails.order.containsAlcohol &&
                !$scope.admin.adminData.orderDetails.order.ageVerification &&
                !$scope.admin.hasSeenAgeVerificationPopup &&
                !isOrderCompleted &&
                !isOrderCancelled
            ) {
                $scope.admin.showAgeVerificationPopup();
            }
            
            if ($rootScope.currentUser.isAdminRestricted && !isOrderCompleted && !isOrderCancelled) {
                if (ENV.assignPackerDriver && !$scope.admin.adminData.orderDetails.order.packer && !$scope.admin.adminData.checkedPacker && !skipPackerPopup) {
                    $scope.admin.config.showPackingPreview = true;
                    $scope.admin.adminData.showPackerPopup(false);
                } else {
                    $scope.admin.config.showPackingPreview = true;
                }
            }
            
            $scope.admin.config.pageFullyLoaded = true;
            $scope.admin.getAllProducts(false, false, orderData);
        },
        hasFailingPreorderStep: function () {
            var preorderSteps = _.get($scope, 'admin.adminData.orderDetails.order.preorderSteps');

            if (!preorderSteps) {
                return false;
            }

            for (var preorderStep of Object.values(preorderSteps)) {
                if (preorderStep === 'Failed') {
                    return true;
                }
            }

            return false;
        },
		hasFailingAdvancedOrderStep: function () {
            var advancedOrderSteps = _.get($scope, 'admin.adminData.orderDetails.order.advancedOrderSteps');

            if (!advancedOrderSteps) {
                return false;
            }

            for (var advancedOrderStep of Object.values(advancedOrderSteps)) {
                if (advancedOrderStep === 'Failed') {
                    return true;
                }
            }

            return false;
        },
        showAgeVerificationPopup() {
            ngDialog.openConfirm({
                showClose: false,
                closeByDocument: false,
                closeByEscape: false,
                data: {
                    heading: 'Age Verification Warning',
                    subHeading: 'The order contains age restricted items. Customer ID verification is pending',
                    confirmBtnText: 'Ok',
                    cancelBtnText: '',
                },
                template: 'partials/popup/confirm-popup.html',
            }).then(function() {
                $scope.admin.hasSeenAgeVerificationPopup = true;
            });
        },
		reloadOrderDetails: function() {
			void 0;
			$scope.admin.config.pageFullyLoaded = false;
			$scope.admin.initOrderDetails();
		},
	    searchProduct: function (query, clear, includeAllItems) {
		    void 0;
		    void 0;
		    if (clear) {
			    $scope.admin.searchedQuery = '';
			    $scope.searchQuery = '';

			    if (query) {
				    if (!$scope.admin.activeTabIndex) {
					    $scope.admin.activeTabIndex = 0;
				    }

				    $scope.admin.productData.categorizedProducts = JSON.parse(JSON.stringify($scope.admin.productData.originalCategorizedProducts));
				    $scope.admin.productData.categorizedProducts.forEach(function (category, idx) {
					    if (idx === $scope.admin.activeTabIndex) {
						    category.loadTab = true;
						    $location.search('category', category.id);

						    setTimeout(function () {
							    document.querySelector('#category-' + category.id + ' a').click();
						    }, 0);
					    } else {
						    category.loadTab = false;
					    }
				    });
                    $scope.admin.filterHelpers.createTable($scope.admin.productData.allProducts);
			    }
		    } else if (query) {
                $scope.searchQuery = query;
                hsSearch.search(query, null, null, false, includeAllItems, true)
                    .then(function(data) {
                        var combinedResults = data.results[0] ? data.results[0] : [];

                        var sortedData = globalFunctions.getSortedProducts(combinedResults);
                        var searchedData = $scope.admin.filterHelpers.getSortedCategories(sortedData.sortedData);
                        $scope.admin.filterHelpers.arrangeTiles(searchedData);
                        $scope.admin.filterHelpers.createTable($scope.admin.productData.allProducts);

                        $scope.admin.productData.categorizedProducts = searchedData;

                        if (searchedData.length) {
                            $scope.admin.activeTabIndex = 0;
                            searchedData[0].loadTab = true;
                            $location.search('category', searchedData[0].id);

                            setTimeout(function () {
                                document.querySelector('#category-' + searchedData[0].id + ' a').click();
                            }, 0);
                        }
                    })
                    .catch(function(err) {
                        void 0;
                    });
		    }
	    },
	    searchItem: function (query) {
		    void 0;
		    $scope.admin.searchedQuery = query;
	    },
	    placeOrder: function (deliveryAddress) {

		    if (!this.config.buttonLoading) {
			    $scope.admin.config.buttonLoading = true;
		    }

		    var orderParams = {
			    user: hsAuth.getUserAuthObj(),
			    delivery: {
				    address: '',
				    date: '',
				    time: '',
				    instructions: '',
				    byDoor: ''
			    }
		    };

		    var user = localStorageService.get('user');

		    if (deliveryAddress) {
			    orderParams.delivery.address =
				    deliveryAddress.street + " " + deliveryAddress.aptUnit + " " + deliveryAddress.city + " " + deliveryAddress.state + " " + deliveryAddress.zip;
		    } else {
			    orderParams.delivery.address = user.address.street + " " + user.address.aptUnit + " " + user.address.city + " " + user.address.state + " " + user.address.zip;
		    }

		    orderParams.delivery.date = $scope.admin.selectedDeliveryDate.dateString;
		    orderParams.delivery.time = $scope.admin.selectedDeliveryTime;
		    orderParams.delivery.instructions = $scope.admin.delivery.instructions;
		    orderParams.delivery.byDoor = $scope.admin.delivery.leaveAtDoor;

		    if ($scope.admin.selectedCoupon.key) {
			    orderParams.coupon = {
				    key: $scope.admin.selectedCoupon.key
			    }
		    }

		    orderParams.tip = parseFloat(this.selectedTip.value);

		    void 0;

		    hsCart.placeOrder(orderParams)
			    .then(function (response) {
				    void 0;
				    if (response.status === 200) {
					    localStorageService.set('orderConfirmed', response.data);
					    $location.url('/cart/checkout/confirm');
					    $scope.admin.config.buttonLoading = false;
				    } else {
					    $scope.admin.config.checkoutError = "Something went wrong. Please try again";
					    $scope.admin.config.buttonLoading = false;
				    }
			    });

	    },
	    selectDeliveryDate: function (dateObj) {
		    $scope.admin.selectedDeliveryDate = dateObj;
		    $scope.admin.deliveryTimes = dateObj.timeSlots;
		    $scope.admin.selectedDeliveryTime = dateObj.timeSlots[0];
	    },
	    showAddCustomItemDialog: function () {
		    $scope.adminCustomDialog = true;
		    $scope.adminData = this.adminData.orderDetails;

		    ngDialog.open({
			    template: 'partials/popup/admin-custom-item-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope
		    });
	    },
        getProductDisplayName(item) {
            return hsCart.getProductDisplayName(item);
        },
        getProductItemizedTotal(item) {
            return hsCart.getProductItemizedTotal(item);
        },
        updateSellByQuantityItemQuantity: function (order, item, index, btnId) {
            var weight = $('#weight-pack-' + btnId + index).val();
            var quantity = $('#quantity-pack-' + btnId + index).val();
            void 0;
            void 0;
            if (!$scope.admin.shouldIgnorePackingQuantityInput(item) && (isNaN(parseFloat(quantity)) || parseFloat(quantity) < item.quantity)) {
                toastr.error('Error updating packed quantity.');
                return Promise.reject(new Error('Error updating packed quantity.'));
            }
            if (!$scope.admin.shouldIgnorePackingWeightInput(item) && (isNaN(parseFloat(weight)) || weight <= 0)) {
                toastr.error('Error updating packed weight.');
                return Promise.reject(new Error('Error updating packed weight.'));
            }

            var orderObj = {
                key: order.key,
                itemName: item.name,
                packedQuantity: parseFloat(quantity),
                packedWeight: parseFloat(weight),
            };

            $scope.admin.scanAndUpdate(item, orderObj);
        },
        allowedToScan() {
            return ENV.enableUpcScanner && ($rootScope.screenWidth.xs || $rootScope.screenWidth.sm);
        },
        canScan(scanner) {
			if (scanner === 'dynamsoft') {
				return window.Dynamsoft && $scope.admin.allowedToScan();
			} else {
				return $scope.admin.allowedToScan();
			}
        },
        shouldScan(item, scanner) {
            var skipScan = item.hasOwnProperty('skipScan') ? item.skipScan : false;
            return !skipScan && $scope.admin.canScan(scanner);
        },
        shouldScanRandomWeightItem(item, scanner) {
            var isRandomWeightBarcode = hsUpc.isRandomWeightProductUpc(item.upc);
            var shouldScan = $scope.admin.shouldScan(item, scanner);
            return shouldScan && isRandomWeightBarcode;
        },
        shouldIgnorePackingWeightInput(item) {
            return $scope.admin.shouldScanRandomWeightItem(item) && (item.sellByQty || item.unit === 'lb');
        },
        shouldIgnorePackingQuantityInput(item) {
            return $scope.admin.shouldScanRandomWeightItem(item);
        },
	    updatePackedItemQuantity: function (order, item, index, btnId) {
		    void 0;
		    var quantity = $('#' + btnId + index).val();
		    void 0;

            var isInvalidWeight = !$scope.admin.shouldIgnorePackingWeightInput(item)
                && (isNaN(parseFloat(quantity)) || parseFloat(quantity) < item.quantity && !ENV.allowToPackLessLB);

            var isInvalidQuantity = !$scope.admin.shouldIgnorePackingQuantityInput(item)
                && (isNaN(parseInt(quantity)) || parseInt(quantity) !== parseFloat(quantity) || parseInt(quantity) !== item.quantity);

		    if (item.unit === 'lb' && isInvalidWeight || item.unit !== 'lb' && isInvalidQuantity) {
			    toastr.error('Error updating packed quantity.');
			    return Promise.reject(new Error('Error updating packed quantity.'));
		    }

            var orderObj = {
                key: order.key,
                itemName: item.name,
                packedQuantity: parseFloat(quantity)
            };

            if (!$scope.admin.shouldIgnorePackingWeightInput(item) && item.unit === 'lb' && parseFloat(quantity) < item.quantity) {
                return $scope.admin.confirmPackingLessLB()
                    .then(function() {
                        return $scope.admin.scanAndUpdate(item, orderObj);
                    })
                    .catch(function(err) {
                        return err;
                    });
            } else {
                $scope.admin.scanAndUpdate(item, orderObj);
            }
	    },
        confirmPackingLessLB: function() {
            return ngDialog.openConfirm({
                data: {
                    heading: 'Confirm Quantity',
                    subHeading: 'You are about to pack the quantity that is less than what customer has ordered.'
                        + ' Please click Confirm to proceed or Cancel to go back and pack a different quantity.',
                    confirmBtnText: 'Confirm',
                    cancelBtnText: 'Cancel'
                },
                template: 'partials/popup/confirm-popup.html'
            });
        },
        scanAndUpdate: function (item, orderData) {
            void 0
            void 0

			var barcodeScanner = scannerUtils.getBarcodeScannerName();
            var shouldScan = $scope.admin.shouldScan(item, barcodeScanner);
			var shouldScanRandomWeightItem = $scope.admin.shouldScanRandomWeightItem(item, barcodeScanner);

            if (item.upc && (item.upc.length >= 12 && (shouldScan || ENV.packerRequiredToInputUpc) || shouldScanRandomWeightItem)) {
                if (shouldScan) {
                    var $newScope = $scope.$new(true);
                    $newScope.targetUpc = item.upc;
                    $newScope.item = item;
					$newScope.scannerType = barcodeScanner;

                    var scannerTemplate = '<upc-scanner scanner-type="scannerType" target-upc="targetUpc" item="item" on-close="closeThisDialog(value)"></upc-scanner>';

                    ngDialog.open({
                        template: scannerTemplate,
                        plain: true,
                        className: 'ngdialog-theme-default',
                        scope: $newScope,
                        name: 'fullscreen',
                    }).closePromise.then(function(data) {
                        void 0;
                        if (data.value && typeof data.value === 'object') {
                            var val = data.value;
                            if (val.result === 'unsupported') {
                                toastr.error('Camera is not supported.');
                                return;
                            }
                            if (val.result === 'cancel') {
                                void 0;
                                return;
                            }
                            if (val.result === 'match') {
                                void 0
                                return _updatePackedQuantity();
                            }
                            if (val.result === 'done') {
                                if (item.sellByQty) {
                                    var packedQuantity = val.quantity;
                                    var packedWeight = val.total / item.price;
                                    orderData.packedQuantity = packedQuantity;
                                    orderData.packedWeight = packedWeight;
                                    void 0;
                                    void 0;
                                    return _updatePackedQuantity();
                                }
                                var packedQuantity = val.total / item.price;
                                orderData.packedQuantity = packedQuantity;
                                void 0;

                                if (item.unit === 'lb' && packedQuantity < item.quantity) {
                                    return $scope.admin.confirmPackingLessLB()
                                        .then(function() {
                                            return _updatePackedQuantity();
                                        })
                                        .catch(function(err) {
                                            void 0;
                                            return err;
                                        });
                                }

                                return _updatePackedQuantity();
                            }
                        }
                        if (typeof data.value === 'string' && shouldScanRandomWeightItem) {
                            void 0;
                            return;
                        }
                        if (data.value instanceof Error) {
                            toastr.error('Something went wrong.');
                        }
                        confirmUpdate(data.value);
                    });
                } else {
                    confirmUpdate();
                }
            } else {
                _updatePackedQuantity();
            }

            function confirmUpdate(skipType) {
                if (ENV.packerRequiredToInputUpc) {
                    var $newScope = $scope.$new(true);
                    $newScope.targetUpc = item.upc;

                    ngDialog.open({
                        template: '<verify-upc target-upc="targetUpc" on-close="closeThisDialog(value)"></verify-upc>',
                        plain: true,
                        className: 'ngdialog-theme-default',
                        scope: $newScope,
                    }).closePromise.then(function(data) {
                        void 0;
                        if (data.value === 'match') {
                            void 0
                            return _updatePackedQuantity();
                        }
                    });
                } else {
                    var message = 'Continue to pack this item without scanning?';

                    if (skipType === 'mismatch') {
                        message = 'UPC did not match. Pack this item anyway?'
                    }
                    ngDialog.openConfirm({
                        data: {
                            heading: 'Confirm Pack',
                            subHeading: message,
                            confirmBtnText: 'Continue',
                            cancelBtnText: 'Cancel'
                        },
                        template: 'partials/popup/confirm-popup.html'
                    }).then(function() {
                        _updatePackedQuantity();
                    })
                    .catch(function(err) {
                        void 0;
                    });
                }
            }

            function _updatePackedQuantity() {

                item.isUpdating = true;
                var data = { order: orderData };

                if (item.selectedModifiers) {
                    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
                        return modifier.name
                    });
                }
                void 0;

                return hsAdmin.updateOrder(data).then(function (response) {
                    switch(response.status) {
                        case 200:
                            void 0;
                            $scope.admin.showSuccessNotification('Item packed successfully');
                            $scope.admin.processOrderData(response.data);
                            if (response.data.packed) {
                                $scope.admin.getPrinters($scope.admin.showPackingCompletedFlow);
                            }
                            break;
                        case 402:
                            toastr.error('Customer credit card was declined and hence the change you are attempting to make was not successful.');
                            break;
                        default:
                            void 0;
                            toastr.error('Error updating packed quantity.');
                            break;
                    }
                    item.isUpdating = false;
                    return response;
                });
            }
        },
	    updateOrderItemQuantity: function (order, item, index) {
		    void 0;
		    var quantity = $('#quantity-' + index).val();
		    item.isUpdating = true;

		    var data = {
			    order: {
				    key: order.key,
				    itemName: item.name,
				    itemQuantity: parseFloat(quantity)
			    }
		    };

		    if (item.selectedModifiers) {
			    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
				    return modifier.name
			    });
		    }

		    hsAdmin.updateOrder(data)
			    .then(function (response) {
				    switch(response.status) {
					    case 200:
						    void 0;
						    toastr.success('Updated quantity successfully.');
							$scope.admin.processOrderData(response.data);
						    break;
						case 409:
							toastr.error('Maximum quantity for product reached.');
							break;
					    case 402:
						    toastr.error('Customer credit card was declined and hence the change you are attempting to make was not successful.');
						    break;
					    default:
						    void 0;
						    toastr.error('Error updating quantity.');
						    break;
				    }

				    item.isUpdating = false;
			    });
	    },
	    updateItemPriceInOrder: function (order, item, priceId) {
	    	var price = $(priceId).val();
	    	void 0;
		    var isNumber = !isNaN(price) && price !== '';
		    void 0;

		    if (isNumber) {
			    var data = {
				    order: {
					    key: order.key,
					    itemName: item.name,
					    price: parseFloat(price)
				    }
			    };

			    if (item.selectedModifiers) {
				    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
					    return modifier.name
				    });
			    }
                if (data.order.price === 0) {
                    toastr.error('Price cannot be $0.  Please check price and try again.');
                } else if (data.order.price > 100) {
				    ngDialog.openConfirm({
					    data: {
						    heading: 'Confirm',
						    subHeading: "Price you've entered is more than $100. Press Confirm to update the price. Cancel to go back and correct the price.",
						    confirmBtnText: 'Confirm',
						    cancelBtnText: 'Cancel'
					    },
					    template: 'partials/popup/confirm-popup.html'
				    }).then(function (confirm) {
					    $scope.admin._updateItemPriceInOrder(data);
				    }, function (reject) {
					    void 0;
					    return;
				    });
			    } else {
			    	$scope.admin._updateItemPriceInOrder(data);
			    }
		    }
	    },
	    _updateItemPriceInOrder(data) {
		    hsAdmin.updateItemPriceInOrder(data)
			    .then(function (response) {
				    if (response.status === 200) {
					    void 0;
					    void 0;
					    toastr.success('Price updated successfully.');

						$scope.admin.processOrderData(response.data);
						if (!ENV.isRestaurant) {
							ngDialog.openConfirm({
								data: {
									heading: 'Change Price In System',
									subHeading: "Do you want to apply this price change to all future orders?",
									confirmBtnText: 'Yes',
									cancelBtnText: 'No'
								},
								template: 'partials/popup/confirm-popup.html'
							}).then(
								function (res) {
									$scope.admin._updateItemPriceForTenant(data.order);
								},
								function (rej) {}
							);
						}
				    } else {
					    void 0;
					    if (response.status === 403) {
						    toastr.error('Error updating price. Please check price and try again.');
					    } else {
						    toastr.error('Error updating price.');
					    }

				    }
			    });
	    },
	    _updateItemPriceForTenant: function (data) {
		    var productData = {
			    product: {
				    name: data.itemName,
				    price: data.price,
			    }
		    };
		    hsAdmin.updateProduct(productData)
			    .then(function (response) {
				    if (response.status === 200) {
					    toastr.success('Product updated successfully.');
				    } else {
					    toastr.error('Error updating product.');
				    }
			    });
        },
        updateItemInStock: function(item, isInStock) {
            var productData = {
                product: {
                    name: item.name,
                    isInStock: isInStock,
                },
            };
            hsAdmin.updateProduct(productData).then(function (response) {
                void 0;
                if (response.status === 200) {
                    toastr.success('Item marked out of stock');
                } else {
                    toastr.error('Error updating product.');
                }
            });
        },
	    updateAddItemQuantity: function (item, updateType, quantityBtnSelector) {
		    quantityBtnSelector = '#' + quantityBtnSelector;
		    var updateBtnSelector = quantityBtnSelector.replace('quantity', 'update-btn');
		    hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
	    },
	    updatePackItemQuantity: function (item, updateType, quantityBtnSelector) {
		    quantityBtnSelector = '#' + quantityBtnSelector;
		    hsCart.updateQuantity(item, updateType, quantityBtnSelector);
	    },
	    removeItem: function (order, item) {
		    void 0;

            var $removeItemScope = $scope.$new(true);
            $removeItemScope.order = order;
            $removeItemScope.item = item;
            $removeItemScope.isTableSideOrder = !!order.tableNumber;
            $removeItemScope.removeItem = $scope.admin.removeItemFromOrder;

            return ngDialog.open({
                template: '<div><remove-item '
                    + 'is-table-side-order="isTableSideOrder" '
                    + 'on-confirm="removeItem(order, item, reason)" '
                    + 'on-close="closeThisDialog(value)" '
                    + '><remove-item/></div>',
                className: 'ngdialog-theme-default',
                plain: true,
                scope: $removeItemScope,
            }).closePromise
                // These are needed for admin-order-item popup, so it can close correctly.
                .then(function(data) {
                    void 0;
                    return data.value === 'success';
                })
                .catch(function(err) {
                    void 0;
                    return false;
                });
	    },
	    removeItemFromOrder(order, item, reason) {
	    	void 0;
		    var data = {
			    order: {
				    key: encodeURIComponent(order.key),
				    itemName: item.name,
				    selectedModifiers : item.selectedModifiers || [],
                    reason: reason || '',
			    }
		    };

		    void 0;

		    return hsAdmin.removeItemFromOrder(data)
			    .then(function (response) {
				    if (response.status === 200) {
					    void 0;
					    toastr.success('Item removed successfully.');
                        $scope.admin.processOrderData(response.data);
                        var isOrderPacked = response.data.packed;
                        if (ENV.promptOutOfStockWhenRemoved) {
                            $scope.admin.showMarkItemOutOfStockPopup(item).then(function() {
                                if (isOrderPacked) {
                                    $scope.admin.showPackingCompletedFlow()
                                }
                            });
                        } else {
                            if (isOrderPacked) {
                                $scope.admin.showPackingCompletedFlow();
                            }
                        }
                        return 'success';
				    } else {
					    void 0;
					    item.isUpdating = false;
					    toastr.error('Error removing item from cart.');
                        return 'Error removing item from cart.';
				    }
			    });
        },
        showMarkItemOutOfStockPopup(item) {
            return ngDialog.openConfirm({
                data: {
                    heading: 'Mark Out of Stock?',
                    subHeading: 'Would you like to mark this item as out of stock for all future orders?',
                    confirmBtnText: 'Yes',
                    cancelBtnText: 'No',
                },
                template: 'partials/popup/confirm-popup.html',
            }).then(function() {
                void 0;
                return $scope.admin.updateItemInStock(item, false);
            }, function () {});
        },
	    addItemToOrder: function (order, item, index) {
		    void 0;
		    if (item.isContainer || item.hasModifiers) {
			    item.quantity = parseFloat($('#quantity-add-' + index).val());
			    this.showProductPopup(item);
		    } else {
			    var data = {
				    order: {
					    key: order.key,
					    itemName: item.name,
					    itemQuantity: parseFloat($('#quantity-add-' + index).val()),
					    isCustomItem: item.isCustom || item.isCustomItem || false,
					    isOrganicItem: item.organic
				    }
			    };

			    this.addItemToExistingOrder(data, item);
		    }
	    },
	    addItemToExistingOrder: function (data, item) {
		    hsAdmin.addItemToOrder(data)
			    .then(function (response) {
				    switch(response.status) {
					    case 200:
						    void 0;
						    toastr.success('Item added to order successfully.');
						    $scope.admin.initOrderDetails();
						    $scope.admin.searchedQuery = '';
						    $scope.admin.searchQuery = '';
						    break;
					    case 409:
						    toastr.error('Item already exists in the order.');
						    break;
					    case 402:
						    toastr.error('Customer credit card was declined and hence the change you are attempting to make was not successful.');
						    break;
					    default:
						    void 0;
						    toastr.error('Error adding item to order.');
						    break;
				    }

				    if (item) {
					    item.isUpdating = false;
					    item.loading = false;
				    }
			    });
	    },
        filterHelpers: {
            getSortedCategories: function(sortedData) {
                var sortedCategories = [];
                Object.keys(sortedData)
                    .sort()
                    .forEach(function (category, idx) {
                        if (sortedData[category].loadTab) {
                            $scope.admin.activeTabIndex = idx;
                        }

                        sortedCategories.push(sortedData[category]);
                    });
                return sortedCategories;
            },
            arrangeTiles: function(sortedCategories) {
                sortedCategories.forEach(function (category) {
                    angular.forEach(category.categories, function (val, key) {
                        val.products = $scope.admin.filterProducts(val.products, $rootScope.screenWidth);
                        val.outOfStockProducts = $scope.admin.filterProducts(val.outOfStockProducts, $rootScope.screenWidth);
                        val.inactiveProducts = $scope.admin.filterProducts(val.inactiveProducts, $rootScope.screenWidth);
						val.autoAddedProducts = $scope.admin.filterProducts(val.autoAddedProducts, $rootScope.screenWidth);
                    });
                });
            },
            getOutOfStockProductsCategories: function(sortedCategories) {
                var outOfStockProducts = [];
                sortedCategories.forEach(function (category) {
                    if (category.outOfStockProducts.length) {
                        outOfStockProducts.push(category);
                    }
                });
                return outOfStockProducts;
            },
            getInactiveProductsCategories: function(sortedCategories) {
                var inactiveProducts = [];
                sortedCategories.forEach(function (category) {
                    if (category.inactiveProducts.length) {
                        inactiveProducts.push(category);
                    }
                });
                return inactiveProducts;
            },
			getAutoAddedProductsCategories: function(sortedCategories) {
                var autoAddedProducts = [];
                sortedCategories.forEach(function (category) {
                    if (category.autoAddedProducts.length) {
                        autoAddedProducts.push(category);
                    }
                });
                return autoAddedProducts;
            },
            getHomepageProductsCategories: function (sortedCategories) {
                var homepageProducts = [];
                sortedCategories.forEach(function (category) {
                    if (category.homepageProducts.length) {
                        homepageProducts.push(category);
                    }
                });
                return homepageProducts;
            },
            createTable: function(products) {
                $scope.admin.productData.tableParams = new NgTableParams({
                    count: globalFunctions.ngTableConfig.count
                }, {
                    counts: globalFunctions.ngTableConfig.counts,
                    dataset: products
                });
            },
        },
        showHomepageProductExplanationPopup() {
            ngDialog.open({
                template: 'partials/popup/homepage-product-explanation.html',
                className: 'ngdialog-theme-default email-capture',
            });
        },
		showSyndigoExplanationPopup() {
            ngDialog.open({
                template: 'partials/popup/syndigo-explanation.html',
                className: 'ngdialog-theme-default email-capture',
            });
        },
        showCategoryRankExplanationPopup() {
            ngDialog.open({
                template: 'partials/popup/category-rank-explanation.html',
                className: 'ngdialog-theme-default email-capture',
            });
        },
        showAdditionalDeliveryFeeExplanationPopup() {
            ngDialog.open({
                template: 'partials/popup/additional-delivery-fee-explanation.html',
                className: 'ngdialog-theme-default email-capture',
            });
        },
        rebuildProductCategoriesOutOfStock: function(product) {
            // I can't figure out a simplier way to do this
            return $scope.admin.rebuildProductCategories(product, 'outOfStockPage');
        },
		rebuildProductCategoriesAutoAdded: function(product) {
            return $scope.admin.rebuildProductCategories(product, 'autoAddedPage');
        },
        rebuildProductCategoriesInactive: function(product) {
            return $scope.admin.rebuildProductCategories(product, 'inactiveProductsPage');
        },
        rebuildProductCategoriesHomepage: function(product) {
            return $scope.admin.rebuildProductCategories(product, 'homepageProductsPage');
        },
        rebuildProductCategories: function(product, pageType) {
            var outOfStockPage = pageType === 'outOfStockPage';
            var inactiveProductsPage = pageType === 'inactiveProductsPage';
			var autoAddedProductsPage = pageType === 'autoAddedPage';
            var homepageProductsPage = pageType === 'homepageProductsPage';

            var urlCategory = $location.search().category;
            // need to sync product for allProducts even if we are in a search, so table view is in sync
            var found = $scope.admin.productData.allProducts.find(function(item) {
                return item.name == product.name;
            });

            if (!found) {
                return;
            }
            Object.assign(found, product);

            if ($scope.searchQuery) {
                var gridView = $location.search().gridView;
                hsSearch.search($scope.searchQuery)
                    .then(function(data) {
                        var combinedResults = data.results[0] ? data.results[0] : [];

                        var found = combinedResults.find(function(item) {
                            return item.name == product.name;
                        });
                        if (!found) {
                            return;
                        }
                        Object.assign(found, product);

                        var previousTabId;
                        var sortedData = globalFunctions.getSortedProducts(combinedResults).sortedData;
                        if (urlCategory && sortedData[urlCategory]) {
                            previousTabId = sortedData[urlCategory].id;
                        }

                        var searchedData = $scope.admin.filterHelpers.getSortedCategories(sortedData);
                        $scope.admin.filterHelpers.arrangeTiles(searchedData);
                        $scope.admin.productData.categorizedProducts = searchedData;

                        if (searchedData.length && gridView) {
                            var index = -1;
                            searchedData.forEach(function(category, i) {
                                if (urlCategory && previousTabId && previousTabId === category.id) {
                                    category.loadTab = true;
                                    index = i;
                                } else {
                                    category.loadTab = false;
                                }
                            });
                            if (!~index) {
                                index = 0;
                            }
                            $scope.admin.activeTabIndex = index;
                            searchedData[index].loadTab = true;
                            $location.search('category', searchedData[index].id);
                        }
                    })
                    .catch(function(err) {
                        void 0;
                    });
            } else {
                var sortedData = globalFunctions.getSortedProducts($scope.admin.productData.allProducts).sortedData;

                if (!outOfStockPage && !inactiveProductsPage && !homepageProductsPage && !autoAddedProductsPage) {
                    if (urlCategory && sortedData[urlCategory]) {
                        sortedData[urlCategory].loadTab = true;
                    } else {
                        var firstCategory = Object.keys(sortedData).sort()[0];
                        sortedData[firstCategory].loadTab = true;
                        $location.search('category', firstCategory);
                    }
                }
                var sortedCategories = $scope.admin.filterHelpers.getSortedCategories(sortedData);
                var outOfStockProducts = $scope.admin.filterHelpers.getOutOfStockProductsCategories(sortedCategories);
                var inactiveProducts = $scope.admin.filterHelpers.getInactiveProductsCategories(sortedCategories);
				var autoAddedProducts = $scope.admin.filterHelpers.getAutoAddedProductsCategories(sortedCategories);
                var homepageProducts = $scope.admin.filterHelpers.getHomepageProductsCategories(sortedCategories);
                $scope.admin.filterHelpers.arrangeTiles(sortedCategories);

                if (outOfStockPage) {
                    var category = outOfStockProducts.find(function(item) {
                        return item.id === urlCategory;
                    });
                    if (urlCategory && category) {
                        category.loadTab = true;
                    } else {
                        outOfStockProducts[0].loadTab = true;
                        $location.search('category', outOfStockProducts[0].id);
                        setTimeout(function() {
                            document.querySelector('#category-' + outOfStockProducts[0].id + ' a').click();
                        }, 0);
                    }
                }

                if (inactiveProductsPage) {
                    var category = inactiveProducts.find(function(item) {
                        return item.id === urlCategory;
                    });
                    if (urlCategory && category) {
                        category.loadTab = true;
                    } else {
                        inactiveProducts[0].loadTab = true;
                        $location.search('category', inactiveProducts[0].id);
                        setTimeout(function() {
                            document.querySelector('#category-' + inactiveProducts[0].id + ' a').click();
                        }, 0);
                    }
                }

				if (autoAddedProductsPage) {
                    var category = autoAddedProducts.find(function(item) {
                        return item.id === urlCategory;
                    });
                    if (urlCategory && category) {
                        category.loadTab = true;
                    } else {
                        autoAddedProducts[0].loadTab = true;
                        $location.search('category', autoAddedProducts[0].id);
                        setTimeout(function() {
                            document.querySelector('#category-' + autoAddedProducts[0].id + ' a').click();
                        }, 0);
                    }
                }

                if (homepageProductsPage) {
                    var category = homepageProducts.find(function(item) {
                        return item.id === urlCategory;
                    });
                    if (urlCategory && category) {
                        category.loadTab = true;
                    } else {
                        homepageProducts[0].loadTab = true;
                        $location.search('category', homepageProducts[0].id);
                        setTimeout(function() {
                            document.querySelector('#category-' + homepageProducts[0].id + ' a').click();
                        }, 0);
                    }
                }

                sortedCategories.forEach(function (category) {
                    angular.forEach(category.categories, function (subCategory) {
                        subCategory.products.sort(function(a, b) {
                            if (a.displayName < b.displayName) return -1;
                            if (a.displayName > b.displayName) return 1;
                            return 0;
                        });
                    });
                });

                $scope.admin.productData.outOfStockProducts = outOfStockProducts;
                $scope.admin.productData.inactiveProducts = inactiveProducts;
                $scope.admin.productData.autoAddedProducts = autoAddedProducts;
                $scope.admin.productData.homepageProducts = homepageProducts;
                $scope.admin.productData.categorizedProducts = sortedCategories;
                $scope.admin.productData.originalCategorizedProducts = sortedCategories;
            }
            var productsObj = $scope.admin.productData.getProductsFromPageType(pageType);
            $scope.admin.initInfiniteScroll(productsObj.products, productsObj.productAvailability, true);
        },
	    getAllProducts: function (isProductDashBoard, productName, orderDetails, pageType, includeAllItems) {
            var outOfStockPage = pageType === 'outOfStockPage';
            var inactiveProductsPage = pageType === 'inactiveProductsPage';
            var homepageProductsPage = pageType === 'homepageProductsPage';
			var autoAddedProductsPage = pageType === 'autoAddedPage';

		    var productList;
		    var req = {
			    method: 'GET',
			    url: ENV.apiEndPoint + '/product/list' + (includeAllItems ? '?includeAllItems=true' : ''),
			    headers: {}
		    };

		    if (orderDetails) {
				req.headers['location'] = orderDetails.location;

			    if (ENV.enablePriceList) {
				    req.headers['pricelist'] = orderDetails.priceList;
			    }
		    } else if (isProductDashBoard) {
			    if (ENV.enablePriceList) {
				    var adminPriceList = $rootScope.adminFilterPriceList || localStorageService.get('adminSelectedPriceList');
					req.headers['pricelist'] = adminPriceList.uniqueName;
			    }
		    }

		    productList = $http(req);

		    $q.all([productList])
			    .then(function (response) {
				    void 0;
				    if (response[0].status === 200) {
					    var categoryOrder = JSON.parse(JSON.stringify(ENV.categoryOrder));
					    var subCategoryOrder = JSON.parse(JSON.stringify(ENV.subCategoryOrder));
					    var data = globalFunctions.getSortedProducts(response[0].data.products, productName);
					    var allProducts = data.allProducts;
					    var hiddenProducts = data.hiddenProducts;
					    var outOfStockProducts = [];
					    var allOutOfStockProducts = data.outOfStockProducts;
                        var inactiveProducts = [];
						var autoAddedProducts = [];
						var allAutoAddedProducts = data.autoAddedProducts;
                        var homepageProducts = [];
                        var allInactiveProducts = data.inactiveProducts;
                        var allHomepageProducts = data.homepageProducts;
					    var sortedData = data.sortedData;

					    if (isProductDashBoard) {
						    if (!productName && !outOfStockPage && !inactiveProductsPage && !homepageProducts && !allAutoAddedProducts) {
							    var urlCategory = $location.search().category;
							    if (urlCategory && sortedData[urlCategory]) {
								    sortedData[urlCategory].loadTab = true;
							    } else {
								    var firstCategory = Object.keys(sortedData).sort()[0];
								    sortedData[firstCategory].loadTab = true;
								    $location.search('category', firstCategory);
							    }
						    }

						    var sortedCategories = $scope.admin.filterHelpers.getSortedCategories(sortedData);
						    $scope.admin.filterHelpers.arrangeTiles(sortedCategories);
						    outOfStockProducts = $scope.admin.filterHelpers.getOutOfStockProductsCategories(sortedCategories);
                            inactiveProducts = $scope.admin.filterHelpers.getInactiveProductsCategories(sortedCategories);
                            homepageProducts = $scope.admin.filterHelpers.getHomepageProductsCategories(sortedCategories);
							autoAddedProducts = $scope.admin.filterHelpers.getAutoAddedProductsCategories(sortedCategories);

                            sortedCategories.forEach(function (category) {
                                angular.forEach(category.categories, function (subCategory) {
                                    subCategory.products.sort(function(a, b) {
                                        if (a.displayName < b.displayName) return -1;
                                        if (a.displayName > b.displayName) return 1;
                                        return 0;
                                    });
                                });
                            });

						    if (outOfStockPage) {
							    $scope.admin.filterHelpers.createTable(allOutOfStockProducts);
                            } else if (inactiveProductsPage) {
                                $scope.admin.filterHelpers.createTable(allInactiveProducts);
						    } else if (homepageProductsPage) {
                                $scope.admin.filterHelpers.createTable(allHomepageProducts);
                            } else if (autoAddedProductsPage) {
                                $scope.admin.filterHelpers.createTable(allAutoAddedProducts);
                            } else {
							    $scope.admin.filterHelpers.createTable(allProducts);
						    }

						    $scope.admin.productData.allProducts = allProducts;
						    $scope.admin.productData.outOfStockProducts = outOfStockProducts;
                            $scope.admin.productData.inactiveProducts = inactiveProducts;
                            $scope.admin.productData.homepageProducts = homepageProducts;
							$scope.admin.productData.autoAddedProducts = autoAddedProducts;
						    $scope.admin.productData.originalCategorizedProducts = sortedCategories;
						    $scope.admin.productData.categorizedProducts = sortedCategories;
						    $scope.admin.productData.selectedProduct = data.selectedProduct;

						    $scope.admin.config.pageFullyLoaded = true;

						    if (productName) {
							    $scope.admin.productData.product = {
								    name: $scope.admin.productData.selectedProduct.name,
								    displayName: $scope.admin.productData.selectedProduct.displayName,
								    type: $scope.admin.productData.selectedProduct.type,
								    subType: $scope.admin.productData.selectedProduct.subType,
								    unit: $scope.admin.productData.selectedProduct.unit,
								    unitQuantity: $scope.admin.productData.selectedProduct.unitQuantity,
								    price: $scope.admin.productData.selectedProduct.price,
								    organic: $scope.admin.productData.selectedProduct.organic,
								    inStock: $scope.admin.productData.selectedProduct.isInStock,
								    brand: $scope.admin.productData.selectedProduct.brand,
								    ingredients: $scope.admin.productData.selectedProduct.ingredients,
									marketingCopy: $scope.admin.productData.selectedProduct.marketingCopy,
								    disclaimer: $scope.admin.productData.selectedProduct.disclaimer,
								    minQuantity: $scope.admin.productData.selectedProduct.minQuantity,
								    maxQuantity: $scope.admin.productData.selectedProduct.maxQuantity,
								    taxRate: $scope.admin.productData.selectedProduct.taxRate,
                                    bottleFee: $scope.admin.productData.selectedProduct.bottleFee,
									sortOrderCustom: $scope.admin.productData.selectedProduct.sortOrderCustom,
									posData: $scope.admin.productData.selectedProduct.posData
							    };

							    if ($scope.admin.productData.selectedProduct.type === 'Fruits & Vegetables'
							    && $scope.admin.productData.unitTypes.indexOf($scope.admin.productData.selectedProduct.unit) !== -1) {
							        $scope.admin.productData.unitEditable = true;
							    } else {
							        $scope.admin.productData.unitEditable = false;
							    }

						    }
					    } else {

						    angular.forEach(sortedData, function(val, key) {
							    if (!val) {
								    delete sortedData[key];
							    } else {
								    // Sorting Sub Category Order if enabled in config
								    if (ENV.sortSubCategoryOrder) {
									    sortedData[key].categories = globalFunctions.sortJSONObj(sortedData[key].categories);
								    }

								    // Maintaining Sub Category order if defined in config
								    if (subCategoryOrder[key]) {
									    var newOrder = {};
									    angular.forEach(subCategoryOrder[key], function(subVal, subKey){
										    newOrder[subKey] = sortedData[key].categories[subKey];
									    });

									    sortedData[key].categories = newOrder;
								    }

								    // Filling the grid with empty tiles For Homepage
								    sortedData[key].homePageProducts = globalFunctions.addEmptyGridTiles('homePageProducts', sortedData[key], $rootScope.screenWidth);

								    // Filling the grid with empty tiles to Show all products on Homepage
								    if (ENV.showAllProducts) {
									    sortedData[key].tileProducts = globalFunctions.addEmptyGridTiles('regular', sortedData[key].tileProducts, $rootScope.screenWidth);
									    sortedData[key].nonTileProducts = globalFunctions.addEmptyGridTiles('regular', sortedData[key].nonTileProducts, $rootScope.screenWidth);
								    }



								    // Iterating over Sub Categories
								    angular.forEach(sortedData[key].categories, function (val, subCatKey){
                                        if (!val) {
                                            delete sortedData[key].categories[subCatKey];
                                            return;
                                        }
									    if ($rootScope.minimalProductLayout) {
										    // Filling the grid with empty tiles for 2 column grid for Order view or Minimal Layout
										    val.products = globalFunctions.addEmptyGridTiles('orderPage', val.products, $rootScope.screenWidth);
									    }

									    // Filling the grid with empty tiles for category pages.
									    val.tileProducts = globalFunctions.addEmptyGridTiles('regular', val.tileProducts, $rootScope.screenWidth);
									    val.nonTileProducts = globalFunctions.addEmptyGridTiles('regular', val.nonTileProducts, $rootScope.screenWidth);
								    });

								    if (categoryOrder.hasOwnProperty(key) === false) {
									    delete categoryOrder[key];
								    }

								    categoryOrder[key] = sortedData[key];
							    }
						    });

						    var sortedCategories = [];
						    Object.keys(categoryOrder)
							    .forEach(function (category, idx) {
								    if (categoryOrder[category]) {
									    sortedCategories.push(categoryOrder[category]);
								    }
							    });


						    sortedCategories.forEach(function (category) {
							    angular.forEach(category.categories, function (val, key) {
								    val.products = $scope.admin.filterProducts(val.products, $rootScope.screenWidth);
							    });
						    });

						    void 0;
						    void 0;

						    $scope.admin.adminData.allProducts = allProducts;
						    $scope.admin.productData.allProducts = allProducts;
						    $scope.admin.productData.outOfStockProducts = outOfStockProducts;
                            $scope.admin.productData.inactiveProducts = inactiveProducts;
							$scope.admin.productData.autoAddedProducts = autoAddedProducts;
						    $scope.admin.productData.originalCategorizedProducts = sortedCategories;
						    $scope.admin.productData.categorizedProducts = sortedCategories;
					    }
				    }
			    })
			    .catch(function (response) {
				    void 0;
			    });
	    },
        loadMore(index, productAvailability, categoryName) {
            var productAvailabilityMap = {
                all: {
                    productAvailabilityKey: 'categorizedProducts',
                    categoryAvailibityKey: 'products',
                },
                inactive: {
                    productAvailabilityKey: 'inactiveProducts',
                    categoryAvailibityKey: 'inactiveProducts',
                },
                outOfStock: {
                    productAvailabilityKey: 'outOfStockProducts',
                    categoryAvailibityKey: 'outOfStockProducts',
                },
                homepage: {
                    productAvailabilityKey: 'homepageProducts',
                    categoryAvailibityKey: 'homepageProducts',
                },
				autoAdded: {
                    productAvailabilityKey: 'autoAddedProducts',
                    categoryAvailibityKey: 'autoAddedProducts',
                }
            };
            var productAvailabilityKey = productAvailabilityMap[productAvailability].productAvailabilityKey;
            var categoryAvailibityKey = productAvailabilityMap[productAvailability].categoryAvailibityKey;
            var threshold = 15;
            var category = $scope.admin.productData.infiniteScrollProducts[index];
            if (!category || !category.categories) return;

            var subCategory = category.categories[categoryName];
            if (!subCategory) return;

            var products = subCategory.products;
            var sourceData = $scope.admin.productData[productAvailabilityKey][index].categories[categoryName][categoryAvailibityKey];

            if (products.length < sourceData.length) {
                var maxLength = Math.min(products.length + threshold, sourceData.length);

                for (var i = products.length; i < maxLength; i++) {
                    if (sourceData[i]) {
                        products.push(sourceData[i]);
                    }
                }
            }
        },
        initInfiniteScroll: function(products, productAvailability, rebuild) {
            var infData = [];
            var productAvailabilityMap = {
                all: 'products',
                inactive: 'inactiveProducts',
                outOfStock: 'outOfStockProducts',
                homepage: 'homepageProducts',
				autoAdded: 'autoAddedProducts',
            };
            var productAvailabilityKey = productAvailabilityMap[productAvailability];
            for (var i = 0; i < products.length; i++) {
                var category = {
                    name: products[i].name,
                    id: products[i].id,
                    categories: {},
                };
                for (var subName of Object.keys(products[i].categories)) {
                    var sub = products[i].categories[subName];
                    var endIndex = 20;

                    if (rebuild && products[i].loadTab
                        && $scope.admin.productData.infiniteScrollProducts[i]
                        && $scope.admin.productData.infiniteScrollProducts[i].categories
                        && $scope.admin.productData.infiniteScrollProducts[i].categories[subName]
                        && $scope.admin.productData.infiniteScrollProducts[i].categories[subName][productAvailabilityKey]
                    ) {
                        endIndex = $scope.admin.productData.infiniteScrollProducts[i].categories[subName][productAvailabilityKey].length;
                    }
                    category.categories[subName] = {
                        name: sub.name,
                        id: sub.id,
                        products: sub[productAvailabilityKey].slice(0, endIndex),
                    };
                }
                infData.push(category);
            }
            $scope.admin.productData.infiniteScrollProducts = infData;
        },
	    sendToQB(event, order) {
	    	event.stopPropagation();
	    	void 0;

	    	var data = {
			    order: {
				    key: order.key,
				    sendToQB: true
			    }
		    };

	    	void 0;
		    hsAdmin.updateOrderStatus(data)
			    .then(function (response) {
				    if (response.status === 200) {
					    void 0;
					    void 0;
					    toastr.success('Send to Quickbooks successfully.');
					    $scope.admin.initOrderDashboard();
				    } else {
					    void 0;
					    void 0;
					    toastr.error('Error sending to Quickbooks.');
				    }
			    });
	    },
	    /**
	     * If the supplied object contains a reference to an AutoComplete object, proceed to
	     * filling the rest of the entity fields, otherwise just skip as no autocomplete event
	     * happened.
	     * @param {object} shippingAddr
	     */
	    addressAutoComplete: function (shippingAddr) {
		    // If the value of `street1` is not a string, it means that it is the object
		    // reference as a result of the `ngAutocomplete` functionality, which means we
		    // have to fill out the rest of the entity fields.
		    if (typeof (this.address.street1) !== 'string') {
			    var autoCompleteObject = shippingAddr.street1;
			    var autoCompleteAddress = address.getAutoCompleteAddress(autoCompleteObject);
			    this.address.street1 = autoCompleteAddress.street1;
			    this.address.street2 = autoCompleteAddress.street2;
			    this.address.city = autoCompleteAddress.city;
			    this.address.state = autoCompleteAddress.state;
			    this.address.zip = autoCompleteAddress.zip;
			    this.address.country = autoCompleteAddress.country;

			    $scope.admin.config.addressNonEditable = true;

			    // Once autocomplete is done populating fields, focus on the Address 2 field
			    // As street2 cannot be autocompleted.
			    // Putting it inside a TimeOut to ensure other events don't prevent this from happening
			    setTimeout(function () {
				    angular.element('#street2').focus();
			    }, 0);

		    }

		    //need to null this var so we get new value everytime
		    $scope.details = null;
	    },
	    /**
	     * Requests backend to verify if User Address is a valid Shipping address and update with
	     * the closest sanitized version of the address.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    verifyAddress: function (shippingAddr) {
		    void 0;
		    this.notification.reset();
		    this.notification.isVerificationLoading = true;

		    address.verify(
			    shippingAddr.street1,
			    shippingAddr.street2,
			    shippingAddr.city,
			    shippingAddr.state,
			    shippingAddr.zip,
			    shippingAddr.country
		    )
			    .success(function (suggestedAddress, responseMap) {
				    // Using the suggested address to update the input values
				    void 0;
				    return suggestedAddress;
			    })
			    .error(function (data, status, headers, config) {
				    void 0;
				    return data.success;
			    });
	    },
	    /**
	     * Takes a verified address and submits it for registration and in case there is a
	     * gift redemption, it will attempt to redeem it.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    submitAddress: function (shippingAddr) {
		    void 0;
		    var apiUrl = ENV.tbApiEndPoint + "/api/v1/user/register/address";
		    $scope.myPromise = $http.post(apiUrl, shippingAddr)
			    .success(function (data, status, headers, config) {
				    void 0;
				    localStorageService.remove('user');
				    localStorageService.set('user', data);

				    $rootScope.signupHeader = false;
				    $rootScope.showSignupFooter = false;

				    //Getting signup progress from the localstorage
				    var signupProgress = localStorageService.get('signupProgress');
				    if (signupProgress) {
					    signupProgress.shipping = true;
					    localStorageService.remove('signupProgress');
					    localStorageService.add('signupProgress', signupProgress);
				    }

				    $location.url('/tb/my-account');
				    return;
			    })
			    .error(function (data, status, headers, config) {
				    $scope.shippingRegistration._handleAddressError(data.code);
			    });
	    },
	    _handleAddressError: function (errorCode) {
		    this.notification.reset();

		    switch (errorCode) {
			    case 200001 :
				    $scope.signup.config.signupError = "Currently, we only serve in United States.";
				    break;
			    case 200002 : // Unable to serve address
				    $scope.signup.config.signupError = "Oopsies, We don't deliver in your state at the moment.";
				    break;
			    case 200003 : // Unable to serve address
				    $scope.signup.config.signupError = "We're unable to verify this as a valid deliverable address. Please contact customer support email at info@naturecarebox.com.";
				    break;
			    default :
				    $scope.signup.config.signupError = "Something went wrong. Please contact customer support email at info@naturecarebox.com.";
				    break;
		    }

		    setTimeout(function () {
			    scrollToElement('.address-error-msg');
		    }, 500);

	    },
	    __validateAddress: function (shippingAddr) {
		    this.notification.reset();

		    if ($.trim(shippingAddr.street1) == "") {
			    this.notification.isAddressError = true;
			    this.notification.errMessage = "Error in address. Address 1 is required";
			    $timeout(function () {
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }
		    if (shippingAddr.country == "US" && (shippingAddr.zip.length != 5 || isNaN(shippingAddr.zip))) {
			    this.notification.isAddressError = true;
			    this.notification.errMessage = "Error in address. ZIP Code should be 5 digits long";
			    $timeout(function () {
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }

		    if (!shippingAddr.street2) {
			    shippingAddr.street2 = "";
		    }

		    this.notification.isRegisterAddrLoading = false;
		    return true;
	    },
	    __resetAddress: function () {
		    this.address = {
			    street1: "",
			    street2: "",
			    city: "",
			    state: "",
			    zip: "",
			    country: "US"
		    };
		    this.billingAddress = {
			    street1: "",
			    street2: "",
			    city: "",
			    state: "",
			    zip: "",
			    country: "US"
		    };
	    },
	    printMeDiv: function (printAreaId, printFrameId) {
            var iframe = document.getElementById(printFrameId);
            var iwindow = iframe.contentWindow;

            iwindow.document.title = document.title;
            iwindow.document.body.innerHTML = document.getElementById(printAreaId).innerHTML;
            iwindow.focus();
            iwindow.print();
	    },
	    exportCSV: function () {
		    headerFields = $scope.csvHeaderFields;
		    valueFields = $scope.csvValueFields;

		    $scope.fieldsAndHeader = generateFieldsAndHeaders(headerFields, [], []);

		    $scope.fields = $scope.fieldsAndHeader.fields,
			    $scope.header = $scope.fieldsAndHeader.header;

		    // $scope.nestedFieldsAndHeader = generateFieldsAndHeaders($scope.valueFields, [], [""]);
		    // $scope.nestedFields = $scope.nestedFieldsAndHeader.fields,
		    //   $scope.nestedHeader = $scope.nestedFieldsAndHeader.header;

		    // console.log("nestedFields: ", $scope.nestedFields, $scope.nestedHeader);

		    var bodyData = _bodyData(valueFields);
		    void 0;
		    void 0;

		    var strData = _convertToExcel(bodyData, $scope.header);
		    var blob = new Blob([strData], {
			    type: "text/plain;charset=utf-8"
		    });

		    var filename = bodyData.split(",")[bodyData.split(",").length - 9];
		    return saveAs(blob, [filename + ".csv"]);

	    },
		showPrintItemsInfoPopup: function () {
			ngDialog.open({
			    template: 'partials/popup/print-items-info-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture'
		    });
		},
	    printThermalReceipt: function () {
		    ngDialog.open({
			    template: 'partials/popup/thermal-printer-popup.html',
			    controller: 'ModalController',
			    className: 'ngdialog-theme-default email-capture',
			    scope: $scope,
			    closeByDocument: false,
			    closeByNavigation: true
		    });
	    },
        movementReport: {
            report: null,
            reportType: '',
            ordersLoaded: false,
            startDate: new Date(),
            datePicker: {
                opened: false,
                options: {
                    showWeeks: false,
                    formatYear: 'yy',
                    maxDate: new Date(),
                    startingDay: 1,
                    showClear: false,
                },
                formats: {
                    daily: {
                        datepickerMode: 'day',
                        format: 'MM-dd-yyyy',
                    },
                    weekly: {
                        datepickerMode: 'day',
                        format: 'MM-dd-yyyy',
                        dateDisabled(data) {
                            return data.mode === 'day' && data.date.getDay() !== 1;
                        },
                    },
                    monthly: {
                        datepickerMode: 'month',
                        format: 'MM-yyyy',
                        minMode: 'month',
                    }
                },
            },
            csv: {
                header: ['UPC', 'Item', 'Category', 'Sub Category', 'Quantity Sold', 'Revenue'],
                getData() {
                    var exportData = [];
                    var tableData = $filter('filter')(
                        $scope.admin.movementReport.tableParams.settings().dataset,
                        $scope.admin.movementReport.tableParams.filter()
                    );
                    tableData = $filter('orderBy')(tableData, $scope.admin.movementReport.tableParams.orderBy());
                    for (var item of tableData) {
                        exportData.push({
                            'UPC': item.upc,
                            'Item': item.displayName,
                            'Category': item.category,
                            'Sub Category': item.subCategory,
                            'Quantity Sold': item.quantity,
                            'Revenue': item.total,
                        });
                    }
                    return exportData;
                },
                getFilename: function () {
                    var formattedDate = globalFunctions.formatDate($scope.admin.movementReport.startDate, '-');
                    return 'movement_' + $scope.admin.movementReport.reportType + '_' + formattedDate + '.csv';
                },
            },
            toggleDatePicker: function() {
                $scope.admin.movementReport.datePicker.opened = !$scope.admin.movementReport.datePicker.opened;
            },
            updateReport: function() {
				var date = new Date($scope.admin.movementReport.startDate);
                $location.search('startdate', date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear());
                $scope.admin.movementReport.initReport();
            },
            initReport() {
                if (!ENV.showReports.movement) {
                    $location.url('/admin/manager-dashboard');
                    return;
                }
                var reportType = $location.path().split('/').slice(-1)[0];
                if (!reportType || !['daily', 'weekly', 'monthly'].includes(reportType)) {
                    $location.url('/admin/manager-dashboard');
                    return;
                }
                $scope.admin.movementReport.reportType = reportType;

                globalFunctions.setSEOdata($scope.admin.movementReport.reportType[0].toUpperCase()
                    + $scope.admin.movementReport.reportType.slice(1) + ' Movement Report | '+ ENV.name.companyName);

                Object.assign($scope.admin.movementReport.datePicker.options,
                    $scope.admin.movementReport.datePicker.formats[$scope.admin.movementReport.reportType]);

                $scope.admin.movementReport.ordersLoaded = false;
                var startDateParam = $location.search().startdate;
                var startDate;
                if (startDateParam) {
                    startDate = $scope.admin.movementReport.getValidStartDateFromParams(startDateParam);
                } else {
                    var date = new Date();
                    var dateString = date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear();
                    startDate = $scope.admin.movementReport.getValidStartDateFromParams(dateString);
                }
                $location.search('startdate', startDate.month + 1 + '-' + startDate.day + '-' + startDate.year);

                $scope.admin.movementReport.startDate = new Date(startDate.year, startDate.month, startDate.day);

                $scope.admin.movementReport.getReport({startDate: startDate});
            },
            getValidStartDateFromParams: function(param) {
                var dateParts = param.split('-');
                var day = parseInt(dateParts[1]);
                var month = parseInt(dateParts[0] - 1);
                var year = parseInt(dateParts[2]);
                var date = new Date(year, month, day);

                if (isNaN(date.getTime()) || date > new Date() || date < new Date(2000, 0 , 1)
                    || day !== date.getDate()
                    || month !== date.getMonth()
                    || year !== date.getFullYear()
                ) {
                    date = new Date();
                    day = date.getDate();
                    month = date.getMonth();
                    year = date.getFullYear();
                }
                if ($scope.admin.movementReport.reportType === 'daily') {
                    return {
                        day: day,
                        month: month,
                        year: year,
                    };
                }
                if ($scope.admin.movementReport.reportType === 'weekly') {
                    var dayOfTheWeek = date.getDay();
                    var diff = (dayOfTheWeek - (dayOfTheWeek === 0 ? -6 : 1)) * 24 * 60 * 60 * 1000;
                    var newDate = new Date(date.getTime() - diff);

                    return {
                        day: newDate.getDate(),
                        month: newDate.getMonth(),
                        year: newDate.getFullYear(),
                    };
                }
                if ($scope.admin.movementReport.reportType === 'monthly') {
                    return {
                        day: 1,
                        month: month,
                        year: year,
                    };
                }
            },
            getReport: function(dateObj) {
                dateObj.endDate = $scope.admin.movementReport.getEndDate(dateObj);
                hsAdmin.getOrderHistoryList(dateObj)
                    .then(function(res) {
                        if (res.status === 200) {
                            $scope.admin.movementReport.report = $scope.admin.movementReport.processOrders(res.data.orders);
                            void 0;

                            $scope.admin.movementReport.tableParams = new NgTableParams(
                                {
                                    count: globalFunctions.ngTableConfig.count
                                },
                                {
                                    counts: globalFunctions.ngTableConfig.counts,
                                    dataset: $scope.admin.movementReport.report
                                }
                            );

                            $scope.admin.movementReport.ordersLoaded = true;
                        } else {
                            void 0;
                            toastr.error('Error getting orders history.');
                        }
                    });
            },
            getEndDate: function(dateObj) {
                if ($scope.admin.movementReport.reportType === 'daily') {
                    return Object.assign({}, dateObj.startDate);
                }
                if ($scope.admin.movementReport.reportType === 'weekly') {
                    var startTime = new Date(dateObj.startDate.year, dateObj.startDate.month, dateObj.startDate.day).getTime();
                    var endDate = new Date(startTime + 7 * 24 * 60 * 60 * 1000 - 1000);
                    return {
                        day: endDate.getDate(),
                        month: endDate.getMonth(),
                        year: endDate.getFullYear(),
                    };
                }
                if ($scope.admin.movementReport.reportType === 'monthly') {
                    var endDate = Object.assign({}, dateObj.startDate);
                    if (dateObj.startDate.month < 11) {
                        endDate.month += 1;
                    } else {
                        endDate.month = 0;
                        endDate.year += 1;
                    }
                    var endTime = new Date(endDate.year, endDate.month, endDate.day).getTime();
                    endTime -= 1000;
                    endDate = new Date(endTime);
                    return {
                        day: endDate.getDate(),
                        month: endDate.getMonth(),
                        year: endDate.getFullYear(),
                    };
                }
            },
            processOrders(orders) {
                var products = {};
                var firstOrderDate = 32503708800000; // Jan 01 3000 - just to find min, max for order dates
                var lastOrderDate = 0;

                for (var order of orders) {
                    if (!['Completed'].includes(order.state)) continue; // possible ['Completed', 'Received', 'Cancelled', 'Processed']

					var msec = 0;
					if (hsUtils.isString(order.deliveryTimeMsec)) {
						msec = order.deliveryTimeMsec.split('-')[0];
					} else if (hsUtils.isNumber(order.deliveryTimeMsec)){
						msec = order.deliveryTimeMsec;
					}

					if (msec > 0) {
						firstOrderDate = Math.min(firstOrderDate, msec);
						lastOrderDate = Math.max(lastOrderDate, msec);
					}

                    for (var item of order.items) {
                        if (!products[item.name]) {
                            products[item.name] = {
                                upc: item.upc || '',
                                name: item.name,
                                displayName: item.displayName,
                                category: item.type,
                                subCategory: item.subType,
                                quantity: item.quantity,
                                total: item.itemizedPrice,
                            };
                        } else {
                            products[item.name].quantity += item.quantity;
                            products[item.name].total += item.itemizedPrice;
                        }
                    }
                }
                var firstOrderDateStr = 'none';
                if (firstOrderDate !== 32503708800000) {
                    firstOrderDate = new Date(firstOrderDate);
                    firstOrderDateStr = (firstOrderDate.getMonth() + 1) + '-' + firstOrderDate.getDate() + '-' + firstOrderDate.getFullYear();
                }
                var lastOrderDateStr = 'none';
                if (lastOrderDate !== 0) {
                    lastOrderDate = new Date(lastOrderDate);
                    lastOrderDateStr = (lastOrderDate.getMonth() + 1) + '-' + lastOrderDate.getDate() + '-' + lastOrderDate.getFullYear();
                }
                void 0;
                void 0;

                return Object.values(products).map(function(product) {
                    product.total = parseFloat(product.total.toFixed(2));
                    product.quantity = parseFloat(product.quantity.toFixed(2));
                    return product;
                });
            },
        },
	    syncPrices: {
		    showPopup(data) {
			    ngDialog.open({
				    template: '/partials/popup/sync-prices/sync-prices-popup.html',
				    controller: 'ModalController',
				    className: 'ngdialog-theme-default email-capture',
				    scope: $scope,
				    data: data,
			    });
			},
			showConfirmation(data) {
				ngDialog.open({
					template: '/partials/popup/sync-prices/sync-prices-popup-confirmation.html',
				    controller: 'ModalController',
				    className: 'ngdialog-theme-default email-capture',
				    scope: $scope,
				    data: data,
				});
			},
			enable() {
				if ($rootScope.currentUser.isAdmin && !$rootScope.currentUser.isAdminRestricted
					&& ENV.enablePriceSync && ENV.enableLocations
				) {
					$scope.admin.config.showSyncPrices = true;
				}
			},
	    },
		syncProducts: {
			showPopup(productInfo) {
				var adminUserLocations = globalFunctions.getUserAdminLocations();
				if (ENV.enableLocations && $rootScope.location && $rootScope.location.allLocations && $rootScope.location.selectedLocation
					&& adminUserLocations.length >= 1
					&& globalFunctions.getTruthyProductKeys(productInfo).length > 1 && productInfo.name)
				{
					hsDialog.openSyncProductDialog(productInfo, adminUserLocations);
				}
			}
		},
		syncProductPopup: {
			elementId: 'sync-product-popup',
			dataToPropagate: null,
			openPopupOrContinue: function(closeThisDialog) {
				var elementId = $scope.admin.syncProductPopup.elementId;
				if (hsAdmin.shouldShowSyncPriceListsPopup()) {
					$('#' + elementId).on('hidden.bs.modal', function(e) {
						$scope.admin.syncProductPopup.handleUpdateCompletion(closeThisDialog);
						$scope.$apply();
					});
					$('#' + elementId).modal('show');
				} else {
					$scope.admin.syncProductPopup.handleUpdateCompletion(closeThisDialog);
				}
			},
			propagateUpdateToTarget: function(target) {
				return hsAdmin.updateProduct($scope.admin.syncProductPopup.dataToPropagate, target);
			},
			isThrowableResponse: function(res) {
				return res.status !== 200;
			},
			handleUpdateCompletion: function(closeThisDialog) {
				if (closeThisDialog && typeof closeThisDialog === 'function') {
					closeThisDialog({ product: $scope.admin.condenseProductData($scope.admin.syncProductPopup.dataToPropagate) });
				}
			},
		},
		resetUnitQuantity: function() {
			$scope.admin.productData.product.unitQuantity = '1';
		},
        locationSettings: {
            loading: false,
            selected: '',
            selectedWeekday: null,
            availableFulfillment: [],
            maxDistanceChoices: {
                'US': {
                    // miles: meters,
                    3: 4828,
                    5: 8047,
                    8: 12875,
                    10: 16094,
                    15: 24141,
                },
                'CA': {
                    // km: meters
                    5: 5000,
                    8: 8000,
                    10: 10000,
                    15: 15000,
                }
            },
			configNameToDistances: {
				'US':{
					threeMiles: 3,
					fiveMiles: 5,
					eightMiles: 8,
					tenMiles: 10,
					fifteenMiles: 15,
				},
				'CA': {
					fiveKilometers: 5,
					eightKilometers: 8,
					tenKilometers: 10,
					fifteenKilometers: 15,
				}
            },
            selectedConfigName: '',
            selectedDeliveryProvider: 'postmates', // hard coded for now, but should change when we can support multiple delivery providers per tenant. 
            hasExceptionCitiesOrZips: false,
            allowedCitiesInputField: '',
            allowedZipcodesInputField: '',
            autocompleteOptions: {
                componentRestrictions: { country: $rootScope.country || 'US' },
                types: ['(cities)'],
            },
            slotStartTime: null,
            slotStartTimeIndex: 0,
            slotEndTime: null,
            slotCutoffTime: null,
            slotMaxOrdersPerSlot: '',
            editingSlot: null,
            weekday: {
                slotStartTime: null,
                slotStartTimeIndex: 0,
                slotEndTime: null,
                slotCutoffTime: null,
                slotMaxOrdersPerSlot: '',
                open: {
                    Monday: true,
                    Tuesday: true,
                    Wednesday: true,
                    Thursday: true,
                    Friday: true,
                    Saturday: true,
                    Sunday: true,
                },
                editingSlot: null,
            },
            timeOptions: ['Midnight','1AM','2AM','3AM','4AM','5AM','6AM','7AM','8AM','9AM','10AM','11AM','Noon','1PM','2PM','3PM','4PM','5PM','6PM','7PM','8PM','9PM','10PM','11PM','Midnight'],
            dayOptions: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
            hoursDay: null,
            hoursOpen: null,
            hoursOpenIndex: 0,
            hoursClosed: null,
            addressInputField: {},
            addressWasAutoFilled: false,
			availableProvidersDisplayNames: null,
			availableProvidersMapping: null,
			selectedProvider: null,
            init: function() {
                if (!ENV.enableLocations || $rootScope.location) {
                    $http.get(ENV.apiEndPoint + '/location')
                        .then(function(res) {
							if (res.status === 200) {
                                $scope.admin.locationSettings.loadSettings(res.data);
                            } else {
                                toastr.error('Error Retrieving Location');
                            }
                            $scope.admin.config.pageFullyLoaded = true;
                        });
                } else {
                    if (!$rootScope.$$listeners.locationUpdated.includes($scope.admin.locationSettings.init)) {
                        var deregister = $rootScope.$on('locationUpdated', $scope.admin.locationSettings.init);
                        $scope.$on('$destroy', deregister);
                    }
                }
            },
			resetPreferredProvider: function() {
				for (var provider of $scope.admin.locationSettings.providerListForSorting) {
					if (provider.preferred) {
						provider.preferred = false;
					}
				}
			},
			onDeliveryProviderChanges: function(updateParams) {
				$scope.admin.locationSettings.resetPreferredProvider();

				if (updateParams && hsUtils.isObject(updateParams)) {

					var event = updateParams.event;
					var idx = updateParams.idx;

					if (event === 'enable') {
						$scope.admin.locationSettings.providerListForSorting[idx].enabled = true;
					} else if (event === 'disable') {
						if ($scope.admin.locationSettings.allowDisable()) {
							$scope.admin.locationSettings.providerListForSorting[idx].enabled = false;
						} else {
							toastr.error("Cannot disable delivery provider. Atleast one provider must be enabled.");
							return;
						}
					}
				}

				for (var provider of $scope.admin.locationSettings.providerListForSorting) {
					if (provider.enabled) {
						provider.preferred = true;
						break;
					}
				}
				$scope.admin.locationSettings.LocationSettingsForm.$setDirty();
			},
			allowDisable: function () {
				var enableCount = 0;

				for (var provider of $scope.admin.locationSettings.providerListForSorting) {
					if (provider.enabled){
						enableCount++;
					}
				}
				return enableCount > 1;
			},
			showDoordashDisclaimer: function() {

				var isDoordashEnabled = false;

				for (var provider of $scope.admin.locationSettings.providerListForSorting) {
					if (provider.name === 'doordash' && provider.enabled) {
						isDoordashEnabled = true;
						break;
					}
				}
				return $scope.admin.locationSettings.selectedConfigName === 'threeMiles' && isDoordashEnabled;
			},
            setCountrySelectedProvider: function () {
                if ($rootScope.country === 'CA') {
                    $scope.admin.locationSettings.selectedDeliveryProvider = 'uberDaas'
                }
            },
            loadSettings: function(location) {

                if (!location) return;

                $scope.admin.locationSettings.data = {
                    email: location.email,
                    orderNotificationEmail: location.orderNotificationEmail,
                    orderNotificationEmailSameAsEmail: location.orderNotificationEmailSameAsEmail ? true : false,
                    phoneNumber: location.phone,
                    operatingHours: location.operatingHours ? location.operatingHours.slice() : [],
                    address: location.address,
                    latitude: location.latitude,
                    longitude: location.longitude,
                    bagFee: location.bagFee,
                    enableBagsBarcodes: location.enableBagsBarcodes,
                    taxRate: location.taxRate ? parseFloat((location.taxRate * 100).toFixed(3)) : 0,
                    slotsOverrides: location.slotsOverrides ? JSON.parse(JSON.stringify(location.slotsOverrides)) : {}, 
                };

				$scope.admin.locationSettings.data.enableShopByDiet = location.hasOwnProperty('enableShopByDiet') ? location.enableShopByDiet : true;

				// if (hsUtils.isObject(location.address)) {
				// 	$scope.admin.locationSettings.addressInputField = {
				// 		street: location.address.street,
				// 		aptUnit: location.address.aptUnit,
				// 		city: location.address.city,
				// 		state: location.address.state,
				// 		zip: location.address.zip,
				// 	};
				// 	$scope.admin.locationSettings.addressWasAutoFilled = true;
				// }
				
                if (location.fulfillment && location.fulfillment.delivery && location.fulfillment.delivery.deliveryProviderConfigs) {
                    $scope.admin.locationSettings.data.deliveryProviderConfigs = location.fulfillment.delivery.deliveryProviderConfigs;

                    Object.keys($scope.admin.locationSettings.data.deliveryProviderConfigs).forEach(function (provider) {
                        Object.keys($scope.admin.locationSettings.data.deliveryProviderConfigs[provider]).forEach(function (radius) {
                            var configSettings = $scope.admin.locationSettings.data.deliveryProviderConfigs[provider][radius];
                            var serviceFeeRate = parseFloat(configSettings.serviceFeeRate);
                            configSettings.serviceFeeRate = !isNaN(serviceFeeRate) ? parseFloat((serviceFeeRate * 100).toFixed(2)) : 0;
                        });
                    });

                    //Convert US settings to CA settings (TEMP)
                    if ($rootScope.country === 'CA' && $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates']
                    && !$scope.admin.locationSettings.data.deliveryProviderConfigs['uberDaas']) {
                        var newConfig =  {
                            fiveKilometers: $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates'].threeMiles,
                            eightKilometers: $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates'].fiveMiles,
                            tenKilometers: $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates'].eightMiles,
                            fifteenKilometers: $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates'].tenMiles,
                        }
                        newConfig.fiveKilometers.maxDistance = 5000;
                        newConfig.eightKilometers.maxDistance = 8000;
                        newConfig.tenKilometers.maxDistance = 10000;
                        newConfig.fifteenKilometers.maxDistance = 15000;
                        newConfig.default = newConfig.fifteenKilometers;
                        $scope.admin.locationSettings.data.deliveryProviderConfigs['uberDaas'] = newConfig;
                        delete $scope.admin.locationSettings.data.deliveryProviderConfigs['postmates'];
                        location.deliveryProviders = ['uberDaas'];
                    }


                    $scope.admin.locationSettings.setCountrySelectedProvider();

                    void 0;
                    
                    var firstFoundConfig = $scope.admin.locationSettings.selectedConfigName
                    if (!firstFoundConfig) {
                        var country = $rootScope.country;
                        firstFoundConfig = Object.keys($scope.admin.locationSettings.configNameToDistances[country]).find(function(key) {
                            return key in $scope.admin.locationSettings.data.deliveryProviderConfigs[$scope.admin.locationSettings.selectedDeliveryProvider];
                        });
                    }
                    $scope.admin.locationSettings.updateSelectedDeliveryConfig(firstFoundConfig);
                }
                var slots = [];
                // This code is intended only as initialization of slots before the first save.
                // After first save, location and fulfillment slots would be consistent.
                if (location.slots) {
                    slots = location.slots;
                } else {
                    if (location.fulfillment.delivery && location.fulfillment.delivery.slots) {
                        slots = location.fulfillment.delivery.slots;
                    } else if (location.fulfillment.pickup && location.fulfillment.pickup.slots) {
                        slots = location.fulfillment.pickup.slots;
                    }
                }
                $scope.admin.locationSettings.data.slots = slots.slice();

                var closedWeekdays = [];
                if (location.closedWeekdays) {
                    closedWeekdays = location.closedWeekdays;
                } else {
                    if (location.fulfillment.delivery && location.fulfillment.delivery.closedWeekdays) {
                        closedWeekdays = location.fulfillment.delivery.closedWeekdays;
                    } else if (location.fulfillment.pickup && location.fulfillment.pickup.closedWeekdays) {
                        closedWeekdays = location.fulfillment.pickup.closedWeekdays;
                    }
                }
                closedWeekdays.forEach(function(weekday) {
                    $scope.admin.locationSettings.weekday.open[weekday] = false;
                });
                // Eventhough we turned off volume limits inputs in UI, keeping the initialization as it was
                var maxOrdersPerSlot = 10;
                var maxOrdersPerDay = 10;
                if (location.volumeLimits) {
                    maxOrdersPerDay = location.volumeLimits.maxOrdersPerDay;
                    maxOrdersPerSlot = location.volumeLimits.maxOrdersPerSlot;
                } else if (location.priceLists && location.priceLists[0] && location.priceLists[0].volumeLimits) {
                    maxOrdersPerDay = location.priceLists[0].volumeLimits.maxOrdersPerDay;
                    maxOrdersPerSlot = location.priceLists[0].volumeLimits.maxOrdersPerSlot;
                }
                $scope.admin.locationSettings.data.maxOrdersPerDay = maxOrdersPerDay;
                $scope.admin.locationSettings.data.maxOrdersPerSlot = maxOrdersPerSlot;

                // This is here becuse we turned off volume limits. Need to set maxOrdersPerSlot on each slot
                // Remove if it is going to be turned on
                $scope.admin.locationSettings.tempSlotsInit();

                if (location.fulfillment.pickup) {
                    var pickupSettings = {
                        offerFreePickup: location.fulfillment.pickup.noFeeFulfillmentAllowed ? true : false,
                        pickupFee: location.fulfillment.pickup.fee,
                        minimumOrderForFreePickup: location.fulfillment.pickup.minOrderWithNoFee,
                        pickupMinimumOrder: location.fulfillment.pickup.minOrder,
                        pickupServiceFee: location.fulfillment.pickup.serviceFeeRate
                            ? parseFloat((location.fulfillment.pickup.serviceFeeRate * 100).toFixed(2)) : 0,
                    };
                    Object.assign($scope.admin.locationSettings.data, pickupSettings);
                    $scope.admin.locationSettings.availableFulfillment.push('pickup');
                }
                if (location.fulfillment.delivery) {

					$scope.admin.locationSettings.data.deliveryProviders = location.deliveryProviders;
					$scope.admin.locationSettings.availableProvidersDisplayNames = location.deliveryProviderDisplayNames;
					$scope.admin.locationSettings.availableProvidersMapping = location.allDeliveryProviders;

                    var deliverySettings = {
                        offerFreeDelivery: location.fulfillment.delivery.noFeeFulfillmentAllowed ? true : false,
                        deliveryFee: location.fulfillment.delivery.fee,
                        minimumOrderForFreeDelivery: location.fulfillment.delivery.minOrderWithNoFee,
                        deliveryMinimumOrder: location.fulfillment.delivery.minOrder,
                        deliveryServiceFee: location.fulfillment.delivery.serviceFeeRate
                            ? parseFloat((location.fulfillment.delivery.serviceFeeRate * 100).toFixed(2)) : 0,
                        maxDistance: location.fulfillment.delivery.maxDistance,
                        allowedCities: (location.fulfillment.delivery.exceptionCities || []).slice().sort(),
                        allowedCitiesDisplay: Object.assign({}, location.fulfillment.delivery.exceptionCitiesDisplay),
                        allowedZipcodes: (location.fulfillment.delivery.exceptionZipcodes || []).slice().sort(),
                    };
                    Object.assign($scope.admin.locationSettings.data, deliverySettings);

					var enabledProviders = [];
					var disabledProviders = [];

					for (var provider of location.deliveryProviders) {
						enabledProviders.push({
							name: provider,
							enabled: true,
							preferred: false,
						});
					}

					for (var provider in location.deliveryProviderDisplayNames) {
						if (!location.deliveryProviders.includes(provider)) {
							disabledProviders.push({
								name: provider,
								enabled: false,
								preferred: false,
							});
						}
					}

					$scope.admin.locationSettings.providerListForSorting = [].concat(enabledProviders, disabledProviders);
					$scope.admin.locationSettings.providerListForSorting[0].preferred = true;

					$scope.admin.locationSettings.availableFulfillment.push('delivery');
                }
                if (!$scope.admin.locationSettings.selected) {
                    $scope.admin.locationSettings.selected = $scope.admin.locationSettings.availableFulfillment[0];
                }

                $scope.admin.locationSettings.checkCitiesDisplayListConsistency();
                $scope.admin.config.pageFullyLoaded = true;

                var deregisterLocationChangeStart = $rootScope.$on("$locationChangeStart", function(event, next, current) {
                    var form = $scope.admin.locationSettings.LocationSettingsForm;
                    if (form && form.$dirty) {
                        event.preventDefault();
                        ngDialog.openConfirm({
                            data: {
                                heading: 'Unsaved Changes',
                                subHeading: 'The changes you made will be lost if you reload or navigate away from this page.',
                                confirmBtnText: 'Continue',
                                cancelBtnText: 'Cancel'
                            },
                            template: 'partials/popup/confirm-popup.html'
                        }).then(function (confirm) {
                            deregisterLocationChangeStart();
                            $location.path(next.replace(window.location.origin, ''));

                        }, function (reject) {});
                    }
                });
                $scope.$on('$destroy', deregisterLocationChangeStart);
            },
            tempSlotsInit() {
                for (var slot of $scope.admin.locationSettings.data.slots) {
                    if (typeof slot.maxOrdersPerSlot !== 'number') {
                        slot.maxOrdersPerSlot = $scope.admin.locationSettings.data.maxOrdersPerSlot;
                    }
                }
                for (var weekday of Object.values($scope.admin.locationSettings.data.slotsOverrides)) {
                    if (weekday.slots) {

                        for (var slot of weekday.slots) {
                            if (typeof slot.maxOrdersPerSlot !== 'number') {
                                slot.maxOrdersPerSlot = $scope.admin.locationSettings.data.maxOrdersPerSlot;
                            }
                        }
                    }
                }
            },
            saveForm: function() {
                $scope.$broadcast('validateAddress-location-settings', function(isValid) {
                    if (!isValid) {
                        toastr.error("Form contains invalid fields. Please correct before continuing.");
                        return;
                    }
                    
                    var data = $scope.admin.locationSettings.data;
                    var locationSettings = {
                        email: data.email,
                        orderNotificationEmail: data.orderNotificationEmail,
                        orderNotificationEmailSameAsEmail: data.orderNotificationEmailSameAsEmail,
                        phone: data.phoneNumber,
                        operatingHours: data.operatingHours,
                        address: data.address,
                        latitude: data.latitude,
                        longitude: data.longitude,
                        bagFee: data.bagFee,
                        enableBagsBarcodes: data.enableBagsBarcodes,
                        taxRate: data.taxRate ? parseFloat((data.taxRate / 100).toFixed(5)) : 0,
                        slots: angular.copy(data.slots),
                        // With each slot having its own maxOrdersPerSlot, it seems unnecessary.
                        // Commented out because it interferes
                        volumeLimits: {
                            // changing due to turned off volume limits
                            // maxOrdersPerDay: data.maxOrdersPerDay,
                            maxOrdersPerDay: $scope.admin.locationSettings.getDailyVolume(),
                            maxOrdersPerSlot: data.maxOrdersPerSlot,
                        },
                        closedWeekdays: [],
                        slotsOverrides: {},
                        fulfillment: {},
                    };
                    if (locationSettings.slots.length) {
                        var hour = data.slots.reduce(function(acc, slot) {
                            if (slot.cutoffHour > acc) return slot.cutoffHour;
                            return acc;
                        }, 0);
                        locationSettings.globalCutoffHour = hour;
                    } else if (!ENV.isRestaurant) {
                        return toastr.error('You have to have at least one slot defined to save.');
                    }
                    $scope.admin.locationSettings.dayOptions.forEach(function(weekday) {
                        if (!$scope.admin.locationSettings.weekday.open[weekday]) {
                            locationSettings.closedWeekdays.push(weekday);
                        }
                    });
                    angular.forEach($scope.admin.locationSettings.data.slotsOverrides, function(val, weekday) {
                        void 0
                        var weekdayObj = {};
                        if (val.volumeLimits) {
                            weekdayObj.volumeLimits = val.volumeLimits;
                        }
                        // Adding this due to turned off volume limits
                        // Need to have explicit maximums set up for a weekday, otherwise location overrrides daily max.
                        weekdayObj.volumeLimits = {
                            maxOrdersPerDay: $scope.admin.locationSettings.getWeekdayDailyVolume(weekday),
                            maxOrdersPerSlot: 10, // this is an arbitrary default value
                        };
                        if (val.slots && val.slots.length) {
                            weekdayObj.slots = val.slots;
                            var hour = val.slots.reduce(function(acc, slot) {
                                if (slot.cutoffHour > acc) return slot.cutoffHour;
                                return acc;
                            }, 0);
                            weekdayObj.globalCutoffHour = hour;
                        } else {
                            // This is added due to turned off volume limits. Need to delete volume limits
                            // from custom slots because they have an effect, but can't be modified
                            delete weekdayObj.volumeLimits;
                        }
                        if (Object.keys(weekdayObj).length) {
                            locationSettings.slotsOverrides[weekday] = weekdayObj;
                        }
                    });
                    if ($scope.admin.locationSettings.availableFulfillment.includes('pickup')) {
                        locationSettings.fulfillment.pickup = {
                            noFeeFulfillmentAllowed: data.offerFreePickup,
                            fee: data.pickupFee,
                            minOrderWithNoFee: data.minimumOrderForFreePickup,
                            minOrder: data.pickupMinimumOrder,
                            serviceFeeRate: data.pickupServiceFee ? parseFloat((data.pickupServiceFee / 100).toFixed(4)) : 0,
                        };
                    }
                    if ($scope.admin.locationSettings.availableFulfillment.includes('delivery')) {
                        // need a fresh copy so when we mutate data in this obj, what's rendered to the user doesn't also change
                        var deliveryProviderConfigs = JSON.parse(JSON.stringify($scope.admin.locationSettings.data.deliveryProviderConfigs));
    
                        var sortedProviders = [];
                        for (var provider of $scope.admin.locationSettings.providerListForSorting) {
                            if (provider.enabled) {
                                sortedProviders.push(provider.name);
                            }
                        }
    
                        if (!sortedProviders.length) {
                            toastr.error("You must select atleast one delivery provider. Please select atleast one delivery provider and try saving again.");
                            return;
                        }
        
                        locationSettings.deliveryProviders = sortedProviders;
                        
                        var maxDistance;
                        var country = globalFunctions.getCountry();
                        var currentDeliveryProviderConfigs = deliveryProviderConfigs[$scope.admin.locationSettings.selectedDeliveryProvider];
                        
                        Object.keys(currentDeliveryProviderConfigs).forEach(function (key) {
    
                            if (currentDeliveryProviderConfigs[key].enabled) {
                                var currDistanceMiles = $scope.admin.locationSettings.configNameToDistances[country][key];
                                var currDistanceMeters = $scope.admin.locationSettings.maxDistanceChoices[country][currDistanceMiles] || 0;
                                maxDistance = Math.max(maxDistance || 0, currDistanceMeters);
                            }
    
                            var serviceFeeRate = currentDeliveryProviderConfigs[key].serviceFeeRate;
                            if (!serviceFeeRate) {
                                currentDeliveryProviderConfigs[key].serviceFeeRate = 0;
                            } else {
                                currentDeliveryProviderConfigs[key].serviceFeeRate = parseFloat((serviceFeeRate / 100).toFixed(4));
                            }
                        });
    
                        if (maxDistance) {
                            currentDeliveryProviderConfigs.default.maxDistance = maxDistance;
                        } else {
                            scrollToElement('#deliverySettings');
                            toastr.error('At least one delivery radius must offer delivery. Please enable one and try saving again.')
                            return;
                        }
                                
                        // normalize settings
                        for (var provider of Object.keys($scope.admin.locationSettings.availableProvidersDisplayNames)) {
                            if (provider !== $scope.admin.locationSettings.selectedDeliveryProvider) {
                                deliveryProviderConfigs[provider] = currentDeliveryProviderConfigs;
                            }
                        }

                        locationSettings.fulfillment.delivery = {
                            maxDistance: maxDistance,
                            exceptionCities: data.allowedCities,
                            exceptionCitiesDisplay: data.allowedCitiesDisplay,
                            exceptionZipcodes: data.allowedZipcodes,
                            deliveryProviderConfigs: deliveryProviderConfigs,
                        };
                    }

                    locationSettings.enableShopByDiet = data.enableShopByDiet;

                    hsAdmin.saveLocationSettings({ locationSettings: locationSettings }).then(function (res) {
                        if (res.status === 200) {
                            toastr.success('Location settings saved successfully.');
                            $scope.admin.locationSettings.selectedWeekday = null;
                            $scope.admin.locationSettings.LocationSettingsForm.$setPristine();

                            if (ENV.enableLocations) {
                                $scope.admin.locationSettings.updateLocation($rootScope.location.selectedLocation.uniqueName);
                            }
                        } else {
                            toastr.error("Couldn't save setting. Please check the values and try again.");
                        }
                    });
                });
            },
            selectFulfillment: function(tab) {
                $scope.admin.locationSettings.selected = tab;
            },
            initCustomSlots(weekday) {
                if (!$scope.admin.locationSettings.data.slotsOverrides[weekday]) {
                    $scope.admin.locationSettings.data.slotsOverrides[weekday] = {};
                }
                var settings = $scope.admin.locationSettings.data.slotsOverrides[weekday];
                if (!settings.slots) {
                    settings.slots = angular.copy($scope.admin.locationSettings.data.slots);
                } else {
                    delete settings.slots;
                    // Since volume limits are not visible in UI but were created,
                    // need to delete it
                    delete settings.volumeLimits;
                }
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            initCustomLimits(weekday) {
                if (!$scope.admin.locationSettings.data.slotsOverrides[weekday]) {
                    $scope.admin.locationSettings.data.slotsOverrides[weekday] = {};
                }
                var settings = $scope.admin.locationSettings.data.slotsOverrides[weekday];
                if (!settings.volumeLimits) {
                    settings.volumeLimits = {
                        maxOrdersPerDay: $scope.admin.locationSettings.data.maxOrdersPerDay,
                        maxOrdersPerSlot: $scope.admin.locationSettings.data.maxOrdersPerSlot,
                    };
                } else {
                    delete settings.volumeLimits;
                }
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            toggleWeekdayEdit(weekday) {
                if ($scope.admin.locationSettings.selectedWeekday === weekday) {
                    $scope.admin.locationSettings.selectedWeekday = null;
                } else {
                    $scope.admin.locationSettings.selectedWeekday = weekday;
                }
            },
            isCustomSlots(weekday) {
                return (weekday in $scope.admin.locationSettings.data.slotsOverrides
                    && $scope.admin.locationSettings.data.slotsOverrides[weekday].slots);
            },
            isCustomLimits(weekday) {
                return (weekday in $scope.admin.locationSettings.data.slotsOverrides
                    && $scope.admin.locationSettings.data.slotsOverrides[weekday].volumeLimits);
            },
            getWeekdayCustomStatus(weekday) {
                return $scope.admin.locationSettings.isCustomLimits(weekday) || $scope.admin.locationSettings.isCustomSlots(weekday);
            },
            getWeekdayDailyVolume(weekday) {
                var defaultSlotMax = 0;
                if ($scope.admin.locationSettings.data.slotsOverrides[weekday].volumeLimits) {
                    defaultSlotMax = $scope.admin.locationSettings.data.slotsOverrides[weekday].volumeLimits.maxOrdersPerSlot;
                } else if($scope.admin.locationSettings.data.volumeLimits) {
                    defaultSlotMax = $scope.admin.locationSettings.data.volumeLimits.maxOrdersPerSlot;
                }
                defaultSlotMax = isNaN(defaultSlotMax) ? 0 : defaultSlotMax;

                var slots;
                if ($scope.admin.locationSettings.data.slotsOverrides[weekday].slots
                    && $scope.admin.locationSettings.data.slotsOverrides[weekday].slots.length
                ) {
                     slots = $scope.admin.locationSettings.data.slotsOverrides[weekday].slots;
                } else {
                     slots = $scope.admin.locationSettings.data.slots;
                }

                return slots.reduce(function(acc, slot) {
                    acc += typeof slot.maxOrdersPerSlot === 'number' ? slot.maxOrdersPerSlot : defaultSlotMax;
                    return acc;
                }, 0);
            },
            getDailyVolume() {
                var slotVolume = $scope.admin.locationSettings.data.maxOrdersPerSlot;
                slotVolume = isNaN(slotVolume) ? 0 : slotVolume;

                return $scope.admin.locationSettings.data.slots.reduce(function(acc, slot) {
                    acc += typeof slot.maxOrdersPerSlot === 'number' ? slot.maxOrdersPerSlot : slotVolume;
                    return acc;
                }, 0);
            },
            selectOpenHour: function() {
                var short = $scope.admin.locationSettings;
                if (short.hoursOpen === 'Closed') {
                    short.hoursClosed = '';
                    return;
                }
                short.hoursOpenIndex = short.timeOptions.indexOf(short.hoursOpen);
                var hoursClosedIndex = short.timeOptions.lastIndexOf(short.hoursClosed);
                if (!short.hoursClosed || hoursClosedIndex <= short.hoursOpenIndex) {
                    short.hoursClosed = short.timeOptions[short.hoursOpenIndex + 1];
                }
            },
            addHours() {
                if (!$scope.admin.locationSettings.hoursDay || !$scope.admin.locationSettings.hoursOpen
                    || !($scope.admin.locationSettings.hoursClosed || $scope.admin.locationSettings.hoursOpen === 'Closed')
                ) {
                    return;
                }
                var short = $scope.admin.locationSettings;
                var hours = {
                    day: short.hoursDay,
                    hours: short.hoursOpen === 'Closed' ? 'Closed' : short.hoursOpen + ' - ' + short.hoursClosed,
                };
                var foundIndex = short.data.operatingHours.findIndex(function(elem) {
                    if (hours.day === elem.day) return true;
                });
                if (~foundIndex) {
                    short.data.operatingHours[foundIndex] = hours;
                } else {
                    short.data.operatingHours.push(hours);
                }
                short.data.operatingHours.sort(function(a, b) {
                    var aIndex = short.dayOptions.indexOf(a.day);
                    var bIndex = short.dayOptions.indexOf(b.day);
                    if (aIndex > bIndex) return 1;
                    if (aIndex < bIndex) return -1;
                    return 0;
                });
                short.hoursDay = null;
                short.hoursOpen = null;
                short.hoursOpenIndex = 0;
                short.hoursClosed = null;
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            removeHours(index) {
                var short = $scope.admin.locationSettings;
                short.data.operatingHours.splice(index, 1);
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            selectStartTimeSlot: function(weekday) {
                var timeOptions = $scope.admin.locationSettings.timeOptions;
                var short = $scope.admin.locationSettings;
                if (weekday) {
                    short = $scope.admin.locationSettings.weekday;
                }
                short.slotStartTimeIndex = timeOptions.indexOf(short.slotStartTime);
                var endTimeIndex = timeOptions.lastIndexOf(short.slotEndTime);
                if (!short.slotEndTime || endTimeIndex <= short.slotStartTimeIndex) {
                    short.slotEndTime = timeOptions[short.slotStartTimeIndex + 1];
                }
                if (!short.slotCutoffTime || timeOptions.indexOf(short.slotCutoffTime) > short.slotStartTimeIndex) {
                    var slotCutoffTimeIndex = short.slotStartTimeIndex ? short.slotStartTimeIndex - 1 : 0;
                    short.slotCutoffTime = timeOptions[slotCutoffTimeIndex];
                }
                // this is here due to turned of volume limits. Need to set the max orders to something
                if (!short.slotMaxOrdersPerSlot) {
                    short.slotMaxOrdersPerSlot = $scope.admin.locationSettings.data.maxOrdersPerSlot;
                }
            },
            addSlot(weekday) {
                var timeOptions = $scope.admin.locationSettings.timeOptions;
                var short = $scope.admin.locationSettings;
                var slots = short.data.slots;

                if (weekday) {
                    short = $scope.admin.locationSettings.weekday;
                    slots = $scope.admin.locationSettings.data.slotsOverrides[weekday].slots;
                }
                if (!short.slotStartTime || !short.slotEndTime || !short.slotCutoffTime || !short.slotMaxOrdersPerSlot) return;

                var slot = {
                    displayName: short.slotStartTime + ' - ' + short.slotEndTime,
                    cutoffHour: timeOptions.indexOf(short.slotCutoffTime),
                };
                if (typeof short.slotMaxOrdersPerSlot === 'number') {
                    slot.maxOrdersPerSlot = short.slotMaxOrdersPerSlot;
                }
                var foundIndex = slots.findIndex(function(elem) {
                    if (slot.displayName === elem.displayName) return true;
                });
                if (~foundIndex) {
                    slots[foundIndex] = slot;
                } else {
                    slots.push(slot);
                }
                $scope.admin.locationSettings.sortSlots(slots);
                $scope.admin.locationSettings.resetSlotsInput(weekday);
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            resetSlotsInput(weekday) {
                var settings = !weekday ? $scope.admin.locationSettings : $scope.admin.locationSettings.weekday;
                settings.slotStartTime = null;
                settings.slotStartTimeIndex = 0;
                settings.slotEndTime = null;
                settings.slotCutoffTime = null;
                settings.slotMaxOrdersPerSlot = '';
                settings.editingSlot = null;
            },
            sortSlots(slots) {
                var timeOptions = $scope.admin.locationSettings.timeOptions;

                slots.sort(function(a, b) {
                    var aStart = a.displayName.substring(0, a.displayName.indexOf(' '));
                    var bStart = b.displayName.substring(0, b.displayName.indexOf(' '));
                    if (timeOptions.indexOf(aStart) > timeOptions.indexOf(bStart)) return 1;
                    if (timeOptions.indexOf(aStart) < timeOptions.indexOf(bStart)) return -1;

                    var aEnd = a.displayName.substring(a.displayName.lastIndexOf(' ') + 1);
                    var bEnd = b.displayName.substring(b.displayName.lastIndexOf(' ') + 1);
                    if (timeOptions.lastIndexOf(aEnd) > timeOptions.lastIndexOf(bEnd)) return 1;
                    if (timeOptions.lastIndexOf(aEnd) < timeOptions.lastIndexOf(bEnd)) return -1;
                    return 0;
                });
            },
            removeSlot(index, weekday) {
                var slots = $scope.admin.locationSettings.data.slots;
                if (weekday) {
                    slots = $scope.admin.locationSettings.data.slotsOverrides[weekday].slots;
                }
                slots.splice(index, 1);
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            isEditingSlot(weekday) {
                var settings = !weekday ? $scope.admin.locationSettings : $scope.admin.locationSettings.weekday;
                return typeof settings.editingSlot === 'number';
            },
            toggleEditSlot(index, weekday) {
                var timeOptions = $scope.admin.locationSettings.timeOptions;
                var settings = $scope.admin.locationSettings;
                var slot = settings.data.slots[index];

                if (weekday) {
                    settings = $scope.admin.locationSettings.weekday;
                    slot = $scope.admin.locationSettings.data.slotsOverrides[weekday].slots[index];
                }

                if (settings.editingSlot === index) {
                    $scope.admin.locationSettings.resetSlotsInput(weekday);
                } else {
                    settings.editingSlot = index;
                    settings.slotStartTime = slot.displayName.split('-')[0].trim();
                    settings.slotStartTimeIndex = timeOptions.indexOf(settings.slotStartTime);
                    settings.slotEndTime = slot.displayName.split('-')[1].trim();
                    settings.slotCutoffTime = timeOptions[slot.cutoffHour];
                    settings.slotMaxOrdersPerSlot = slot.maxOrdersPerSlot;
                }
            },
            updateSlot(weekday) {
                var timeOptions = $scope.admin.locationSettings.timeOptions;
                var settings = !weekday ? $scope.admin.locationSettings : $scope.admin.locationSettings.weekday;

                if (typeof settings.editingSlot !== 'number') return;
                if (!settings.slotStartTime || !settings.slotEndTime || !settings.slotCutoffTime || !settings.slotMaxOrdersPerSlot) return;

                var slots = !weekday ? settings.data.slots : $scope.admin.locationSettings.data.slotsOverrides[weekday].slots;
                var slot = slots[settings.editingSlot];

                slot.displayName = settings.slotStartTime + ' - ' + settings.slotEndTime;
                slot.cutoffHour = timeOptions.indexOf(settings.slotCutoffTime);
                slot.maxOrdersPerSlot = settings.slotMaxOrdersPerSlot;

                $scope.admin.locationSettings.resetSlotsInput(weekday);
                $scope.admin.locationSettings.sortSlots(slots);
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            getSlotMaxOrdersPerSlot(index, weekday) {
                var short = $scope.admin.locationSettings;
                var slot = short.data.slots[index];
                if (weekday) {
                    slot = $scope.admin.locationSettings.data.slotsOverrides[weekday].slots[index];
                }
                if (typeof slot.maxOrdersPerSlot === 'number') return slot.maxOrdersPerSlot;
                return 'shared';
            },
            addCity: function() {
                var settings = $scope.admin.locationSettings;
                if (!settings.allowedCitiesInputField) {
                    return;
                }
                var city = settings.formatCity(settings.allowedCitiesInputField.formatted_address);
                var normalized = settings.normalizeCity(city);
                if (settings.data.allowedCities.includes(normalized)) {
                    settings.updateNormalizedCityDisplayName(city, normalized);
                    settings.allowedCitiesInputField = '';
                    return;
                }
                settings.data.allowedCities.push(normalized);
                settings.data.allowedCities.sort();
                settings.data.allowedCitiesDisplay[normalized] = city;
                settings.allowedCitiesInputField = '';
                $scope.admin.locationSettings.setHasExceptionCitiesOrZips();
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            updateNormalizedCityDisplayName(city, normalized) {
                if ($scope.admin.locationSettings.data.allowedCitiesDisplay[normalized] !== city) {
                    $scope.admin.locationSettings.data.allowedCitiesDisplay[normalized] = city;
                    $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
                }
            },
            formatCity(city) {
                var cityArray = city.split(',');
                var index = cityArray[1].search(/[A-Z]{2}/);
                var state = '';
                if (index) {
                    state = ', ' + cityArray[1].slice(index, index + 2);
                }
                return cityArray[0] + state;
            },
            normalizeCity(city) {
                return city.split(',')[0].replace(/\s/g, '').toLowerCase();
            },
            removeCity: function(index) {
                var city = $scope.admin.locationSettings.data.allowedCities[index];
                $scope.admin.locationSettings.data.allowedCities.splice(index, 1);
                delete $scope.admin.locationSettings.data.allowedCitiesDisplay[city];
                $scope.admin.locationSettings.setHasExceptionCitiesOrZips();
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            checkCitiesDisplayListConsistency: function() {
                var data = $scope.admin.locationSettings.data;
                if (!data.allowedCities || !data.allowedCities.length) {
                    data.allowedCitiesDisplay = {};
                    return;
                }
                var displayCitiesKeys = Object.keys(data.allowedCitiesDisplay);
                data.allowedCities.forEach(function(city) {
                    if (data.allowedCitiesDisplay.hasOwnProperty(city)) {
                        delete displayCitiesKeys[city];
                    } else {
                        data.allowedCitiesDisplay[city] = city;
                    }
                });
                displayCitiesKeys.forEach(function(city) {
                    delete data.allowedCities[city];
                });
            },
			getZipcodeMinLength: function() {
				var country = $rootScope.country;
				var minLength;

				switch(country) {
					case 'CA':
						minLength = 7;
						break;
					default:
						minLength = 5;
						break;
				}
				return minLength;
			},
			getZipcodeLabel: function() {
				var country = $rootScope.country;
				var zipcodeLabel;

				switch(country) {
					case 'CA':
						zipcodeLabel = 'Allowed Postal Codes';
						break;
					default:
						zipcodeLabel = 'Allowed Zipcodes';
						break;
 				}
				return zipcodeLabel;
			},
			validateZipcode: function(zipcode) {	
				var country = $rootScope.country;
				var isValid;

				switch(country) {
					case 'CA':
						var exp = new RegExp('^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$');
						var evalExp = exp.test(zipcode);
						isValid = {
							value: evalExp, 
							errorMsg: !evalExp ? 'Please enter a valid Canadian postal code': '',
						};
						break;
					default:
						isValid = { 
							value: true, 
							errorMsg: '', 
						};
						break;
				}
				return isValid;
			},
            addZipcode: function() {
                if (!$scope.admin.locationSettings.allowedZipcodesInputField
                    || $scope.admin.locationSettings.LocationSettingsForm.allowedZipcodesInputField.$viewValue.length !== $scope.admin.locationSettings.getZipcodeMinLength()
                ) {
                    return;
                }

				var zipcode = $scope.admin.locationSettings.allowedZipcodesInputField;
				var isValid = $scope.admin.locationSettings.validateZipcode(zipcode);

				if (!isValid.value) {
					toastr.error(isValid.errorMsg);
					return;
				}

                if ($scope.admin.locationSettings.data.allowedZipcodes.includes(zipcode)) {
                    $scope.admin.locationSettings.allowedZipcodesInputField = '';
                    return;
                }
                $scope.admin.locationSettings.data.allowedZipcodes.push(zipcode);
                $scope.admin.locationSettings.data.allowedZipcodes.sort();
				$scope.admin.locationSettings.setHasExceptionCitiesOrZips();
				$scope.admin.locationSettings.LocationSettingsForm.$setDirty();
                $scope.admin.locationSettings.allowedZipcodesInputField = '';
            },
            removeZipcode: function(index) {
                $scope.admin.locationSettings.data.allowedZipcodes.splice(index, 1);
                $scope.admin.locationSettings.setHasExceptionCitiesOrZips();
                $scope.admin.locationSettings.LocationSettingsForm.$setDirty();
            },
            updateLocation: function(locationName) {
                $http.get(ENV.apiEndPoint + '/locations')
                    .then(function(res) {
                        if(res.status === 200) {
                            var selectedLocation;
                            var savedSelectedLocation = localStorageService.get('location');
                            res.data.forEach(function(location) {
                                location['directions'] = $sce.trustAsResourceUrl(
                                    'https://maps.google.com/maps?q='+
                                    location.address.street +' '+
                                    location.address.city +' '+ location.address.state +' '+ location.address.zip
                                );
                                if(locationName === location.uniqueName) {
                                    selectedLocation = location;
                                }
                            });
                            var locationData = {
                                allLocations: res.data,
                                selectedLocation: selectedLocation,
                            };
                            localStorageService.set('location', locationData);
                            $rootScope.$emit('locationUpdated');
                            $scope.admin.locationSettings.init();
                        } else {
                            toastr.error('Error retrieving locations.')
                        }
                    })
                    .catch(function(err) {
                        toastr.error('Error retrieving locations.');
                    });
            },
            getDeliveryProviderConfigs: function () {
                var selectedDeliveryProvider = $scope.admin.locationSettings.selectedDeliveryProvider;
                var config = $scope.admin.locationSettings.data.deliveryProviderConfigs[selectedDeliveryProvider];
                var country = $rootScope.country;
                void 0;
                var orderedKeys = Object.keys($scope.admin.locationSettings.configNameToDistances[country]);
                var ordered = {};
                for (var i = 0; i < orderedKeys.length; i++) {
                    var key = orderedKeys[i];
                    if (key in config) {
                        ordered[key] = config[key];
                    }
                }
                if (config.default) {
                    ordered.default = config.default;
                }
                return ordered;
            },
            updateSelectedDeliveryConfig: function (configName) {
                $scope.admin.locationSettings.selectedConfigName = configName;
                var selectedDeliveryProvider = $scope.admin.locationSettings.selectedDeliveryProvider;
                $scope.admin.locationSettings.selectedDeliveryConfig = $scope.admin.locationSettings.data.deliveryProviderConfigs[selectedDeliveryProvider][configName];
                $scope.admin.locationSettings.setHasExceptionCitiesOrZips();
                void 0;
            },
            getConfigDisplayName: function (configName) {
                var isMobile = $rootScope.screenWidth.xs;
				var country = $rootScope.country;
                if (configName !== 'default') {
					var suffix = country === 'CA' ? 'km' : 'miles';
					if (suffix === 'miles') {
						suffix = isMobile ? 'mi' : 'miles';
					}
                    return $scope.admin.locationSettings.configNameToDistances[country][configName] + ' ' + suffix;
                } 

                return isMobile ? "Add'l" : 'Additional Areas';
            },
            setHasExceptionCitiesOrZips: function () {
                var settings = $scope.admin.locationSettings.data;
                if (!settings || !settings.allowedCities || !settings.allowedZipcodes) {
                    return;
                }
                var hasCities = settings.allowedCities.length > 0;
                var hasZips = settings.allowedZipcodes.length > 0;
                $scope.admin.locationSettings.hasExceptionCitiesOrZips = hasCities || hasZips;
            }
        },
        showItemPopup: function(category, product) {

            var $newScope = $scope.$new(true);
            $newScope.order = $scope.admin.adminData.orderDetails.order;
            $newScope.product = product;
            $newScope.packingPreview = $scope.admin.config.showPackingPreview;

            $newScope.updateItemPriceInOrder = $scope.admin.updateItemPriceInOrder;
            $newScope.updateAddItemQuantity = $scope.admin.updateAddItemQuantity;
            $newScope.updateOrderItemQuantity = $scope.admin.updateOrderItemQuantity;
            $newScope.removeItem = $scope.admin.removeItem;
            $newScope.showAddItemPopup = $scope.admin.adminData.showAddItemPopup;
            $newScope.updatePackedItemQuantity = product.unit === 'lb' && product.sellByQty
                ? $scope.admin.updateSellByQuantityItemQuantity
                : $scope.admin.updatePackedItemQuantity;
            $newScope.updatePackItemQuantity = $scope.admin.updatePackItemQuantity;

            $scope.$watch('admin.adminData.orderDetails.order', function(newValue, oldValue) {
                if (newValue === oldValue) return;

                $newScope.order = newValue;

                // probably item was the only one in this category and it was removed
                if (!newValue.sortedItems[category]) return;

                var index = newValue.sortedItems[category].products.findIndex(function(elem) {
                    return hsCart.isSameItem(product, elem);
                });
                // item was removed
                if (index === -1) return;

                $newScope.product = newValue.sortedItems[category].products[index];
            });

            ngDialog.open({
                template: '<div><admin-order-item '
                    + 'order="order" '
                    + 'product="product" '
                    + 'packing-preview="packingPreview" '
                    + 'on-update-price="updateItemPriceInOrder(order, product, priceId)" '
                    + 'on-change-quantity="updateAddItemQuantity(product, updateType, selector)" '
                    + 'on-update-quantity="updateOrderItemQuantity(order, product, index)" '
                    + 'on-remove-item="removeItem(order, product)" '
                    + 'on-replace-item="showAddItemPopup(product, \'replace\')" '
                    + 'on-pack-quantity="updatePackedItemQuantity(order, product, index, selector)" '
                    + 'on-change-pack-quantity="updatePackItemQuantity(product, updateType, selector)" '
                    + '><admin-order-item/></div>',
                className: 'ngdialog-theme-default ngdialog-full-width ngdialog-admin-product-item-popup',
                plain: true,
                scope: $newScope,
            });
        },
        showSuccessNotification: function(message) {
            $scope.admin.showSuccessfulPackNotification = true;
            $scope.admin.successfulPackNotification = message;

            $timeout(function() {
                $scope.admin.showSuccessfulPackNotification = false;
            }, 1500);
        },
        doesDeliveryRequirePacking: function(argument) {
            return globalFunctions.getSelectedLocation()
                .then(function(location) {
                    return !!location.deliveryRequiresPacking;
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to get location.');
                });
        },
        doesProcessedOrderRequirePacking: function(argument) {
            return globalFunctions.getSelectedLocation()
                .then(function(location) {
                    return !!location.processedOrderRequiresPacking;
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to get location.');
                });
        },
        isOrderForUserEnabled: function() {
            var selectedLocation = globalFunctions.getSelectedLocationFromStorage();
            return hsUtils.isObject(selectedLocation) ? !!selectedLocation.enableOrderForUser : false;
        },
        getProductFields: function(productName) {
            return hsApi.getProduct(productName, true)
                .then(function (productResp) {
					var keysToAdd = ['ingredients', 'marketingCopy', 'modifiers'];
					keysToAdd.forEach(function (key) {
						if (key in productResp) {
							$scope.admin.productData.product[key] = productResp[key];
						}
					});
                })
                .catch(function (error) {
                    void 0;
                });
        },
        canUpdateTip(tipType) {
            var order = $scope.admin.adminData.orderDetails.order;

            var cantUpdate = $rootScope.ENV.disableTip || ['Completed', 'Cancelled'].includes(order.state) ||
							// Temporarily added to hide update tip button for doordash. To be removed once update tip is implemented for doordash in BE
							(order.managedDelivery && order.managedDelivery.deliveryProvider === 'doordash');

            if (cantUpdate) return false;

            if (tipType === 'shopperTip') return true;

            var isDelivery = order.fulfillmentMethod === 'delivery';
            var tipWasSet = !!(order.minus && order.minus.thirdPartyTip);

            if (['tip', 'driverTip'].includes(tipType)) return !isDelivery || !tipWasSet;

            return true;
        },
        setShowChatFlag() {
			return hsConversations.isConversationEnabled().then(function(isEnabled) {
				$scope.admin.config.showChat = isEnabled;
				if (!isEnabled
					&& $scope.admin.adminData.orderDetails.order
					&&  Array.isArray($scope.admin.adminData.orderDetails.order.conversations)) {
						var lastConversation = $scope.admin.adminData.orderDetails.order.conversations[
							$scope.admin.adminData.orderDetails.order.conversations.length - 1
						];
						$scope.admin.config.showChat = (!!lastConversation && !!lastConversation.state && lastConversation.state !== 'closed');
				}
			});
		},
		setAutoSendChatMessage() {
			return hsConversations.isAutoSendMessageEnabled().then(function(isEnabled) {
				$scope.admin.config.autoSendMessageEnabled = isEnabled;
			});
		},
		setPackerRequiredForConversation() {
			return hsConversations.isPackerRequired().then(function(isRequired) {
				$scope.admin.config.packerRequiredForConversation = isRequired;
			});
		},
		initOrderConversationIndex() {
			return hsConversations.initOrdersWithActiveConversations().catch(function(err){
				void 0;
			});
		},
		loginToStoreAdmin: {
			exec() {
				var _this = this;
				var newTab = window.open();
				newTab.document.body.style.cursor = 'wait';

				var url = ENV.apiEndPoint + '/user/login/store-admin';
				$http
					.post(url)
					.then(function (response) {
						if (response.status === 200) {
							var storeAdminUrlLink = response.data;
							newTab.location.href = storeAdminUrlLink;
							newTab.document.body.style.cursor = 'auto';
						} else {
							_this.redirectToErrorPage(newTab);
							void 0;
						}
					})
					.catch(function (error) {
						_this.redirectToErrorPage(newTab);
						void 0;
					})
			},
			redirectToErrorPage(tab) {
				// this will show an error page file that is stored in Store Admin's S3 bucket
				tab.location.href = ENV.storeAdminUrl + '/error.html';
			}
		},
		getLocationInStoreString(locationInStore) {
			var stringArray = [];
			if (locationInStore.aisle) {
				stringArray.push('Aisle: ' + locationInStore.aisle);
			}
			if (locationInStore.section) {
				stringArray.push('Section: ' + locationInStore.section);
			}
			if (locationInStore.shelf) {
				stringArray.push('Shelf: ' + locationInStore.shelf);
			}
			if (locationInStore.position) {
				stringArray.push('Position: ' + locationInStore.position);
			}
			var locationInStoreString = '';
			for (var i = 0; i < stringArray.length; i++) {
				locationInStoreString = locationInStoreString + stringArray[i];
				if(i !== stringArray.length-1) {
					locationInStoreString = locationInStoreString + ' | ';
				}
			}
			return locationInStoreString;
		},
		roundNumber(number) {
			return hsUtils.roundNumber(number);
		},
        getRelevantPromotionForPrice: function (item) {
            return hsPromos.getRelevantPromotionForPrice(item, item.promotion);
        },
		showQRCodeButton: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			if (!hsUtils.isObject(location) || !hsUtils.isObject(location.appConfig) 
				|| typeof location.appConfig.showQRCode !== 'boolean') {
					return false;
			}

			return location.appConfig.showQRCode;
		},
		generatePickingAppBarcode: function() {

			var encodingData = ENV.APIKey;
			var title = 'Picking App QR Code';
			var $newScope = $scope.$new(true);
            $newScope.encodingData = encodingData;
			$newScope.title = title;
			
			ngDialog.open({
				template: '<div><qr-code '
					+ 'encoding-data="encodingData" '
					+ 'title="title" '
					+ '</qr-code></div>',
				className: 'ngdialog-theme-default ngdialog-theme-fixed-height',
				plain: true,
				scope: $newScope,
			});
		},
		redirectToTrackDelivery: function() {
			var url = $scope.admin.adminData.orderDetails.order.managedDelivery.trackingUrl;

			if (hsPickingApp.isWrapped()) {
				var message = {
					type: hsPickingApp.REACT_NATIVE_EVENT_TYPES.EXTERNAL_URL_REDIRECT,
					payload: {
						url: url,
					}
				};
				hsPickingApp.postMessage(message);
			} else {
				window.open(url, "_blank");
			}
		},
        isWrapped: function() {
            return hsPickingApp.isWrapped();
        },
        showBackButtonInOrderDetails: function() {
            return !hsPickingApp.isWrapped();
        },
		shouldShowStripeEmbeddedPayments: function() {
			if (!$scope.admin.currentUserHasBankAccountAccess() || !$scope.admin.currentLocationHasStripeConnectedAccount()) {
				return false;
			}
			return true;
		},
		currentUserHasBankAccountAccess: function() {
			var user = $rootScope.currentUser;
			return user.isAdmin && user.hasBankAccountAccess;
		},
		currentLocationHasStripeConnectedAccount: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			return hsUtils.isNonEmptyObject(location) && location.hasStripeConnectedAccount === true;
		},
		shouldShowEbtFields: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			return hsUtils.isObject(location) && hsUtils.isObject(location.ebtConfig) && hsUtils.isNonEmptyString(location.ebtConfig.fnsNumber);
		},
		isOrdersDashboardEnabled: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			return hsUtils.isObject(location) && hsUtils.isObject(location.ordersDashboardConfig) && location.ordersDashboardConfig.enabled;
		},
		showLoyaltyDashboard: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			return hsUtils.isObject(location) && hsUtils.isObject(location.loyaltyDashboardConfig) && location.loyaltyDashboardConfig.enabled;
		},
		showPOSDepartmentPopup: function() {
			ngDialog.open({
                template: 'partials/popup/pos-department-popup.html',
                className: 'ngdialog-theme-default email-capture',
            });
		},
		showPOSSubdepartmentPopup: function() {
			ngDialog.open({
                template: 'partials/popup/pos-subdepartment-popup.html',
                className: 'ngdialog-theme-default email-capture',
            });
		},
    };

	function generateFieldsAndHeaders(fieldsObject, fields, header) {
      void 0;

      angular.forEach(fieldsObject, function(field, key) {
        if (!field || !key) {
          throw new Error("error json report fields");
        }
        fields.push(key);
        header.push(field);
      });
      return {
        fields: fields,
        header: header
      };
    };

    function _convertToExcel(body, header) {
      return header + "\n" + body;
    };

    function _objectToString(object) {
      var output = "";
      angular.forEach(object, function(value, key) {
        output += key + ":" + value + " ";
      });

      return "'" + output + "'";
    }

    function generateFieldValues(list, rowItems, dataItem) {
      angular.forEach(list, function(field) {
        var data = "",
          fieldValue = "",
          curItem = null;
        if (field.indexOf(".")) {
          field = field.split(".");
          curItem = dataItem;
          // deep access to obect property
          angular.forEach(field, function(prop) {
            if (curItem !== null && curItem !== undefined) {
              curItem = curItem[prop];
            }
          });
          data = curItem;
        } else {
          data = dataItem[field];
        }
        fieldValue = data !== null ? data : " ";
        if (fieldValue !== undefined && angular.isObject(fieldValue)) {
          fieldValue = _objectToString(fieldValue);
        }
        rowItems.push(fieldValue);
      });
      return rowItems;
    }

    function _bodyData(valueFields) {
      var body = "";

      angular.forEach(valueFields, function(dataItem) {
      	void 0;
        var rowItems = [];
        var nestedBody = "";
        rowItems = generateFieldValues($scope.fields, rowItems, dataItem);
        void 0;
        // rowItems = [1,"github",4000];

        //Nested Json body generation start 
        if ($scope.nestedDataProperty && dataItem[$scope.nestedDataProperty].length) {
          angular.forEach(dataItem[scope.nestedDataProperty], function(nestedDataItem) {
            var nestedRowItems = [""];
            nestedRowItems = generateFieldValues(nestedFields, nestedRowItems, nestedDataItem);
            nestedBody += nestedRowItems.toString() + "\n";
          });
          var strData = _convertToExcel(nestedBody, nestedHeader);
          body += rowItems.toString() + "\n" + strData;
          ////Nested Json body generation end 
        } else {
          body += rowItems.toString() + "\n";
        }
      });
      return body;
    }

    	
    // Disable weekend selection
    function disabled(data) {
	    var date = data.date,
		    mode = data.mode;
	    return mode === 'day' && (date.getDay() === 0 || date.getDay() === 6);
    }

}]);

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('cartCtrl', [
    '$scope', '$rootScope','$location','$http','globalFunctions','OpenGraphTags','ENV','$sce','$q','scrollToElement','$routeParams','$filter','allProducts','hsCart','hsAuth','toastr','address','localStorageService','$interval','$document','ngDialog','$route', 'hsApi', 'hsTableSideOrders', 'hsPromos', 'hsUtils',
	'aiSearchEvents', 'hsUserPayments', 'ebtService',
    function($scope, $rootScope, $location,$http,globalFunctions,OpenGraphTags,ENV,$sce,$q,scrollToElement,$routeParams,$filter, allProducts, hsCart, hsAuth, toastr, address, localStorageService, $interval,$document, ngDialog, $route, hsApi, hsTableSideOrders, hsPromos, hsUtils,
		aiSearchEvents, hsUserPayments, ebtService){
    
    void 0;

    if ($rootScope.orderingDisabled) {
    	$location.url('/products');
    	return;
    }
    
    var location = $location.url();
    switch (location){
        default:
            globalFunctions.setSEOdata('Cart | ' + ENV.name.companyName);
            break;
	}

    function getInitReplacementLocationCheckedVal() {
        var locations = localStorageService.get('location') || { allLocations: [] };
        var isMultiLocationStore = locations.allLocations.length > 1;

        return !ENV.autoCheckoutLocationChange || !isMultiLocationStore;
    }

    $scope.cart = {
        config                      : {
            requiresPhoneNumberVerification: false,
        	pageFullyLoaded             : false,
	        showUpdatedAddressSection   : false,
	        showUpdatePhoneSection      : false,
			showDiscountCodeBox			: true,
	        showUpdatedCCSection        : false,
	        addressNonEditable          : false,
	        allAddressNonEditable       : false,
	        billingAddressNonEditable   : false,
	        total                       : '',
        	emptyCart                   : false,
	        checkoutError               : '',
	        buttonLoading               : false,
	        updateCCError               : '',
	        updateCCButtonLoading       : false,
	        updateAddressError          : '',
	        updateAddressButtonLoading  : false,
        	alertClass                  : '',
        	alertMessage                : '',
	        numberOfProducts            : 12,
	        categoryLimit               : 4,
	        categoryOrder               : ENV.categoryOrder,
			managedDeliveryTipShare 	: null,
            scrollTo                    : function (section) {
                scrollToElement(section);
            },
            navigateTo                  : function (url) {
                $location.url(url);
            },
	        checkoutValidationRules     : {
		        rules               : {
			        ccNumber        : {
				        required    : true
			        },
			        ccExpiry        : {
				        required    : true
			        },
			        ccCvc           : {
				        required    : true
			        },
			        zipCode         : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        },
			        street1         : {
				        required    : true
			        },
			        city            : {
				        required    : true
			        },
			        state           : {
				        required    : true
			        },
			        zip             : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        },
			        phoneUS         : {
				        required    : true,
				        phoneUS     : true
			        },
			        "billing-street1"         : {
				        required    : true
			        },
			        "billing-city"            : {
				        required    : true
			        },
			        "billing-state"           : {
				        required    : true
			        },
			        "billing-zip"             : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        }
                },
		        messages            : {
			        ccNumber        : {
				        required    : "Please enter your Credit Card number"
			        },
			        ccExpiry        : {
				        required    : "Expiration date required"
			        },
			        ccCvc           : {
				        required    : "Enter security code from behind the card."
			        },
			        zipCode         : {
				        required    : "Please enter valid zipcode",
				        number      : "Please enter numbers only",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        },
			        street1         : {
				        required    : "Please enter your street address"
			        },
			        city            : {
				        required    : "Please enter your city"
			        },
			        state           : {
				        required    : "Please select your state"
			        },
			        zip             : {
				        required    : "Please enter valid zipcode",
				        number      : "Please only enter numbers",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        },
			        phoneUS         : {
				        required    : "Please enter valid phone number",
				        phoneUS     : "Please enter valid phone number"
			        },
			        "billing-street1"         : {
				        required    : "Please enter your billing street address"
			        },
			        "billing-city"            : {
				        required    : "Please enter your billing city"
			        },
			        "billing-state"           : {
				        required    : "Please select your billing state"
			        },
			        "billing-zip"             : {
				        required    : "Please enter valid billing zipcode",
				        number      : "Please only enter numbers",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        }
		        }
	        },
	        ccValidationRules           : {
		        rules               : {
			        ccNumber        : {
				        required    : true
			        },
			        ccExpiry        : {
				        required    : true
			        },
			        ccCvc           : {
				        required    : true
			        },
			        zipCode         : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        },
			        "billing-street1"         : {
				        required    : true
			        },
			        "billing-city"            : {
				        required    : true
			        },
			        "billing-state"           : {
				        required    : true
			        },
			        "billing-zip"             : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        }
		        },
		        messages            : {
			        ccNumber        : {
				        required    : "Please enter your Credit Card number"
			        },
			        ccExpiry        : {
				        required    : "Expiration date required"
			        },
			        ccCvc           : {
				        required    : "Enter security code from behind the card."
			        },
			        zipCode         : {
				        required    : "Please enter valid zipcode",
				        number      : "Please enter numbers only",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        },
			        "billing-street1"         : {
				        required    : "Please enter your billing street address"
			        },
			        "billing-city"            : {
				        required    : "Please enter your billing city"
			        },
			        "billing-state"           : {
				        required    : "Please select your billing state"
			        },
			        "billing-zip"             : {
				        required    : "Please enter valid billing zipcode",
				        number      : "Please only enter numbers",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        }
		        }
	        },
	        billingAddressValidationRules : {
		        rules               : {
			        "billing-street1"         : {
				        required    : true
			        },
			        "billing-city"            : {
				        required    : true
			        },
			        "billing-state"           : {
				        required    : true
			        },
			        "billing-zip"             : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        }
		        },
		        messages            : {
			        "billing-street1"         : {
				        required    : "Please enter your street address"
			        },
			        "billing-city"            : {
				        required    : "Please enter your city"
			        },
			        "billing-state"           : {
				        required    : "Please select your state"
			        },
			        "billing-zip"             : {
				        required    : "Please enter valid zipcode",
				        number      : "Please only enter numbers",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        }
		        }
	        },
	        addressValidationRules      : {
		        rules               : {
			        street1         : {
				        required    : true
			        },
			        city            : {
				        required    : true
			        },
			        state           : {
				        required    : true
			        },
			        zip             : {
				        required    : true,
				        number      : true,
				        minlength   : 5,
				        maxlength   : 5
			        }
		        },
		        messages            : {
			        street1         : {
				        required    : "Please enter your street address"
			        },
			        city            : {
				        required    : "Please enter your city"
			        },
			        state           : {
				        required    : "Please select your state"
			        },
			        zip             : {
				        required    : "Please enter valid zipcode",
				        number      : "Please only enter numbers",
				        minlength   : "zipcode must be 5 digits",
				        maxlength   : "zipcode must be 5 digits"
			        }
		        }
	        }
        },
        getProductDisplayName: function (item) {
            return hsCart.getProductDisplayName(item);
        },
        getIsPickupOnly: function (item) {
            return hsCart.getIsPickupOnly(item);
        },
        sanitizeFulfillmentMethods: function (fulfillmentMethods) {
            angular.forEach(fulfillmentMethods, function(fulfillmentMethodObj) {
                if ('availableTimes' in fulfillmentMethodObj) {
                    angular.forEach(fulfillmentMethodObj.availableTimes, function(day) {
                        day.timeSlots = $scope.cart.getUniqueTimeSlots(day.timeSlots);
                    });
                }
            });
        },
        getUniqueTimeSlots: function (timeSlots) {
            if (!Array.isArray(timeSlots)) {
                return timeSlots;
            }
            var uniqueTimeSlots = {};
            for (let i = 0; i < timeSlots.length; i++) {
                uniqueTimeSlots[timeSlots[i]] = true;
            }

            return Object.keys(uniqueTimeSlots);
        },
		setSelectedDeliveryTime: function() {
			if ($scope.cart.priceListHasManagedDelivery()
				&& ($scope.cart.isAsapTimeSelected() || $scope.cart.isSelectedDeliveryTimeUninitialized() || $scope.cart.isInitialTimeSelected()))
			{
				$scope.cart.selectedDeliveryTime = $scope.cart.convertFirstTimeSlotToAsap($scope.cart.deliveryTimes || $scope.cart.deliveryPreferences[0].timeSlots)[0];
			} else {
				$scope.cart.selectedDeliveryTime = $scope.cart.deliveryTimes[0] || $scope.cart.deliveryPreferences[0].timeSlots[0];
			}
		},
		convertFirstTimeSlotToAsap: function(timeSlots) {
			if (!Array.isArray(timeSlots) || !timeSlots.length || !$scope.cart.selectedDeliveryDate.isToday) {
				return timeSlots;
			}
			return hsCart.convertFirstTimeSlotToAsap(timeSlots);
		},
		isAsapTimeSelected: function() {
			return !!$scope.cart.selectedDeliveryTime
				&& typeof $scope.cart.selectedDeliveryTime === "string"
				&& $scope.cart.selectedDeliveryTime.includes("ASAP")
				&& $scope.cart.selectedDeliveryDate.isToday;
		},
		isInitialTimeSelected: function() {
			return !!$scope.cart.selectedDeliveryTime
				&& typeof $scope.cart.selectedDeliveryTime === "string"
				&& $scope.cart.selectedDeliveryTime === ($scope.cart.deliveryTimes[0] || $scope.cart.deliveryPreferences[0].timeSlots[0])
				&& $scope.cart.selectedDeliveryDate.isToday;
		},
		isSelectedDeliveryTimeUninitialized: function() {
			return $scope.cart.selectedDeliveryTime === false || $scope.cart.selectedDeliveryTime === '' || hsUtils.isEmptyObject($scope.cart.selectedDeliveryTime);
		},
		priceListHasManagedDelivery: function() {
			var currentPriceList = $rootScope.globalFunctions.getSelectedPriceListFromStorage();
			return !!currentPriceList && !!currentPriceList.fulfillment && !!currentPriceList.fulfillment.managedDelivery;
		},
        toggleDiscountCode			: function () {
			this.config.showDiscountCodeBox = !this.config.showDiscountCodeBox;
		},
        toggleLoyatlyPointsInput: function() {
            this.loyaltyPoints.showInput = !this.loyaltyPoints.showInput;
        },
	    toggleUpdateAddress         : function () {
            this.config.showUpdatedAddressSection = !this.config.showUpdatedAddressSection;
            
            this.address = {
	            street1             : "",
	            street2             : "",
	            city                : "",
	            state               : "",
	            zip                 : "",
	            country             : ""
            };

            /*if(!this.config.showUpdatedAddressSection){
            	$scope.cart.canDeliver = true;
            }*/
	    },
	    togglePhoneNumber           : function () {
            this.config.showUpdatePhoneSection = !this.config.showUpdatePhoneSection;

            if(!this.config.showUpdatePhoneSection) {
	            this.phoneNumber = '';
            }
	    },
	    toggleUpdateCC              : function () {
            this.config.showUpdatedCCSection = !this.config.showUpdatedCCSection;

            if (!this.config.showUpdatedCCSection) {
	            $scope.cart.config.billingAddressNonEditable = false;
            	$scope.cart.billing = {
		            ccNumber				: '',
		            expDate					: '',
		            cvc						: ''
	            };

            	$scope.cart.config.checkoutError = '';
	            $scope.cart.billingAddress = {
		            street1             : "",
		            street2             : "",
		            city                : "",
		            state               : "",
		            zip                 : "",
		            country             : ""
	            };
            }
	    },
	    toggleDriverTipSection      : function () {
            this.showDriverTipSection = !this.showDriverTipSection;
	    },
		selectFullfillmentMethod    : function (method) {
        	angular.forEach(this.totalObj.fullfillmentOptions, function(val, key){
        		if (val.name === method.name) {
        			val.checked = true;
        			$scope.cart.fulfillmentMethod           = val.name;
        			$scope.cart.selectedFulfillmentMethod   = val.name;
        			$scope.cart.renderCheckoutOptions       = true;
        			$scope.cart.totalObj.delivery           = val;
        			$scope.cart.totalObj.total              = val.total;
        			$scope.cart.totalObj.tax                = val.tax;

        			if (val.hasOwnProperty('unavailable') &&
			            val.unavailable.reason === 'Minimum Order Constraint Not Met') {
        				$scope.cart.renderCheckoutOptions = false;
                    }

                    if (val.hasOwnProperty('unavailable') &&
			            val.unavailable.reason === 'Pickup Only Item In Cart') {
        				$scope.cart.renderCheckoutOptions = false;
                    }
                    
			        if (val.hasOwnProperty('unavailable') &&
				        val.unavailable.reason === 'At Capacity') {
				        $scope.cart.renderCheckoutOptions = false;
				        $scope.cart.renderSummaryDetails = false;

				        $scope.cart.allSlotsFull = true;
				        $scope.cart.allSlotsFullMessage = val.unavailable.reasonDisplay;
			        } else {
				        $scope.cart.allSlotsFull = false;
				        $scope.cart.allSlotsFullMessage = "";
			        }


			        if (val.name === 'pickup') {
				        if($scope.cart.showDriverTipSection){
					        $scope.cart.showDriverTipSection = false;
				        }
			        }

			        if (val.name === 'delivery') {
						$scope.cart.showDriverTipSection = val.tips;
						$scope.cart.renderSummaryDetails = $scope.cart.canDeliver;
			        }
        			
        			if (val.name === 'shipping') {
				        if($scope.cart.showDriverTipSection){
					        $scope.cart.showDriverTipSection = false;
				        }
        				if(!$scope.cart.selectedShippingKey){
        					$scope.cart.selectedShippingKey = Object.keys(val.fee)[0];
				        }

				        $scope.cart.selectedShippingOption = val.fee[$scope.cart.selectedShippingKey];
				        $scope.cart.totalObj.subTotal = $filter('number')($scope.cart.selectedShippingOption.subTotal,2);
				        $scope.cart.totalObj.total = $filter('number')($scope.cart.selectedShippingOption.total,2);
				        $scope.cart.totalObj.originalTotal = $filter('number')($scope.cart.selectedShippingOption.total,2);
				        $scope.cart.totalObj.shipping = $filter('number')($scope.cart.selectedShippingOption.shipping,2);
			        } else if (!val.hasOwnProperty('availableTimes')) {
				        $scope.cart.renderSummaryDetails = true;
			        } else if (val.hasOwnProperty('availableTimes') && val.availableTimes.length) {
				        $scope.cart.deliveryPreferences     = val.availableTimes;
				        $scope.cart.selectedDeliveryDate    = $scope.cart.deliveryPreferences[0];
						$scope.cart.deliveryTimes = $scope.cart.deliveryPreferences[0].timeSlots;
				        $scope.cart.selectedDeliveryTime    = ENV.enableNewCheckout ?
							'' : $scope.cart.priceListHasManagedDelivery() ?
								$scope.cart.convertFirstTimeSlotToAsap($scope.cart.deliveryPreferences[0].timeSlots)[0]
								: $scope.cart.deliveryPreferences[0].timeSlots[0];
				        $scope.cart.renderSummaryDetails = true;
			        } else {
				        $scope.cart.deliveryPreferences     = false;
				        $scope.cart.selectedDeliveryDate    = false;
				        $scope.cart.deliveryTimes           = false;
				        $scope.cart.selectedDeliveryTime    = false;

						if (!$scope.cart.deliveryTimeRequired) {
							$scope.cart.renderSummaryDetails = true;
						}
			        }

			        if (val.hasOwnProperty('discount') && val.discount.code) {
				        $scope.cart.discountDetails = val.discount;
				        $scope.cart.config.showDiscountCodeBox = false;
			        } else {
				        $scope.cart.config.showDiscountCodeBox = true;
			        }

			        if (val.tips) {
				        if ($scope.cart.selectedTip.title === 'Other') {
					        var otherTipNode = {
						        display : 'Other',
						        value   : $scope.cart.selectedTip.value,
						        title   : 'Other',
						        checked : true
					        };

					        otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

					        $scope.cart.totalObj.delivery.tips.push(otherTipNode);
					        $scope.cart.applyCustomTip();
				        } else {
					        $scope.cart.processTip($scope.cart.selectedTip);
				        }
			        }

        			$scope.cart.updateAlertMessage();
        			$scope.cart.syncCart(true, true);
		        } else {
        			val.checked = false;
		        }
	        });

			if (localStorageService.get('discountCode') !== null) {
				$scope.cart.discountCode = localStorageService.get('discountCode');
			}
	    },
	    updateShippingOption        : function (key, option) {
		    $scope.cart.selectedShippingKey = key;
		    $scope.cart.selectedShippingOption = option;

		    void 0;
		    void 0;

		    $scope.cart.totalObj.subTotal = $filter('number')($scope.cart.selectedShippingOption.subTotal,2);
		    $scope.cart.totalObj.total = $filter('number')($scope.cart.selectedShippingOption.total,2);
		    $scope.cart.totalObj.originalTotal = $filter('number')($scope.cart.selectedShippingOption.total,2);
		    $scope.cart.totalObj.shipping = $filter('number')($scope.cart.selectedShippingOption.shipping,2);
	    },
        checkoutSteps               : {
        	hasPaymentMethod        : false,
			hasEbtPaymentMethod: false,
        	hasAddress              : false,
        	hasPhone                : false
        },
	    processLeaveAll() {
		    var globalLeaveOut = true;
		    var globalReplaceAll = true;
		    this.originalBasketItems.forEach(function (item) {
		    	if (item.leaveOut === false) {
		    		globalLeaveOut = false;
			    }

		    	if (item.canReplace === false) {
		    		void 0;
		    		globalReplaceAll = false;
			    }
		    });

		    this.leaveAll = globalLeaveOut;
		    this.replaceAll = globalReplaceAll;
		    void 0;
	    },
	    toggleLeaveAll() {
        	void 0;
        	this.leaveAll = !this.leaveAll;

        	this.updateCart(null, true);
	    },
	    updateLeaveAll(leaveAll) {
        	void 0;
        	this.leaveAll = leaveAll;

        	this.updateCart(null, true);
	    },
	    substituteItem(item, leaveOut){
		    item.leaveOut = leaveOut;
		    this.updateCart(item, false);
	    },
	    updateCart (item, allItems, dontSyncCart) {
		    void 0;

		    if(!$rootScope.loggedIn){
			    var basket = localStorageService.get('basket');

			    basket.forEach(function (basketItem) {
				    if (allItems) {
					    basketItem.leaveOut = $scope.cart.leaveAll;
					    basketItem.canReplace = !$scope.cart.leaveAll;
				    } else {
					    if (basketItem.name === item.name) {
							basketItem.instructions = item.instructions;
						    if (item.hasOwnProperty('selectedModifiers') && item.selectedModifiers.length) {
							    var basketModifier = basketItem.selectedModifiers.map(function(modifier) {
								    return modifier.name;
							    });
							    var itemModifier = item.selectedModifiers.map(function(modifier) {
								    return modifier.name;
							    });

							    if (_.isEqual(basketModifier, itemModifier)) {
								    basketItem.leaveOut = item.leaveOut;
								    basketItem.canReplace = !item.leaveOut;
							    }
						    } else {
							    basketItem.leaveOut = item.leaveOut;
							    basketItem.canReplace = !item.leaveOut;
						    }
					    }
				    }
			    });

			    toastr.success('Item updated successfully.');
			    localStorageService.set('basket', basket);
			    $scope.cart.originalBasketItems = basket;
			    $scope.cart.data = $scope.cart.filterProductsByCategory(basket);
			    $scope.cart.processLeaveAll();
			    $rootScope.$emit('cartUpdated', true);
		    } else {
			    /*[{
			     name            : item.name,
			     quantity        : quantity,
			     isCustomItem    : false,
			     instructions    : item.instructions || "",
			     displayName     : item.displayName,
			     type            : item.type,
			     subType         : item.subType,
			     organic         : item.organic,
			     unit            : item.unit,
			     selectedModifiers: item.selectedModifiers ?
			     item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
			     }]*/

			    var data = {
				    items : []
			    };

			    if (allItems) {
				    $scope.cart.originalBasketItems.forEach(function (basketItem) {
				    	var item = {
						    name            : basketItem.name,
						    quantity        : basketItem.quantity,
						    isCustomItem    : false,
						    canReplace      : false,
						    instructions    : basketItem.instructions || "",
						    displayName     : basketItem.displayName,
						    type            : basketItem.type,
						    subType         : basketItem.subType,
						    organic         : basketItem.organic,
						    unit            : basketItem.unit,
						    selectedModifiers: basketItem.selectedModifiers ?
							    basketItem.selectedModifiers.map(function(modifier) { return modifier.name}) : []
					    };

				    	if (dontSyncCart) {
				    		item.canReplace = basketItem.canReplace;
					    } else {
				    		item.canReplace = !$scope.cart.leaveAll;
					    }

					    data.items.push(item);
				    });
			    } else {
				    data.items.push({
					    name            : item.name,
					    quantity        : item.quantity,
					    isCustomItem    : false,
					    canReplace      : !item.leaveOut,
					    instructions    : item.instructions || "",
					    displayName     : item.displayName,
					    type            : item.type,
					    subType         : item.subType,
					    organic         : item.organic,
					    unit            : item.unit,
					    selectedModifiers: item.selectedModifiers ?
						    item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
				    });
			    }

			    return hsCart.addItemToCart(data)
				    .then(function(response){
					    void 0;
					    if(response.status === 200){
						    void 0;
						    if (!dontSyncCart) {
							    toastr.success('item updated successfully.');
							    $scope.cart.syncCart();
						    }
					    }else{
						    toastr.error('Error updating item.');
					    }
				    });
		    }
	    },
	    ngCheckoutForm				: '',
	    originalBasketItems         : [],
	    containsAlcohol				: false,
	    leaveAll                    : false,
	    replaceAll                  : false,
	    showDriverTipSection        : false,
        tips                        : false,
        shopperTips                 : false,
        checkoutPage                : false,
	    gotAllPickupInfo            : false,
	    allSlotsFull                : false,
	    allSlotsFullMessage         : '',
	    canPlaceOrder               : true,
	    phoneNumber                 : '',
	    renderCheckoutOptions       : true,
	    fulfillmentMethod           : ENV.defaultFulfillmentMethod,
	    selectedFulfillmentMethod   : '',
	    selectedShippingOption      : '',
	    selectedShippingKey         : '',
	    totalObj                    : {
        	subTotal                : '',
        	delivery                : '',
	        coupon                  : '',
        	total                   : ''
        },
        selectedTip                 : false,
        showShopperTipSection       : ENV.enableSeparateTips,
        selectedShopperTip          : false,
        discountDetails             : {},
        orderData                   : {},
        data                        : {},
        userData                    : {},
        rewardsData                 : {
	        selectedReward          : false,
        	data                    : {},
	        availableRewards        : [],
	        showRewardsOption       : false,
	        showRewardsPopup        : false
        },
		customTip                   : '',
        customShopperTip            : '',
		discountCode				: '',
		outOfCoverageMessage        : '',
	    gotAllInfo                  : false,
	    showSummaryPopup            : false,
	    canDeliver                  : true,
	    deliveryUnavailableMsg      : false,
	    pickupAvailable             : false,
	    localCart                   : false,
	    delivery                    : {
        	leaveAtDoor             : true,
		    instructions            : ''
	    },
	    deliveryFee                 : {},
	    deliveryPreferences         : false,
	    deliveryTimes               : false,
		deliveryTimeRequired		: true,
		asapDeliveryTime			: '',
	    pickupAvailableInOtherLocations: false,
	    renderSummaryDetails        : true,
	    deliveryTime                : {},
	    selectedDeliveryDate        : {},
	    selectedDeliveryTime        : {},
        loyaltyPoints: {
            model: null,
            balance: null,
            applied: null,
            showInput: false,
            config: null,
        },
		limitScrollOnItems          : 3,
		priceListTypes: {
			CATERING: 'catering'
		},
		fulfillmentDate: {
			model: '',
			format: 'MM-dd-yyyy',
			opened: false,
			dateOptions: {
				showWeeks: false,
				formatYear: 'yy',
				maxDate: new Date(),
				minDate: new Date(),
				startingDay: 1,
				showClear: false,
				dateDisabled: function(data) {
					
					var date = data.date;
					var dateObj = {
						date: date.getDate(),
						month: date.getMonth(),
						year: date.getFullYear()
					};

					var deliveryPreferences = $scope.cart.deliveryPreferences;
					var dateAvailable = deliveryPreferences.filter(function(preference) {
						if (dateObj.date === preference.date && dateObj.month === (preference.monthNum - 1) && dateObj.year == preference.year) {
							return preference;
						}
					})
					
					return !dateAvailable.length;
				  },
			},
		},
		openFulfillmentDatePicker() {
			$scope.cart.fulfillmentDate.opened = !$scope.cart.fulfillmentDate.opened;
		},
		showDatePicker() {
			var selectedPriceList = hsCart.getSelectedPriceList();
			return hsUtils.isObject(selectedPriceList) && selectedPriceList.type === $scope.cart.priceListTypes.CATERING;
		},
		isPickupAvailableInOtherLocations() {
        	var location = localStorageService.get('location');

        	if (location
				&& location.allLocations && Array.isArray(location.allLocations)) {
        		location.allLocations.forEach(function(loc) {
        			if (loc.uniqueName !== location.selectedLocation.uniqueName) {
	        			if (loc.fulfillment && loc.fulfillment.hasOwnProperty('pickup')) {
	        				$scope.cart.pickupAvailableInOtherLocations = true;
						}
					}
				});
			}
		},
		shouldShowTBDFulfillmentFee() {
			var selectedPriceList = hsCart.getSelectedPriceList();
			return globalFunctions.hasTBDFulfillmentFees(selectedPriceList.uniqueName);
		},
		showTBDFulfillmentFeePopup() {
			var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/shipping-fee-popup.html',
			    controller:'ModalController',
			    className: modalClass
		    });
		},
	    checkout                    : {
        	selectedStep            : 'fulfillmentMethod',
		    updateAddress           : false,
		    updatePayment           : false,
		    updatePhone             : false,
            isMinOrderConstraintMet: true,
			paymentMethod: null,
			selectedPaymentMethod: null,
			isHouseChargeOrder: false,
			switchLocations() {
				$scope.cart.loadLocationsPopup(true, function(value) {
					$route.reload();
				});
			},
		    toggleCheckoutUpdateSection(type) {
        		void 0;
        		switch(type) {
			        case 'address':
				        this.updateAddress = !this.updateAddress;

				        if(!this.updateAddress) {
				        	$scope.cart.address = {
						        street1             : "",
						        street2             : "",
						        city                : "",
						        state               : "",
						        zip                 : "",
						        country             : ""
					        };
				        }
			        	break;
			        case 'payment':
				        this.updatePayment = !this.updatePayment;
			        	break;
                    case 'selectPayment':
                        this.selectPayment = !this.selectPayment;
                        break;
			        case 'phone':
				        this.updatePhone = !this.updatePhone;

				        if (!this.updatePhone) {
				        	$scope.cart.phoneNumber = '';
				        }
			        	break;
		        }
		    },
        	steps                   : {
        		fulfillmentMethod   : {
        			stepId: 'fulfillment-step',
        			activated: true,
			        current: true
		        },
        		delivery            : {
        			stepId: 'delivery-step',
        			activated: false,
			        current: false
                },
                deliveryInstructions: {
                    stepId: 'delivery-instructions-step',
                    activated: false,
                    current: false,
                },
        		payment             : {
        			stepId: 'payment-step',
        			activated: false,
			        current: false
		        },
        		contact             : {
        			stepId: 'contact-step',
        			activated: false,
			        current: false
		        },
		        preferences         : {
        			stepId: 'preferences-step',
        			activated: false,
			        current: false
		        },
        		summary             : {
        			stepId: 'summary-step',
        			activated: false,
			        current: false
		        }
	        },
		    selectPickUpMethod() {
                var pickup = null;
                $scope.cart.config.buttonLoading = true;
			    angular.forEach($scope.cart.totalObj.fullfillmentOptions, function(val, key){
			    	if (val.name === 'pickup') {
			    		pickup = val;
				    }
			    });

			    if (pickup) {
			    	this.selectFullfillmentMethod(pickup, 'delivery');
			    }
		    },
		    selectFullfillmentMethod (method, step) {
			    angular.forEach($scope.cart.totalObj.fullfillmentOptions, function(val, key){
				    if (val.name === method.name) {
					    val.checked = true;
					    $scope.cart.fulfillmentMethod           = val.name;
					    $scope.cart.selectedFulfillmentMethod   = val.name;
					    $scope.cart.renderCheckoutOptions       = true;
					    $scope.cart.totalObj.delivery           = val;
					    $scope.cart.totalObj.total              = val.total;
					    $scope.cart.totalObj.tax                = val.tax;

					    if (val.hasOwnProperty('unavailable') &&
						    val.unavailable.reason === 'Minimum Order Constraint Not Met') {
						    $scope.cart.renderCheckoutOptions = false;
                        }
                        
                        if (val.hasOwnProperty('unavailable') && val.unavailable.reason === 'Pickup Only Item In Cart') {
                            $scope.cart.renderCheckoutOptions = false;
                        }

					    if (val.hasOwnProperty('unavailable') &&
						    val.unavailable.reason === 'At Capacity') {
						    $scope.cart.renderCheckoutOptions = false;
						    $scope.cart.renderSummaryDetails = false;

						    $scope.cart.allSlotsFull = true;
						    $scope.cart.allSlotsFullMessage = val.unavailable.reasonDisplay;
					    } else {
						    $scope.cart.allSlotsFull = false;
						    $scope.cart.allSlotsFullMessage = "";
					    }

					    if (val.name === 'pickup') {
						    if($scope.cart.showDriverTipSection){
							    $scope.cart.showDriverTipSection = false;
						    }
					    }

					    if (val.name === 'delivery') {
						    $scope.cart.showDriverTipSection = val.tips;
						    $scope.cart.renderSummaryDetails = $scope.cart.canDeliver;
					    }

					    if (val.name === 'shipping') {
						    if($scope.cart.showDriverTipSection){
							    $scope.cart.showDriverTipSection = false;
						    }
						    if(!$scope.cart.selectedShippingKey){
							    $scope.cart.selectedShippingKey = Object.keys(val.fee)[0];
						    }

						    $scope.cart.selectedShippingOption = val.fee[$scope.cart.selectedShippingKey];
						    $scope.cart.totalObj.subTotal = $filter('number')($scope.cart.selectedShippingOption.subTotal,2);
						    $scope.cart.totalObj.total = $filter('number')($scope.cart.selectedShippingOption.total,2);
						    $scope.cart.totalObj.originalTotal = $filter('number')($scope.cart.selectedShippingOption.total,2);
						    $scope.cart.totalObj.shipping = $filter('number')($scope.cart.selectedShippingOption.shipping,2);
					    } else if (!val.hasOwnProperty('availableTimes')) {
						    $scope.cart.renderSummaryDetails = true;
					    } else if (val.hasOwnProperty('availableTimes') && val.availableTimes.length) {
						    $scope.cart.deliveryPreferences     = val.availableTimes;
						    $scope.cart.selectedDeliveryDate    = $scope.cart.deliveryPreferences[0];
							$scope.cart.deliveryTimes = $scope.cart.deliveryPreferences[0].timeSlots;
							$scope.cart.selectedDeliveryTime    = ENV.enableNewCheckout ? '' : $scope.cart.priceListHasManagedDelivery() ? 
								$scope.cart.convertFirstTimeSlotToAsap($scope.cart.deliveryPreferences[0].timeSlots)[0]
								: $scope.cart.deliveryPreferences[0].timeSlots[0];

						    if (!$scope.cart.allSlotsFull
							    && $scope.cart.selectedDeliveryDate
							    && $scope.cart.selectedDeliveryDate.hasOwnProperty('shortDay')
							    && $scope.cart.selectedDeliveryDate.shortDay !== 'Today') {
							    $scope.cart.showFutureOrderAlert();
						    }

						    $scope.cart.renderSummaryDetails = true;
					    } else {
						    $scope.cart.deliveryPreferences     = false;
						    $scope.cart.selectedDeliveryDate    = false;
						    $scope.cart.deliveryTimes           = false;
						    $scope.cart.selectedDeliveryTime    = false;

							if (!$scope.cart.deliveryTimeRequired) {
								$scope.cart.renderSummaryDetails = true;
							}
					    }

					    if (val.hasOwnProperty('discount') && val.discount.code) {
						    $scope.cart.discountDetails = val.discount;
						    $scope.cart.config.showDiscountCodeBox = false;
					    } else {
						    $scope.cart.config.showDiscountCodeBox = true;
					    }

					    if (val.tips) {
						    if ($scope.cart.selectedTip.title === 'Other') {
							    var otherTipNode = {
								    display : 'Other',
								    value   : $scope.cart.selectedTip.value,
								    title   : 'Other',
								    checked : true
							    };

							    otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

							    $scope.cart.totalObj.delivery.tips.push(otherTipNode);
							    $scope.cart.applyCustomTip();
						    } else {
							    $scope.cart.processTip($scope.cart.selectedTip);
						    }
					    }

					    $scope.cart.updateAlertMessage();
					    if (step) {
					        $scope.cart.checkout.syncCart(true, true, null, null, step);
					    } else {
					        $scope.cart.checkout.syncCart(true, true);
					    }
				    } else {
					    val.checked = false;
				    }
			    });

			    if (localStorageService.get('discountCode') !== null) {
				    $scope.cart.discountCode = localStorageService.get('discountCode');
			    }

		    },
		    init (checkoutPage) {
			    if(!$rootScope.loggedIn) {
				    $rootScope.$emit('cartUpdated');
				    if(checkoutPage) {
					    $location.url('/login?redirect=/cart/checkout');
				    } else {
					    var basket = localStorageService.get('basket');
					    if (basket && basket.length > 0) {

						    var total = 0;

						    basket.forEach(function (item) {
							    var price = 0;
							    void 0;
							    if (item.hasOwnProperty('canReplace')) {
							    	item.canReplace = true;
							    	item.leaveOut = false;
							    } else {
							    	item.leaveOut = !item.canReplace;
							    }
							    

							    if (item.hasOwnProperty('selectedModifiers')) {
								    item.selectedModifiers.forEach(function (modifier) {
									    if (modifier.hasOwnProperty('price')) {
										    price += modifier.price;
									    }
								    });
							    }
                                
                                var itemizedCost = item.sellByQty && item.unit === 'lb' 
                                    ? (item.quantity * item.avgWeight * item.price) + price
                                    : (item.price + price) * item.quantity;
                                
							    total += itemizedCost;
						    });

						    $scope.cart.originalBasketItems = basket;
						    $scope.cart.data = $scope.cart.filterProductsByCategory(basket);
						    $scope.cart.totalObj = {
							    delivery                : '',
							    coupon                  : '',
							    subTotal                : total.toFixed(2),
							    total                   : total.toFixed(2)
						    };
					    } else {
						    $scope.cart.config.emptyCart = true;
					    }
				    }
				    $scope.cart.config.pageFullyLoaded = true;
			    } else {
					if (ENV.enableLocations) {
						var location = localStorageService.get('location');
						if (!location || !location.hasOwnProperty('allLocations')) {
							void 0;
							$scope.cart.loadLocationsPopup(false, function(value) {
								sessionStorage.setItem('hs_session', new Date());
								$route.reload();
							});
							return;
						}
					}

                    globalFunctions.getSelectedLocation(true)
                        .then(function(location) {
							$scope.cart.config.managedDeliveryTipShare = location.managedDeliveryTipShare;
                            $scope.cart.config.phoneNumberRequiresVerification = !!location.requiresPhoneNumberVerification;
							$scope.cart.setDeliveryTimeRequired(location);
                        });


				    if(checkoutPage){
					    $scope.cart.checkoutPage = true;
				    }

				    var LocationEventListener = $rootScope.$on('locationUpdated', function(event, shouldReload) {
                        shouldReload = shouldReload !== false;
				    	void 0;
					    event.stopPropagation && event.stopPropagation();
					    shouldReload && $route.reload();
						if (!shouldReload) {
							globalFunctions.getSelectedLocation(true)
								.then(function(location) {
									$scope.cart.config.managedDeliveryTipShare = location.managedDeliveryTipShare;
									$scope.cart.config.phoneNumberRequiresVerification = !!location.requiresPhoneNumberVerification;
									$scope.cart.setDeliveryTimeRequired(location);
								});
						}
				    });

				    $scope.$on('$viewContentLoaded', function(event){
					    // code that will be executed ...
					    // every time this view is loaded
					    //Here your view content is fully loaded !!
					    $document.bind('scroll',function(){
						    if(!$rootScope.screenWidth.xs && !$rootScope.screenWidth.sm && !ENV.enableNewCheckout) {
							    var window_top = $(window).scrollTop();
							    var anchor      = '.billing-scrolling-anchor';
							    var divToFix    = '.billing-summary';
							    var div_top     = $(anchor).offset().top;
							    if (window_top > div_top) {
								    $(divToFix).addClass('fixed');
								    $(anchor).height($(divToFix).outerHeight());
							    } else {
								    $(divToFix).removeClass('fixed');
								    $(anchor).height(0);
							    }
						    }
					    });
					    //sticky_relocate();
					    var getAllProducts = setInterval(function() {
                            $scope.cart.checkout.syncCart(checkoutPage, true)
                                .then(function () {
                                    $scope.cart.ebt.updateSnapAmount();
                                    $scope.cart.updatePoints();
                                });
                        }, 60000);
					    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
						    //..do something  //if you don't want event to bubble up
						    clearInterval(getAllProducts);
					    });
				    });

				    $scope.$on('$destroy', function() {
					    $document.unbind('scroll');
					    LocationEventListener();
				    });

				    $scope.cart.checkout.syncCart(checkoutPage)
                        .then(function() {
                            $scope.cart.ebt.updateSnapAmount();
                            $scope.cart.updatePoints(true);
                        });
			    }

			    if(ENV.enablePriceList) {
				    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
					    event.preventDefault();
					    $scope.cart.loadLocationsPopup(checkoutPage, false, function (event) {
						    sessionStorage.setItem('hs_session', new Date());
						    $route.reload();
					    });
				    });

				    $scope.$on('$destroy', function() {
					    sessionExpired();
				    });
			    }
		    },
			initDeliveryStep() {
        		void 0;
        		var fulfillmentMethod = $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod];

        		if (ENV.autoCheckoutLocationChange && $scope.cart.checkoutSteps.hasAddress
					&& fulfillmentMethod && fulfillmentMethod.hasOwnProperty('unavailable')
					&& fulfillmentMethod.unavailable.hasOwnProperty('reason')
					&& fulfillmentMethod.unavailable.reason === 'Delivery Not Available'
					&& $scope.cart.replacementLocation.checked === false) {
        			void 0;
                    void 0;
                    $scope.cart.config.buttonLoading = true;
					$scope.cart.checkDeliveryArea($scope.cart.userData.address);
				} else {
                    $scope.cart.config.buttonLoading = false;
        			void 0;
				}
			},
			initFulfillmentStep() {
        		$scope.cart.isPickupAvailableInOtherLocations();
			},
		    switchStep (step) {
        		if ($scope.cart.selectedFulfillmentMethod !== 'pickup'
			        && (!$scope.cart.checkoutSteps.hasAddress || !$scope.cart.canDeliver)
			        && step !== 'fulfillmentMethod') {
        			return;
		        }

        		if ($scope.cart.checkout.steps[step].activated) {
			        $scope.cart.checkout.proceedToStep(step);
		        }
            },
            useSelectedCard(paymentMethod) {
                $scope.cart.checkout.paymentMethod = paymentMethod;
                $scope.cart.checkout.selectPayment = false;
                $scope.cart.checkout.processStep('payment');
            },
			deletePaymentMethod(value) {
				ngDialog.openConfirm({
					data: {
						heading: 'Are You Sure?',
						subHeading: 'Please confirm that you want to delete payment method.',
						confirmBtnText: 'Confirm',
						cancelBtnText: 'Cancel'
					},
					template: 'partials/popup/confirm-popup.html',
				}).then(function (confirm) {
					$scope.cart.checkout.updatingPaymentMethods = true;
					hsUserPayments.deletePaymentMethod(value.pmid)
						.then(function(resp) {
							$scope.cart.userData = resp;
							$scope.cart.checkout.setPaymentMethod();
							toastr.success('Account Updated Successfully');
						})
						.catch(function(err) {
							toastr.error(err);
						})
						.finally(function() {
							$scope.cart.checkout.updatingPaymentMethods = false;
						})
				}, function (reject) {
					void 0;
					return;
				});
			},
			setSelectedCard(value) {
				var pmid = value.pmid;	
				var targetPaymentMethod = $scope.cart.checkout.paymentMethods.find(function(paymentMethod) {
					return paymentMethod.pmid === pmid;
				});

				$scope.cart.checkout.selectedPaymentMethod = targetPaymentMethod;
				$scope.cart.checkout.setPaymentMethod();
			},
			selectPaymentMethod() {
				$scope.cart.checkout.processStep('payment');
			},
			addCardToUser: function (userData) {
				$scope.cart.userData = userData;
				$scope.cart.checkout.paymentMethod = null;
				$scope.cart.checkout.selectedPaymentMethod = null;
				$scope.cart.checkout.setPaymentMethod();
				if ($scope.cart.checkoutSteps.hasPaymentMethod) {
					$scope.cart.checkout.processStep('payment');
				}
			},
			getAddPaymentTitleText() {
				var location = globalFunctions.getSelectedLocationFromStorage();

				if (hsUtils.isObject(location) && hsUtils.isObject(location.ebtConfig) && location.ebtConfig.enabled) {
					return 'Add New Payment Method';
				}

				return 'Add New Credit/Debit Card';
			},
            setPaymentMethod(autoReload) {
                $scope.cart.checkout.paymentProcessor = $rootScope.paymentProcessor;

				var paymentMethods = $scope.cart.userData.paymentMethods || [];
				
				paymentMethods = paymentMethods.filter(function(pm) {
					return pm.paymentProcessor === $scope.cart.checkout.paymentProcessor
						|| pm.paymentProcessor === hsUserPayments.PAYMENT_PROCESSORS.forage;
				});
				$scope.cart.checkout.paymentMethods = paymentMethods;

				var selected = $scope.cart.checkout.selectedPaymentMethod;
				if (autoReload && hsUtils.isObject(selected) && selected.pmid) {
				    $scope.cart.checkout.paymentMethod = $scope.cart.checkout.paymentMethods.find(function (pm) {
				        return pm.pmid === selected.pmid;
				    });
					$scope.cart.checkout.setHasPaymentMethod();
				    if ($scope.cart.checkout.paymentMethod) return;
				}

				if(hsUtils.isNonEmptyArray(paymentMethods)) {
					var ebtPaymentMethod = paymentMethods.find(function(paymentMethod) {
						return paymentMethod.paymentProcessor === hsUserPayments.PAYMENT_PROCESSORS.forage;
					});
                    $scope.cart.ebt.setPaymentMethod(ebtPaymentMethod, autoReload);

					if (hsUtils.isObject(ebtPaymentMethod)) {
						$scope.cart.checkoutSteps.hasEbtPaymentMethod = true;
                    }

					var defaultPaymentMethod = paymentMethods.find(function(paymentMethod) {
						return paymentMethod.default && paymentMethod.paymentProcessor !== hsUserPayments.PAYMENT_PROCESSORS.forage;
					});

					var selectedPaymentMethod = null;
					if (hsUtils.isObject($scope.cart.checkout.selectedPaymentMethod)) {
						selectedPaymentMethod = paymentMethods.find(function(paymentMethod) {
							return paymentMethod.pmid  === $scope.cart.checkout.selectedPaymentMethod.pmid
						}) || null;
					}
					
					if (!selectedPaymentMethod ||
						(hsUtils.isObject(defaultPaymentMethod) && !hsUtils.isObject($scope.cart.checkout.selectedPaymentMethod))
					) {
						$scope.cart.checkout.selectedPaymentMethod = defaultPaymentMethod;
					}

					$scope.cart.checkout.paymentMethod = $scope.cart.checkout.selectedPaymentMethod || {};
					$scope.cart.checkout.setHasPaymentMethod();
				} else {
                    $scope.cart.ebt.setPaymentMethod(null);
					$scope.cart.checkout.paymentMethod = {};
					$scope.cart.checkout.setHasPaymentMethod();
                    return;
				}
				$scope.cart.checkout.setHasPaymentMethod();
            },
            setHasPaymentMethod() {
                var ccKeys = ['cardBrand', 'cardLast4'];
                var paymentMethod = $scope.cart.checkout.paymentMethod;
                $scope.cart.checkoutSteps.hasPaymentMethod = ccKeys.every(function(key) {
                    return paymentMethod && paymentMethod[key];
                });
            },
		    proceedToStep (step) {
        		$scope.cart.config.checkoutError = '';
        		Object
			        .keys($scope.cart.checkout.steps)
			        .forEach(function (key) {
			            $scope.cart.checkout.steps[key].current = (key === step);

			        	if (key === step) {
			        		$scope.cart.checkout.selectedStep = key;
			        		$scope.cart.checkout.steps[key].activated = true;

			        		setTimeout(function() {
						        $scope.cart.config.scrollTo('#' + $scope.cart.checkout.steps[key].stepId);
					        }, 500);
				        }
			        });
		    },
		    processCheckoutInfoAdded () {
        		switch($scope.cart.selectedFulfillmentMethod) {
			        case 'pickup' :
				        if ($scope.cart.acceptCreditCard()) {
					        $scope.cart.checkout.proceedToStep('payment');
				        } else {
					        $scope.cart.checkout.proceedToStep('contact');
				        }
				        break;

			        case 'delivery' :
			        case 'shipping' :
				        $scope.cart.checkout.proceedToStep('delivery');
				        break;
		        }
		    },
		    processStepByFulfillmentMethod (fulfillmentMethod) {
			    var selectedMethod = $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod];
			    if (selectedMethod.hasOwnProperty('unavailable')
				    && selectedMethod.unavailable.reason === 'Minimum Order Constraint Not Met') {
				    return;
			    }

			    var requirePayment = $scope.cart.acceptCreditCard();
			    void 0;
                void 0;
                
        		switch(fulfillmentMethod) {
			        case 'pickup':
                        if (!$scope.cart.acceptCreditCard()) {
                            if ($scope.cart.checkoutSteps.hasPhone) {
                                if (!$scope.cart.deliveryTimeRequired) {
                                    $scope.cart.checkout.skipToStep('summary');
                                } else {
                                    $scope.cart.checkout.skipToStep('preferences');
                                }
                            } else {
                                $scope.cart.checkout.proceedToStep('contact');
                            }
                        } else if ($scope.cart.checkout.isHouseChargeAvailable()) {
							$scope.cart.checkout.skipToStep('payment');
						} else if ($scope.cart.checkoutSteps.hasPaymentMethod && $scope.cart.checkoutSteps.hasPhone) {
                            if ($scope.cart.checkout.paymentMethod.hasBillingAddress) {
								if (!$scope.cart.deliveryTimeRequired) {
                                	$scope.cart.checkout.skipToStep('summary');
								} else {
                                	$scope.cart.checkout.skipToStep('preferences');
								}
                            } else {
                                if (!$scope.cart.checkout.updatePayment) {
                                    $scope.cart.checkout.toggleCheckoutUpdateSection('payment');
                                }
                                $scope.cart.checkout.skipToStep('payment');
                            }
                        } else {
                            $scope.cart.checkout.proceedToStep('payment');
                        }
			        	break;
			        case 'delivery':
			        case 'specialDelivery':
		            case 'shipping':
                        var hasAllFieldsCompleted = Object.values($scope.cart.checkoutSteps).every(function(val) { return val; });
                        if ($scope.cart.deliveryPreferences && $scope.cart.deliveryTimeRequired && hasAllFieldsCompleted) {
							if ($scope.cart.checkout.isHouseChargeAvailable()) {
								$scope.cart.checkout.skipToStep('payment');
							} else if ($scope.cart.acceptCreditCard()) {
								if ($scope.cart.checkout.paymentMethod.hasBillingAddress) {
									$scope.cart.checkout.skipToStep('preferences');
								} else {
									if (!$scope.cart.checkout.updatePayment) {
										$scope.cart.checkout.toggleCheckoutUpdateSection('payment');
									}
									$scope.cart.checkout.skipToStep('payment');
								}		
							} else {
								$scope.cart.checkout.skipToStep('preferences');
							}
                        } else {
                            $scope.cart.checkout.proceedToStep('delivery');
                        }
			        	break;
                }
                $scope.cart.config.buttonLoading = false;
            },
            skipToStep(step) {
                var stepKeys = Object.keys($scope.cart.checkout.steps);
                for (var stepKey of stepKeys) {
                    if (stepKey === step) {
                        break;
                    }
                    $scope.cart.checkout.steps[stepKey].activated = true;
                }
                $scope.cart.checkout.proceedToStep(step);
            },
		    processStep (step) {
        		void 0;
        		switch (step) {
			        case 'fulfillmentMethod':
			        	$scope.cart.checkout.processStepByFulfillmentMethod($scope.cart.selectedFulfillmentMethod);
			        	break;

			        case 'delivery' :
                        if ($scope.cart.selectedFulfillmentMethod === 'delivery') {
                            $scope.cart.checkout.proceedToStep('deliveryInstructions');
                        } else {
                            $scope.cart.checkout.processStepByFulfillmentMethod($scope.cart.selectedFulfillmentMethod);
                        }
			        	break;
                    case 'deliveryInstructions':
                        if ($scope.cart.acceptCreditCard()) {
                            $scope.cart.checkout.proceedToStep('payment');
                        } else {
                            $scope.cart.checkout.proceedToStep('contact');
                        }
                        break;
			        case 'payment' :
                        if ($rootScope.tableSideOrder) {
                            $scope.cart.checkout.proceedToStep('summary');
                        } else {
                            $scope.cart.checkout.proceedToStep('contact');
                        }
			        	break;
			        case 'contact' :
				        var nextStep = 'preferences';
			        	if (!$scope.cart.deliveryTimeRequired) {
			        		nextStep = 'summary';
			        	}
			        	$scope.cart.checkout.proceedToStep(nextStep);
			        	break;
			        case 'preferences' :
			        	if ($rootScope.ENV.hideProductPrice) {
			        		$scope.cart.checkout.standAloneCheckout();
				        } else {
				            $scope.cart.checkout.proceedToStep('summary');
				        }
			        	break;
			        case 'back-preferences' :
				        $scope.cart.checkout.proceedToStep('contact');
			        	break;
			        case 'back-contact' :
			        	void 0;
				        if ($scope.cart.selectedFulfillmentMethod === 'pickup') {
					        if ($scope.cart.acceptCreditCard()) {
						        $scope.cart.checkout.proceedToStep('payment');
					        } else {
						        $scope.cart.checkout.proceedToStep('fulfillment');
					        }
				        } else {
					        if ($scope.cart.acceptCreditCard()) {
						        $scope.cart.checkout.proceedToStep('payment');
					        } else {
						        $scope.cart.checkout.proceedToStep('delivery');
					        }
				        }
			        	break;
		        }
		    },
		    addAddress (address, update) {
			    $scope.cart.config.checkoutError = '';
                $scope.$broadcast('validateAddress-checkout-delivery', function(isValid) {
                    if (!isValid) {
                        return;
                    }

                    $scope.cart.config.buttonLoading = true;
                    $scope.cart.outOfCoverageMessage = '';
				    var userData = {
			    		user: {
			    			address: {
							    street          : address.street,
							    aptUnit         : address.aptUnit || '',
							    city            : address.city,
							    state           : address.state,
							    zip             : address.zip
						    }
					    }
				    };

			    	void 0;
                    if (ENV.autoCheckoutLocationChange) {
                        $scope.cart.replacementLocation.checked = getInitReplacementLocationCheckedVal();
                    }
				    hsCart.updateUser(userData)
					    .then(function(res){
					    	void 0;
						    if (res.status === 200) {
							    $scope.cart.checkoutSteps.hasAddress = true;
							    localStorageService.set('user', res.data);
							    $scope.cart.userData = res.data;

							    if (!update) {
								    toastr.success('Address Added Successfully');
							        $scope.cart.canDeliver = true;
							    } else {
								    toastr.success('Address Updated Successfully');
								    $scope.cart.checkout.toggleCheckoutUpdateSection('address');
								    $scope.cart.config.showUpdatedAddressSection = false;
							    }

							    $scope.cart.checkout.syncCart(true, null, null, null, 'delivery', true);
						    } else {
							    toastr.error('Error Updating Address');
							    $scope.cart.config.checkoutError = "Something went wrong updating your address. Please try again";
                                $scope.cart.config.buttonLoading = false;
						    }
					    });
                });
            },
            addPaymentPreSubmit: function () {
                $scope.cart.config.buttonLoading = true;
            },
            addPaymentSuccess: function () {
                $scope.cart.checkout.updatePayment = false;
                $scope.cart.checkout.selectPayment = false;
                $scope.cart.checkout.syncCart(true, null, null, null, 'payment').then(function () {
                    $scope.cart.config.buttonLoading = false;
                });
            },
            addPaymentFailure: function () {
                $scope.cart.config.buttonLoading = false;
            },
            addPhone(form, update) {
                if(form.validate()) {
                    if ($scope.cart.config.phoneNumberRequiresVerification) {
                        var $newScope = $scope.$new(true);
                        $newScope.phoneNumber = $filter('bcTelephone')($scope.cart.phoneNumber, 'clean');

                        ngDialog.open({
                            template: '<div><code-verification '
                                + 'phone-number="phoneNumber" '
                                + 'on-close="closeThisDialog(value)" '
                                + 'purpose="updatePhoneNumber" '
                                + '></code-verification></div>',
                            className: 'ngdialog-theme-default',
                            plain: true,
                            scope: $newScope,
                        }).closePromise
                            .then(function(data) {
                                void 0;
                                if (data.value) {
                                    if (data.value.error) {
                                        toastr.error(data.value.error);
                                    } else if (data.value.user) {
                                        $scope.cart.checkoutSteps.hasPhone = true;
                                        localStorageService.set('user', data.value.user);
                                        $scope.cart.userData = data.value.user;
                                        $rootScope.currentUser = data.value.user;

                                        if (!update) {
                                            toastr.success('Contact Info Added Successfully');
                                        } else {
                                            toastr.success('Contact Info Updated Successfully');
                                            $scope.cart.checkout.toggleCheckoutUpdateSection('phone');
                                        }
                                        return $scope.cart.checkout.syncCart(true, null, null, null, 'contact')
                                    }
                                }
                            })
                            .catch(function(err) {
                                void 0;
                                toastr.error('Could not verify phone number. Please try again.');
                            })
                            .finally(function() {
                                $scope.cart.config.buttonLoading = false;
                            });
                    } else {
                        $scope.cart.checkout._addPhone(form, update);
                    }
                }
            },
		    _addPhone (form, update) {
			    $scope.cart.config.checkoutError = '';
			    if (form.validate()) {
				    $scope.cart.config.buttonLoading = true;
				    var userData = {
			    		user: {
			    			phoneNumber: $filter('bcTelephone')($scope.cart.phoneNumber, 'clean')
					    }
				    };

			    	void 0;

				    hsCart.updateUser(userData)
					    .then(function(res){
						    void 0;
						    if (res.status === 200) {
							    $scope.cart.checkoutSteps.hasPhone = true;
							    localStorageService.set('user', res.data);
							    $scope.cart.userData = res.data;

							    if (!update) {
								    toastr.success('Contact Info Added Successfully');
							    } else {
								    toastr.success('Contact Info Updated Successfully');
								    $scope.cart.checkout.toggleCheckoutUpdateSection('phone');
							    }

							    $scope.cart.checkout.syncCart(true, null, null, null, 'contact').then(function() {
                                    $scope.cart.config.buttonLoading = false;
                                });
						    } else {
							    toastr.error('Error Updating Contact Info');
							    if (res.status === 402) {
								    $scope.cart.config.checkoutError = "Your credit card was declined. Please check your card and try again.";
								    toastr.error('Your credit card was declined. Please check your card and try again.');
							    } else {
								    $scope.cart.config.checkoutError = "Something went wrong. Please try again.";
								    toastr.error('Something went wrong. Please try again.');
							    }
                                $scope.cart.config.buttonLoading = false;
						    }
					    });
			    }
		    },
		    addCheckoutInfo (form, address, phoneNumber) {
			    $scope.cart.config.checkoutError = '';
			    if (form.validate()) {
				    var apiUrls                 = [],
					    userData                = {
						    user    : {}
					    };

				    if ($scope.cart.selectedFulfillmentMethod !== 'pickup' && !$scope.cart.checkoutSteps.hasAddress){
					    userData.user.address              = {
						    street          : address.street1,
						    aptUnit         : address.street2,
						    city            : address.city,
						    state           : address.state,
						    zip             : address.zip
					    };
					    userData.user.deliveryInstructions = $scope.cart.delivery.instructions || '';
				    }

				    if (!$scope.cart.checkoutSteps.hasPhone) {
					    userData.user.phoneNumber = $filter('bcTelephone')(phoneNumber, 'clean');
				    }

				    if ($scope.cart.acceptCreditCard() && !$scope.cart.checkoutSteps.hasPaymentMethod) {
					    var ccData = {
						    ccNumber    : $scope.cart.billing.ccNumber,
						    expMonth    : $scope.cart.billing.expDate.month,
						    expYear     : $scope.cart.billing.expDate.year,
						    cvc         : $scope.cart.billing.cvc
					    };

					    if (ccData.expYear < 2000) {
						    ccData.expYear = ccData.expYear + 2000;
					    }

					    Stripe.card.createToken({
						    number      : ccData.ccNumber,
						    cvc         : ccData.cvc,
						    exp_month   : ccData.expMonth,
						    exp_year    : ccData.expYear
					    }, function(status, res) {
						    void 0;
						    void 0;
						    if (res.error) {
							    void 0;
							    $scope.cart.config.checkoutError = "There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.";
							    $scope.cart.config.buttonLoading = false;
							    $scope.$apply();
						    } else {
							    userData.user.paymentMethod  = {
								    token       : res.id,
								    last4       : res.card.last4,
								    cardBrand   : res.card.brand
							    };

							    void 0;
							    apiUrls.push(hsCart.updateUser(userData));

							    void 0;
							    $scope.cart.checkout.checkoutInfo(apiUrls, userData.user.paymentMethod, function (error, success) {
								    if (success) {
									    $scope.cart.checkout.processCheckoutInfoAdded();
								    }
							    });
						    }
					    });
				    } else {
					    void 0;
					    apiUrls.push(hsCart.updateUser(userData));

					    void 0;
					    $scope.cart.checkout.checkoutInfo(apiUrls, userData.user.paymentMethod, function (error, success) {
						    if (success) {
							    $scope.cart.checkout.processCheckoutInfoAdded();
						    }
					    });
				    }
			    }
		    },
		    checkoutInfo (apiUrls, ccObj, callback) {
			    $q.all(apiUrls)
				    .then(function(response){
					    void 0;
					    var user = localStorageService.get('user');
					    if(response[0].status === 200){
						    $scope.cart.checkoutSteps = {
							    hasPaymentMethod    : true,
							    hasAddress          : true,
							    hasPhone            : true
						    };
						    user.address = response[0].data.address;
						    if(ccObj){
							    user.paymentMethod = {
								    cardLast4   : ccObj.last4,
								    cardBrand   : ccObj.cardBrand
							    };
						    }
						    void 0;

						    localStorageService.set('user',user);
						    $scope.cart.userData = user;

						    if($scope.cart.selectedShippingOption){
							    setTimeout(function(){
								    scrollToElement('.shipping-speed');
							    },0)
						    }

						    void 0;
						    $scope.cart.canDeliver = true;

						    void 0;
						    toastr.success('Checkout information updated successfully.');
						    $scope.cart.syncCart(true, false, false, true);

						    callback(false, true);
					    } else {
						    switch(response[0].status) {
							    case 402:
								    $scope.cart.config.checkoutError = "Your credit card was declined. Please check your card and try again.";
								    toastr.error('Your credit card was declined. Please check your card and try again.');
								    break;
							    default:
								    $scope.cart.config.checkoutError = "Something went wrong. Please try again.";
								    toastr.error('Something went wrong. Please try again.');
								    break;

						    }

						    callback(true, false);
					    }
					    $scope.cart.config.buttonLoading = false;
				    });
		    },
			sendCheckoutConfirmEvents(items) {
				for(var item of items) {
					aiSearchEvents.sendEvent(globalFunctions.GAEventType.CHECKOUT_CONFIRM, aiSearchEvents.eventAction.PURCHASE, item.name);
				}
			},
		    placeOrder (deliveryAddress, tableSideOrder, ebtSnapPaymentRef) {
                if ($scope.cart.config.buttonLoading) return;

                $scope.cart.config.checkoutError = '';
                var amountToCharge = $scope.cart.totalObj.total - ($scope.cart.ebt.snapAmount.applied || 0);

                if (amountToCharge > 0 && amountToCharge < 0.5) {
                    var message = 'Order not placed: Your current charge is $' + +amountToCharge.toFixed(2)
                        + ' and Credit Card Charges must be $0 or  $0.50. Please adjust to proceed';

                    $scope.cart.config.checkoutError = message;
                    return;
                }
                if ($scope.cart.ebt.snapAmount.applied) {
                    if (!$scope.cart.ebt.showCaptureChargePinInput) {
                        $scope.cart.ebt.showCaptureChargePinInput = true;
                        return;
                    }
                    if (!ebtSnapPaymentRef) {
                        throw 'Missing captured payment parameter.';
                    }
                }
                $scope.cart.config.buttonLoading = true;

			    var selectedReward = localStorageService.get('selectedReward');
			    var discountCode = localStorageService.get('discountCode');

			    var orderParams = {
				    delivery        : {
                        paymentMethods: {},
					    instructions: $scope.cart.delivery.instructions || ''
				    }
			    };
			    if (discountCode && (!ebtSnapPaymentRef || $scope.cart.discountDetails.value > 0)) {
				    orderParams.delivery.discountCode = discountCode;
			    }

			    if (selectedReward) {
				    orderParams.delivery.rewardId = selectedReward.id;
			    }

			    if($scope.cart.fulfillmentMethod !== 'pickup'){
				    if(deliveryAddress){
					    orderParams.delivery.address = {
						    street          : deliveryAddress.street,
						    aptUnit         : deliveryAddress.aptUnit,
						    city            : deliveryAddress.city,
						    state           : deliveryAddress.state,
						    zip             : deliveryAddress.zip
					    };
				    }else {
					    orderParams.delivery.address = {
						    street          : $scope.cart.userData.address.street,
						    aptUnit         : $scope.cart.userData.address.aptUnit,
						    city            : $scope.cart.userData.address.city,
						    state           : $scope.cart.userData.address.state,
						    zip             : $scope.cart.userData.address.zip
					    };
				    }

				    if(ENV.driverTip && $scope.cart.selectedTip.value){
					    orderParams.delivery.tip = parseFloat($scope.cart.selectedTip.value);
				    }
                    if(ENV.enableSeparateTips){
                        if ($scope.cart.selectedShopperTip.value) {
                            orderParams.delivery.shopperTip = parseFloat($scope.cart.selectedShopperTip.value);
                        } else {
                            orderParams.delivery.shopperTip = 0;
                        }
				    }
			    } else {
                    if ($scope.cart.shopperTips.length) {
                        if ($scope.cart.selectedShopperTip.value) {
                            orderParams.delivery.shopperTip = parseFloat($scope.cart.selectedShopperTip.value);
                        } else {
                            orderParams.delivery.shopperTip = 0;
                        }
				    }
                }

                if(tableSideOrder) {
                    hsTableSideOrders.refreshSession();

                    if (ENV.driverTip && $scope.cart.selectedTip.value) {
                        orderParams.delivery.tip = parseFloat($scope.cart.selectedTip.value);
                    }

                    var session = hsTableSideOrders.getSession();

                    if (session) {
                        orderParams.delivery.tableNumber = session.tableNumber;
                        orderParams.delivery.partySize = session.partySize;
                    }
                }

			    orderParams.delivery.fulfillmentMethod = $scope.cart.fulfillmentMethod;

			    if($scope.cart.fulfillmentMethod === 'shipping') {
				    var date = new Date();
				    date = $filter('date')(date, 'd MMM y');

				    orderParams.delivery.deliveryDate = date;
				    orderParams.delivery.shipmentIds  = $scope.cart.selectedShippingOption.shipmentIds;
				    orderParams.delivery.rateIds      = $scope.cart.selectedShippingOption.rateIds;
			    }


			    if($scope.cart.deliveryPreferences && $scope.cart.deliveryTimeRequired) {
				    orderParams.delivery.date = $scope.cart.selectedDeliveryDate.dateString;
					if ($scope.cart.isAsapTimeSelected()) {
						orderParams.delivery.asapTime = $scope.cart.selectedDeliveryTime;
					}
				    orderParams.delivery.time = $scope.cart.priceListHasManagedDelivery() && $scope.cart.isAsapTimeSelected() ?
						($scope.cart.deliveryTimes[0] || $scope.cart.selectedDeliveryDate.timeSlots[0])
						: $scope.cart.selectedDeliveryTime;
			    }

                if ($scope.cart.loyaltyPoints.applied) {
                    orderParams.delivery.payWithPointsRequest = $scope.cart.loyaltyPoints.applied;
                }

                if ($rootScope.currentUser && $rootScope.currentUser.membership && $rootScope.currentUser.membership.isActive) {
                    orderParams.delivery.isMember = true;
                }
                if ($scope.cart.acceptCreditCard() && hsUtils.isObject($scope.cart.checkout.paymentMethod) && $scope.cart.checkout.paymentMethod.pmid) {
                    orderParams.delivery.paymentMethods.card = $scope.cart.checkout.paymentMethod;
                }
                if (ebtSnapPaymentRef) {
                    orderParams.delivery.ebtSnapPaymentRef = ebtSnapPaymentRef;
                }

				orderParams.delivery.houseCharge = $scope.cart.checkout.isHouseChargeOrder;

			    void 0;

			    return hsCart.placeOrder(orderParams)
				    .then(function(response){
					    void 0;
					    $rootScope.fixPageScrolling = false;
					    switch (response.status) {
						    case 200:

                                if (tableSideOrder) {
                                    hsTableSideOrders.setOpenOrder(response.data);
                                }
                                response.data.viewOrderUrl = '/my-account?order=' + encodeURIComponent(response.data.key);
							    localStorageService.set('orderConfirmed', response.data);

							    if (discountCode) {
								    localStorageService.remove('discountCode');
							    }
							    if (selectedReward) {
								    localStorageService.remove('selectedReward');
							    }

                                localStorageService.remove('loyaltyPoints');

							    void 0;
								var orderItems = response.data.items;
								$scope.cart.checkout.sendCheckoutConfirmEvents(orderItems);
							    $location.url('/cart/checkout/confirm');
							    break;
						    case 402:
                                if (response.data.message.toLowerCase().includes('we are unable to validate')) {
                                    $scope.cart.config.checkoutError = response.data.message;
                                } else {
                                    $scope.cart.config.checkoutError = "Sorry, the payment card associated with your account was declined. To proceed with the order, please make sure the billing address and CVC are correct and the card has enough funds, or ask the issuing bank to authorize this transaction or enter a new payment card.";
                                }
							    $scope.cart.config.buttonLoading = false;
							    break;
						    default:
							    $scope.cart.config.checkoutError = "Something went wrong. Please try again";
							    $scope.cart.config.buttonLoading = false;
							    break;
					    }
				    });

		    },
		    syncCart (checkoutPage, autoReload, isApplyingDiscount, updateScope, step, recheckDelivery) {
                void 0;
			    var apiUrls = [hsCart.getCartItems(null, false, localStorageService.get('snapAmount'))];

			    if (checkoutPage) {
				    $scope.cart.checkRewards();
			    }

			    void 0;
			    return hsAuth.getUpdatedUser()
				    .then(function(response) {
					    void 0;
					    if(response.status === 200) {
                            $rootScope.currentUser = response.data;
						    localStorageService.set('user', response.data);
						    $scope.cart.userData = response.data;
                            $scope.cart.checkout.setPaymentMethod(autoReload);
						    if(checkoutPage && !response.data.canPlaceOrder) {
							    $scope.cart.canPlaceOrder           = false;
							    $scope.cart.outOfCoverageMessage    = response.data.displayMessage || '';
							    $scope.cart.config.pageFullyLoaded  = true;
						    } else {
							    if (!autoReload) {
								    $scope.cart.delivery.instructions = response.data.deliveryInstructions || '';
							    }

							    if (response.data.address) {
								    $scope.cart.checkoutSteps.hasAddress = true;
							    }

							    if (response.data.phoneNumber) {
								    $scope.cart.checkoutSteps.hasPhone = true;
							    }

							    if ($scope.cart.acceptCreditCard()) {
                                    $scope.cart.checkout.setHasPaymentMethod();
								    if($scope.cart.checkoutSteps.hasPaymentMethod && $scope.cart.checkoutSteps.hasPhone){
									    $scope.cart.gotAllPickupInfo = true;
								    }
							    } else {
								    delete $scope.cart.checkoutSteps.hasPaymentMethod;
								    if($scope.cart.checkoutSteps.hasPhone){
									    $scope.cart.gotAllPickupInfo = true;
								    }
							    }

							    var gotInfo = true;
							    angular.forEach($scope.cart.checkoutSteps, function(val, key){
								    if ($scope.cart.checkoutSteps[key] === false){
									    gotInfo = false;
								    }
							    });

							    $scope.cart.gotAllInfo = gotInfo;

							    return $q.all(apiUrls)
								    .then(function(res){
									    void 0;
									    var basketData = res[0].data;
										for (var fulfillmentType in basketData.orderFee) {
											if (basketData.orderFee[fulfillmentType].isDisabled) {
												delete basketData.orderFee[fulfillmentType];
											}
										}

                                        $scope.cart.sanitizeFulfillmentMethods(basketData.orderFee);
									    $scope.cart.containsAlcohol = basketData.containsAlcohol;
										// delete basketData.orderFee['pickup'];

                                        $scope.cart.ebt.setPaymentMethod(basketData.ebtPaymentMethod, true);
                                        $scope.cart.ebt.setBalance(basketData.ebtBalance);

									    if (!checkoutPage) {
										    var needBasketSync = false;
										    var globalLeaveOut = true;
										    var globalReplaceAll = true;
										    basketData.basketItems.forEach(function (item) {
											    void 0;
											    if (!item.hasOwnProperty('canReplace')) {
												    needBasketSync = true;
												    item.canReplace = !ENV.isRestaurant;
												    item.leaveOut = !item.canReplace;
											    } else {
												    item.leaveOut = !item.canReplace;
											    }

											    if (item.leaveOut === false) {
												    globalLeaveOut = false;
											    }

											    if (item.canReplace === false) {
												    globalReplaceAll = false;
											    }
										    });

										    $scope.cart.leaveAll = globalLeaveOut;
										    $scope.cart.replaceAll = globalReplaceAll;

										    $scope.cart.originalBasketItems = basketData.basketItems;
										    if (needBasketSync) {
											    $scope.cart.updateCart(null, true, true);
										    }
									    }

									    // sorting the fee options by lowest shipping price
									    if(basketData.orderFee['shipping']) {
										    var shippingFeeOptions = JSON.parse(JSON.stringify(basketData.orderFee['shipping'].fee));
										    var feeOptions = {};

										    angular.forEach(basketData.orderFee['shipping'].fee, function(value, key) {
											    shippingFeeOptions[key].name = key;
										    });

										    var sortedList = Object.values(shippingFeeOptions).sort(function(a,b){return a.shipping - b.shipping});

										    sortedList.forEach(function(item) {
											    feeOptions[item.name] = item;
										    });
										    basketData.orderFee['shipping'].fee = feeOptions
									    }

									    if (!autoReload) {
										    if (!basketData.orderFee[$scope.cart.fulfillmentMethod]) {
											    $scope.cart.fulfillmentMethod = Object.keys(basketData.orderFee)[0];
										    }

										    angular.forEach(basketData.orderFee, function(val, key) {
											    if (val.name === $scope.cart.fulfillmentMethod) {
												    val.checked = true;
												    if (checkoutPage) {
													    $scope.cart.selectedFulfillmentMethod = val.name;

													    if (val.hasOwnProperty('unavailable') &&
														    (val.unavailable.reason === 'Minimum Order Constraint Not Met'
														    || val.unavailable.reason === 'At Capacity')) {
														    $scope.cart.renderCheckoutOptions = false;
														    $scope.cart.renderSummaryDetails = false;

														    $scope.cart.allSlotsFull = val.unavailable.reason === 'At Capacity';
														    $scope.cart.allSlotsFullMessage = val.unavailable.reasonDisplay;
													    }
												    }
											    } else {
												    val.checked = false;
											    }
										    });
									    }

									    //Processing Cart Items
									    if(basketData.basketItems.length === 0) {
										    $scope.cart.config.emptyCart = true;
										    var total = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].total, 2);

										    $rootScope.cartGlobal = {
											    items       : [],
											    itemsTotal  : 0,
											    cartSubTotal: 0,
											    cartTotal   : 0,
											    coupon      : false,
											    deliveryFee : false
										    };

										    $scope.cart.totalObj = {
                                                bottleFee: $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].bottleFee, 2),
											    subTotal            : $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].subTotal, 2),
											    delivery            : basketData.orderFee[$scope.cart.fulfillmentMethod],
											    fullfillmentOptions : basketData.orderFee,
											    tax                 : $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].tax, 2),
											    originalTotal       : total,
											    total               : total,
											    checkoutMessage     : basketData.checkoutMessage
										    };
									    } else {
										    $scope.cart.data = $scope.cart.filterProductsByCategory(basketData.basketItems);

										    $scope.cart.discountDetails = basketData.orderFee[$scope.cart.fulfillmentMethod].discount || {};

										    if (isApplyingDiscount && $scope.cart.discountCode !== "" && !$scope.cart.discountDetails.code) {
											    toastr.error('Discount code is invalid, already used or not applicable to your account.');
										    }

										    if ($scope.cart.rewardsData.selectedReward && !$scope.cart.discountDetails.value) {
											    toastr.error('The Reward is not applicable.');
										    }

										    var total = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].total, 2);

										    $rootScope.cartGlobal = {
											    items       : basketData.basketItems,
											    itemsTotal  : basketData.basketItems.length,
											    cartSubTotal: $filter('number')(basketData.basketSubTotal, 2),
											    cartTotal   : total,
											    coupon      : basketData.coupon,
											    deliveryFee : basketData.orderFee[$scope.cart.fulfillmentMethod].fee
										    };

										    $scope.cart.totalObj.subTotal            = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].subTotal, 2);
                                            $scope.cart.totalObj.bottleFee = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].bottleFee, 2);
										    $scope.cart.totalObj.delivery            = basketData.orderFee[$scope.cart.fulfillmentMethod];
										    $scope.cart.totalObj.fullfillmentOptions = basketData.orderFee;
										    $scope.cart.totalObj.tax                 = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].tax, 2);
										    $scope.cart.totalObj.originalTotal       = total;
										    $scope.cart.totalObj.total               = total;
										    $scope.cart.totalObj.checkoutMessage     = basketData.checkoutMessage;

                                            if (basketData.ebtEligible) {
                                                $scope.cart.totalObj.ebtSnapEligible = basketData.ebtEligible;
                                            }

										    if($scope.cart.fulfillmentMethod === 'shipping'
											    && basketData.orderFee.shipping.fee) {
											    if(!$scope.cart.selectedShippingKey) {
												    $scope.cart.selectedShippingKey =
													    Object.keys(basketData.orderFee.shipping.fee)[0];
											    }

											    $scope.cart.selectedShippingOption =
												    basketData.orderFee.shipping.fee[$scope.cart.selectedShippingKey];


											    $scope.cart.totalObj.subTotal = $filter('number')($scope.cart.selectedShippingOption.subTotal, 2);
											    $scope.cart.totalObj.tax = $filter('number')($scope.cart.selectedShippingOption.tax, 2);
											    $scope.cart.totalObj.total = $filter('number')($scope.cart.selectedShippingOption.total, 2);
											    $scope.cart.totalObj.originalTotal = $filter('number')($scope.cart.selectedShippingOption.total, 2);
											    $scope.cart.totalObj.shipping = $filter('number')($scope.cart.selectedShippingOption.shipping, 2);
											    $scope.cart.renderSummaryDetails = $scope.cart.checkoutSteps.hasAddress;

										    } else {
											    if (($scope.cart.selectedFulfillmentMethod === 'delivery'
												    || $scope.cart.selectedFulfillmentMethod === 'specialDelivery')
												    && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable')) {
												    $scope.cart.canDeliver              = false;
												    $scope.cart.deliveryUnavailableMsg  = true;

												    if (recheckDelivery) {
												    	$scope.cart.checkout.initDeliveryStep();
													}

												    if (basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason !== 'Delivery Address Not Available') {
													    $scope.cart.outOfCoverageMessage    = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reasonDisplay;
                                                        $scope.cart.isMinOrderConstraintMet = false;
												    } else {
													    $scope.cart.outOfCoverageMessage = '';
                                                        $scope.cart.isMinOrderConstraintMet = true;
												    }
											    } else {
												    $scope.cart.canDeliver              = true;
												    $scope.cart.deliveryUnavailableMsg  = false;
												    $scope.cart.outOfCoverageMessage    = '';

												    if (step && step === 'delivery') {
                                                        $scope.cart.checkout.processStepByFulfillmentMethod($scope.cart.selectedFulfillmentMethod);
												    } else if (step) {
                                                        $scope.cart.checkout.processStep(step);
                                                    }
											    }

											    /*if (($scope.cart.selectedFulfillmentMethod !== 'pickup')
												    && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable')) {
											    	console.log('Delivery Unavailable');
												    $scope.cart.canDeliver              = false;
                                                    $scope.cart.outOfCoverageMessage    = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reasonDisplay
											    } else {
											    	console.log('Delivery Available');
												    $scope.cart.canDeliver              = true;
												    $scope.cart.outOfCoverageMessage    = '';
												    if (step) {
													    $scope.cart.checkout.processStep(step);
												    }
											    }*/
												if($scope.cart.selectedFulfillmentMethod &&
												    !basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('availableTimes')){
												    $scope.cart.renderSummaryDetails    = true;

											    } else if($scope.cart.selectedFulfillmentMethod &&
												    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('availableTimes') &&
												    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes.length){
												    $scope.cart.deliveryPreferences     = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes;
													
													var selectedPriceList = hsCart.getSelectedPriceList();

													if (hsUtils.isObject(selectedPriceList) && selectedPriceList.type === $scope.cart.priceListTypes.CATERING) {
														var deliveryPreferences = $scope.cart.deliveryPreferences;
														var firstDate = deliveryPreferences[0];
														var lastDate = deliveryPreferences[deliveryPreferences.length - 1];
														var firstDateObj = new Date(firstDate.year, firstDate.monthNum - 1, firstDate.date);
														var lastDateObj = new Date(lastDate.year, lastDate.monthNum - 1, lastDate.date);
														
														$scope.cart.fulfillmentDate.model = firstDateObj;
														$scope.cart.fulfillmentDate.dateOptions.minDate = firstDateObj;
														$scope.cart.fulfillmentDate.dateOptions.maxDate = lastDateObj;
													}

													var dateObjIndex = -1;
												    var timeObjIndex = -1;
												    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes.forEach(function (dateObj, idx) {
												    	dateObj.checked = false;
													    if ($scope.cart.selectedDeliveryDate
														    && $scope.cart.selectedDeliveryDate.dateString === dateObj.dateString) {
														    dateObj.checked = true;
														    dateObjIndex = idx;

														    $scope.cart.selectedDeliveryDate    = dateObj;
														    timeObjIndex = dateObj.timeSlots.indexOf($scope.cart.selectedDeliveryTime);
													    }
												    });


												    if (dateObjIndex === -1) {
                                                        $scope.cart.deliveryPreferences = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes;
													    $scope.cart.deliveryPreferences[0].checked = true;
													    $scope.cart.selectedDeliveryDate = $scope.cart.deliveryPreferences[0];
												    }

                                                    $scope.cart.deliveryTimes = hsCart.filterTimeSlots($scope.cart.selectedDeliveryDate.timeSlots, $scope.cart.getProductsWithAvailableTimes());
                                                    $scope.cart.setDeliveryDateAndTime();

                                                    if(timeObjIndex === -1 && ENV.enableNewCheckout) {
														$scope.cart.setSelectedDeliveryTime();
                                                    }

												    $scope.cart.renderSummaryDetails    = true;
											    } else {
												    $scope.cart.deliveryPreferences     = false;
												    $scope.cart.selectedDeliveryDate    = false;
												    $scope.cart.deliveryTimes           = false;
												    $scope.cart.selectedDeliveryTime    = false;
												    $scope.cart.canDeliver              = !$scope.cart.deliveryTimeRequired;

													if (!$scope.cart.checkoutSteps.hasAddress
													    || ($scope.cart.selectedFulfillmentMethod === 'delivery'
													    && !$scope.cart.canDeliver)) {
													    $scope.cart.renderSummaryDetails = false;
												    }
											    }
										    }
									    }


									    //checking for Pickup Method
									    if (basketData.orderFee.pickup && (!basketData.orderFee.pickup.hasOwnProperty('isDisabled')
												|| !basketData.orderFee.pickup.isDisabled)) {
										    $scope.cart.pickupAvailable = true;
										    $scope.cart.renderCheckoutOptions = false;
									    } else {
										    $scope.cart.renderCheckoutOptions = true;
									    }

									    // Check for Method At Capacity
									    if (checkoutPage && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') &&
										    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'At Capacity') {
										    $scope.cart.renderCheckoutOptions = false;
										    $scope.cart.renderSummaryDetails = false;

										    $scope.cart.allSlotsFull = true;
										    $scope.cart.allSlotsFullMessage = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reasonDisplay;
									    } else {
										    $scope.cart.allSlotsFull = false;
										    $scope.cart.allSlotsFullMessage = "";
									    }

                                        if ($scope.cart.selectedFulfillmentMethod) {
										    $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod].checked = true;
										    if(basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') &&
											    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Minimum Order Constraint Not Met') {
											    $scope.cart.renderCheckoutOptions = false;
											    $scope.cart.renderSummaryDetails = false;
										    } else {
											    $scope.cart.renderCheckoutOptions = true;
											    if (step) {
											    	if (step === 'delivery' && !$scope.cart.canDeliver) {
                                                        if (!recheckDelivery) {
                                                            $scope.cart.config.buttonLoading = false;
                                                        }
                                                    } else {
                                                        $scope.cart.checkout.processStep(step);
                                                    }
											    }
										    }
									    }
									    
                                        /* Addressed merge conflict - was commented out in step-by-step-checkout branch
                                         * Can be safely deleted?
                                        $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod].checked = true;
									    if(
                                            (
                                                basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') && (
                                                basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Minimum Order Constraint Not Met' ||
                                                basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Pickup Only Item In Cart')
                                            )
                                        ) {
										    $scope.cart.renderCheckoutOptions = false;
										    $scope.cart.renderSummaryDetails = false;
									    } else {
										    $scope.cart.renderCheckoutOptions = true;
                                        }
                                        */


									    /*if (!autoReload
										    && !$scope.cart.allSlotsFull
										    && $scope.cart.selectedDeliveryDate
										    && $scope.cart.selectedDeliveryDate.hasOwnProperty('shortDay')
										    && $scope.cart.selectedDeliveryDate.shortDay !== 'Today') {
										    $scope.cart.showFutureOrderAlert();
									    }*/

                                        if (typeof $scope.cart.totalObj.subTotal === 'string') {
										    $scope.cart.totalObj.subTotal = parseFloat($scope.cart.totalObj.subTotal.split(",").join(""));
									    }
									    if (typeof $scope.cart.totalObj.total === 'string') {
										    $scope.cart.totalObj.total = parseFloat($scope.cart.totalObj.total.split(",").join(""));
									    }
									    if (typeof $scope.cart.totalObj.originalTotal === 'string') {
										    $scope.cart.totalObj.originalTotal = parseFloat($scope.cart.totalObj.originalTotal.split(",").join(""));
									    }


									    if(isApplyingDiscount) {
										    if($scope.cart.discountDetails.code) {
											    toastr.success('Discount code successfully applied.');
											    $scope.cart.config.showDiscountCodeBox = false;
										    } else {
											    $scope.cart.config.showDiscountCodeBox = true;
											    $scope.cart.discountCode = '';
											    localStorageService.remove('discountCode');
											    localStorageService.remove('selectedReward');
										    }
									    } else {
										    if(!$scope.cart.discountDetails.code) {
											    localStorageService.remove('discountCode');
											    localStorageService.remove('selectedReward');
											    $scope.cart.config.showDiscountCodeBox = true;
										    } else if(!autoReload){
											    $scope.cart.config.showDiscountCodeBox = false;
										    }
									    }

                                        //Processing Tips
                                        if (($scope.cart.showShopperTipSection || $scope.cart.selectedFulfillmentMethod === 'pickup') 
                                            && $scope.cart.totalObj.delivery.tips
                                        ) {
                                            void 0;
                                            $scope.cart.totalObj.delivery.shopperTips = JSON.parse(JSON.stringify($scope.cart.totalObj.delivery.tips));
                                        }

									    //Processing Tips
									    if($scope.cart.totalObj.delivery.tips){
										    angular.forEach($scope.cart.totalObj.delivery.tips, function(tip){
											    tip.title = tip.display;
											    tip.checked = ($scope.cart.selectedTip && $scope.cart.selectedTip.title === tip.title);
											    if (tip.checked) {
												    $scope.cart.totalObj.total = $filter('number')(tip.total, 2);
												    $scope.cart.selectedTip = tip;
											    }

											    if (!$scope.cart.selectedTip) {
												    $scope.cart.totalObj.total = $filter('number')(tip.total, 2);
												    $scope.cart.selectedTip = tip;
												    tip.checked = true;
											    }
										    });

										    var otherTipNode = {
											    display : 'Other',
											    value   : $scope.cart.selectedTip.title === 'Other'?
												    parseFloat($scope.cart.selectedTip.value) :
												    parseFloat(($scope.cart.totalObj.delivery.tips[0].value).toFixed(2)),
											    title   : 'Other',
											    checked : ($scope.cart.selectedTip.title === 'Other')
										    };

										    otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;
                                            
										    $scope.cart.totalObj.delivery.tips.push(otherTipNode);

										    $scope.cart.tips = $scope.cart.totalObj.delivery.tips;

										    if($scope.cart.selectedTip.total) {
											    $scope.cart.processTip($scope.cart.selectedTip);
										    }
									    }

                                         //Process Shopper Tips
                                        if (($scope.cart.showShopperTipSection || $scope.cart.selectedFulfillmentMethod === 'pickup') 
                                            && $scope.cart.totalObj.delivery.shopperTips
                                        ) {
                                            var selectedShopperTipExists = $scope.cart.totalObj.delivery.shopperTips.some(function(tip) { 
                                                return tip.title === $scope.cart.selectedShopperTip.title;
                                            });

                                            if (!selectedShopperTipExists) {
                                                $scope.cart.selectedShopperTip = false;
                                            }

                                            angular.forEach($scope.cart.totalObj.delivery.shopperTips, function(tip){
                                                tip.title = tip.display;
                                                tip.shopperChecked = ($scope.cart.selectedShopperTip && $scope.cart.selectedShopperTip.title === tip.title);
                                                if (tip.shopperChecked) {
                                                    $scope.cart.totalObj.total = $filter('number')(tip.total, 2);
                                                    $scope.cart.selectedShopperTip = tip;
                                                }

                                                if (!$scope.cart.selectedShopperTip) {
                                                    $scope.cart.totalObj.total = $filter('number')(tip.total, 2);
                                                    $scope.cart.selectedShopperTip = tip;
                                                    tip.shopperChecked = true;
                                                }
                                            });
                                        
                                            var otherTipNode = {
                                                display : 'Other',
                                                value   : $scope.cart.selectedShopperTip.title === 'Other'
                                                    ? parseFloat($scope.cart.selectedShopperTip.value)
                                                    : parseFloat(($scope.cart.totalObj.delivery.shopperTips[0].value).toFixed(2)),
                                                title   : 'Other',
                                                checked : ($scope.cart.selectedShopperTip.title === 'Other')
                                            };
                                        
                                            otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

                                            $scope.cart.totalObj.delivery.shopperTips.push(otherTipNode);
                                            
                                            $scope.cart.shopperTips = $scope.cart.totalObj.delivery.shopperTips;

                                            if($scope.cart.selectedShopperTip.total) {
                                                $scope.cart.processShopperTip($scope.cart.selectedShopperTip);
                                            }
                                        }

                                        if (typeof $scope.cart.totalObj.subTotal === 'string') {
										    $scope.cart.totalObj.subTotal = parseFloat($scope.cart.totalObj.subTotal.split(",").join(""));
									    }
									    if (typeof $scope.cart.totalObj.total === 'string') {
										    $scope.cart.totalObj.total = parseFloat($scope.cart.totalObj.total.split(",").join(""));
									    }
									    if (typeof $scope.cart.totalObj.originalTotal === 'string') {
										    $scope.cart.totalObj.originalTotal = parseFloat($scope.cart.totalObj.originalTotal.split(",").join(""));
									    }
									    $scope.cart.updateAlertMessage();

									    if (updateScope) {
										    $scope.cart.config.buttonLoading = false;
										    $scope.cart.config.pageFullyLoaded = true;

										    setTimeout(function(){
											    scrollToElement('.delivery-options-container');
										    }, 1000);
									    } else if (!autoReload) {
										    $scope.cart.config.pageFullyLoaded = true;
                                        }
								    })
								    .catch(function(err){
									    void 0;
									    toastr.error('Error getting cart information. Please reload the page.')
								    });
						    }
					    } else {
						    hsAuth.logoutUser();
					    }
				    });
	    	},
			handleSelectChargeType: function(value) {
				if (hsUtils.isNonEmptyObject(value) && hsUtils.isBoolean(value.isHouseChargeOrder)) {
					$scope.cart.checkout.isHouseChargeOrder = value.isHouseChargeOrder;
				}
			},
			isHouseChargeAvailable: function() {
				return hsUserPayments.isHouseChargeAvailable($scope.cart.userData);
			},
			getPaymentDrawerDescription: function() {
				if ($scope.cart.checkout.isHouseChargeOrder) {
					return 'Housecharge';
				} else if (!$scope.cart.checkout.paymentMethods.length || !hsUtils.isNonEmptyObject($scope.cart.checkout.paymentMethod)) {
					return 'Add New Payment';
				}
				return $scope.cart.checkout.paymentMethod
					? $scope.cart.checkout.paymentMethod.cardBrand + ' ' + $scope.cart.checkout.paymentMethod.cardLast4
					: '';
			},
		},
	    billing 					: {
            ccNumber				: '',
            expDate					: '',
            cvc						: ''
		},
	    closeSummaryPopup() {
        	this.showSummaryPopup = false;
        	$rootScope.fixPageScrolling = false;
	    },
		canAccessCheckout() {
            void 0;
            var checkoutUrl = $rootScope.tableSideOrder ? '/checkout/table-side' : '/cart/checkout';

        	if (this.containsAlcohol) {
        		if ($rootScope.loggedIn) {
			        ngDialog.open({
				        template        : 'partials/popup/alcohol-warning-popup.html',
				        controller      : 'ModalController',
				        className       : 'ngdialog-theme-default email-capture',
				        showClose       : true,
				        closeByDocument : false,
				        closeByEscape   : false,
				        closeByNavigation: true,
				        scope           : $scope,
				        name            : 'alcoholWarningPopup',
				        id              : 'alcoholWarningPopup',
				        preCloseCallback: function(value) {
					        if (typeof value === 'boolean' && value === true) {
                                $location.url(checkoutUrl);
					        }
				        }
			        });
		        } else {
	        		$location.url('/login?redirect=/cart');
		        }
			} else {
                $location.url(checkoutUrl);
			}
		},
	    // The Entity that represents the user's billing address
	    billingAddress              : {
		    street1             : "",
		    street2             : "",
		    city                : "",
		    state               : "",
		    zip                 : "",
		    country             : ""
	    },
	    // The Entity that represents the user's address
	    address                     : {
		    street1             : "",
		    street2             : "",
		    city                : "",
		    state               : "",
		    zip                 : "",
		    country             : ""
	    },
	    // Object used to control notifications on the View
	    notification                : {
		    isAddressEdit           : true,
		    isAddressError          : false,
		    isVerificationLoading   : false,
		    isRegisterAddrLoading   : false,
		    errMessage              : "",
		    reset                   : function() {
			    this.isAddressError         = false;
			    this.isVerificationLoading  = false;
			    this.isRegisterAddrLoading  = false;
			    this.errMessage             = "";
		    }
	    },
	    replacementLocation         : {
        	location: {},
		    checked: getInitReplacementLocationCheckedVal(),
		    showReplacementPopup: false,
            showLocationChangeMessage: false,
            originalLocation: null,
            originalPriceList: null,
            switchBackToOriginalLocation() {
                var location = $scope.cart.replacementLocation.originalLocation;
                var priceList = $scope.cart.replacementLocation.originalPriceList;
                $scope.cart.checkout.selectPickUpMethod();
                $scope.cart.config.buttonLoading = true;
                $scope.cart.replacementLocation.switchLocations(location, priceList).then(function () {
                    $scope.cart.replacementLocation.showLocationChangeMessage = false;
                    $scope.cart.config.buttonLoading = false;
                    $scope.cart.replacementLocation.checked = getInitReplacementLocationCheckedVal();
                    $scope.cart.checkout.processStepByFulfillmentMethod($scope.cart.selectedFulfillmentMethod);
                });
            },
            switchLocations(selectedLocation, selectedPriceList) {
                var location = localStorageService.get('location');
                var locationData = {
                    allLocations: location.allLocations,
                    selectedLocation: selectedLocation
                };
                localStorageService.set('location', locationData);
                if (selectedPriceList) {
				    localStorageService.set('selectedPriceList', selectedPriceList);
			    }
                $rootScope.$emit('locationUpdated', false);

                return $scope.cart.checkout.syncCart(true, null, null, null, null, false);
            },
            /**
             * @TODO - `selectLocation` and `processSelectLocation` are only used by old checkout flow - verify this is true and remove dead code.
             */
		    selectLocation(event, selectedLocation, selectedPriceList) {
			    event.stopPropagation();
			    event.preventDefault();

			    if (!ENV.enablePriceList) {
				    this.processSelectLocation(selectedLocation)
			    } else {
				    this.processSelectLocation(selectedLocation, selectedPriceList);
			    }
		    },
		    processSelectLocation(selectedLocation, selectedPriceList) {
        		var location = localStorageService.get('location');
			    var locationData = {
				    allLocations    	: location.allLocations,
				    selectedLocation	: selectedLocation
			    };

			    void 0;

			    localStorageService.set('location', locationData);

			    if(selectedPriceList) {
				    localStorageService.set('selectedPriceList', selectedPriceList);
			    }

			    $rootScope.$emit('locationUpdated', true);
			    $scope.cart.syncCart(true);
		    },
	    },
        tableSideOrder: {
            init() {
                void 0;
                if (!$rootScope.loggedIn) {
                    $location.url('/login?redirect=/checkout/table-side');
                    return;
                }
                if (!$rootScope.tableSideOrder) {
                    $location.url('/cart/checkout');
                    return;
                }

                $scope.cart.checkoutPage = true;
                globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', 'User landed on checkout page.');

                var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
                    $route.reload();
                });

                $scope.$on('$viewContentLoaded', function(event){
                    $document.bind('scroll',function(){
                        if(!$rootScope.screenWidth.xs && !$rootScope.screenWidth.sm && !ENV.enableNewCheckout) {
                            var window_top = $(window).scrollTop();
                            var anchor      = '.billing-scrolling-anchor';
                            var divToFix    = '.billing-summary';
                            var div_top     = $(anchor).offset().top;
                            if (window_top > div_top) {
                                $(divToFix).addClass('fixed');
                                $(anchor).height($(divToFix).outerHeight());
                            } else {
                                $(divToFix).removeClass('fixed');
                                $(anchor).height(0);
                            }
                        }
                    });

                    var getAllProducts = setInterval(function() {
                        $scope.cart.checkout.syncCart(true, true);
                    }, 60000);

                    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
                        clearInterval(getAllProducts);
                    });
                });

                $scope.$on('$destroy', function() {
                    $document.unbind('scroll');
                    LocationEventListener();
                });

                $scope.cart.fulfillmentMethod = 'pickup';
                $scope.cart.selectedFulfillmentMethod = 'pickup';
                $scope.cart.checkout.syncCart(true)
                    .then(function() {
                        $scope.cart.checkout.proceedToStep('payment');
                    });

                if(ENV.enablePriceList) {
                    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
                        event.preventDefault();
                        $scope.cart.loadLocationsPopup(false, false, function (event) {
                            sessionStorage.setItem('hs_session', new Date());
                            $route.reload();
                        });
                    });

                    $scope.$on('$destroy', function() {
                        sessionExpired();
                    });
                }
            },
            getGratuityMessage() {
                return hsTableSideOrders.getGratuityMessage();
            }
        },
	    checkDeliveryArea           : function (address) {
		    var addressObj = {
			    address : {
				    street          : address.street,
				    aptUnit         : address.aptUnit,
				    city            : address.city,
				    state           : address.state,
				    zip             : address.zip
			    }
		    };
		    
		    void 0;
		    hsCart.verifyAddress(addressObj)
			    .then(function(res) {
				    if(res.status === 200) {
					    void 0;
					    if(res.data.canDeliver) {
						    $scope.cart.replacementLocation.location = res.data.location;

						    var location = localStorageService.get('location');
                            $scope.cart.replacementLocation.originalLocation = location.selectedLocation;

						    var locationData = {
                                allLocations: location.allLocations,
							    selectedLocation: $scope.cart.replacementLocation.location
						    };
                            
						    void 0;
						    localStorageService.set('location', locationData);

                            var selectedPricelist = null;
						    if (ENV.enablePriceList) {
                                $scope.cart.replacementLocation.originalPriceList = localStorageService.get('selectedPriceList');
						    	var pricelist = $scope.cart.replacementLocation.originalPriceList;
						    	locationData.selectedLocation.priceLists.forEach(function(pl){
						    		if (pl.name.toLowerCase() === pricelist.name.toLowerCase()) {
						    			void 0;
						    			selectedPricelist = pl;
								    }
							    });

						    	if (!selectedPricelist) {
						    		selectedPricelist = res.data.location.priceLists[0];
							    }

						        localStorageService.set('selectedPriceList', selectedPricelist);
							    $rootScope.selectedPriceList = selectedPricelist;
						    }

                            $rootScope.$emit('locationUpdated', false);

						    $rootScope.$broadcast('cartUpdated', true);
                            $scope.cart.checkout.syncCart(true, null, null, null, null, false).then(function() {
                                $scope.cart.config.buttonLoading = false;
                                $scope.cart.replacementLocation.checked = true;
                                $scope.cart.replacementLocation.showLocationChangeMessage = true;
                            })
						    setTimeout(function(){
						    	globalFunctions.scrollToElement('.checkout-location-change', 150);
						    }, 300);
					    } else {
                            $scope.cart.config.buttonLoading = false;
                            $scope.cart.replacementLocation.checked = true;
                        }
				    } else {
                        $scope.cart.config.buttonLoading = false;
                    }
			    })
	    },
	    loadLocationsPopup          : function (openingFromCheckout, callback) {
		    $scope.searchPage = false;
		    $scope.runUpdate = false;
		    $scope.openingFromCheckout = openingFromCheckout;

		    void 0;
		    if (!ngDialog.isOpen('locationpopup-dialog') && !ngDialog.isOpen('location-dialog')) {
			    var dialogOptions = {
				    template        : 'partials/popup/select-location.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default email-capture',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'locationPopup',
				    id              : 'locationPopup'
			    };

			    if (callback) {
				    dialogOptions.preCloseCallback = function(value) {
					    callback(value);
				    }
			    }

			    ngDialog.open(dialogOptions);
		    }
	    },
	    showProductPopup            : function (product) {
        	void 0;
        	
        	var modalClass = '';
        	if(product.hasImage){
        		modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
	        }else{
        		modalClass = 'ngdialog-theme-default email-capture';
	        }
        	
		    ngDialog.open({
			    template: 'partials/popup/product-item/product-item-popup.html',
			    controller:'ModalController',
			    className: modalClass,
			    data: product
		    });
	    },
	    showServiceFeePopup         : function () {
        	var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/service-fee-details-popup.html',
			    controller:'ModalController',
			    className: modalClass,
			    data: $scope.cart.totalObj.delivery
		    });
	    },
        showAdjustEbtPopup: function () {
            var modalClass = 'ngdialog-theme-default email-capture';

            ngDialog.open({
                template: 'partials/popup/adjust-ebt-amount-popup.html',
                controller:'ModalController',
                className: modalClass,
                data: { amount: $scope.cart.discountDetails.setEbtSnapTo },
            });
        },
	    showCreditCardHoldPopup     : function () {
        	var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/credit-card-hold-popup.html',
			    controller:'ModalController',
			    className: modalClass
		    });
	    },
	    showLeaveOutPopup() {
        	var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/leave-out-items-popup.html',
			    controller:'ModalController',
			    closeByNavigation: true,
			    className: modalClass
		    });
	    },
	    processTip                  : function (tip) {
            var addValue = 0;
            if ($scope.cart.selectedShopperTip) {
                addValue = parseFloat($scope.cart.selectedShopperTip.value);
            }
			if(tip.title === 'Other'){
				void 0;
				var tipValue = parseFloat(tip.value);
                var total = parseFloat($scope.cart.totalObj.originalTotal);
				$scope.cart.totalObj.total = parseFloat((total + tipValue + addValue).toFixed(2)); 
				$scope.cart.customTip = tip.value;
			}else{
				$scope.cart.totalObj.total = parseFloat((tip.total + addValue).toFixed(2));
			}

			/*console.log("TotalOBJ: ", $scope.cart.totalObj);*/
			$scope.cart.selectedTip = tip;
			/*console.log("tipOBJ: ", $scope.cart.selectedTip);*/

		   angular.forEach($scope.cart.tips, function(tipVal) {
				tipVal.checked = tipVal.title === tip.title;
		   });
		   
		   void 0;
		   
	    },
        processShopperTip: function (tip) {
            var addValue = 0;
            if ($scope.cart.selectedTip && $scope.cart.selectedFulfillmentMethod === 'delivery') {
                addValue = parseFloat($scope.cart.selectedTip.value);
            }
			if(tip.title === 'Other'){
				void 0;
				var tipValue = parseFloat(tip.value);
                var total = parseFloat($scope.cart.totalObj.originalTotal)
				$scope.cart.totalObj.total = parseFloat((total + tipValue + addValue).toFixed(2)); 
				$scope.cart.customShopperTip      = tip.value;
			}else{
				$scope.cart.totalObj.total = parseFloat((tip.total + addValue).toFixed(2));
			}

			$scope.cart.selectedShopperTip = tip;

		   angular.forEach($scope.cart.shopperTips, function(tipVal) {
				tipVal.shopperChecked = tipVal.title === tip.title;
		   });
		   
		   void 0;
		   
	    },
        applyCustomShopperTip              : function () {
			void 0;
			void 0;
			void 0;
			angular.forEach($scope.cart.shopperTips, function(tipVal){
				if (tipVal.title === 'Other') {					
					tipVal.shopperChecked = true;
					$scope.cart.selectedShopperTip = tipVal;
				} else {
					tipVal.shopperChecked = false;
				}
			});

            var addValue = 0;
            if ($scope.cart.selectedTip && $scope.cart.selectedFulfillmentMethod === 'delivery') {
                addValue = parseFloat($scope.cart.selectedTip.value);
            }
			var customShopperTip = parseFloat(this.customShopperTip) || 0;
			void 0;
			$scope.cart.selectedShopperTip.value = parseFloat(customShopperTip.toFixed(2));
            var total = parseFloat($scope.cart.totalObj.originalTotal)
			this.totalObj.total = parseFloat((total + addValue + customShopperTip).toFixed(2));
	    },
	    applyCustomTip              : function () {
			void 0;
			void 0;
			void 0;
			angular.forEach($scope.cart.tips, function(tipVal){
				if (tipVal.title === 'Other') {					
					tipVal.checked = true;
					$scope.cart.selectedTip = tipVal;
				} else {
					tipVal.checked = false;
				}
			});

            var addValue = 0;
            if ($scope.cart.selectedShopperTip) {
                addValue = parseFloat($scope.cart.selectedShopperTip.value);
            }
			var customTip = parseFloat(this.customTip) || 0;
			void 0;
			$scope.cart.selectedTip.value = parseFloat(customTip.toFixed(2));
            var total = parseFloat($scope.cart.totalObj.originalTotal);
			this.totalObj.total = parseFloat((total + addValue + customTip).toFixed(2));
	    },
	    calculateProductPrice       : function (priceObj) {
		    return hsCart.calculateProductPrice(priceObj);
	    },
        calculatePricePerQuantity   : function (priceObj) {
		    return hsCart.calculatePricePerQuantity(priceObj);
	    },
		calculateEstimatedPricePerItem   : function (priceObj, isXs) {
		    return hsCart.calculateEstimatedPricePerItem(priceObj, isXs);
	    },
        calculateAvailableTimeString: function (availableObj) {
            return hsCart.calculateAvailableTimeString(availableObj, 'item');
        },
        showAvailableTimes(product) {
            var $availableTimesScope = $scope.$new(true);
            $availableTimesScope.product = product;

            ngDialog.open({
                template: '<div><available-times '
                    + 'product="product">'
                    + '</available-times></div>',
                scope: $availableTimesScope,
                plain: true,
                closeByDocument: true,
                closeByNavigation: true,
            });
        },
        showCheckoutAvailablePopup() {
            var $checkoutAvailableTimesScope = $scope.$new(true);
            $checkoutAvailableTimesScope.cart = $scope.cart;

            ngDialog.open({
                template: '<div><checkout-available-times '
                    + 'cart="cart" on-close="closeThisDialog()">'
                    + '</checkout-available-times></div>',
                scope: $checkoutAvailableTimesScope,
                plain: true,
                closeByDocument: true,
                closeByNavigation: true,
            });
        },
        hasAvailableTimesItems: function () {
            return $scope.cart.getProductsWithAvailableTimes().length > 0;
        },
        getProductsWithAvailableTimes: function () {
            var products = [];
            Object.keys($scope.cart.data).forEach(function (key) {
                var currentCat = $scope.cart.data[key];
                for (var i = 0; i < currentCat.products.length; i++) {
                    var curProduct = currentCat.products[i];
                    if (Array.isArray(curProduct.availableTimes) && curProduct.availableTimes.length > 0) {
                        products.push(curProduct);
                    }
                }
            });
            return products;
        },
        hasNoTimes: function() {
            return $scope.cart.deliveryTimes.length === 0;
        },
        setDeliveryDateAndTime: function() {
            if ($scope.cart.deliveryTimes.length === 0 && $scope.cart.deliveryTimeRequired) {
                $scope.cart.deliveryPreferences[0].checked = false;
                var found = false;
                for (var i = 1; i < $scope.cart.deliveryPreferences.length ; i++) {
                    var availSlots = hsCart.filterTimeSlots($scope.cart.deliveryPreferences[i].timeSlots, $scope.cart.getProductsWithAvailableTimes());
                    if (availSlots.length > 0) {
                        $scope.cart.deliveryPreferences[i].checked = true;
                        $scope.cart.selectedDeliveryDate = $scope.cart.deliveryPreferences[i];
                        $scope.cart.deliveryTimes = availSlots;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    $scope.cart.deliveryPreferences[0].checked = true;
                }
            }
        },
	    updateCreditCard            : function (form) {
		    $scope.cart.config.updateCCError = '';
		    if (form.validate()) {
			    void 0;
			    $scope.cart.config.updateCCButtonLoading = true;
			
			    var exp = form.ccExpiry.$modelValue;
			    if (!exp || !exp.month || !exp.year) {
				    $scope.cart.config.updateCCError = "Please enter a valid credit card expiration date.";
				    toastr.error('Please enter a valid credit card expiration date.');
				    $scope.cart.config.updateCCButtonLoading = false;
				    return;
			    }

			    var ccData = {
				    ccNumber    : form.ccNumber.$modelValue,
				    expMonth    : exp.month,
				    expYear     : exp.year,
				    cvc         : form.ccCvc.$modelValue
			    };
			    
			    void 0;

			    if (ccData.expYear < 2000) {
				    ccData.expYear = ccData.expYear + 2000;
			    }
			
			    Stripe.card.createToken({
				    number          : ccData.ccNumber,
				    cvc             : ccData.cvc,
				    exp_month       : ccData.expMonth,
				    exp_year        : ccData.expYear
			    }, function(status, res){
				    void 0;
				    void 0;
				    if (res.error) {
					    toastr.error('Error validating Payment Method.');
					    $scope.cart.config.updateCCError            = "Something went wrong validating your payment method. Please try again.";
					    $scope.cart.config.updateCCButtonLoading    = false;
				    } else {
					    var ccObj = {
						    user    : {
							    paymentMethod   : {
								    token       : res.id,
								    last4       : res.card.last4,
								    cardBrand   : res.card.brand
							    }
						    }
					    };
					
					    hsCart.updateUser(ccObj)
					    .then(function(response){
						    void 0;
						    if (response.status === 200) {
						    	$scope.cart.toggleUpdateCC();
							    $scope.cart.config.updateCCButtonLoading    = false;
							    toastr.success('Payment Method Updated Successfully.');
							    $scope.cart.syncCart(true);
						    } else {
							    if (response.status === 402) {
								    toastr.success('There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.');
								    $scope.cart.config.updateCCError = "There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.";
							    } else {
								    $scope.cart.config.checkoutError = "Something went wrong. Please try again.";
								    toastr.error('Something went wrong. Please try again.');
							    }
							    $scope.cart.config.updateCCButtonLoading    = false;
						    }
					    });
				    }
			    });
		    }
	    },
	    updateAddress               : function (form, address) {
		    $scope.cart.config.updateAddressError = '';
		    $scope.cart.config.updateAddressButtonLoading = false;
		
		    if(form.validate()){
			    void 0;
			    $scope.cart.config.updateAddressButtonLoading = true;
			
			    var addressObj              = {
				    user         : {
					    address   :{
						    street          : address.street1,
						    aptUnit         : address.street2,
						    city            : address.city,
						    state           : address.state,
						    zip             : address.zip
					    }
				    }
			    };

			    hsCart.updateUser(addressObj)
				    .then(function(response){
					    void 0;
					    if (response.status === 200) {
						    localStorageService.set('user', response.data);
						    $scope.cart.userData = response.data;

						    $scope.cart.syncCart(true);
						    toastr.success('Address Updated Successfully');

						    $scope.cart.config.showUpdatedAddressSection = false;
						    $scope.cart.canDeliver = true;
					    } else if (response.status === 403) {
						    toastr.error('Error Updating Address');
						    $scope.cart.config.updateAddressError = "We do not deliver to the address you provided. " +
							    "Please contact " +
							    "<a href='mailto:support@phontabulous.com' class='text-900 text-secondary mleftright2'>Customer Support <i class='fa fa-external-link'></i></a> " +
							    "for further assistance.";
					    } else {
						    toastr.error('Error Updating Address');
						    $scope.cart.config.updateAddressError = "Something went wrong updating your address. Please try again";
					    }

					    $scope.cart.config.updateAddressButtonLoading = false;
				    });
		    }
	    },
	    filterProductsByCategory    : function (basketItems) {
        	return globalFunctions.filterProductsByCategory(basketItems);
	    },
        init                        : function (checkoutPage) {
            if ($rootScope.tableSideOrder) {
                if ($rootScope.openTableSideOrder) {
                    return $location.url($rootScope.openTableSideOrder + '&showAddItemSummary=true');
                }
                hsTableSideOrders.checkOpenOrder()
                    .then(function(openOrder) {
                        if (openOrder) {
                            $location.url($rootScope.openTableSideOrder + '&showAddItemSummary=true');
                        }
                    })
                    .catch(function(err) { void 0; });
            }
            if(!$rootScope.loggedIn) {
            	$rootScope.$emit('cartUpdated');
            	if(checkoutPage) {
            	    $location.url('/login?redirect=/cart/checkout');
            	    return;
	            } else {
		            var basket = localStorageService.get('basket');
		            if (basket && basket.length > 0) {
			            var total = 0;
			            var globalLeaveOut = true;

			            var containsAlcohol = false;
			            var globalReplaceAll = true;

			            basket.forEach(function (item) {
				            var price = 0;

				            if (item.isAlcohol) {
				            	containsAlcohol = true;
				            }

				            if (!item.hasOwnProperty('canReplace')) {
				            	item.canReplace = !ENV.isRestaurant;
				            	item.leaveOut = !item.canReplace;
				            } else {
				            	item.leaveOut = !item.canReplace;
				            }

				            if (item.leaveOut === false) {
				            	globalLeaveOut = false;
				            }

				            if (item.canReplace === false) {
					            globalReplaceAll = false;
				            }

				            if (item.hasOwnProperty('selectedModifiers')) {
					            item.selectedModifiers.forEach(function (modifier) {
						            if (modifier.hasOwnProperty('price')) {
							            price += modifier.price;
						            }
					            });
				            }
				            var itemizedCost = item.sellByQty && item.unit === 'lb' 
                                ? (item.quantity * item.avgWeight * item.price) + price
                                : (item.price + price) * item.quantity;
							
                            total += itemizedCost;
			            });

			            localStorageService.set('basket', basket);
			            $scope.cart.leaveAll = globalLeaveOut;
			            $scope.cart.replaceAll = globalReplaceAll;
			            $scope.cart.originalBasketItems = basket;
			            $scope.cart.containsAlcohol = containsAlcohol;
			            $scope.cart.data = this.filterProductsByCategory(basket);
			            $scope.cart.totalObj = {
				            delivery                : '',
				            coupon                  : '',
				            subTotal                : total.toFixed(2),
				            total                   : total.toFixed(2)
			            };

		            } else {
			            $scope.cart.config.emptyCart = true;
		            }

                    _updateBasketItemsWithPromotions();

                    $scope.$on('$destroy', $rootScope.$on('locationUpdated', _updateBasketItemsWithPromotions));

                    function _updateBasketItemsWithPromotions() {
                        hsPromos.getOngoingPromotions()
                            .then(function() {
                                var basket = $scope.cart.originalBasketItems;
                                var total = 0;

                                if (Array.isArray(basket) && basket.length > 0) {
                                    basket.forEach(function(item) {
                                        hsPromos.addPromotionToItem(item);
                                        total += item.itemizedPrice;
                                    });
                                    $scope.cart.totalObj.subTotal = total.toFixed(2);
                                    $scope.cart.totalObj.total = total.toFixed(2);
                                }
                            })
                            .catch(function(err) {
                                void 0;
                            });
                    }
	            }
	            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', 'Visitor landed on cart page.');
                $scope.cart.config.pageFullyLoaded = true;
            } else {
				if (ENV.enableLocations) {
					var location = localStorageService.get('location');
					if (!location || !location.hasOwnProperty('allLocations')) {
						void 0;
						$scope.cart.loadLocationsPopup(false, function(value) {
							sessionStorage.setItem('hs_session', new Date());
							$route.reload();
						});
						return;
					}
				}

	            if(checkoutPage){
		            $scope.cart.checkoutPage = true;
		            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', 'User landed on checkout page.');
	            } else {
		            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', 'User landed on cart page.');
	            }

	            var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
		            $route.reload();
	            });

	            $scope.$on('$viewContentLoaded', function(event){
		            // code that will be executed ...
		            // every time this view is loaded
		            // Here your view content is fully loaded !!
		            $document.bind('scroll',function(){
			            if(!$rootScope.screenWidth.xs && !$rootScope.screenWidth.sm) {
				            var window_top = $(window).scrollTop();
				            var anchor      = '.billing-scrolling-anchor';
				            var divToFix    = '.billing-summary';
				            var div_top     = $(anchor).offset().top;
				            if (window_top > div_top) {
					            $(divToFix).addClass('fixed');
					            $(anchor).height($(divToFix).outerHeight());
				            } else {
					            $(divToFix).removeClass('fixed');
					            $(anchor).height(0);
				            }
			            }
		            });
		            //sticky_relocate();
		            if (checkoutPage) {
			            var getAllProducts = setInterval(function(){$scope.cart.syncCart(checkoutPage, true);}, 60000);
			            $rootScope.$on( "$routeChangeStart", function(event, next, current) {
				            //..do something  //if you don't want event to bubble up
				            clearInterval(getAllProducts);
			            });
		            }
	            });
	
	            $scope.$on('$destroy', function() {
		            $document.unbind('scroll');
		            LocationEventListener();
	            });
	
	            $scope.cart.syncCart(checkoutPage);
            }

	        if(ENV.enablePriceList) {
		        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
			        event.preventDefault();
			        $scope.cart.loadLocationsPopup(false, false, function (event) {
				        sessionStorage.setItem('hs_session', new Date());
				        $route.reload();
			        });
		        });

		        $scope.$on('$destroy', function() {
			        sessionExpired();
		        });
	        }
	        hsPromos.getOngoingPromotions($rootScope.currentUser).catch(console.error);
        },
	    initConfirm                 : function () {
        	$scope.$on('$viewContentLoaded', function(event){
		        setTimeout(function () {
			        var orderData = localStorageService.get('orderConfirmed');
			        void 0;
			        if(orderData){
				        void 0;
				        $scope.cart.orderData               = orderData;
				        $scope.cart.config.pageFullyLoaded  = true;
						$scope.$apply();
				        $rootScope.$emit('cartUpdated');
			        }else{
				        $location.url('/');
			        }
		        },1000)
	        });
		},
		applyDiscountCode			: function () {
			void 0;
            $scope.cart.config.buttonLoading = true;
			localStorageService.set('discountCode', $scope.cart.discountCode);
			$scope.cart.checkout.syncCart(true, false, true)
                .then(function() {
                    $scope.cart.ebt.updateSnapAmount();
                    $scope.cart.updatePoints();
                })
                .finally(function() {
                    $scope.cart.config.buttonLoading = false;
                });
		},
        updatePoints: function (setInputState) {
            if ($rootScope.currentUser && $rootScope.currentUser.membership) {
                var balance = $rootScope.currentUser.membership.balance;

                if (ENV.legal.legalName === 'Erewhon') {
                    $scope.cart.updateLoyaltyPoints(balance);
                } else {
                    if ($rootScope.currentUser.membership.loyaltyPoints) {
                        $scope.cart.loyaltyPoints.config = $rootScope.currentUser.membership.loyaltyPoints;
                    }
                    $scope.cart.updateMembershipLoyaltyPoints(balance);
                }
                if (setInputState) {
                    $scope.cart.loyaltyPoints.showInput = !!balance && !$scope.cart.loyaltyPoints.applied;
                }
            }
        },
        applyLoyaltyPointsToOrder: function() {
            if (!$scope.cart.loyaltyPoints.model && $scope.cart.loyaltyPoints.applied) {
                $scope.cart.loyaltyPoints.applied = null;
                $scope.cart.loyaltyPoints.model = null;
                $scope.cart.loyaltyPoints.showInput = !!$scope.cart.loyaltyPoints.balance;
                localStorageService.remove('loyaltyPoints');
                return;
            }
            if (!$scope.cart.loyaltyPoints.model || isNaN($scope.cart.loyaltyPoints.model)) {
                return toastr.error('Please enter a valid number.');
            }
            if ($scope.cart.loyaltyPoints.model > $scope.cart.loyaltyPoints.balance) {
                return toastr.error('Please enter a number less than or equal to the available points.');
            }
            if ($scope.cart.loyaltyPoints.model > $scope.cart.totalObj.total) {
                return toastr.error('Please enter a number less than or equal to the order total.');
            }
            $scope.cart.loyaltyPoints.applied = $scope.cart.loyaltyPoints.model;
            $scope.cart.loyaltyPoints.showInput = false;
            localStorageService.set('loyaltyPoints', $scope.cart.loyaltyPoints.applied);
        },
        updateLoyaltyPoints: function(balance) {
            if (balance && !isNaN(balance)) {
                $scope.cart.loyaltyPoints.balance = Number(Number(balance).toFixed(2));
            }
            var applied = localStorageService.get('loyaltyPoints');

            if (!applied || !$scope.cart.loyaltyPoints.balance) {
                localStorageService.remove('loyaltyPoints');
                $scope.cart.loyaltyPoints.applied = null;
                $scope.cart.loyaltyPoints.model = null;
                $scope.cart.loyaltyPoints.showInput = !!$scope.cart.loyaltyPoints.balance;
                return;
            }

            if (applied > $scope.cart.loyaltyPoints.balance) {
                applied = $scope.cart.loyaltyPoints.balance;
            }
            if (applied > $scope.cart.totalObj.total) {
                applied = $scope.cart.totalObj.total;
            }
            localStorageService.set('loyaltyPoints', applied);
            $scope.cart.loyaltyPoints.applied = applied;
            $scope.cart.loyaltyPoints.model = applied;
            $scope.cart.loyaltyPoints.showInput = false;
        },
        updateMembershipLoyaltyPoints: function(balance) {
            var multiplier = $scope.cart.loyaltyPoints.config && $scope.cart.loyaltyPoints.config.pointsMultiplier || 1;
            var increment = $scope.cart.loyaltyPoints.config && $scope.cart.loyaltyPoints.config.pointIncrements || 1;

            if (balance && !isNaN(balance)) {
                $scope.cart.loyaltyPoints.balance = Number(Number(balance).toFixed(2));
                $scope.cart.loyaltyPoints.balance = $scope.cart.loyaltyPoints.balance * multiplier;
            }
            var applied = localStorageService.get('loyaltyPoints');

            if (!applied || !$scope.cart.loyaltyPoints.balance) {
                localStorageService.remove('loyaltyPoints');
                $scope.cart.loyaltyPoints.applied = null;
                $scope.cart.loyaltyPoints.model = 0;
                $scope.cart.loyaltyPoints.showInput = !!$scope.cart.loyaltyPoints.balance;
                return;
            }
            var maxTotal = $scope.cart.totalObj.total;

            if ($scope.cart.ebt.snapAmount.applied > 0) {
                maxTotal = Math.max(0, maxTotal - $scope.cart.ebt.snapAmount.applied);
            }
            if (applied > maxTotal) {
                applied = Math.floor(maxTotal * multiplier / increment) * increment / multiplier;
            }

            localStorageService.set('loyaltyPoints', applied);
            $scope.cart.loyaltyPoints.applied = applied;

            $scope.cart.loyaltyPoints.model = parseInt(applied * multiplier);
            $scope.cart.loyaltyPoints.showInput = false;
        },
		checkIfIncrementSizeIsOne: function() {
			return $scope.cart.loyaltyPoints.config.pointIncrements === 1;
		},
        applyMembershipPointsToOrder: function() {
            if (!$scope.cart.loyaltyPoints.model && $scope.cart.loyaltyPoints.applied) {
                $scope.cart.loyaltyPoints.applied = null;
                $scope.cart.loyaltyPoints.model = 0;
                $scope.cart.loyaltyPoints.showInput = !!$scope.cart.loyaltyPoints.balance;
                localStorageService.remove('loyaltyPoints');
                return;
            }

            var pointsNeeded = $scope.cart.loyaltyPoints.config.pointIncrements;
            var conversion = $scope.cart.loyaltyPoints.config.pointConversion;

            if (!$scope.cart.loyaltyPoints.model || isNaN($scope.cart.loyaltyPoints.model)) {
                return toastr.error('Please input a valid number.');
            }
            if ($scope.cart.loyaltyPoints.model > $scope.cart.loyaltyPoints.balance) {
                return toastr.error('Please input a number less than or equal to the available points.');
            }
            if ($scope.cart.loyaltyPoints.model < pointsNeeded || $scope.cart.loyaltyPoints.model % pointsNeeded !== 0) {
                return toastr.error('Please enter a number increment of ' + pointsNeeded);
            }

            var moneyDiscount = $scope.cart.loyaltyPoints.model/conversion;

            var maxTotal = $scope.cart.totalObj.total;

            if ($scope.cart.ebt.snapAmount.applied > 0) {
                maxTotal = Math.max(0, maxTotal - $scope.cart.ebt.snapAmount.applied);
            }
            var maxTotalPoints = Math.floor(maxTotal * conversion / pointsNeeded) * pointsNeeded;

            if (maxTotalPoints < pointsNeeded) {
                return toastr.error('Available order amount is less than the smallest points increment of ' + pointsNeeded + '.');
            }
            maxTotal = maxTotalPoints / conversion;

            if (moneyDiscount > maxTotal) {
                if ($scope.cart.loyaltyPoints.config.units === 'money') {
                    return toastr.error('Please enter a value less than or equal to $' + maxTotal.toFixed(2) + '.');
                } else {
                    return toastr.error('Please use points that are less than or equal to $' + maxTotal.toFixed(2) + '.');
                }
            }
            $scope.cart.loyaltyPoints.applied = moneyDiscount;
            $scope.cart.loyaltyPoints.showInput = false;
            localStorageService.set('loyaltyPoints', moneyDiscount);
        },
        getMaxLoyaltyPointsValue: function() {
            var pointsNeeded = $scope.cart.loyaltyPoints.config.pointIncrements;
            var balance = $scope.cart.loyaltyPoints.balance;
            return parseInt(balance / pointsNeeded) * pointsNeeded;
        },
        showMembershipLoyaltyPointsWithIncrements: function () {
            if (!(ENV.legal.legalName === 'Erewhon')
                && $scope.cart.loyaltyPoints.config) {
                    return true;
            }
            return false;
        },
	    mobileCheckout() {
		    var form = $('form[name="deliveryPreferenceForm"]');
		    if(form.valid()) {
			    $scope.cart.placeOrder();
		    }
	    },
	    standAloneCheckout          : function () {
        	if(!$scope.cart.canDeliver && $scope.cart.selectedFulfillmentMethod === 'delivery'){
        		return;
	        }

		    var form = $('form[name="checkoutForm"]');
		    if(form.valid()){
		        this.addCheckoutInfo(form, this.address, this.phoneNumber, true);
		    }
	    },
	    addCheckoutInfo             : function (form, address, phoneNumber, standAlone, tableSideOrder) {
			var userData = {user: {}};
        	$scope.cart.config.checkoutError = '';
		    function processForm() {
			    void 0;
			    void 0;

			    if(!$scope.cart.checkoutSteps.hasPhone){
				    userData.user.phoneNumber = $filter('bcTelephone')(phoneNumber, 'clean');
			    }
			
			    if($scope.cart.acceptCreditCard() && !$scope.cart.checkoutSteps.hasPaymentMethod) {
				    void 0;
				    if (!$scope.cart.billing.expDate
					    || !$scope.cart.billing.expDate.month
					    || !$scope.cart.billing.expDate.year) {
					    $scope.cart.config.checkoutError = "Please enter a valid credit card expiration date.";
					    toastr.error('Please enter a valid credit card expiration date.');
					    $scope.cart.config.buttonLoading = false;
					    return;
				    }
				    var ccData = {
					    ccNumber    : $scope.cart.billing.ccNumber,
					    expMonth    : $scope.cart.billing.expDate.month,
					    expYear     : $scope.cart.billing.expDate.year,
					    cvc         : $scope.cart.billing.cvc
				    };

				    if (ccData.expYear < 2000) {
					    ccData.expYear = ccData.expYear + 2000;
				    }
				
				    Stripe.card.createToken({
					    number          : ccData.ccNumber,
					    cvc             : ccData.cvc,
					    exp_month       : ccData.expMonth,
					    exp_year        : ccData.expYear
				    }, function(status, res){
					    void 0;
					    void 0;
					    if(res.error){
					    	void 0;
						    $scope.cart.config.checkoutError = "There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.";
						    $scope.cart.config.buttonLoading = false;
						    $scope.$apply();
					    }else{
						    userData.user.paymentMethod  = {
							    token       : res.id,
							    last4       : res.card.last4,
							    cardBrand   : res.card.brand
						    };
						
						    void 0;
						    apiUrls.push(hsCart.updateUser(userData));
						
						    void 0;
						    $scope.cart.checkoutInfo(apiUrls, userData.user.paymentMethod, tableSideOrder);
					    }
				    });
			    } else {
				    if(Object.keys(userData.user).length === 0){
					    $scope.cart.placeOrder(null, tableSideOrder);
				    }else{
					    void 0;
					    apiUrls.push(hsCart.updateUser(userData));

					    $scope.cart.checkoutInfo(apiUrls, userData.user.paymentMethod, tableSideOrder);
				    }
			    }
		    }
		
		    if(form.validate()){
        		void 0;

        		if ((($scope.cart.selectedFulfillmentMethod !== 'pickup' && $scope.cart.renderSummaryDetails)
			        || ($scope.cart.selectedFulfillmentMethod === 'pickup' && $scope.cart.gotAllPickupInfo)) && !standAlone
			        && ($rootScope.screenWidth.sm || $rootScope.screenWidth.xs)) {
        			$scope.cart.showSummaryPopup = true;
			        setTimeout(function(){
			            $rootScope.fixPageScrolling = true;
			        },0);
        			return;
		        }

        		if(standAlone){
        			form = form[0];
		        }
		        
        	    $scope.cart.config.buttonLoading = true;

        	    if ($scope.cart.selectedFulfillmentMethod !== 'pickup'
        	    	&& $scope.cart.delivery.instructions !== ($scope.cart.userData.deliveryInstructions || '')
        	    ) {
					userData.user.deliveryInstructions = $scope.cart.delivery.instructions;
				}

        	    if(this.gotAllInfo){
        	    	void 0;
					if (typeof userData.user.deliveryInstructions === 'string') {
						hsCart.updateUser(userData)
							.then(function(res){
								if (res.status === 200) {
									localStorageService.set('user', res.data);
									$scope.cart.userData = res.data;
								} else {
									void 0;
								}
							});
					}
        	    	$scope.cart.placeOrder(null, tableSideOrder);
	            }else{
		            var apiUrls = [];

        	    	if($scope.cart.selectedFulfillmentMethod !== 'pickup' && !$scope.cart.checkoutSteps.hasAddress){
			            userData.user.address              = {
				            street          : address.street1,
				            aptUnit         : address.street2,
				            city            : address.city,
				            state           : address.state,
				            zip             : address.zip
			            };

			            processForm();
		            } else {
        	    		processForm();
		            }
	            }
	        }
	    },
	    checkoutInfo                : function (apiUrls, ccObj, tableSideOrder) {
		    $q.all(apiUrls)
		    .then(function(response){
			    void 0;

			    var user = localStorageService.get('user');
			    if(response[0].status === 200){
				    $scope.cart.checkoutSteps.hasPaymentMethod = true;
				    $scope.cart.checkoutSteps.hasPhone = true;

				    if (response[0].data.address) {
					    $scope.cart.checkoutSteps.hasAddress = true;
					    user.address = response[0].data.address;
				    }

				    if (ccObj) {
					    user.paymentMethod = {
						    cardLast4   : ccObj.last4,
						    cardBrand   : ccObj.cardBrand
					    };
				    }
				    void 0;
				    
				    localStorageService.set('user', user);
				    $scope.cart.userData = user;

				    if (tableSideOrder) {
					    $scope.cart.placeOrder(null, tableSideOrder);
					    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'User added Checkout Info.');
					    return;
				    }


				    if ($scope.cart.selectedFulfillmentMethod !== 'pickup' && $scope.cart.renderSummaryDetails) {
					    $scope.cart.placeOrder(response[0].data.address, tableSideOrder);
				    } else {
					    if($scope.cart.selectedShippingOption){
						    setTimeout(function(){
							    scrollToElement('.shipping-speed');
						    },0)
					    }

					    void 0;
					    $scope.cart.canDeliver = true;

					    toastr.success('Checkout information updated successfully.');
					    $scope.cart.syncCart(true, false, false, true);
				    }

				    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'User added Checkout Info.');
			    } else {
			    	switch(response[0].status) {
					    case 402:
						    $scope.cart.config.checkoutError = "Your credit card was declined. Please check your card and try again.";
						    toastr.error('Your credit card was declined. Please check your card and try again.');
					    	break;
					    default:
						    $scope.cart.config.checkoutError = "Something went wrong. Please try again.";
						    toastr.error('Something went wrong. Please try again.');
						    break;
				    }
				    $scope.cart.config.buttonLoading = false;
			    }
		    });
	    },
	    placeOrder                  : function (deliveryAddress, tableSideOrder) {
        	void 0;
		    if(!this.config.buttonLoading){
		        $scope.cart.config.checkoutError = '';
        		$scope.cart.config.buttonLoading = true;
        	}

		    var selectedReward = localStorageService.get('selectedReward');
        	
	        var orderParams = {
		        delivery        : {
			        instructions     : ''
		        }
	        };

			if (localStorageService.get('discountCode') !== null) {
				orderParams.delivery.discountCode = localStorageService.get('discountCode');
			}

			if (selectedReward) {
				orderParams.delivery.rewardId = selectedReward.id;
			}

	        if(this.fulfillmentMethod !== 'pickup'){
		        if(deliveryAddress){
			        orderParams.delivery.address = {
				        street          : deliveryAddress.street,
				        aptUnit         : deliveryAddress.aptUnit,
				        city            : deliveryAddress.city,
				        state           : deliveryAddress.state,
				        zip             : deliveryAddress.zip
			        };
		        }else {
			        orderParams.delivery.address = {
				        street          : $scope.cart.userData.address.street,
				        aptUnit         : $scope.cart.userData.address.aptUnit,
				        city            : $scope.cart.userData.address.city,
				        state           : $scope.cart.userData.address.state,
				        zip             : $scope.cart.userData.address.zip
			        };
		        }
		
		        if(ENV.driverTip && $scope.cart.selectedTip.value){
			        orderParams.delivery.tip = parseFloat($scope.cart.selectedTip.value);
		        }
                if (ENV.enableSeparateTips && $scope.cart.selectedShopperTip.value) {
                    orderParams.delivery.shopperTip = parseFloat($scope.cart.selectedTip.value);
                }
	        } else {
		        if (ENV.driverTip && $scope.cart.selectedTip.value) {
			        orderParams.delivery.tip = parseFloat($scope.cart.selectedTip.value);
		        }
                if (ENV.enableSeparateTips && $scope.cart.selectedShopperTip.value) {
                    orderParams.delivery.shopperTip = parseFloat($scope.cart.selectedTip.value);
                }
	        }
	        
	        orderParams.delivery.instructions   = $scope.cart.delivery.instructions || '';
	        orderParams.delivery.fulfillmentMethod = this.fulfillmentMethod;
	        
	        if(this.fulfillmentMethod === 'shipping') {
	        	var date = new Date();
	        	date = $filter('date')(date, 'd MMM y');
	        	
	        	orderParams.delivery.deliveryDate = date;
		        orderParams.delivery.shipmentIds  = $scope.cart.selectedShippingOption.shipmentIds;
			    orderParams.delivery.rateIds      = $scope.cart.selectedShippingOption.rateIds;
	        }
			
	        if(this.deliveryPreferences && $scope.cart.deliveryTimeRequired) {
	        	orderParams.delivery.date = $scope.cart.selectedDeliveryDate.dateString;
				if ($scope.cart.isAsapTimeSelected()) {
					orderParams.delivery.asapTime = $scope.cart.selectedDeliveryTime;
				}
				orderParams.delivery.time = $scope.cart.isAsapTimeSelected() ? ($scope.cart.deliveryTimes[0] || $scope.cart.selectedDeliveryDate.timeSlots[0]) : $scope.cart.selectedDeliveryTime;
	        }

	        if(tableSideOrder) {
                var session = hsTableSideOrders.getSession();

                if (session) {
                    orderParams.delivery.tableNumber = session.tableNumber;
                }
	        }

	        void 0;

	        hsCart.placeOrder(orderParams)
	        .then(function(response){
		        void 0;
		        $rootScope.fixPageScrolling = false;
		        switch (response.status) {
			        case 200:
			        	if (tableSideOrder) {
			        		$rootScope.tableNumber = null;
			        		$rootScope.tableSideOrder = false;

			        		response.data.fulfillmentMethod = 'Table Side';
			        		response.data.tablesideOrder = true;
			        		response.data.viewOrderUrl = '/my-account?order=' + encodeURIComponent(response.data.key);
				        }

				        globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'User placed Order Successfully.');
				        localStorageService.set('orderConfirmed', response.data);
				        if (localStorageService.get('discountCode') !== null) {
					        localStorageService.remove('discountCode');
				        }
				        if (localStorageService.get('selectedReward') !== null) {
					        localStorageService.remove('selectedReward');
				        }
				        void 0;
				        $location.url('/cart/checkout/confirm');
			            // $scope.cart.config.buttonLoading = false;
				        break;
			        case 402:
				        globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'Order failed because of payment issues.');
				        $scope.cart.config.checkoutError = "Sorry, the payment card associated with your account was declined. To proceed with the order, please make sure the card has enough funds or ask the issuing bank to authorize this transaction or enter a new payment card.";
				        $scope.cart.config.buttonLoading = false;
						$scope.cart.closeSummaryPopup();
						setTimeout(function () {
					        scrollToElement('#checkout-error');
				        },300);
			        	break;
			        default:
				        globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'Order failed.');
				        $scope.cart.config.checkoutError = "Something went wrong. Please try again";
						$scope.cart.config.buttonLoading = false;
						$scope.cart.closeSummaryPopup();
				        setTimeout(function () {
					        scrollToElement('#checkout-error');
				        },300);
			        	break;
		        }
	        });
	        
	    },
	    selectDeliveryDate          : function (dateString) {
			var selectedPriceList = hsCart.getSelectedPriceList();
			if (hsUtils.isObject(selectedPriceList) && selectedPriceList.type === $scope.cart.priceListTypes.CATERING) {
				var date = $scope.cart.fulfillmentDate.model
				dateString = hsUtils.getDateString(date);
			}
			
			angular.forEach($scope.cart.deliveryPreferences, function ( val ) {
		        if(dateString === val.dateString){
		        	val.checked = true;
			        $scope.cart.selectedDeliveryDate = val;
			        $scope.cart.deliveryTimes = hsCart.filterTimeSlots(val.timeSlots, $scope.cart.getProductsWithAvailableTimes());
					if ($scope.cart.priceListHasManagedDelivery() && $scope.cart.selectedDeliveryDate.isToday) {
						$scope.cart.selectedDeliveryTime = $scope.cart.convertFirstTimeSlotToAsap($scope.cart.deliveryTimes || $scope.cart.deliveryPreferences[0].timeSlots)[0];
					} else {
						$scope.cart.selectedDeliveryTime = $scope.cart.deliveryTimes[0] || $scope.cart.deliveryPreferences[0].timeSlots[0];
					}
		        } else {
		        	val.checked = false;
		        }
	        });
        },
        selectDeliveryTime(time) {
            $scope.cart.selectedDeliveryTime = time;
            $scope.cart.checkout.proceedToStep('summary');
        },
        formatDeliveryDateTime() {
			if (!$scope.cart.deliveryTimeRequired) return;
			if ($scope.cart.priceListHasManagedDelivery()
			 	&& $scope.cart.selectedDeliveryDate.isToday
			 	&& ($scope.cart.isAsapTimeSelected() || $scope.cart.isInitialTimeSelected()))
			{
			 	return $scope.cart.convertFirstTimeSlotToAsap($scope.cart.deliveryTimes)[0];
			} else {
				if (!$scope.cart.selectedDeliveryTime || !$scope.cart.checkout.steps.preferences.activated) {
					return '';
				}
				var shortDay = $scope.cart.selectedDeliveryDate.shortDay === 'Today' 
					? 'Today'
					: $scope.cart.selectedDeliveryDate.month.slice(0, 3) + ' ' + $scope.cart.selectedDeliveryDate.date;
				return shortDay + ', ' + $scope.cart.selectedDeliveryTime;
			}
        },
        formatAddress() {
            var address = $scope.cart.userData.address;
            if (!address) {
                return '';
            }
            return address.street + ' ' + (address.aptUnit ? address.aptUnit + ', ' : ', ') 
                + address.city + ', ' + address.state + ' ' + address.zip;
        },
        updateQuantity              : function (item, updateType, quantityBtnSelector) {
            if ($rootScope.tableSideOrder) {
                hsTableSideOrders.refreshSession();
            }
	        quantityBtnSelector = '#' + quantityBtnSelector;
	        var updateBtnSelector = quantityBtnSelector.replace('quantity', 'update-btn');

	        var quantity = $(quantityBtnSelector).val();

			var inputElement = $(quantityBtnSelector);
			var limits = hsCart.checkQuantityLimits(item, inputElement);
			if (updateType === 'add' && limits.max.reached) {
				inputElement.val(limits.max.value);
				toastr.error(limits.max.message);
				return;
			}
			if (updateType === 'subtract' && limits.min.reached) {
				inputElement.val(limits.min.value);
				toastr.error(limits.min.message);
				return;
			}

	        hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
        },
		updateInstructionsInCart: function (item, index, category) {
			
			if (item._isUpdating) {
				return;
			}
			
            void 0;
            void 0;

			var inputElement = $('#item-instructions-' + category + '-' + index);
			item.instructions = inputElement.val();
			item._isUpdating = true;
			item._showInstructions = false;
			this.updateCart(item, false).then(function(){
				delete item._isUpdating;
				delete item._showInstructions;
			});
        },
		getProductItemizedTotal: function(item) {
			return hsCart.getProductItemizedTotal(item);
		},
		showInstructionUpdate: function(item){
			if (item._isUpdating){
				return;
			}
			void 0;
			void 0;
			item._showInstructions = !item._showInstructions;
		},
	    updateItemInCart            : function (item, index, category) {
            void 0;
            void 0;
		
			var inputElement = $('#quantity-' + category +'-'+ index);
			var validationError = hsCart.validateQuantity(item, inputElement);

			if (validationError) {
				toastr.error(validationError);
				return;
			}
		    var quantity = parseFloat(inputElement.val());
      
		    if(!$rootScope.loggedIn){
			    var basket = localStorageService.get('basket');
				item.quantity = quantity;
			    
			    if(basket){
				    var sameItem = false;
				    basket.forEach(function (basketItem) {
					    if(basketItem.name === item.name){
						    basketItem.quantity = item.quantity;
						    sameItem = true;

						    if (!item.hasOwnProperty('canReplace')) {
							    item.canReplace = true;
							    item.leaveOut = false;
						    } else {
							    item.leaveOut = !item.canReplace;
						    }
					    }
				    });
				
				    if(!sameItem){
					    basket.push(item);
                        toastr.success('Quantity updated successfully.');
				    }else{
                        toastr.success('Item added successfully.');
					}
				
				    localStorageService.set('basket', basket);
				    $scope.cart.init(false);
			    }else{
				    var basketArray = [];
				    basketArray.push(item);
				    localStorageService.set('basket', basketArray);
                    toastr.success('Item added successfully.');
				    $scope.cart.data = $scope.cart.filterProductsByCategory(basketArray);
			    }
			    
			    $('#update-btn-'+ category +'-'+ index).addClass('hidden');
			    $rootScope.$emit('cartUpdated',true);
		    } else{
			    var data = {
				    items : [{
					    name            : item.name,
					    quantity        : quantity,
					    isCustomItem    : false,
					    canReplace      : globalFunctions.canReplace(item),
					    instructions    : item.instructions || "",
					    displayName     : item.displayName,
					    type            : item.type,
					    subType         : item.subType,
					    organic         : item.organic,
					    unit            : item.unit,
					    selectedModifiers: item.selectedModifiers ?
						    item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
				    }]
			    };

			    void 0;
			    hsCart.addItemToCart(data)
			    .then(function(response){
				    void 0;
				    if(response.status === 200){
					    void 0;
					    toastr.success('Quantity updated successfully.');
					    $('#update-btn-'+ category +'-'+ index).addClass('hidden');
					    $scope.cart.init();
				    }else{
						if (response.status === 409) {
							toastr.error('Maximum quantity for product reached');
							$scope.cart.init();
						} else {
							toastr.error('Error updating quantity.');
						}
				    }
			    });
		    }
        },
        removeItem                  : function (item) {
            void 0;
            void 0;
            
            if(!$rootScope.loggedIn){
	            var basket = localStorageService.get('basket');
	            var itemIndex = 0;
	
	            basket.forEach(function(product, idx){
		            if(product.name === item.name){
			            itemIndex = idx;
		            }
	            });
	
	            basket.splice(itemIndex, 1);
	            
				localStorageService.set('basket', basket);
	
	            item.quantity       = 0;
	            item.showRemoveBtn  = false;
	            $scope.cart.init();
	            $rootScope.$emit('cartUpdated',true);
            }else{
	            var data = {
		            itemName            : item.name,
		            selectedModifiers   : item.selectedModifiers
	            };
	
	            hsCart.removeItemFromCart(data)
	            .then(function(response){
		            if(response.status === 200){
			            void 0;
			            void 0;
			            toastr.success('Item removed successfully.');
			            $scope.cart.syncCart(false,false,false,false,null,true);
		            }else{
			            void 0;
			            void 0;
			            toastr.error('Error removing item from cart.');
		            }
	            });
            }
        },
	    syncCart                    : function (checkoutPage, autoReload, isApplyingDiscount, updateScope, step, resetTimeSlots) {
            var apiUrls = [hsCart.getCartItems()];

	        if (checkoutPage) {
		        this.checkRewards();
	        }
		    
		    return hsAuth.getUpdatedUser()
		    .then(function(response) {
		    	void 0;
			    if(response.status === 200){
                    $rootScope.currentUser = response.data;
				    localStorageService.set('user', response.data);
				    $scope.cart.userData = response.data;
				    $scope.cart.canDeliver = true;
				    if(checkoutPage && !response.data.canPlaceOrder) {
				        $scope.cart.canPlaceOrder           = false;
				        $scope.cart.outOfCoverageMessage    = response.data.displayMessage || '';
				        $scope.cart.config.pageFullyLoaded  = true;
				    } else {
				    	if (!autoReload) {
					        $scope.cart.delivery.instructions = response.data.deliveryInstructions || '';
					    }

					    if (response.data.address) {
						    $scope.cart.checkoutSteps.hasAddress = true;
					    }
					
					    if (response.data.phoneNumber) {
						    $scope.cart.checkoutSteps.hasPhone = true;
					    }

					    if ($scope.cart.acceptCreditCard()) {
						    $scope.cart.checkoutSteps.hasPaymentMethod = !!response.data.paymentMethod;
						
						    if($scope.cart.checkoutSteps.hasPaymentMethod && $scope.cart.checkoutSteps.hasPhone){
							    $scope.cart.gotAllPickupInfo = true;
						    }
					    } else {
						    delete $scope.cart.checkoutSteps.hasPaymentMethod;
						    if($scope.cart.checkoutSteps.hasPhone){
							    $scope.cart.gotAllPickupInfo = true;
						    }
					    }
					
					    var gotInfo = true;
					    angular.forEach($scope.cart.checkoutSteps, function(val, key){
						    if ($scope.cart.checkoutSteps[key] === false){
							    gotInfo = false;
						    }
					    });
					
					    $scope.cart.gotAllInfo = gotInfo;

					    return $q.all(apiUrls)
					    .then(function(res){
					    	void 0;

                            if (res[0].data.limitedUsePromos && Object.keys(res[0].data.limitedUsePromos).length) {
                                $scope.cart.limitedUsePromos = res[0].data.limitedUsePromos;
                                Object.keys($scope.cart.limitedUsePromos).forEach(function (key, i) {
                                    var promo = $scope.cart.limitedUsePromos[key];
                                    promo.index = i + 1;
                                    promo.endsOn = new Date(promo.endDate.year, promo.endDate.month - 1, promo.endDate.date)
                                        .toDateString().split(' ').slice(1, -1).join(' ');
                                });
                            }
							var basketData = res[0].data;
							$scope.cart.containsAlcohol = basketData.containsAlcohol;

						    if (!checkoutPage) {
						    	var needBasketSync = false;
						    	var globalLeaveOut = true;
						    	var globalReplaceAll = true;
							    basketData.basketItems.forEach(function (item) {
							    	void 0;
								    if (!item.hasOwnProperty('canReplace')) {
								    	needBasketSync = true;
									    item.canReplace = !ENV.isRestaurant;
									    item.leaveOut = !item.canReplace;
								    } else {
								    	item.leaveOut = !item.canReplace;
								    }

								    if (item.leaveOut === false) {
								    	globalLeaveOut = false;
								    }

								    if (item.canReplace === false) {
									    globalReplaceAll = false;
								    }
							    });

							    $scope.cart.leaveAll = globalLeaveOut;
							    $scope.cart.replaceAll = globalReplaceAll;

							    $scope.cart.originalBasketItems = basketData.basketItems;
							    if (needBasketSync) {
							        $scope.cart.updateCart(null, true, true);
							    }
						    }

						    // sorting the fee options by lowest shipping price
							if(basketData.orderFee['shipping']) {
								var shippingFeeOptions = JSON.parse(JSON.stringify(basketData.orderFee['shipping'].fee));
								var feeOptions = {};

                                angular.forEach(basketData.orderFee['shipping'].fee, function(value, key) {
                                    shippingFeeOptions[key].name = key;
                                });

								var sortedList = Object.values(shippingFeeOptions).sort(function(a,b){return a.shipping - b.shipping});

								sortedList.forEach(function(item) {
								   	feeOptions[item.name] = item;
								});
                                basketData.orderFee['shipping'].fee = feeOptions
							}
						
						    if (!autoReload) {
							    if (!basketData.orderFee[$scope.cart.fulfillmentMethod]) {
								    $scope.cart.fulfillmentMethod = Object.keys(basketData.orderFee)[0];
							    }
							    
							    angular.forEach(basketData.orderFee, function(val, key) {
								    if (val.name === $scope.cart.fulfillmentMethod) {
									    val.checked = true;
									    if (checkoutPage) {
										    $scope.cart.selectedFulfillmentMethod = val.name;

										    if (val.hasOwnProperty('unavailable') &&
											    (val.unavailable.reason === 'Minimum Order Constraint Not Met'
                                                || val.unavailable.reason === 'At Capacity'
                                                || val.unavailable.reason === 'Pickup Only Item In Cart')) {
											    $scope.cart.renderCheckoutOptions = false;
											    $scope.cart.renderSummaryDetails = false;

										        $scope.cart.allSlotsFull = val.unavailable.reason === 'At Capacity';
										        $scope.cart.allSlotsFullMessage = val.unavailable.reasonDisplay;
										    }
									    }
								    } else {
									    val.checked = false;
								    }
							    });
						    }
						
						    //Processing Cart Items
						    if(basketData.basketItems.length === 0) {
							    $scope.cart.config.emptyCart = true;
							
							    $rootScope.cartGlobal = {
								    items       : [],
								    itemsTotal  : 0,
								    cartSubTotal: 0,
								    cartTotal   : 0,
								    coupon      : false,
								    deliveryFee : false
							    };

							    $scope.cart.totalObj = {
								    subTotal            : $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].subTotal, 2),
								    delivery            : basketData.orderFee[$scope.cart.fulfillmentMethod],
								    fullfillmentOptions : basketData.orderFee,
								    tax                 : $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].tax, 2),
								    originalTotal       : total,
								    total               : total,
								    checkoutMessage     : basketData.checkoutMessage
							    };
						    } else {
							    $scope.cart.data = $scope.cart.filterProductsByCategory(basketData.basketItems);

							    $scope.cart.discountDetails = basketData.orderFee[$scope.cart.fulfillmentMethod].discount || {};

							    if ($scope.cart.discountCode !== "" && !$scope.cart.discountDetails.code) {
							        toastr.error('Discount code is invalid, already used or not applicable to your account.');
							    }

							    if ($scope.cart.rewardsData.selectedReward && !$scope.cart.discountDetails.value) {
								    toastr.error('The Reward is not applicable.');
							    }

							    var total = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].total, 2);

							    $rootScope.cartGlobal = {
								    items       : basketData.basketItems,
								    itemsTotal  : basketData.basketItems.length,
								    cartSubTotal: $filter('number')(basketData.basketSubTotal, 2),
								    cartTotal   : total,
								    coupon      : basketData.coupon,
								    deliveryFee : basketData.orderFee[$scope.cart.fulfillmentMethod].fee
							    };


							    $scope.cart.totalObj.subTotal            = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].subTotal, 2);
							    $scope.cart.totalObj.delivery            = basketData.orderFee[$scope.cart.fulfillmentMethod];
							    $scope.cart.totalObj.fullfillmentOptions = basketData.orderFee;
							    $scope.cart.totalObj.tax                 = $filter('number')(basketData.orderFee[$scope.cart.fulfillmentMethod].tax, 2);
							    $scope.cart.totalObj.originalTotal       = total;
							    $scope.cart.totalObj.total               = total;
							    $scope.cart.totalObj.checkoutMessage     = basketData.checkoutMessage;

							    if($scope.cart.fulfillmentMethod === 'shipping'
								    && basketData.orderFee.shipping.fee) {
							    	if(!$scope.cart.selectedShippingKey) {
							    		$scope.cart.selectedShippingKey =
										    Object.keys(basketData.orderFee.shipping.fee)[0];
								    }
								    
								    $scope.cart.selectedShippingOption =
									    basketData.orderFee.shipping.fee[$scope.cart.selectedShippingKey];
								    			
								    
								    $scope.cart.totalObj.subTotal = $filter('number')($scope.cart.selectedShippingOption.subTotal, 2);
								    $scope.cart.totalObj.tax = $filter('number')($scope.cart.selectedShippingOption.tax, 2);
								    $scope.cart.totalObj.total = $filter('number')($scope.cart.selectedShippingOption.total, 2);
								    $scope.cart.totalObj.originalTotal = $filter('number')($scope.cart.selectedShippingOption.total, 2);
								    $scope.cart.totalObj.shipping = $filter('number')($scope.cart.selectedShippingOption.shipping, 2);
								    $scope.cart.renderSummaryDetails = $scope.cart.checkoutSteps.hasAddress;

							    } else {
							    	if (($scope.cart.selectedFulfillmentMethod === 'delivery' || $scope.cart.selectedFulfillmentMethod === 'specialDelivery')
								        && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable')) {
									    $scope.cart.canDeliver              = false;
									    $scope.cart.deliveryUnavailableMsg  = true;
									    $scope.cart.outOfCoverageMessage    = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reasonDisplay;
									    
									    if (response.data.address
										    && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Delivery Not Available'
										    && $scope.cart.replacementLocation.checked === false
									        && ENV.autoCheckoutLocationChange) {
                                            $scope.cart.config.buttonLoading = true;
										    $scope.cart.checkDeliveryArea(response.data.address);
									    }

								    } else {
									    $scope.cart.canDeliver              = true;
									    $scope.cart.deliveryUnavailableMsg  = false;
								    }

							    	if($scope.cart.selectedFulfillmentMethod &&
									    !basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('availableTimes')){
										
									    $scope.cart.renderSummaryDetails    = true;

								    } else if($scope.cart.selectedFulfillmentMethod &&
									    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('availableTimes') &&
									    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes.length){
									    $scope.cart.deliveryPreferences     = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes;

										var dateObjIndex = -1;
							    		var timeObjIndex = -1;
                                        if (!resetTimeSlots) {
                                            basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes.forEach(function (dateObj, idx) {
                                            if ($scope.cart.selectedDeliveryDate &&
                                                $scope.cart.selectedDeliveryDate.dateString === dateObj.dateString) {
                                                    dateObj.checked = true;
                                                    dateObjIndex = idx;

                                                $scope.cart.selectedDeliveryDate    = dateObj;
                                                    timeObjIndex = dateObj.timeSlots.indexOf($scope.cart.selectedDeliveryTime);
                                            }
                                            });
                                        }


									    if (dateObjIndex === -1) {
                                            $scope.cart.deliveryPreferences     = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].availableTimes;
                                            $scope.cart.deliveryPreferences[0].checked = true;
										    $scope.cart.selectedDeliveryDate    = $scope.cart.deliveryPreferences[0];


										    if (timeObjIndex === -1) {
											    $scope.cart.deliveryTimes           = hsCart.filterTimeSlots($scope.cart.selectedDeliveryDate.timeSlots, $scope.cart.getProductsWithAvailableTimes());
                                                $scope.cart.setDeliveryDateAndTime();
												$scope.cart.setSelectedDeliveryTime();
										    }
									    } else if (timeObjIndex === -1) {
										    $scope.cart.deliveryTimes           = hsCart.filterTimeSlots($scope.cart.selectedDeliveryDate.timeSlots, $scope.cart.getProductsWithAvailableTimes());
                                            $scope.cart.setDeliveryDateAndTime();
											$scope.cart.setSelectedDeliveryTime();
									    }
									    
									    $scope.cart.renderSummaryDetails    = true;
								    } else {
									    $scope.cart.deliveryPreferences     = false;
									    $scope.cart.selectedDeliveryDate    = false;
									    $scope.cart.deliveryTimes           = false;
									    $scope.cart.selectedDeliveryTime    = false;

										if(!$scope.cart.checkoutSteps.hasAddress || ($scope.cart.selectedFulfillmentMethod === 'delivery' && !$scope.cart.canDeliver)) {
										    $scope.cart.renderSummaryDetails = false;
									    }
								    }
							    }
						    }

						    void 0;

						    //checking for Pickup Method
						    if (basketData.orderFee.pickup) {
							    $scope.cart.pickupAvailable = true;
							    $scope.cart.renderCheckoutOptions = false;
						    } else {
							    $scope.cart.renderCheckoutOptions = true;
						    }

						    // Check for Method At Capacity
						    if (checkoutPage && basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') &&
							    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'At Capacity') {
							    $scope.cart.renderCheckoutOptions = false;
							    $scope.cart.renderSummaryDetails = false;

							    $scope.cart.allSlotsFull = true;
							    $scope.cart.allSlotsFullMessage = basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reasonDisplay;
						    } else {
							    $scope.cart.allSlotsFull = false;
							    $scope.cart.allSlotsFullMessage = "";
						    }

						    if(autoReload && $scope.cart.selectedFulfillmentMethod){
							    $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod].checked = true;
							    if(basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') && (
                                    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Minimum Order Constraint Not Met' ||
                                    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Pickup Only Item In Cart')) {
								    $scope.cart.renderCheckoutOptions = false;
								    $scope.cart.renderSummaryDetails = false;
							    } else {
								    $scope.cart.renderCheckoutOptions = true;
							    }
						    } else if ($scope.cart.selectedFulfillmentMethod){
							    $scope.cart.totalObj.fullfillmentOptions[$scope.cart.selectedFulfillmentMethod].checked = true;
							    if(basketData.orderFee[$scope.cart.selectedFulfillmentMethod].hasOwnProperty('unavailable') && (
                                    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Minimum Order Constraint Not Met' ||
                                    basketData.orderFee[$scope.cart.selectedFulfillmentMethod].unavailable.reason === 'Pickup Only Item In Cart')) {
								    $scope.cart.renderCheckoutOptions = false;
								    $scope.cart.renderSummaryDetails = false;
							    } else {
								    $scope.cart.renderCheckoutOptions = true;
								    if (step) {
								    	$scope.cart.checkout.processStep(step);
								    }
							    }
						    }


						    /*if (!autoReload
							    && !$scope.cart.allSlotsFull
							    && $scope.cart.selectedDeliveryDate
							    && $scope.cart.selectedDeliveryDate.hasOwnProperty('shortDay')
						        && $scope.cart.selectedDeliveryDate.shortDay !== 'Today') {
						    	$scope.cart.showFutureOrderAlert();
						    }*/

                            if (typeof $scope.cart.totalObj.subTotal === 'string') {
							    $scope.cart.totalObj.subTotal = parseFloat($scope.cart.totalObj.subTotal.split(",").join(""));
						    }
						    if (typeof $scope.cart.totalObj.total === 'string') {
							    $scope.cart.totalObj.total = parseFloat($scope.cart.totalObj.total.split(",").join(""));
						    }
						    if (typeof $scope.cart.totalObj.originalTotal === 'string') {
							    $scope.cart.totalObj.originalTotal = parseFloat($scope.cart.totalObj.originalTotal.split(",").join(""));
						    }

						    if(isApplyingDiscount) {
							    if($scope.cart.discountDetails.code) {
								    toastr.success('Discount code successfully applied.');
								    $scope.cart.config.showDiscountCodeBox = false;
							    } else {
								    $scope.cart.config.showDiscountCodeBox = true;
								    $scope.cart.discountCode = '';
								    localStorageService.remove('discountCode');
								    localStorageService.remove('selectedReward');
							    }
						    } else {
							    if(!$scope.cart.discountDetails.code) {
							    	if (!$scope.cart.discountCode) {
								        $scope.cart.discountCode = '';
								    }
								    localStorageService.remove('discountCode');
								    localStorageService.remove('selectedReward');
								    $scope.cart.config.showDiscountCodeBox = true;
							    } else if(!autoReload){
								    $scope.cart.config.showDiscountCodeBox = false;
							    }
						    }

						    //Processing Tips
						    if($scope.cart.totalObj.delivery.tips){
							    angular.forEach($scope.cart.totalObj.delivery.tips, function(tip){
									tip.title = tip.display;
									tip.checked = ($scope.cart.selectedTip && $scope.cart.selectedTip.title === tip.title);
									if (tip.checked) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedTip = tip;
									}

									if (!$scope.cart.selectedTip) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedTip = tip;
										tip.checked = true;
									}
							    });
							
							    var otherTipNode = {
 								    display : 'Other',
								    value   : $scope.cart.selectedTip.title === 'Other'?
									    parseFloat($scope.cart.selectedTip.value) :
									    parseFloat(($scope.cart.totalObj.delivery.tips[0].value).toFixed(2)),
								    title   : 'Other',
									checked : ($scope.cart.selectedTip.title === 'Other')
							    };
							
								otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

							    $scope.cart.totalObj.delivery.tips.push(otherTipNode);
								
								$scope.cart.tips = $scope.cart.totalObj.delivery.tips;

							    if($scope.cart.selectedTip.total) {
								    $scope.cart.processTip($scope.cart.selectedTip);
							    }
						    }


                            //Processing Tips
                            if ($scope.cart.showShopperTipSection && $scope.cart.totalObj.delivery.tips) {
                                void 0;
                                $scope.cart.totalObj.delivery.shopperTips = JSON.parse(JSON.stringify($scope.cart.totalObj.delivery.tips));
                            }

						    if($scope.cart.totalObj.delivery.tips){
							    angular.forEach($scope.cart.totalObj.delivery.tips, function(tip){
									tip.title = tip.display;
									tip.checked = ($scope.cart.selectedTip && $scope.cart.selectedTip.title === tip.title);
									if (tip.checked) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedTip = tip;
									}

									if (!$scope.cart.selectedTip) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedTip = tip;
										tip.checked = true;
									}
							    });
							
							    var otherTipNode = {
 								    display : 'Other',
								    value   : $scope.cart.selectedTip.title === 'Other'?
									    parseFloat($scope.cart.selectedTip.value) :
									    parseFloat(($scope.cart.totalObj.delivery.tips[0].value).toFixed(2)),
								    title   : 'Other',
									checked : ($scope.cart.selectedTip.title === 'Other')
							    };
							
								otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

							    $scope.cart.totalObj.delivery.tips.push(otherTipNode);
								
								$scope.cart.tips = $scope.cart.totalObj.delivery.tips;

							    if($scope.cart.selectedTip.total) {
								    $scope.cart.processTip($scope.cart.selectedTip);
							    }
						    }

                            //Process Shopper Tips
                            if ($scope.cart.showShopperTipSection && $scope.cart.totalObj.delivery.shopperTips) {
                                angular.forEach($scope.cart.totalObj.delivery.shopperTips, function(tip){
									tip.title = tip.display;
									tip.shopperChecked = ($scope.cart.selectedShopperTip && $scope.cart.selectedShopperTip.title === tip.title);
									if (tip.shopperChecked) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedShopperTip = tip;
									}

									if (!$scope.cart.selectedShopperTip) {
										$scope.cart.totalObj.total = $filter('number')(tip.total, 2);
										$scope.cart.selectedShopperTip = tip;
										tip.shopperChecked = true;
									}
							    });
							
							    var otherTipNode = {
 								    display : 'Other',
								    value   : $scope.cart.selectedShopperTip.title === 'Other'?
									    parseFloat($scope.cart.selectedShopperTip.value) :
									    parseFloat(($scope.cart.totalObj.delivery.shopperTips[0].value).toFixed(2)),
								    title   : 'Other',
									checked : ($scope.cart.selectedShopperTip.title === 'Other')
							    };
							
								otherTipNode.total = parseFloat($scope.cart.totalObj.originalTotal) + otherTipNode.value;

							    $scope.cart.totalObj.delivery.shopperTips.push(otherTipNode);
								
								$scope.cart.shopperTips = $scope.cart.totalObj.delivery.shopperTips;

							    if($scope.cart.selectedShopperTip.total) {
								    $scope.cart.processShopperTip($scope.cart.selectedShopperTip);
							    }
                            }

                            if (typeof $scope.cart.totalObj.subTotal === 'string') {
							    $scope.cart.totalObj.subTotal = parseFloat($scope.cart.totalObj.subTotal.split(",").join(""));
						    }
						    if (typeof $scope.cart.totalObj.total === 'string') {
							    $scope.cart.totalObj.total = parseFloat($scope.cart.totalObj.total.split(",").join(""));
						    }
						    if (typeof $scope.cart.totalObj.originalTotal === 'string') {
							    $scope.cart.totalObj.originalTotal = parseFloat($scope.cart.totalObj.originalTotal.split(",").join(""));
						    }

						    $scope.cart.updateAlertMessage();

						    if (updateScope) {
							    $scope.cart.config.buttonLoading = false;
							    $scope.cart.config.pageFullyLoaded = true;

							    setTimeout(function(){
								    scrollToElement('.delivery-options-container');
							    }, 1000);
						    } else if (!autoReload) {
							    $scope.cart.config.pageFullyLoaded = true;
                            }
					    })
					    .catch(function(err){
						    void 0;
						    toastr.error('Error getting cart information. Please reload the page.')
					    });
				    }
			    }else{
			    	hsAuth.logoutUser();
			    }
		    });
	    },
	    showFutureOrderAlert        : function () {
		    // ngDialog.openConfirm({
			//     data: {
			// 	    heading: 'Attention',
			// 	    subHeading: 'You\'re placing order for a future day.',
			// 	    confirmBtnText: 'Confirm',
			// 	    cancelBtnText: '',
			// 	    showPopupInCenter: true
			//     },
			//     closeByEscape: false,
			//     closeByNavigation: true,
			//     closeByDocument: false,
			//     className: "ngdialog-theme-default confirm-dialog",
			//     template: 'partials/popup/confirm-popup.html'
		    // }).then(function (confirm) {
			//     console.log(confirm);
		    // }, function (reject) {
			//     console.log(reject);
			//     return;
		    // });
	    },
	    toggleRewardsPopup          : function () {
        	this.rewardsData.showRewardsPopup = !this.rewardsData.showRewardsPopup;
	    },
	    selectReward                : function (item) {
		    this.rewardsData.availableRewards.forEach(function (reward) {
			    if (item.id === reward.id) {
			    	reward.checked = true;
			    	$scope.cart.rewardsData.selectedReward = reward;
			    	localStorageService.set('selectedReward', reward);
			    } else {
			    	reward.checked = false;
			    }
		    });
	    },
	    applyReward                 : function (cancel) {
        	if (cancel) {
        		this.rewardsData.selectedReward = false;
        		this.rewardsData.availableRewards.forEach(function(reward) {
        			reward.checked = false;
		        });
        		localStorageService.remove('selectedReward');
	        } else {
		        $scope.cart.selectedTip = false;
	        }

		    this.syncCart(true, false, true, true);
            this.rewardsData.showRewardsPopup = false;
	    },
	    checkRewards                : function () {
        	hsApi.getAllPoints()
		        .then(function(res) {
		        	if (res.status === 200) {
				        var selectedReward = localStorageService.get('selectedReward');
				        if(selectedReward) {
					        $scope.cart.rewardsData.selectedReward = selectedReward;
				        }

				        res.data.userRewards.forEach(function (reward) {
				        	if (selectedReward) {
		        			    reward.checked = selectedReward.id === reward.id;
					        } else {
		        			    reward.checked = false;
					        }
				        });

		        		$scope.cart.rewardsData.data = res.data;
		        		$scope.cart.rewardsData.availableRewards = res.data.userRewards.filter(function (reward) {
					        	return reward.canRedeem;
					        });

		        		if ($scope.cart.rewardsData.availableRewards.length) {
		        			$scope.cart.rewardsData.showRewardsOption = true;
				        }
			        } else {
		        		void 0;
			        }
		        });
	    },
	    updateAlertMessage          : function () {
        	if ($scope.cart.totalObj.delivery.hasOwnProperty('unavailable')) {
		        $scope.cart.config.alertMessage = '';
		        $scope.cart.config.alertClass = '';
		        return;
	        }

		    //Processing Delivery Fees
		    var messageExcerpt = "";
		    if (!$scope.cart.selectedFulfillmentMethod) {
			    messageExcerpt = "Delivery or Pickup";
		    } else if ($scope.cart.selectedFulfillmentMethod === 'pickup') {
			    messageExcerpt = "Pickup";
		    } else {
			    messageExcerpt = "Delivery";
			}

		    if ($rootScope.tableSideOrder) {
			    $scope.cart.config.alertClass = 'bg-adaptive-tertiary-to-black text-white';
			    $scope.cart.config.alertMessage = 'Quick Easy & <b class="text-900">Contactless Ordering</b>';
			    return;
		    }


			if ($scope.cart.selectedFulfillmentMethod === 'delivery' && $scope.cart.totalObj
				&& $scope.cart.totalObj.delivery && $scope.cart.totalObj.delivery.feeMessage) {
				$scope.cart.config.alertClass = 'bg-adaptive-secondary text-white';
			    $scope.cart.config.alertMessage = $scope.cart.totalObj.delivery.feeMessage;
			} else if (($scope.cart.totalObj.subTotal >= $scope.cart.totalObj.delivery.minOrderWithNoFee) ||
			    $scope.cart.totalObj.delivery.freeOrders > 0) {
			    $scope.cart.config.alertClass = 'bg-adaptive-tertiary-to-black text-white';
				$scope.cart.config.alertMessage = '<b class="text-900">Lucky You!</b> Enjoy Free '+ messageExcerpt+' on this order. ';
				
				if ($scope.cart.selectedFulfillmentMethod === 'pickup') {
					$scope.cart.config.alertMessage = '<b class="text-900">Skip The Line!</b> Quick Easy & Free Pickup. ';
				}

		    } else if ($scope.cart.selectedFulfillmentMethod === 'shipping' &&
			    $scope.cart.totalObj.delivery.differenceForNoFee === 0) {
			    $scope.cart.config.alertClass = 'bg-adaptive-tertiary-to-black text-white';
			    $scope.cart.config.alertMessage = '<b class="text-900">Lucky You!</b> Enjoy Free Shipping on this order. ';
		    } else if (!$scope.cart.renderSummaryDetails &&
			    $scope.cart.totalObj.delivery.hasOwnProperty('unavailable') &&
			    $scope.cart.totalObj.delivery.unavailable.reasonDisplay){
			    $scope.cart.config.alertClass = 'bg-adaptive-tertiary-to-black text-white';

			    $scope.cart.config.alertMessage = $scope.cart.totalObj.delivery.unavailable.reasonDisplay;
		    }
	    },
	    /**
	     * If the supplied object contains a reference to an AutoComplete object, proceed to
	     * filling the rest of the entity fields, otherwise just skip as no autocomplete event
	     * happened.
	     * @param {object} shippingAddr
	     */
	    addressAutoComplete         : function (shippingAddr, property, addr2Label) {
		    // If the value of `street1` is not a string, it means that it is the object
		    // reference as a result of the `ngAutocomplete` functionality, which means we
		    // have to fill out the rest of the entity fields.
		    if (typeof(this[property].street1) !== 'string') {
			    var autoCompleteObject  = shippingAddr.street1;
			    var autoCompleteAddress = address.getAutoCompleteAddress(autoCompleteObject);
			    void 0;
			    this[property].street1    = autoCompleteAddress.street1;
			    this[property].street2    = autoCompleteAddress.street2;
			    this[property].city       = autoCompleteAddress.city;
			    this[property].state      = autoCompleteAddress.state;
			    this[property].zip        = autoCompleteAddress.zip;
			    this[property].country    = autoCompleteAddress.country;
			    $scope.cart.isValidAddressFromGoogleMaps = true;
			    $scope.cart.config[property + 'NonEditable'] = true;
			
			    // Once autocomplete is done populating fields, focus on the Address 2 field
			    // As street2 cannot be auto completed.
			    // Putting it inside a TimeOut to ensure other events don't prevent this from happening
			    setTimeout(function() {
			    	angular.element('#' + addr2Label).focus();
		        }, 0);
		    }
	    },
	    /**
	     * Requests backend to verify if User Address is a valid Shipping address and update with
	     * the closest sanitized version of the address.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    verifyAddress               : function (shippingAddr, placeOrder, preventButtonLoading) {
		    var addressObj = {
			    address : shippingAddr
		    };
		    
		    hsCart.verifyAddress(addressObj)
		    .then(function(res){
			    if(res.status === 200){
			        $scope.cart.canDeliver              = res.data.canDeliver;
				    $scope.cart.outOfCoverageMessage    = res.data.displayMessage || '';
				    $scope.cart.config.updateAddressButtonLoading = false;
					if(!res.data.canDeliver) {
						setTimeout(function(){
							scrollToElement('.cant-deliver');
						},1000)
					}

				    if(placeOrder){
			        	if($scope.cart.canDeliver){
			        		$scope.cart.config.showUpdatedAddressSection = false;
			        		$scope.cart.placeOrder(shippingAddr);
				        }
			        }
			    }else{
			    	toastr.error('Something went wrong adding address.');

				    setTimeout(function(){
			    		scrollToElement('.cant-deliver');
				    },1000)
			    }

			    if(!preventButtonLoading){
			        $scope.cart.config.buttonLoading = false;
			    }
		    })
	    },
	    /**
	     * Takes a verified address and submits it for registration and in case there is a
	     * gift redemption, it will attempt to redeem it.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    submitAddress               : function (shippingAddr) {
		    void 0;
		    var apiUrl   = ENV.tbApiEndPoint + "/api/v1/user/register/address";
		    $scope.myPromise = $http.post(apiUrl, shippingAddr)
		    .success(function(data, status, headers, config){
			    void 0;
			    localStorageService.remove('user');
			    localStorageService.set('user', data);
			
			    $rootScope.signupHeader     = false;
			    $rootScope.showSignupFooter = false;
			
			    //Getting signup progress from the localstorage
			    var signupProgress = localStorageService.get('signupProgress');
			    if(signupProgress){
				    signupProgress.shipping = true;
				    localStorageService.remove('signupProgress');
				    localStorageService.add('signupProgress', signupProgress);
			    }
			
			    $location.url('/tb/my-account');
			    return;
		    })
		    .error(function(data, status, headers, config){
			    $scope.shippingRegistration._handleAddressError(data.code);
		    });
	    },
	    _handleAddressError         : function (errorCode) {
		    this.notification.reset();
		
		    switch(errorCode) {
			    case 200001 :
				    $scope.signup.config.signupError = "Currently, we only serve in United States.";
				    break;
			    case 200002 : // Unable to serve address
				    $scope.signup.config.signupError = "Oopsies, We don't deliver in your state at the moment.";
				    break;
			    case 200003 : // Unable to serve address
				    $scope.signup.config.signupError = "We're unable to verify this as a valid deliverable address. Please contact customer support email at info@naturecarebox.com.";
				    break;
			    default :
				    $scope.signup.config.signupError = "Something went wrong. Please contact customer support email at info@naturecarebox.com.";
				    break;
		    }
		
		    setTimeout(function(){
			    scrollToElement('.address-error-msg');
		    },500);
		
	    },
	    __validateAddress           : function (shippingAddr) {
		    this.notification.reset();
		
		    if ($.trim(shippingAddr.street1) == "") {
			    this.notification.isAddressError = true;
			    this.notification.errMessage     = "Error in address. Address 1 is required";
			    $timeout(function(){
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }
		    if (shippingAddr.country == "US" && (shippingAddr.zip.length != 5 || isNaN(shippingAddr.zip))) {
			    this.notification.isAddressError = true;
			    this.notification.errMessage     = "Error in address. ZIP Code should be 5 digits long";
			    $timeout(function(){
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }
		
		    if (!shippingAddr.street2) {
			    shippingAddr.street2 = "";
		    }
		
		    this.notification.isRegisterAddrLoading = false;
		    return true;
	    },
        shouldShowJoinMembership: function() {
            var isErewhon = ENV.legal.legalName === 'Erewhon';
            var isMember = $rootScope.currentUser && $rootScope.currentUser.membership;
            var isDelivery = $scope.cart.selectedFulfillmentMethod === 'delivery';
            var membershipCanWaiveFee = $scope.cart.totalObj.delivery.fee && $scope.cart.totalObj.delivery.minOrderWithNoFee
                && $scope.cart.totalObj.delivery.subTotal >= $scope.cart.totalObj.delivery.minOrderWithNoFee;

            return isErewhon && !isMember && isDelivery && membershipCanWaiveFee;
        },
        showMembershipForm: function() {
            var $newScope = $scope.$new(true);

            ngDialog.open({
                template: '<div><erewhon-membership-popup '
                    + 'on-close="closeThisDialog()" '
                    + '></erewhon-membership-popup></div>',
                className: 'ngdialog-theme-default ngdialog-theme-erewhon',
                plain: true,
                scope: $newScope,
            }).closePromise
                .then(function(data) {
                    if (data.value && data.value === 'success') {
                        $route.reload();
                    }
                })
                .catch(function(err) {
                    void 0;
                });
        },
        scrollDates: function(direction) {
			var scrollAmount = 0;
			var step = 100;
			var distance = 150;
			var speed = 50;
			var element = document.getElementById('dateScrollBar');
			var slideTimer = setInterval(function(){
				if (direction == 'left') {
					element.scrollLeft -= step;
				} else {
					element.scrollLeft += step;
				}
				scrollAmount += step;
				if (scrollAmount >= distance) {
					window.clearInterval(slideTimer);
				}
			}, speed);
		},
		showScroll: function() {
			return !(($rootScope.screenWidth.xs)||($scope.cart.deliveryPreferences.length <= $scope.cart.limitScrollOnItems));
		},
        updateDeliveryInstructions: function(deliveryInstructions) {

			if ($scope.cart.delivery.instructions === deliveryInstructions) {
				$scope.cart.checkout.processStep('deliveryInstructions');
				return;
			}

			$scope.cart.delivery.instructions = deliveryInstructions;
            var userData = {
                user: {
                    deliveryInstructions: deliveryInstructions
                }
            };
			$scope.cart.config.buttonLoading = true;
            hsCart.updateUser(userData)
			        .then(function(res){
						$scope.cart.config.buttonLoading = false;
                        if (res.status === 200) {
                            localStorageService.set('user', res.data);
                            $scope.cart.userData = res.data;
                            //proceed to next step
                            $scope.cart.checkout.processStep('deliveryInstructions');
                        } else {
                            toastr.error('Error Updating Delivery Instructions');
                            if (res.status === 402) {
                                $scope.cart.config.checkoutError = "Could not save delivery instructions. Please try again.";
                                toastr.error('Could not save delivery instructions. Please try again.');
                            } else {
                                $scope.cart.config.checkoutError = "Something went wrong. Please try again.";
                                toastr.error('Something went wrong. Please try again.');
                            }
                        }
                    });
        },
		handleEditAddress: function($event){
			address.handleEditAddress($event, $scope.cart);
		},
		roundNumber(number) {
			return hsUtils.roundNumber(number);
		},
        shouldShowMembershipDiscount: function (item, showPotentialSavings) {
            // addPotentialMemberSavings(item) is called when we loop through the items in cart.html
            return hsPromos.shouldShowMembershipDiscount(item, item.promotion)
                || showPotentialSavings && hsPromos.shouldShowMembershipDiscount(item, item.potentialSavingsPromo);
        },
        addPotentialMemberSavings: function (item) {
            $scope.$watch('hsPromos.ongoingPromotions', function() {
                var promotion = hsPromos.getPotentialSavingsPromo(item);
                if (promotion && promotion.membersOnly) {
                    item.potentialSavingsPromo = promotion;
                }
            });
        },
        updatePromoOptOut: function (promo, value) {
            if ($scope.cart.updatingOptOutOptions) return;

            var options = {
                promotionsOptOut: {
                    promotionId: promo.id,
                    optOut: value,
                },
            };
            void 0;

            $scope.cart.updatingOptOutOptions = promo.index;

            hsCart.updateCartOptions(options)
                .then(function(response) {
                    if(response.status === 200){
                        promo.optOut = value;
                        $scope.cart.init();
                    } else {
                        toastr.error('Failed to save an option.');
                    }
                })
                .catch(function (err) {
                    toastr.error('Failed to save an option.');
                })
                .finally(function () {
                    $scope.cart.updatingOptOutOptions = false;
                });
        },
        getRelevantPromotionForPrice: function (item) {
            return hsPromos.getRelevantPromotionForPrice(item, item.promotion);
        },
        getLimitedUsePromoName: function (promo) {
            return hsPromos.getLimitedUsePromoName(promo);
        },
        shouldShowUnit: function (promotion) {
            if (ENV.hideItemUnit) return false;
            if (hsUtils.isObject(promotion) && promotion.type === hsPromos.types.FREE_ITEM && !promotion.optOut) return false;

            return true;
        },
		shouldShowSubstitutionOption: function () {
			if ($rootScope.tableSideOrder) {
				return false;
			}

			var selectedPriceList = $rootScope.globalFunctions.getSelectedPriceListFromStorage();
			if (selectedPriceList && selectedPriceList.disableProductSubstitutionOption === true) {
				return false;
			}

			var selectedLocation = $rootScope.globalFunctions.getSelectedLocationFromStorage();
			if (selectedLocation && selectedLocation.disableProductSubstitutionOption === true) {
				return false;
			}
			
			return true;
		},
		setDeliveryTimeRequired: function (location) {
			var priceList = globalFunctions.getSelectedPriceListFromStorage();
			if (!hsUtils.isObject(priceList)) {
				if (hsUtils.isObject(location) && hsUtils.isArray(location.priceLists)) {
					priceList = location.priceLists.find(function (pl) {
						return pl.default && !pl.isDisabled;
					});
					if (!hsUtils.isObject(priceList)) {
						priceList = location.priceLists.find(function (pl) {
							return !pl.isDisabled;
						});
					}
				}
			}

			if (hsUtils.isObject(priceList)) {
				$scope.cart.deliveryTimeRequired = hsUtils.isBoolean(priceList.deliveryTimeRequired)
					? priceList.deliveryTimeRequired
					: true;
			} else {
				void 0;
				$scope.cart.deliveryTimeRequired = true;
			}
		},
        ebt: {
            error: '',
            balance: null,
            paymentMethod: null,
            elements: {
                balance: null,
                payment: null,
            },
            isLoadingForage: false,
            isCheckingBalance: false,
            isPlacingOrder: false,
            showBalancePinInput: false,
            showCaptureChargePinInput: false,
            snapAmount: {
                model: null,
                applied: null,
                balance: null,
            },
            isApplicable: function () {
                return $scope.cart.totalObj.ebtSnapEligible && $scope.cart.totalObj.ebtSnapEligible.total > 0 && $scope.cart.ebt.paymentMethod && $scope.cart.ebt.paymentMethod.ref && !$scope.cart.checkout.isHouseChargeOrder;
            },
            loadForage: function () {
                $scope.cart.ebt.isLoadingForage = true;
                ebtService.getClient()
                    .catch(function (err) {
                        void 0;
                    })
                    .finally(function () {
                        $scope.cart.ebt.isLoadingForage = false;
                        $scope.$apply();
                    });
            },
            initForage: function (inputType) {
                $scope.cart.ebt.isLoadingForage = true;
                ebtService.getClient()
                    .then(function (forage) {
                        if (inputType === 'balance') {
                            var ebtBalanceElement = forage.create('ebt_pin_check_balance')
                            ebtBalanceElement.mount('ebt-balance-check-container');
                            ebtBalanceElement.on('change', (event) => {
                                if (event.error) {
                                    void 0;
                                }
                            });
                            $scope.cart.ebt.elements.balance = ebtBalanceElement;
                        }
                        if (inputType === 'payment') {
                            var ebtPaymentCaptureElement = forage.create('ebt_pin_capture_payment');
                            ebtPaymentCaptureElement.mount('ebt-pin-capture-container');
                            ebtPaymentCaptureElement.on('change', (event) => {
                                if (event.error) {
                                    void 0;
                                }
                                if (event.complete) {
                                    void 0;
                                }
                            });
                            $scope.cart.ebt.elements.payment = ebtPaymentCaptureElement;
                        }
                    })
                    .catch(function (err) {
                        void 0;
                    })
                    .finally(function () {
                        $scope.cart.ebt.isLoadingForage = false;
                        $scope.$apply();
                    });;
            },
            shouldCheckBalance: function () {
                if (!$scope.cart.ebt.balance) return true;
                if (!$scope.cart.ebt.balance.snap) return true;
                if (!$scope.cart.ebt.balance.updated) return true;

                var updated = new Date($scope.cart.ebt.balance.updated).getTime();

                if (!updated) return true;

                var maxTime = Date.now() - 15 * 60 * 1000;
                return maxTime > updated;
            },
            setShowBalancePinInput: function (value) {
                $scope.cart.ebt.showBalancePinInput = value;
            },
            setBalance: function (ebtBalance) {
                if (!hsUtils.isObject(ebtBalance)) {
                    $scope.cart.ebt.balance = null;
                    $scope.cart.ebt.snapAmount.balance = 0;
                } else if (!$scope.cart.ebt.balance || !$scope.cart.ebt.balance.updated
                    || new Date($scope.cart.ebt.balance.updated) < new Date(ebtBalance.updated)
                ) {
                    $scope.cart.ebt.balance = ebtBalance;
                    $scope.cart.ebt.balance.lastChecked = hsUtils.convertISOStringToChatDisplayTime(ebtBalance.updated);
                    $scope.cart.ebt.snapAmount.balance = Number($scope.cart.ebt.balance.snap) || 0;
                }
                if (!$scope.cart.ebt.shouldCheckBalance()) {
                    $scope.cart.ebt.setShowBalancePinInput(false);
                }
            },
            checkBalance: function () {
                if ($scope.cart.ebt.isCheckingBalance) return;

                $scope.cart.ebt.isCheckingBalance = true;
                $scope.cart.config.checkoutError = '';

                ebtService.getClient()
                    .then(function (forage) {
                        return forage.createEbtPinBalanceCheck($scope.cart.ebt.elements.balance, $scope.cart.ebt.paymentMethod.ref)
                            .then(function (res) {
                                void 0;
                                $scope.cart.ebt.setBalance(res);
                                $scope.cart.ebt.setShowBalancePinInput(false);
                            })
                            .catch(function (err) {
                                void 0;
                                $scope.cart.config.checkoutError = ebtService.getUserFriendlyError(err);;
                            })
                            .finally(function () {
                                $scope.cart.ebt.isCheckingBalance = false;
                                $scope.$apply();
                            });
                    });
            },
            setPaymentMethod: function (paymentMethod, isAutoCall) {
                var now = Date.now();

                if (!isAutoCall) {
                    $scope.cart.ebt.paymentMethodManuallySetAt = now;
                } else if ($scope.cart.ebt.paymentMethodManuallySetAt) {
                    if (now - 15 * 1000 < $scope.cart.ebt.paymentMethodManuallySetAt) {
                        return;
                    }
                    $scope.cart.ebt.paymentMethodManuallySetAt = null;
                }

                if (hsUtils.isObject(paymentMethod)) {
                    $scope.cart.ebt.paymentMethod = {
                        ref: paymentMethod.ref,
                        cardLast4: paymentMethod.cardLast4,
                    };
                } else {
                    $scope.cart.ebt.paymentMethod = null;
                    $scope.cart.ebt.setBalance(null);
                    $scope.cart.ebt.updateSnapAmount();
                }
            },
            applySnapAmount: function () {
                $scope.cart.config.checkoutError = '';

                if (!$scope.cart.ebt.snapAmount.model && $scope.cart.ebt.snapAmount.applied) {
                    $scope.cart.ebt.snapAmount.applied = null;
                    $scope.cart.ebt.snapAmount.model = null;
                    localStorageService.remove('snapAmount');
                } else if (!$scope.cart.ebt.snapAmount.model || isNaN($scope.cart.ebt.snapAmount.model)) {
                    $scope.cart.config.checkoutError = 'Please enter a valid number.';
                    return toastr.error('Please enter a valid number.');
                } else if ($scope.cart.ebt.snapAmount.model > $scope.cart.ebt.snapAmount.balance) {
                    $scope.cart.config.checkoutError = 'Please enter a number less than or equal to the available balance: $' + $scope.cart.ebt.snapAmount.balance;
                    return toastr.error('Please enter a number less than or equal to the available balance: $' + $scope.cart.ebt.snapAmount.balance);
                } else if ($scope.cart.ebt.snapAmount.model > $scope.cart.totalObj.ebtSnapEligible.total) {
                    $scope.cart.config.checkoutError = 'Please enter a number less than or equal to the total SNAP eligible: $' + $scope.cart.totalObj.ebtSnapEligible.total;
                    return toastr.error('Please enter a number less than or equal to the total SNAP eligible: $' + $scope.cart.totalObj.ebtSnapEligible.total);
                } else {
                    $scope.cart.ebt.snapAmount.applied = $scope.cart.ebt.snapAmount.model;
                    localStorageService.set('snapAmount', $scope.cart.ebt.snapAmount.applied);
                }
                $scope.cart.config.buttonLoading = true;
                $scope.cart.checkout.syncCart(true)
                    .finally(function () {
                        $scope.cart.config.buttonLoading = false;
                        $scope.cart.updatePoints();
                    });
            },
            updateSnapAmount: function () {
                var applied = localStorageService.get('snapAmount');

                if (!applied || !$scope.cart.ebt.snapAmount.balance) {
                    localStorageService.remove('snapAmount');
                    $scope.cart.ebt.snapAmount.applied = null;
                    $scope.cart.ebt.snapAmount.model = null;
                    return;
                }
                if (applied > $scope.cart.ebt.snapAmount.balance) {
                    applied = $scope.cart.ebt.snapAmount.balance;
                }
                if (applied > $scope.cart.totalObj.ebtSnapEligible.total) {
                    applied = $scope.cart.totalObj.ebtSnapEligible.total;
                }
                localStorageService.set('snapAmount', applied);
                $scope.cart.ebt.snapAmount.applied = applied;
                $scope.cart.ebt.snapAmount.model = applied;
            },
            capturePayment: function (paymentRef) {
                return ebtService.getClient()
                    .then(function (forage) {
                        return forage.captureEbtPinPayment($scope.cart.ebt.elements.payment, paymentRef)
                            .catch(function (err) {
                                var error = ebtService.getUserFriendlyError(err);
                                void 0;
                                throw error;

                            });
                    });
            },
            placeOrder: function () {
                $scope.cart.ebt.isPlacingOrder = true;
                $scope.cart.config.checkoutError = '';
                
                ebtService.startSession($scope.cart.ebt.snapAmount.applied, $scope.cart.fulfillmentMethod)
                    .then(function (session) {
                        void 0;

                        return $scope.cart.ebt.capturePayment(session.paymentRef);
                    })
                    .then(function (capturedPayment) {
                        void 0;

                        // $scope.cart.ebt.setBalance(capturedPayment.receipt.balance);

                        return $scope.cart.checkout.placeOrder(null, false, capturedPayment.ref)
                            .then(function (res) {
                                localStorageService.remove('snapAmount');
                                $scope.cart.ebt.updateSnapAmount();
                                return res;
                            });
                    })
                    .catch(function (err) {
                        void 0;
                        $scope.cart.config.checkoutError = err;
                    })
                    .finally(function () {
                        $scope.cart.ebt.isPlacingOrder = false;
                    });
            },
            cancelPlaceOrder: function () {
                $scope.cart.ebt.showCaptureChargePinInput = false;
                $scope.cart.config.checkoutError = '';
            },
        },
        convertISOStringToDisplayTime(isoStr) {
            return hsUtils.convertISOStringToDisplayTime(isoStr);
        },
		getTipLabel: function() {
			return hsCart.getTipLabel($scope.cart.config.managedDeliveryTipShare);
		},
		getTipDisclaimer: function() {
			return hsCart.getTipDisclaimer($scope.cart.config.managedDeliveryTipShare);
		},
		acceptCreditCard: function() {
			return $rootScope.acceptCreditCard;
		},
    };
    
    window.prerenderReady = true;
    
}]);

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('landingCtrl', [
    '$scope', '$rootScope','$route','$location','$http','globalFunctions','OpenGraphTags','ENV','$sce','$q','scrollToElement',
    '$routeParams','$filter','$window','ngDialog','$interval','hsCart', 'hsAuth','$document','toastr','localStorageService',
    'hsApi', 'hsSearch', 'hsTableSideOrders', 'hsPromos', 'hsMarketingService', 'hsPickingApp', '$timeout', 'aiSearchEvents',
	'hsMasonryGrid', 'hsUtils', 'hsPromotionsV2',
    function($scope, $rootScope, $route, $location,$http,globalFunctions,OpenGraphTags,ENV,$sce,$q,scrollToElement,
        $routeParams,$filter, $window, ngDialog, $interval, hsCart, hsAuth, $document, toastr, localStorageService,
        hsApi, hsSearch, hsTableSideOrders, hsPromos, hsMarketingService, hsPickingApp, $timeout, aiSearchEvents, 
		hsMasonryGrid, hsUtils, hsPromotionsV2){
    
    void 0;
    
    if ($rootScope.loggedIn) {
    	void 0;
    	setTimeout(function() {
		    $scope.landing.checkOpenOrders();
	    }, 0);
    }

    $scope.landing = {
        allProductsHash: $rootScope.allProductsHash,
        config                      : {
        	redirectTimer           : 3,
	        showTabularView         : false,
			fullListLoaded			: false,
			shortListLoaded			: false,
        	pageFullyLoaded         : false,
			searching				: false,
			categoryUrl				: '',
        	allProducts             : ENV.allProducts,
            imageBaseUrl            : globalFunctions.imageBaseUrl,
	        numberOfProducts        : 12,
	        categoryLimit           : 4,
	        message                 : '',
	        messageClass            : '',
	        buttonLoading           : false,
            selectSubCategory: function(subCategory) {
                $scope.landing.config.selectedSubCategory = subCategory;
                $scope.landing.populateSubCategoryData();
                $window.scrollTo(0, 0);
            },
            scrollTo                : function(section, container){
				if (container === '.TabList') {
					var containerElement = $(container);
					var containerOffset = containerElement.offset();
					var element = (section === 'Ingredients') ? $(container).children()[0] : $(container).children()[1];
					var elementOffset = $(element).offset();
					$(container).animate({scrollLeft: elementOffset.left - containerOffset.left},'slow');
				} else {
					var element = $('#' + section);
					var offset = $(element).offset();
					var scrollAmount = offset.top;
					//console.log('Scroll amount is:'+scrollAmount);
					scrollAmount -= 185;
					//console.log('New Scroll amount is:'+scrollAmount);
					// Scroll
					$("html, body").animate({scrollTop: scrollAmount},'slow');
				}
            },
            navigateTo              : function(url){
                $location.url(url);
            },
	        selectedCategory        : '',
	        selectedSubCategory     : '',
	        updateSEOdata           : function ($title, $keywords, $description, $image) {
		        globalFunctions.setSEOdata($title, $keywords, $description, $image);
	        },
	        categoryOrder           : ENV.categoryOrder,
	        subCategoryOrder        : ENV.subCategoryOrder
        },
	    locations                   : [],
	    disabledLocations           : [],
	    selectedNews                : {},
	    news                        : [],
	    searchThreshold             : 15,
	    categoryCarousel            : {
        	slides                  : [],
		    config                  : {
			    method: {},
			    dots: false,
			    arrows: true,
			    infinite: true,
			    slidesToShow: 3,
			    slidesToScroll: 1,
			    responsive: [
				    {
					    breakpoint: 1024,
					    settings: {
						    slidesToShow: 2,
						    dots: true,
						    infinite: true
					    }
				    },
				    {
					    breakpoint: 600,
					    settings: {
						    slidesToShow: 1,
						    dots: false,
						    infinite: true
					    }
				    },
				    {
					    breakpoint: 480,
					    settings: {
						    slidesToShow: 1,
						    dots: false,
						    infinite: true
					    }
				    }
			    ]
		    }
	    },
	    locationEventListener       : '',
	    priceListEventListener      : '',
	    faqs                        : ENV.FAQ,
	    data                        : {},
	    coupons						: {},
	    searchResults               : false,
	    renderFulfillmentMethods    : false,
	    selectedLocation            : {},
	    noCouponsAvailable			: false,
	    showSearchBox               : false,
	    searchData                  : {},
	    subCategoryData             : {},
	    referral                    : {},
	    quantity                    : 1,
		quantityFooter				: 1,
	    selectedProduct             : {},
		selectedProductInstructions : '',
	    allProducts                 : [],
        searchQuery					: '',
	    searchedQuery               : '',
	    searching                   : false,
		showMainSearchBar: $rootScope.screenWidth.xs ? false : true,
	    searchMobile                : {
		    category: '',
		    subCategory: '',
		    organic: false,
		    clearFilters: false,
			isBottomSheetVisible: false,
			isSearchPageScrollable: true,
			onOpen() {
				this.isSearchPageScrollable = false;
			},
			onClose() {
				this.isSearchPageScrollable = true;
			},
		    selectCategory() {
			    this.subCategory = '';
		    },
		    selectSubCategory(category) {
			    this.category = category;
		    },
		    apply() {
			    void 0;
			    void 0;
			    void 0;
			    var queryParams = $location.search();

			    queryParams.organic = this.organic.toString();

			    if (this.subCategory) {
				    queryParams.dept = this.category;
				    queryParams.sub = this.subCategory;
			    } else if(this.category) {
				    queryParams.dept = this.category;
				    queryParams.sub = null;
			    }

			    $location.search(queryParams);

			    if (this.clearFilters) {
				    $scope.landing.resetSearchFilter('department');
			    }
			    return $scope.landing.processSearch();
		    },
		    clear() {
			    this.organic = false;
			    this.category = '';
			    this.subCategory = '';
			    $scope.landing.resetSearchFilter('all');
		    }
	    },
		filters: {
			healthClaims: {
				titles: ['healthClaims'],
				multiSelect: true,
				data: {},
				onLanding: true,
				displayMap: {},
				intersectionSearch: true, // AND search.
				iconPath: '/images/shared-assets/health-claims/',
				enabled: false
			},
			brands: {
				titles: ['brands'],
				multiSelect: true,
				data: {},
				onLanding: false,
				enabled: true
			},
			categories: {
				titles: ['categories', 'subcategories'],
				multiSelect: false,
				data: {},
				onLanding: false,
				enabled: true
			}
		},
		filterHandlers: {
			getFilterDisplayName(filterName) {
				var displayName;
				switch (filterName) {
					case 'categories':
						displayName = 'Categories';
						break;
					case 'brands':
						displayName = 'Brands';
						break;
					case 'healthClaims':
						displayName = 'Shop By Diet';
						break;
					default:
						displayName = 'Filter';
				}
				return displayName;
			},
			initHealthClaimsFilterData() {
				var healthClaims = $rootScope.healthClaims;
				if (healthClaims) {
					var healthClaimsList = [];
					Object.keys(healthClaims).forEach(function(healthClaim) {
						$scope.landing.filters.healthClaims.displayMap[healthClaims[healthClaim].displayName] = healthClaims[healthClaim].key;
						if (!healthClaims[healthClaim].disable && !healthClaims[healthClaim].hide) {
							healthClaimsList.push(healthClaims[healthClaim].displayName);
						}
					});
					$scope.landing.filters.healthClaims.data = healthClaimsList;
				}
			},
			createHealthClaimsMap: function(healthClaims) {
				Object.keys(healthClaims).forEach(function(healthClaim) {
					$scope.landing.filters.healthClaims.displayMap[healthClaims[healthClaim].displayName] = healthClaims[healthClaim].key;
				});
			},
			getProductsWithHealthClaims: function(products) {
				var productsWithHealthClaims = products.filter(product => product.healthClaims && Array.isArray(product.healthClaims) && product.healthClaims.length);
				return productsWithHealthClaims;
			},
			refreshShopByDietState: function(filterOptions) {
				if (!filterOptions || !filterOptions.healthClaims) {
					$rootScope.shopByDietApplied = false;
				} else if (Array.isArray(filterOptions.healthClaims)) {
					$rootScope.shopByDietApplied = !!filterOptions.healthClaims.length;
				}
			}
		},
		filterStates: {
			hasProductsWithHealthClaims: false
		},
	    clientPages                 : {
        	loadPage: false,
		    partial: '',
        	init() {
        		void 0;
        		if (!ENV.clientPages.length) {
        			$location.url('/');
        			return;
		        }
        		var page = $routeParams.page;
        		var selectedPage = false;

        		ENV.clientPages.forEach(function(clientPage) {
        			if (clientPage.href === '/p/' + page) {
        				selectedPage = clientPage;
			        }
		        });

        		if (!selectedPage) {
			        $location.url('/');
			        return;
		        }

        		this.partial = '../partials/client-pages/' + selectedPage.parent + '/' + selectedPage.partial;
        		this.loadPage = true;

        		return this.partial;
	        }
	    },
        initAppState: function() {
            var message = {
                type: hsPickingApp.REACT_NATIVE_EVENT_TYPES.INIT_FE_STATE,
                payload: {
                    data: ENV,
                }
            };
            hsPickingApp.postMessage(message);
            $location.url('/');
        },
        getLandingPageImageUrl: function (product) {
            var basePath = '../images/client-assets/' + ENV.folderLocation + '/products/';
            var image;
            if ($rootScope.screenWidth.xs) {
                image = product.image.xs;
            } else {
                image = product.image.default;
            }
            return basePath + image;
        },
        getHeroCarouselStyle: function (product) {
            return {
                'background-image': 'url(' +  $scope.landing.getLandingPageImageUrl(product) + ')',
            };
        },
		processRedirect() {
			void 0;
			var locationName = $routeParams.redirectKey.toLowerCase().replace(/\s/g, '');
			var tableNumber = $location.search().tableNumber;
			var url = '/products' + (tableNumber ? '?tableNumber=' + tableNumber : '');
			void 0;

			var location = localStorageService.get('location');
			if (location && location.hasOwnProperty('allLocations')) {
				if (routeToLocation(location.allLocations)) {
					return $location.url(url);
				}
			}

			$http.get(ENV.apiEndPoint + '/locations')
				.then(function(res) {
					void 0;
					if (res.status === 200) {
						if (routeToLocation(res.data)) {
							return $location.url(url);
						}
						$location.url('/404');
					}
				});

			function routeToLocation(locations) {
				var locationState = {
					allLocations: locations,
					selectedLocation: false
				};

				var foundLocation = locations.find(function(loc) {
					return loc.name.toLowerCase().replace(/\s/g, '') === locationName;
				});

				if (foundLocation) {
					locationState.selectedLocation = foundLocation;
					localStorageService.set('location', locationState);
					$rootScope.location = foundLocation;
					$rootScope.$broadcast('locationUpdated');

					if (ENV.enablePriceList) {
						$rootScope.selectedPriceList = locationState.selectedLocation.priceLists[0];
						localStorageService.set('selectedPriceList', locationState.selectedLocation.priceLists[0]);
					}

					if (tableNumber) {
						url += '&tsoLocation=' + encodeURIComponent(foundLocation.uniqueName)
							+ '&tsoPriceList=' + encodeURIComponent(foundLocation.priceLists[0].uniqueName);
					}
					return true;
				}
			}
	    },
	    checkOpenOrders() {
		    hsCart.getOrderHistory(1)
			    .then(function (res) {
				    void 0;
				    if (res.data && res.data.orders
					    && Array.isArray(res.data.orders)
					    && res.data.orders.length) {
					    var order = res.data.orders[0];
					    if (order) {
						    order.viewOrderUrl = '/my-account?order=' + encodeURIComponent(order.key);
						    order.showBanner = (order.state !== 'Cancelled' && order.state !== 'Completed');
						    $rootScope.openOrder = order;
					    } else {
						    $rootScope.openOrder = null;
					    }
					    void 0;
				    }
			    });
	    },
	    initFireworks() {
		    setTimeout(function() {
			    var ConfettiSettings = {
				    "target":"confetti",
				    "max": $rootScope.screenWidth.xs ? "100": "180",
				    "animate":true,
				    "props":["circle","square","triangle","line"],
				    "colors":[[165,104,246],[230,61,135],[0,199,228],[253,214,126]],
				    "clock":"20"
			    };

			    var Confetti = new ConfettiGenerator(ConfettiSettings);
			    Confetti.render();
		    }, 100);
	    },
	    saleItemClick(item) {
		    if (item.targetUrl && item.online) {
			    $location.url(item.targetUrl);
		    }
	    },
	    initPageNotFound() {
		    $rootScope.bgHome = true;
		    window.prerenderReady = false;
		    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
			    //..do something  //if you don't want event to bubble up
			    $rootScope.bgHome = false;
		    });

		    var redirectTimer = setInterval(function () {
			    if ($scope.landing.config.redirectTimer > 1) {
				    $scope.landing.config.redirectTimer--;
				    $scope.$apply();
			    } else {
				    window.location.href = '/products';
				    clearInterval(redirectTimer);
			    }
		    }, 1000);
	    },
	    showCheckDeliveryAreaPopup() {
		    var dialogOptions = {
			    template        : 'partials/popup/check-delivery-area.html',
			    controller      : 'ModalController',
			    className       : 'ngdialog-theme-default email-capture',
			    closeByDocument : true,
			    closeByEscape   : true,
			    scope           : $scope,
			    name            : 'check-delivery-popup',
			    id              : 'check-delivery-popup'
		    };

		    ngDialog.open(dialogOptions);
	    },
	    loadLocationsPopup(searchPage, runUpdate, callback) {
		    $scope.searchPage = searchPage || false;
		    $scope.runUpdate = runUpdate || false;

		    if (!ngDialog.isOpen('locationpopup-dialog') && !ngDialog.isOpen('location-dialog')) {
			    var dialogOptions = {
				    template        : 'partials/popup/select-location.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default email-capture',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'locationPopup',
				    id              : 'locationPopup'
			    };

			    if (callback) {
				    dialogOptions.preCloseCallback = function(value) {
						$scope.landing.disablePriceListSelector();
					    callback(value);
				    }
			    }

			    ngDialog.open(dialogOptions);
		    }
	    },
	    calculateCategorySlides(selectedWidth) {
		    switch (selectedWidth) {
			    case 'lg' :
			    case 'md' :
				    return 3;
			    case 'sm' :
				    return 2;
			    case 'xs' :
				    return 1;
		    }
	    },
		disablePriceListSelector() {
            return globalFunctions.disablePriceListSelector();
		},
	    updateLocation(location) {
        	if (location.isDisabled) {
        		return;
	        }

		    var locationData = {
			    allLocations    	: $scope.landing.locations,
			    selectedLocation	: location
		    };

		    localStorageService.set('location', locationData);
		    if (ENV.enablePriceList) {
				localStorageService.set('selectedPriceList', location.priceLists[0]);
		    }
		    $rootScope.$emit('locationUpdated', true);

		    sessionStorage.setItem('hs_session', new Date());

		    $location.url('/whats-new');
	    },
	    navigateNewsItem(item) {
        	switch (item.type) {
		        case 'redirect':
			        if (item.target.indexOf('https://') === -1 && item.target.indexOf('http://') === -1) {
				        $location.url(item.target);
			        } else {
				        var win = window.open(item.target, '_blank');
				        win.focus();
			        }
		        	break;
		        case 'content':
			        $location.url('/whats-new' + item.target);
		        	break;
		        default:
		            break;
	        }
	    },
	    getNews(updateContentData) {
        	if (!$rootScope.ENV.showWhatsNewPage) {
        		return $location.url('/products');
	        }

		    var location = localStorageService.get('location');
		    if (!$location.search().location && (!location || !location.hasOwnProperty('allLocations'))){
			    ngDialog.open({
				    template        : 'partials/popup/select-location.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default email-capture',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'location',
				    id              : 'location',
					preCloseCallback : function() {
						$scope.landing.disablePriceListSelector();
						$rootScope.$broadcast('locationUpdated');
					}
			    });
		    } else {
			    $rootScope.$broadcast('locationUpdated');
			    hsApi.getNews()
				    .then(function(res){
					    if (res.status === 200) {
						    var doesTargetExist = false;
						    res.data.forEach(function (item) {
							    var image = item.image.split('.');
							    if (image.length === 1) {
								    item.image += '.jpg'
							    }

							    if (Object.keys(item.content).length) {
								    if (item.content.image) {
									    item.content.image += '.jpg';
								    }

									// @TODO: mutate image reference in array, not the local `image` variable
								    item.content.sections.forEach(function (section) {
									    section.images.forEach(function (image) {
										    var image = image.split('.');
										    if (image.length === 1) {
											    image += '.jpg'
										    }
									    });
								    });
							    }

							    if (updateContentData) {
								    if ('/' + $routeParams.target === item.target) {
									    if (item.content.image) {
										    item.content.image = $scope.landing.config.imageBaseUrl + item.content.image;
									    }
									    $scope.landing.selectedNews = item;
									    doesTargetExist = true;
								    }
							    }
						    });

						    if (updateContentData) {
							    if (!doesTargetExist) {
								    $location.url('/whats-new');
							    }
						    }

						    $scope.landing.news = res.data;
					    } else {
						    toastr.error('Error retrieving locations.')
					    }
				    });
		    }

		    if (ENV.enablePriceList) {
			    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				    event.preventDefault();
				    $scope.landing.loadLocationsPopup(false, false, function (value) {
					    sessionStorage.setItem('hs_session', new Date());
					    $route.reload();
				    });
			    });

			    $scope.$on('$destroy', function() {
				    sessionExpired();
			    });
		    }

		    var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
			    event.stopPropagation();
			    $route.reload();
		    });

		    $scope.$on('$destroy', function() {
			    LocationEventListener();
		    });
	    },
	    getLocations() {
		    $http.get(ENV.apiEndPoint + '/locations')
		    .then(function(res){
			    void 0;
			    if (res.status === 200) {
			    	res.data.forEach(function(location) {
			    		if (location.isDisabled) {
			    			$scope.landing.disabledLocations.push(location);
					    }
				    });

			        $scope.landing.locations = res.data;
			    } else {
				    toastr.error('Error retrieving locations.');
			    }
		    });
	    },
		copyToClipboard(str) {
        	globalFunctions.copyToClipboard(str);
        },
	    getHomePageGridLength(selectedWidth, productLength) {
		    switch (selectedWidth) {
			    case 'lg' : {
				    var tileLength = 0;
				    productLength <=4 ? tileLength = 4 : tileLength = 5;
				    return (Math.ceil(productLength/tileLength) * tileLength) - productLength;
			    }
			    case 'md' : {
				    return (Math.ceil(productLength/3) * 3) - (productLength + 1);
			    }
			    case 'sm' : {
				    return (Math.ceil(productLength/3) * 3) - (productLength + 1);
			    }
			    case 'xs' : {
				    return (Math.ceil(productLength/2) * 2) - productLength;
			    }
		    }
	    },
	    getOrderPageGridLength(selectedWidth, productLength) {
		    switch (selectedWidth) {
			    case 'lg' :
			    case 'md' :
			    case 'sm' : {
				    if (productLength % 2) {
					    return 1;
				    } else {
					    return 0;
				    }
			    }
			    case 'xs' : {
				    return 0;
			    }
		    }
	    },
	    getMaxGridLength(selectedWidth, productLength) {
		    switch (selectedWidth) {
			    case 'lg' : {
				    return (Math.ceil(productLength/5) * 5) - productLength;
			    }
			    case 'md' : {
				    return (Math.ceil(productLength/3) * 3) - productLength;
			    }
			    case 'sm' : {
				    return (Math.ceil(productLength/3) * 3) - productLength;
			    }
			    case 'xs' : {
				    return (Math.ceil(productLength/2) * 2) - productLength;
			    }
		    }
	    },
	    addEmptyGridTiles(type, products, screenWidth) {
	        var homePageProducts;
		    var productLength;
        	if (type === 'homePageProducts') {
		        if (products.tileProducts.length < 4) {
			        if(products.tileProducts.length >= products.nonTileProducts.length){
				        homePageProducts = products.tileProducts;
			        }else{
				        homePageProducts = products.nonTileProducts;
			        }
		        }else{
			        homePageProducts = products.tileProducts;
		        }

		        productLength = homePageProducts.length;
	        } else {
        		productLength = products.length;
	        }

		    var selectedWidth;
		    var maxGridLength;

		    angular.forEach(screenWidth, function(width, key) {
			    width === true ? selectedWidth = key : '';
		    });

		    switch (type) {
			    case 'homePageProducts' : {
				    maxGridLength = $scope.landing.getHomePageGridLength(selectedWidth, productLength);
				    break;
			    }
			    case 'orderPage' : {
				    maxGridLength = $scope.landing.getOrderPageGridLength(selectedWidth, productLength);
				    break;
			    }
			    case 'regular' : {
				    maxGridLength = $scope.landing.getMaxGridLength(selectedWidth, productLength);
				    break;
			    }
		    }

		    if (type === 'homePageProducts'
			    && selectedWidth === 'lg'
			    && (productLength > 4 && productLength < 9)) {
			    return homePageProducts.slice(0,4);
		    } else{
			    var objectsToAdd = [];
			    for (var i = 0; i < maxGridLength; i++) {
				    objectsToAdd.push({
					    renderEmptyTile : true
				    });
			    }

			    if (type === 'homePageProducts') {
			    	return homePageProducts.concat(objectsToAdd);
			    } else {
			        return products.concat(objectsToAdd);
			    }

		    }
	    },
	    calculateEmptyTiles(products, screenWidth) {
		    for (var j = products.length -1 ; j >= 0; --j) {
			    if(products[j].hasOwnProperty('renderEmptyTile')){
				    products.splice(j, 1);
			    }
		    }

		    var productLength = products.length;
		    var selectedWidth;
		    var maxGridLength;

		    angular.forEach(screenWidth, function(width, key) {
			    width === true ? selectedWidth = key : '';
		    });

		    switch (selectedWidth) {
			    case 'lg' : {
				    maxGridLength = (Math.ceil(productLength/5) * 5) - productLength;
				    break;
			    }
			    case 'md' : {
				    maxGridLength = (Math.ceil(productLength/3) * 3) - productLength;
				    break;
			    }
			    case 'sm' : {
				    maxGridLength = (Math.ceil(productLength/3) * 3) - productLength;
				    break;
			    }
			    case 'xs' : {
				    maxGridLength = (Math.ceil(productLength/2) * 2) - productLength;
				    break;
			    }
		    }

		    var objectsToAdd = [];
		    for(var i = 0; i < maxGridLength; i++){
			    objectsToAdd.push({
				    renderEmptyTile : true
			    });
		    }

		    return products.concat(objectsToAdd);

	    },
	    showCategoryItems(products, screenWidth, searchPage) {
        	angular.forEach(products, function (val, key) {
		        val.tileProducts = $scope.landing.calculateEmptyTiles(val.tileProducts, screenWidth, searchPage);
		        val.nonTileProducts = $scope.landing.calculateEmptyTiles(val.nonTileProducts, screenWidth, searchPage);
	        });
	    },
	    showAllProducts(products, screenWidth) {
        	var val = products;
		    if(val.tileProducts.length > 0){
			    for (var j = val.tileProducts.length -1 ; j >= 0; --j) {
				    if(val.tileProducts[j].hasOwnProperty('renderEmptyTile')){
					    val.tileProducts.splice(j, 1);
				    }
			    }

			    var productLength = val.tileProducts.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach(screenWidth, function(width, key) {
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' : {
					    maxGridLength = (Math.ceil(productLength/5) * 5) - productLength;
					    break;
				    }
				    case 'md' : {
					    maxGridLength = (Math.ceil(productLength/3) * 3) - productLength;
					    break;
				    }
				    case 'sm' : {
					    maxGridLength = (Math.ceil(productLength/3) * 3) - productLength;
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = (Math.ceil(productLength/2) * 2) - productLength;
					    break;
				    }
			    }

			    var objectsToAdd = [];
			    for(var i = 0; i < maxGridLength; i++){
				    objectsToAdd.push({
					    renderEmptyTile : true
				    });
			    }

			    val.tileProducts = val.tileProducts.concat(objectsToAdd);
		    }

		    if(val.nonTileProducts.length > 0) {
			    for (var j = val.nonTileProducts.length - 1; j >= 0; --j) {
				    if (val.nonTileProducts[j].hasOwnProperty('renderEmptyTile')) {
					    val.nonTileProducts.splice(j, 1);
				    }
			    }

			    var productLength = val.nonTileProducts.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach(screenWidth, function (width, key) {
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' : {
					    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
					    break;
				    }
				    case 'md' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'sm' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
					    break;
				    }
			    }

			    var objectsToAdd = [];
			    for (var i = 0; i < maxGridLength; i++) {
				    objectsToAdd.push({
					    renderEmptyTile: true
				    });
			    }

			    val.nonTileProducts = val.nonTileProducts.concat(objectsToAdd);
		    }
	    },
	    showProductItems(products, screenWidth) {
        	if (products) {
		        var selectedWidth;
		        var productLength = products.length;
		        angular.forEach(screenWidth, function(width, key){
			        width === true ? selectedWidth = key : '';
		        });

		        switch (selectedWidth){
			        case 'lg' : {
				        return productLength >= 9 ? 9 : 4;
			        }
			        case 'md' : {
				        return productLength >= 9 ? 8 : 2;
			        }
			        case 'sm' : {
				        return productLength >= 9 ? 8 : 2;
			        }
			        case 'xs' : {
				        return 4;
			        }
		        }
	        }
	    },
	    showProductPopup(product) {
        	if(product.renderEmptyTile){
        		return;
	        }
		    var modalClass = '';

		    if(product.hasImage){
			    modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
		    }else{
			    modalClass = 'ngdialog-theme-default email-capture';
		    }

		    ngDialog.open({
			    template    : 'partials/popup/product-item/product-item-popup.html',
			    controller  : 'ModalController',
			    className   : modalClass,
			    data        : product
		    });
	    },
		initFaq() {
        	void 0;
        	if(!ENV.FAQ) {
        		$location.url('/404');
			}
		},
	    scrollToElement(elem, amount) {
            globalFunctions.scrollToElement(elem, amount);
	    },
	    scrollTo() {
        	this.config.scrollTo($scope.selectedCategory);
	    },
		searchV2(value, orderView, updateSearch) {
			$scope.landing.search(value, orderView, updateSearch);
			if (!$rootScope.screenWidth.xs) {
				$scope.landing.scrollToElement('#search-page-section');
			} else {
				$scope.landing.scrollToElement('#all-categories');
			}
		},
		searchV2Enabled() {
			return hsSearch.searchV2Enabled();
		},
		setSearchQuery(searchTerm) {
			$scope.landing.searchQuery = searchTerm;
		},
	    search(searchTerm, orderView, updateSearch) {
            var hadSearchTerm = !!$scope.landing.searchedQuery;
        	var originalSearchTerm = searchTerm;
        	var tabularView = false;
			if(!searchTerm){return;}
		    searchTerm = encodeURIComponent(searchTerm);
		    searchTerm = 'item=' + searchTerm;
		    if (orderView || $location.search().orderView) {
		    	searchTerm += '&orderView=true';
		    	tabularView = true;
		    }

			if (!hadSearchTerm && $rootScope.currentLocation.includes('/search')) {
				$location.search('item', originalSearchTerm);
			} else {
				$location.url('/search?'+ searchTerm);
			}

		    $scope.landing.searchedQuery = originalSearchTerm;
			$scope.landing.searchMobile.isBottomSheetVisible = !$scope.landing.searchMobile.isBottomSheetVisible;
            $scope.landing.searchQuery = originalSearchTerm;
		    if (updateSearch) {
		    	this.searching = true;
				if (!$scope.screenWidth.xs && hadSearchTerm) {
					return $scope.landing.processSearch().then(function() {
						angular.element(document.getElementById('filter-bar')).scope().$ctrl.applySearchTermChange();
					});
				} else {
					if (!hadSearchTerm) {
						var searchParams = hsSearch.resolveSearchURL(false);
						return $scope.landing.processSearch(searchParams).then(function() {
							angular.element(document.getElementById('filter-bar')).scope().$ctrl.applySearchTermChangeAndRefresh();
						});
					} else {
						return $scope.landing.processSearch();
					}
				}
		    }
	    },
	    resetSearch() {

	    },
	    clearSearchField() {
        	void 0;
		    $scope.landing.searchQuery= "";
		    $scope.searchedQuery= "";
		    $('#searchQuery').val('');
		    return this.processSearch();
	    },
		clearSearchInput() {
			$scope.landing.searchQuery= "";
		},
	    resetSearchFilter(type) {
        	var queryParams = $location.search();
		    switch(type) {
			    case 'all':
				    queryParams.categories = null;
				    queryParams.subcategories = null;
				    queryParams.brands = null;
				    queryParams.healthClaims = null;
				    break;
			    case 'department':
				    queryParams.categories = null;
				    queryParams.subcategories = null;
				    $scope.landing.searchMobile.category = '';
				    $scope.landing.searchMobile.subCategory = '';
				    break;
		    }
		    $location.search(queryParams);
			return $scope.landing.processSearch();
	    },
		resetSearchFilters() {
			['categories', 'subcategories', 'brands', 'healthClaims'].forEach(function(key) {
				$location.search(key, null);
			});
            if (!$scope.landing.searchedQuery) {
                $location.url('/products');
                return Promise.resolve();
            }
			return $scope.landing.processSearch();
	    },
		resetFilters() {
			this.resetSearchFilters().then(function() {
				angular.element(document.getElementById('filter-bar')).scope().$ctrl.revert();
			});
		},
	    applySearchFilter(type, category, subCategory) {
        	var queryParams = $location.search();
        	switch(type) {
		        case 'category':
		        	queryParams.categories = category;
		        	queryParams.subcategories = null;
		        	break;
		        case 'subCategory':
		        	queryParams.categories = category;
		        	queryParams.subcategories = subCategory;
		        	break;
		        case 'organic':
			        $scope.landing.searchOrganic = !$scope.landing.searchOrganic;
			        if ($scope.landing.searchOrganic) {
						queryParams.healthClaims = 'Organic';
					} else {
						queryParams.healthClaims = null;
					}
		        	break;
	        }
	        $location.search(queryParams);
			return $scope.landing.processSearch();
	    },
        applySearchFiltersLanding: function(options) {
            ['categories', 'subcategories', 'brands', 'healthClaims'].forEach(function(key) {
				$location.search(key, null);
			});
			Object.keys(options).forEach(function(key) {
				var uri = options[key];
				$location.search(key, uri);
			});
			$location.path('/search');
            return Promise.resolve();
        },
		applySearchFilters(options) {
			['categories', 'subcategories', 'brands', 'healthClaims'].forEach(function(key) {
				$location.search(key, null);
			});
			Object.keys(options).forEach(function(key) {
				var uri = options[key];
				$location.search(key, uri);
			});
			if ($scope.landing.searchedQuery || hsSearch.hasSearchParams(hsSearch.resolveSearchURL(false))) {
				return $scope.landing.processSearch(options);
			} else {
				$location.url('/products');
				return Promise.resolve();
			}
	    },
	    initLocationEventListener(searchPage, productId, categoryName, showTabularView) {
        	if (!this.locationEventListener) {
		        this.locationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
					if (event && typeof event.stopPropagation === 'function') {
						event.stopPropagation();
					}
			        void 0;
					$rootScope.allProducts = null;
					$rootScope.fullListLoaded = false;
					$scope.landing.data = null;
					$scope.landing.config.pageFullyLoaded = false;
					$scope.landing.checkProductLandingData(searchPage, showTabularView, productId, categoryName);
		        });

		        $scope.$on('$destroy', function() {
			        $scope.landing.locationEventListener();
		        });
	        }


        	if (!this.priceListEventListener) {
		        this.priceListEventListener = $rootScope.$on('priceListUpdated', function(event, data) {
					if (event && typeof event.stopPropagation === "function") {
						event.stopPropagation();
					}
			        void 0;
			        $rootScope.allProducts = null;
					$rootScope.fullListLoaded = false;
					$scope.landing.data = null;
					$scope.landing.config.pageFullyLoaded = false;
					$scope.landing.checkProductLandingData(searchPage, showTabularView, productId, categoryName);
		        });

		        $scope.$on('$destroy', function() {
			        $scope.landing.priceListEventListener();
		        });
	        }
	    },
	    calculateProductPrice(priceObj) {
		    return hsCart.calculateProductPrice(priceObj);
	    },
	    calculatePricePerQuantity(priceObj) {
	    	return hsCart.calculatePricePerQuantity(priceObj);
	    },
        initDiscountPage() {
	        if (!$rootScope.ENV.showDealsPage) {
		        return $location.url('/products');
	        }

	        var location = localStorageService.get('location');
	        if (ENV.enableLocations && !$location.search().location && (!location || !location.hasOwnProperty('allLocations'))){
		        ngDialog.open({
			        template        : 'partials/popup/select-location.html',
			        controller      : 'ModalController',
			        className       : 'ngdialog-theme-default email-capture',
			        showClose       : false,
			        closeByDocument : false,
			        closeByEscape   : false,
			        closeByNavigation: true,
			        scope           : $scope,
			        name            : 'location',
			        id              : 'location',
					preCloseCallback : function() {
						$scope.landing.disablePriceListSelector();
						$rootScope.$broadcast('locationUpdated');
					}
		        });
	        } else {
		        $rootScope.$broadcast('locationUpdated');
		        $http.get(ENV.apiEndPoint + '/user/coupon')
			        .then(function(res){
				        void 0;
				        if (res.status === 200) {
					        if (res.data.length === 0) {
						        $scope.landing.noCouponsAvailable = true;
					        } else {
						        var coupons = {
							        new 		: [],
							        used		: [],
							        expired		: []
						        };

						        res.data.forEach(function(order){
							        if(order.hasOwnProperty('used') && order.used) {
								        coupons.used.push(order);
							        } else if(order.hasOwnProperty('expired') && order.expired) {
								        coupons.expired.push(order);
							        } else {
								        coupons.new.push(order);
							        }
						        });

						        void 0;
						        $scope.landing.coupons = coupons;
					        }
				        }else {
					        toastr.error('Error getting coupons. Please reload the page.');
					        $scope.landing.setPageFullyLoaded();
				        }
				        $scope.landing.setPageFullyLoaded();
			        })
			        .catch(function(err){
				        void 0;
				        $scope.landing.setPageFullyLoaded();
			        });
	        }

	        if (ENV.enablePriceList) {
		        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
			        event.preventDefault();
			        $scope.landing.loadLocationsPopup(false, false, function (value) {
				        sessionStorage.setItem('hs_session', new Date());
				        $route.reload();
			        });
		        });

		        $scope.$on('$destroy', function() {
			        sessionExpired();
		        });
	        }

	        var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
		        event.stopPropagation();
		        $route.reload();
	        });

	        $scope.$on('$destroy', function() {
		        LocationEventListener();
	        });
        },
		setPageFullyLoaded() {
			void 0;
			$scope.landing.config.pageFullyLoaded = true;
		},
		initScrollAnimationMobile() {
			// Uses the same logic as in header-footer.js controller
			$(window).scroll(function(event){
				hasScrolled();
			});

			var maxCatTop = 120;
			if (ENV.enableLocations && $rootScope.location && $rootScope.location.selectedLocation && $rootScope.location.selectedLocation.name) {
				maxCatTop = 170;
			}
			var lastScrollTop = 0;
			var currCatTop = maxCatTop;

			function hasScrolled() {
				if (!$rootScope.screenWidth.xs) return;

				maxCatTop = 120;
				if (ENV.enableLocations && $rootScope.location && $rootScope.location.selectedLocation && $rootScope.location.selectedLocation.name) {
					maxCatTop = 170;
				}

				var st = $(window).scrollTop();
				var pixelsScrolled = Math.abs(lastScrollTop - st);

				if (st < 0) {
					currCatTop = maxCatTop;
					return;
				}

				if (st > lastScrollTop) { // scrolldown
					currCatTop -= pixelsScrolled;
					if (currCatTop < 55) {
						currCatTop = 55;
					}
				} else { // scrollup
					currCatTop += pixelsScrolled;

					if (currCatTop > maxCatTop) {
						currCatTop = maxCatTop;
					}
				}

				$('#slideup-menubar').css({
					top: (currCatTop) + 'px'		
				});

				$('#product-landing-all-categories-fixed').css({
					top: (currCatTop) + 'px'		
				});

				$('#product-landing-slideup-menubar').css({
					top: (currCatTop) + 'px'		
				});

				$('#category-page-all-categories-fixed').css({
					top: (currCatTop) + 'px'		
				});

				lastScrollTop = st;
			}
		},
		initScrollAnimationTablet() {
			// Uses the same logic as in header-footer.js controller
			$(window).scroll(function(event){
				hasScrolled();
			});

			var lastScrollTop = 0;
			var currCatTop = 127;

			function hasScrolled() {
				if ($rootScope.screenWidth.xs || $rootScope.screenWidth.lg) return;
				
				var st = $(window).scrollTop();
				var pixelsScrolled = Math.abs(lastScrollTop - st)/2;

				if (st < 0) {
					currCatTop = 127;
					return;
				}

				if (st > lastScrollTop) { // scrolldown
					currCatTop -= pixelsScrolled;
					if (currCatTop < 65) {
						currCatTop = 65;
					}

					$('#all-categories-fixed').css({
						top: (currCatTop) + 'px'		
					});

				} else { // scrollup
					currCatTop += pixelsScrolled;

					if (currCatTop > 127) {
						currCatTop = 127;
					}

					$('#all-categories-fixed').css({
						top: (currCatTop) + 'px'		
					});
				}

				lastScrollTop = st;
			}
		},
        init(searchPage, loadLocations, showTabularView) {
			$scope.landing.initScrollAnimationMobile();
			$scope.landing.initScrollAnimationTablet();

            var userType = $rootScope.loggedIn ? 'User' : 'Visitor';
            var onReadyCalled = false;

            if (searchPage) {
                this.config.showTabularView = $location.search().orderView;
                var searchTerm = $location.search().item;

	            if (searchTerm) {
		            searchTerm = searchTerm.replace(/-/g, ' ');
		            $scope.landing.searchedQuery = searchTerm;
		            $scope.landing.searchQuery = searchTerm;

		            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', userType + ' searched for ' + searchTerm + '.');
	            }
            }

            if (showTabularView){
	            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', userType + ' Landed on Order Page.');
            } else {
	            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'landed', userType + ' Landed on Products Page.');
            }

	        var locationParam = $location.search().loc;
            var locName = ($location.search().locName || '').toLowerCase();
            var pListName = ($location.search().pListName || '').toLowerCase();
	        var pricelistParam = $location.search().plist;
	        var tableNumberParam = $location.search().tableNumber;
            var hasLocationQueryParam = !!(locName || locationParam);
            var hasPriceListQueryParam = !!(pListName || pricelistParam);
            if (tableNumberParam) {
                hsTableSideOrders.initSession(tableNumberParam, $location.search().tsoLocation, $location.search().tsoPriceList);
                $location.search('tableNumber', null);
                $location.search('tsoLocation', null);
                $location.search('tsoPriceList', null);
            }

            if ($rootScope.tableSideOrder) {
                hsTableSideOrders.checkOpenOrder()
                    .then(function(openOrder) {
                        if (openOrder) {
                            $location.url($rootScope.openTableSideOrder + '&showAddItem=true');
                        }
                    })
                    .catch(function(err) { void 0; });
            }

	        void 0;
	        if (hasLocationQueryParam) {
                var locationFound = false;
                var priceListFound = false;
		        var location = localStorageService.get('location');

		        if (location) {
		        	var selectedPriceList = null;

			        location.allLocations.forEach(function(loc) {
				        if (hsMarketingService.isMatchingLocation(locName, loc) || loc.uniqueName === locationParam) {
					        location.selectedLocation = loc;
					        $rootScope.location = loc;
                            locationFound = true;
                            priceListFound = false;
					        if (ENV.enablePriceList) {
						        if (hasPriceListQueryParam) {
							        loc.priceLists.forEach(function (plist) {
								        if (hsMarketingService.isMatchingPriceList(pListName, plist) || plist.uniqueName === pricelistParam) {
								        	selectedPriceList = plist;
									        $rootScope.selectedPriceList = plist;
                                            priceListFound = true;
								        }
							        });
                                    // need to return here. 
                                    // if the plist query param pl key doesn't exist for the selected location
                                    // we should show the pl selector, which happens if we don't go into this if block
                                    if (selectedPriceList) {
                                        localStorageService.set('selectedPriceList', selectedPriceList);
                                        sessionStorage.setItem('hs_session', new Date());
                                        localStorageService.set('location', location);
                                        hsMarketingService.clearDirectLinkingQueryParams();
                                        $rootScope.$broadcast('locationUpdated');
                                        $scope.landing.checkProductLandingData(searchPage, showTabularView);
                                        onReady();
                                        return;
                                    }

						        } 
                                if (locationFound && (!hasPriceListQueryParam || !priceListFound)) {
                                    // user must select a pricelist here
                                    localStorageService.remove('selectedPriceList');
                                }


                                
                                localStorageService.set('location', location);
                                ngDialog.open({
                                    template        : 'partials/popup/select-location.html',
                                    controller      : 'ModalController',
                                    className       : 'ngdialog-theme-default email-capture',
                                    showClose       : false,
                                    closeByDocument : false,
                                    closeByEscape   : false,
                                    closeByNavigation: true,
                                    scope           : $scope,
                                    name            : 'location',
                                    id              : 'location',
                                    preCloseCallback : function() {
                                        sessionStorage.setItem('hs_session', new Date());
                                        $scope.landing.disablePriceListSelector();
                                        hsMarketingService.clearDirectLinkingQueryParams();
                                        $rootScope.$broadcast('locationUpdated');
                                        $scope.landing.checkProductLandingData(searchPage, showTabularView);
                                    }
                                });
					        }
				        }
			        });
                    if (!locationFound) {
                        // clear saved data and go thru flow again w/o query params so user can 
                        // select their location and PL if applicable
                        localStorageService.remove('location');
                        localStorageService.remove('selectedPriceList');
                        $rootScope.location = null;
                        $rootScope.selectedPriceList = null;
                        hsMarketingService.clearDirectLinkingQueryParams();
                        return $scope.landing.init(searchPage, loadLocations, showTabularView);
                    }
                    if (!ENV.enablePriceList || locationFound) {
                        sessionStorage.setItem('hs_session', new Date());
                        localStorageService.set('location', location);
                        hsMarketingService.clearDirectLinkingQueryParams();
                        $rootScope.$broadcast('locationUpdated');
                        $scope.landing.checkProductLandingData(searchPage, showTabularView);
                    }
		        } else {
			        $http.get(ENV.apiEndPoint + '/locations')
				        .then(function(res){
					        void 0;
					        if (res.status === 200) {
					        	var locationState = {
					        		allLocations: res.data,
							        selectedLocation: {}
						        };
                                var selectedPriceList = null;

					        	res.data.forEach(function(loc) {
							        if (hsMarketingService.isMatchingLocation(locName, loc) || loc.uniqueName === locationParam) {
								        locationState.selectedLocation = loc;
								        $rootScope.location = loc;
                                        locationFound = true;
								        if (ENV.enablePriceList) {
									        if (hasPriceListQueryParam) {
										        locationState.selectedLocation.priceLists.forEach(function(plist) {
											        if (hsMarketingService.isMatchingPriceList(pListName, plist) || plist.uniqueName === pricelistParam) {
                                                        selectedPriceList = plist;
                                                        $rootScope.selectedPriceList = plist;
											        }
										        });

                                                // need to return here. 
                                                // if the plist query param pl key doesn't exist for the selected location
                                                // we should show the pl selector, which happens if we don't go into this if block
                                                if (selectedPriceList) {
                                                    localStorageService.set('selectedPriceList', selectedPriceList);
                                                    localStorageService.set('location', locationState);
                                                    sessionStorage.setItem('hs_session', new Date());
                                                    hsMarketingService.clearDirectLinkingQueryParams();
                                                    $rootScope.$broadcast('locationUpdated');
                                                    $rootScope.allProducts = {};
													$rootScope.fullListLoaded = false;			
                                                    $scope.landing.checkProductLandingData(searchPage, showTabularView);
                                                    onReady();
                                                    return;
                                                }
									        } 

                                            localStorageService.set('location', locationState);
                                            ngDialog.open({
                                                template        : 'partials/popup/select-location.html',
                                                controller      : 'ModalController',
                                                className       : 'ngdialog-theme-default email-capture',
                                                showClose       : false,
                                                closeByDocument : false,
                                                closeByEscape   : false,
                                                closeByNavigation: true,
                                                scope           : $scope,
                                                name            : 'location',
                                                id              : 'location',
                                                preCloseCallback : function() {
                                                    sessionStorage.setItem('hs_session', new Date());
                                                    $scope.landing.disablePriceListSelector();
                                                    hsMarketingService.clearDirectLinkingQueryParams();
                                                    $rootScope.$broadcast('locationUpdated');
                                                    $scope.landing.checkProductLandingData(searchPage, showTabularView);
                                                }
                                            });
								        }
							        }
						        });
                                if (!locationFound) {
                                    localStorageService.remove('location');
                                    localStorageService.remove('selectedPriceList');
                                    $rootScope.location = null;
                                    $rootScope.selectedPriceList = null;
                                    hsMarketingService.clearDirectLinkingQueryParams();
                                    return $scope.landing.init(searchPage, loadLocations, showTabularView);
                                }
                                if (!ENV.enablePriceList || locationFound) {
                                    sessionStorage.setItem('hs_session', new Date());
                                    localStorageService.set('location', locationState);
                                    hsMarketingService.clearDirectLinkingQueryParams();
                                    $rootScope.$broadcast('locationUpdated');
                                    $scope.landing.checkProductLandingData(searchPage, showTabularView);
                                }

					        }
				        });
		        }


		        if (ENV.enablePriceList && !$rootScope.tableSideOrder) {
			        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				        event.preventDefault();
				        $scope.landing.loadLocationsPopup(searchPage, true, function (value) {
					        sessionStorage.setItem('hs_session', new Date());
				        });
			        });

			        $scope.$on('$destroy', function() {
				        sessionExpired();
			        });
		        }
	        } else {
				var location = localStorageService.get('location');
				var selectedPriceList = localStorageService.get('selectedPriceList');
		        if (ENV.enableLocations) {
			        if (!$rootScope.tableSideOrder && (!$location.search().location && (!location || !location.hasOwnProperty('allLocations')) || $rootScope.showPriceListSelector)) {
						$scope.searchPage = searchPage;
						$scope.runUpdate = true;
						$scope.showTabularView = showTabularView;
						
						ngDialog.open({
					        template        : 'partials/popup/select-location.html',
					        controller      : 'ModalController',
					        className       : 'ngdialog-theme-default email-capture',
					        showClose       : false,
					        closeByDocument : false,
					        closeByEscape   : false,
					        closeByNavigation: true,
					        scope           : $scope,
					        name            : 'location',
					        id              : 'location',
					        preCloseCallback : function() {
								$scope.landing.disablePriceListSelector();
                                hsMarketingService.clearDirectLinkingQueryParams();
								$rootScope.$broadcast('locationUpdated');
						        $scope.landing.checkProductLandingData(searchPage, showTabularView);
					        }
				        });
					} else {
				        $scope.landing.checkProductLandingData(searchPage, showTabularView);
			        }

			        if (ENV.enablePriceList && !$rootScope.tableSideOrder) {
				        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
					        event.preventDefault();
					        $scope.landing.loadLocationsPopup(searchPage, true, function (value) {
						        sessionStorage.setItem('hs_session', new Date());
					        });
				        });

				        $scope.$on('$destroy', function() {
					        sessionExpired();
				        });
			        }
		        } else if (ENV.enablePriceList && !$rootScope.tableSideOrder) {
			        if ($rootScope.showPriceListSelector || !selectedPriceList) {
				        $scope.searchPage = searchPage;
				        $scope.runUpdate = true;
				        $scope.showTabularView = showTabularView;
				        ngDialog.open({
					        template        : 'partials/popup/select-price-list.html',
					        controller      : 'ModalController',
					        className       : 'ngdialog-theme-default email-capture',
					        showClose       : false,
					        closeByDocument : false,
					        closeByEscape   : false,
					        scope           : $scope,
					        name            : 'location',
					        id              : 'location',
					        preCloseCallback : function() {
								$scope.landing.disablePriceListSelector();
								$rootScope.$broadcast('priceListUpdated');
				                $scope.landing.checkProductLandingData(searchPage, showTabularView);
					        }
				        });
			        } else {
				        $scope.landing.checkProductLandingData(searchPage, showTabularView);
			        }

			        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				        event.preventDefault();
				        $scope.landing.loadLocationsPopup(searchPage, true, function (value) {
					        sessionStorage.setItem('hs_session', new Date());
				        });
			        });

			        $scope.$on('$destroy', function() {
				        sessionExpired();
			        });
		        } else {
			        $scope.landing.checkProductLandingData(searchPage, showTabularView);
		        }
	        }

            onReady();

            function onReady() {
                if (onReadyCalled) {
                    return;
                }

                onReadyCalled = true;

                $document.ready(function(event){
                    $document.bind('scroll', function(){
                        var windowTop   = $(window).scrollTop() + 10;
                        var selectedDiv = $('#all-categories');
                        // console.log(windowTop);
    
                        if(selectedDiv && selectedDiv.offset()){
                            var divTop      = selectedDiv.offset().top + 50;
                            if (windowTop >= divTop) {
                                $('#all-categories-fixed').css({
                                    display: 'block',
                                    opacity: 1
                                });
								$timeout(function() {
									$scope.landing.showMainSearchBar = false;
								}, 0);
                            } else if (windowTop < divTop) {
                                $('#all-categories-fixed').css({
                                    display: 'none',
                                    opacity: 0
                                });
								$timeout(function() {
									if (!$rootScope.screenWidth.xs) {
										$scope.landing.showMainSearchBar = true;
									}
								}, 0);
                            }
                        }
                    });
    
                    var getAllProducts = setInterval(function() {
                        $scope.landing.getAllProducts(searchPage, null, null, showTabularView, true);
                    },3.6e+6);
    
                    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
                        //..do something  //if you don't want event to bubble up
                        clearInterval(getAllProducts);
                    });
                });
    
                $scope.$on('$destroy', function() {
					if (searchPage) {
						var isProductPage = $location.path().startsWith('/product/');
						var searchQuery = localStorageService.get('searchQuery');
						if (hsUtils.isNonEmptyString(searchQuery) && !isProductPage && !$scope.landing.addedItemFromSearch) {
							aiSearchEvents.sendEvent(globalFunctions.GAEventType.SEARCH, aiSearchEvents.eventAction.UNSUCCESSFUL_SEARCH, searchQuery);
							localStorageService.set('searchQuery', null);
						}
					}
                    $document.unbind('scroll');
                });
            }

        },
	    initLandingPage(searchPage, showTabularView, productId, categoryName) {

		    if (searchPage) {
				void 0;
			    var searchTerm = $location.search().item;
			    if(searchTerm){
				    $scope.landing.searchedQuery = searchTerm;
			    }

			    $scope.landing.searchQuery = searchTerm;
			    this.config.updateSEOdata('Search - '+ ENV.name.companyName +' | ' + ENV.name.tagline);
			    return $scope.landing.getAllProducts(searchPage, productId || null, categoryName || null, showTabularView);
		    } else {
				void 0;
			    this.config.updateSEOdata();
				if(ENV.showAllProducts || ENV.showOrderPage) {
					return $scope.landing.getAllProducts(searchPage, productId || null, categoryName || null, showTabularView);
				} else {
					$scope.landing.getAllProducts(searchPage, productId || null, categoryName || null, showTabularView);				
					return $scope.landing.getAllProductsShortlist(categoryName || null, showTabularView);	
				}
		    }
	    },
		copyProductUrlToClipboard() {
			globalFunctions.copyProductUrlToClipboard($scope.landing.selectedProduct, false);
		},
		getProductDisplayName(item) {
			return hsCart.getProductDisplayName(item);
		},
		initProductDetail() {
	        var productId = $routeParams.productId;
			$scope.landing.initLocationEventListener(false, productId);

            $scope.$on('$destroy', $scope.$watch('landing.selectedProduct', function () {
                var product = $scope.landing.selectedProduct;
                product.promotion = hsPromos.getVisiblePromotion(product);
                product.volumePromotions = hsPromos.getVisibleVolumePromotions(product);
            }));

	        if (productId) {
				var location = localStorageService.get('location');
				var selectedPriceList = localStorageService.get('selectedPriceList');
		        if (ENV.enableLocations) {
					$scope.$on('changeLocation', function() {
						$scope.landing.fetchProduct(productId)
					});
					if (ENV.enablePriceList) {
						$scope.$on('changePriceList', function() {
							$scope.landing.fetchProduct(productId)
						});
					}

                    var directLinkingQueryParams = hsMarketingService.getDirectLinkingQueryParams();

                    if (directLinkingQueryParams && directLinkingQueryParams.locName) {
                        return $scope.landing.initWithDirectLinkingQueryParams()
                            .then(function() {
                                $scope.landing.getAllProducts(false, productId);
        
                                var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
                                    event.preventDefault();
                                    $scope.landing.loadLocationsPopup(false, false, function (value) {
                                        sessionStorage.setItem('hs_session', new Date());
                                        $scope.landing.checkProductData(category, true);
                                    });
                                });
        
                                $scope.$on('$destroy', function() {
                                    sessionExpired();
                                });
                            }).catch(function(error) {
                                void 0;
                                return initProductDetail();
                            })
                    }

			        if (!$location.search().location && (!location || !location.hasOwnProperty('allLocations')) || $rootScope.showPriceListSelector) {
						ngDialog.open({
					        template        : 'partials/popup/select-location.html',
					        controller      : 'ModalController',
					        className       : 'ngdialog-theme-default email-capture',
					        showClose       : false,
					        closeByDocument : false,
					        closeByEscape   : false,
					        closeByNavigation: true,
					        scope           : $scope,
					        name            : 'location',
					        id              : 'location',
					        preCloseCallback : function() {
								$scope.landing.disablePriceListSelector();
								$rootScope.$broadcast('locationUpdated');
						        $scope.landing.getAllProducts(false, productId);
					        }
				        });
			        } else {
						$scope.landing.fetchProduct(productId);
			        }

			        if (ENV.enablePriceList) {
						$scope.$on('changePriceList', function() {
							$scope.landing.fetchProduct(productId)
						});
				        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
					        event.preventDefault();
					        $scope.landing.loadLocationsPopup(false, true, function (value) {
						        sessionStorage.setItem('hs_session', new Date());
					        });
				        });

				        $scope.$on('$destroy', function() {
					        sessionExpired();
				        });
			        }
		        } else if (ENV.enablePriceList) {
			        if ($rootScope.showPriceListSelector || !selectedPriceList) {
				        ngDialog.open({
					        template        : 'partials/popup/select-price-list.html',
					        controller      : 'ModalController',
					        className       : 'ngdialog-theme-default email-capture',
					        showClose       : false,
					        closeByDocument : false,
					        closeByEscape   : false,
					        scope           : $scope,
					        name            : 'location',
					        id              : 'location',
					        preCloseCallback : function() {
								$scope.landing.disablePriceListSelector();
								$rootScope.$broadcast('priceListUpdated');
						        $scope.landing.getAllProducts(false, productId);
					        }
				        });
			        } else {
						$scope.landing.fetchProduct(productId);
			        }

			        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				        event.preventDefault();
				        $scope.landing.loadLocationsPopup(false, true, function (value) {
					        sessionStorage.setItem('hs_session', new Date());
				        });
			        });

			        $scope.$on('$destroy', function() {
				        sessionExpired();
			        });
		        } else {
					$scope.landing.fetchProduct(productId);
		        }

				$document.ready(function(event){

					// Display the product float at bottom if scroll past the product quantity button.
					// Product float will then be removed again if we are within 150px of the top of the 'Similar Products' div.
			        $document.bind('scroll', function(){
				        var windowTop   = $(window).scrollTop();
				        var selectedDiv = $('#quantity');
						var similarProductsDiv = $('#similar-products');
						var footerDiv = $('#sales-pitch');
						var productDetailFooterDiv = $('#product-detail-footer');

				        if (selectedDiv && similarProductsDiv && footerDiv) {
					        var divTop      = selectedDiv.offset().top;
							var similarProductsDivTop = similarProductsDiv.offset().top;
							var footerDivTop = footerDiv.offset().top;
					 		var productDetailFooterDivTop = productDetailFooterDiv.offset().top;
					 		var productDetailFooterDivBot = productDetailFooterDivTop + productDetailFooterDiv.height();

					        if (windowTop >= divTop && windowTop <= similarProductsDivTop - 150 && productDetailFooterDivBot < footerDivTop) {
						        $('#product-detail-footer').css({
									visibility: 'visible',
							        opacity: 1
						        });
					        } else if (windowTop < divTop || windowTop >= similarProductsDivTop - 150) {
						        $('#product-detail-footer').css({
									visibility: 'hidden',
							        opacity: 0
						        });
					        } else if (productDetailFooterDivBot > footerDivTop) {
								$('#product-detail-footer').css({
									visibility: 'hidden',
							        opacity: 0
						        });
							}
				        }
			        });
		        });
		        $scope.$on('$destroy', function() {
					var searchQuery = localStorageService.get('searchQuery');
					var path = $location.path();
					if (path !== '/search') {
						if (hsUtils.isNonEmptyString(searchQuery) && !$scope.landing.addedItemFromSearch) {
							aiSearchEvents.sendEvent(globalFunctions.GAEventType.SEARCH, aiSearchEvents.eventAction.UNSUCCESSFUL_SEARCH, searchQuery);
						}	
						localStorageService.set('searchQuery', null);
					}

					localStorageService.set('productSearchIndex', null);
					localStorageService.set('previousPath', null);

			        $document.unbind('scroll');
		        });
	        } else {
	        	$location.url('/');
	        }
        },
		activateTab(subCategory, index) {
			Object.keys($scope.landing.data).forEach(function(key) {
				$scope.landing.data[key].loadTab = false;
			});

			if ($scope.landing.data[subCategory]) {
			  $scope.landing.data[subCategory].loadTab = true;
				$location.search('category', subCategory);
			}
		},
	    updateQuantity(item, updateType, sourceBtn) {
			var quantityBtn = sourceBtn ? sourceBtn : '#quantity';
		    var updateBtn = '#update';
			if (quantityBtn === '#quantityFooter') {
				if ($('#quantity')) {
					hsCart.updateQuantity(item, updateType, quantityBtn, updateBtn, ['#quantity']);
				} else {
					hsCart.updateQuantity(item, updateType, quantityBtn, updateBtn);
				}
			} else if (quantityBtn === '#quantity') {
				if ($('#quantityFooter')) {
					hsCart.updateQuantity(item, updateType, quantityBtn, updateBtn, ['#quantityFooter']);
				} else {
					hsCart.updateQuantity(item, updateType, quantityBtn, updateBtn);
				}
			}
	    },
		addedItemFromSearch: false,
		sendAddProductGAEvent(item) {
			var searchQuery = localStorageService.get('searchQuery');
			var productSearchIndex = localStorageService.get('productSearchIndex');
			var path = localStorageService.get('previousPath');
			if (hsUtils.isNonEmptyString(searchQuery)) {
				aiSearchEvents.sendEvent(globalFunctions.GAEventType.SEARCH, aiSearchEvents.eventAction.ADD_TO_CART, item.name);
				aiSearchEvents.sendEvent(globalFunctions.GAEventType.SEARCH, aiSearchEvents.eventAction.SEARCH_ITEM_RANK, productSearchIndex);
				$scope.landing.addedItemFromSearch = true;
			} else {
				var gaEventCategory = aiSearchEvents.getEventCategory(path);
				aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.ADD_TO_CART, item.name);
				$scope.landing.addedItemFromSearch = false;
			}
		},
	    updateItemInCart(item) {
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement);

			if (validationError) {
				toastr.error(validationError);
				return;
			}

			var quantity = parseFloat(inputElement.val());
			var basket = localStorageService.get('basket');

		    if (!$rootScope.loggedIn) {
				var itemQuantity = 0;
			    item.quantity = parseFloat(quantity);

				if ($scope.landing.selectedProductInstructions) {
					item.instructions = $scope.landing.selectedProductInstructions;
				}

			    if (basket) {
				    var sameItem = false;
					var sameModifiers = false;
					var wasPickupOnly = basket.some(hsCart.getIsPickupOnly);
				    basket.forEach(function (basketItem) {
					    if (basketItem.name === item.name) {
						    if (basketItem.selectedModifiers) {
						    	item.selectedModifiers.forEach(function (i) { delete i.$$hashKey});

						    	if (_.isEqual(basketItem.selectedModifiers, item.selectedModifiers)) {
						    		sameModifiers = true;
									basketItem.instructions = item.instructions;
									if (!basketItem.hasOwnProperty('canReplace')) {
										basketItem.canReplace = !ENV.isRestaurant;
									}
								    basketItem.selectedModifiers = item.selectedModifiers;
								    basketItem.quantity = item.quantity;
							        itemQuantity += item.quantity;
							    } else {
						    		itemQuantity += basketItem.quantity;
							    }
						    } else {
							    basketItem.quantity = item.quantity;
						    }
						    sameItem = true;
					    }
				    });

				    if (!sameItem || (item.hasOwnProperty('selectedModifiers') && !sameModifiers)) {
					    basket.push(item);
						toastr.success('Item added to cart successfully.');
				    } else {
						toastr.success('Item updated successfully.');
					}

					if (hsCart.getIsPickupOnly(item) && !wasPickupOnly) {
                        toastr.warning('Item added is Pick Up only.');
                    }

				    localStorageService.set('basket', basket);

					if (item.hasOwnProperty('selectedModifiers')) {
				    	if (!sameModifiers) {
				    		itemQuantity += item.quantity;
					    }
				    	item.quantity = itemQuantity;
				    }
			    } else {
				    var basketArray = [];
					if (!item.hasOwnProperty('canReplace')) {
					    item.canReplace = !ENV.isRestaurant;
				    }
				    basketArray.push(item);
				    localStorageService.set('basket', basketArray);
					toastr.success('Item added to cart successfully.');
			    }

			    $rootScope.$emit('cartUpdated',true);
				
				$scope.landing.sendAddProductGAEvent(item);
		    } else {
			    $scope.landing.config.message = "";
			    $scope.landing.config.messageClass = "";
			    item.loading = true;

			    quantity = parseFloat(quantity);

			    var data = {
					items : [{
						name            : item.name,
						quantity        : quantity,
						isCustomItem    : false,
						canReplace      : globalFunctions.canReplace(item),
						instructions    : $scope.landing.selectedProductInstructions || "",
						displayName     : item.displayName,
						type            : item.type,
						subType         : item.subType,
						organic         : item.organic,
						unit            : item.unit,
						selectedModifiers: item.selectedModifiers ?
						    item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
					}]
			    };

				var wasPickupOnly = basket.isPickupOnly;
			    hsCart.addItemToCart(data)
			    .then(function(response) {
				    if (response.status === 200) {
					    if (item.hasModifiers) {
				    		var itemQuantity = 0;
				    		var newItem = true;
						    basket.items.forEach(function (basketItem) {
							    if (basketItem.name === item.name) {
								    if (basketItem.selectedModifiers) {
								    	var basketModifiers = basketItem.selectedModifiers.map(function(modifier) { return modifier.name});

								    	if (_.isEqual(basketModifiers, data.items[0].selectedModifiers)) {
								    		newItem = false;
								    		itemQuantity += quantity;
									    } else {
								    		itemQuantity += basketItem.quantity;
									    }
								    }
							    }
						    });

						    if (newItem) {
						    	itemQuantity += quantity;
						    }

					        item.quantity = itemQuantity;
					    } else {
					        item.quantity = quantity;
                        }
					    toastr.success('Item added to cart successfully.');
					    $rootScope.$broadcast('cartUpdated');
					    $scope.landing.config.message = "Item added to cart successfully.";
					    $scope.landing.config.messageClass = "alert-success";
						if (hsCart.getIsPickupOnly(item) && !wasPickupOnly) {
                            toastr.warning('Item added is Pick Up only.');
                        }
						$scope.landing.sendAddProductGAEvent(item);
				    }else{
						if (response.status === 409) {
							toastr.error('Maximum quantity for product reached');
							$scope.landing.config.message = "Maximum quantity for product reached.";
							$scope.landing.config.messageClass = "alert-danger";
						} else {
							toastr.error('Error adding product.');
							$scope.landing.config.message = "Error adding product.";
							$scope.landing.config.messageClass = "alert-danger";
						}
				    }

				    item.loading = false;
			    });
		    }
	    },
		addModifierItemToCart		: function (item) {
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement);
			if (validationError) {
				toastr.error(validationError);
				return;
			}
		    var interval = globalFunctions.getQuantityInterval(item);
        	var productModifierOption = [];
			var errors = [];
        	item.modifiers.forEach(function (modifier) {
        		modifier.error = '';
        		var minSelection = modifier.minSelections;
        		var maxSelection = modifier.maxSelections;
        		var selections = [];
        		if (modifier.selectionRequired) {
        			var error = true;
        			modifier.options.forEach(function(choice) {
        				if(choice.checked) {
        					error = false;
        					productModifierOption.push(choice);
					        selections.push(choice);
						}
					});

        			if (error) {
                        modifier.error = "Please select an option below.";
				        errors.push(true);
					}
				} else {
                    error = false;
                    modifier.options.forEach(function(choice) {
                        if(choice.checked) {
                            productModifierOption.push(choice);
                            selections.push(choice);
                        }
                    });
				}

        		if (!modifier.singleSelection) {
        			if (minSelection && (selections.length < minSelection)) {
        				void 0;
				        errors.push(true);
        				modifier.error = "Please select at least " + minSelection + " items.";
			        } else if (maxSelection && (selections.length > maxSelection)) {
        				void 0;
				        errors.push(true);
				        modifier.error = "Max " + maxSelection + " items are allowed.";
			        }
		        }
			});

			if (!errors.length) {
				item.selectedModifiers = productModifierOption;
				$scope.landing.updateItemInCart(item);
			}
		},
		addContainerItemToCart		: function (item) {
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement);
			if (validationError) {
				toastr.error(validationError);
				return;
			}
        	var productApiOption = "name=" + encodeURIComponent(item.name);
			var error = true;
        	item.orderingOptions.forEach(function (option){
        		if (option.selectionRequired) {
        			error = true;
        			option.choices.forEach(function(choice) {
        				if(choice.checked) {
        					error = false;
        					productApiOption += "&choice=" + encodeURIComponent(choice.name);
						}
					});

        			if (error) {
                        option.error = "Please select an option below."
					}
				} else {
                    error = false;
                    option.choices.forEach(function(choice) {
                        if(choice.checked) {
                            productApiOption += "&choice=" + encodeURIComponent(choice.name);
                        }
                    });
				}
			});

			if(!error){
		        hsCart.getProductWithOrderingOption(productApiOption)
			        .then(function(res) {
			        	void 0;
				        if(res.status === 200){
							$scope.landing.updateItemInCart(res.data);
				        } else {
					        toastr.error('Error adding item to the cart. Please try again.');
				        }
			        });
			} else {
				toastr.error('Error adding item to the cart. Please try again.');
			}
		},
		processItemToCart(item) {
			if (item.isContainer) {
				$scope.landing.addContainerItemToCart(item);
			} else if (item.hasModifiers) {
				$scope.landing.addModifierItemToCart(item);
			} else {
				$scope.landing.updateItemInCart(item);
			}
		},

		processIntoState(response, shortlistFlag, searchPage, productId, categoryName, showTabularView) {

			if(shortlistFlag && $scope.landing.config.pageFullyLoaded) return;
		
			var start = Date.now();
			var categoryOrder = JSON.parse(JSON.stringify($scope.landing.config.categoryOrder));
			var subCategoryOrder = JSON.parse(JSON.stringify($scope.landing.config.subCategoryOrder));
			var slides      = [];
			var products    = response.data.products;
			var healthClaims = response.data.healthClaims;
			var allProducts = [];
			var basket = localStorageService.get('basket');
			var basketMap = {};

			hsPromotionsV2.promotions = response.promotions;
		
			if (healthClaims) {
				$scope.landing.filters.healthClaims.enabled = !response.data.disableShopByDietFilterForLocation;
				$rootScope.healthClaims = healthClaims;
				$scope.landing.filterHandlers.initHealthClaimsFilterData();
				$rootScope.$broadcast('healthClaimsMapUpdated', healthClaims);
			}
		
			var promotionCategories = null;
			if (response.data.promotions && response.data.promotions.categoriesToDisplay) {
				promotionCategories = response.data.promotions.categoriesToDisplay;
			}
		
			hsSearch.convertFilterParamsToTitleCase($scope.landing.filters);
		
			if (basket) {
				var basketSrc = basket;
				if ($rootScope.loggedIn) {
					basketSrc = basket.items;
				}
		
				if (basketSrc) {
					try {
						basketSrc.forEach(function (item) {
							if (!basketMap.hasOwnProperty(item.name)) {
								basketMap[item.name] = {
									quantity: item.quantity,
									instructions: item.instructions
								}
							} else {
								basketMap[item.name].quantity += item.quantity;
							}
						});
					} catch (err) {
						if (!$rootScope.loggedIn && basketSrc.hasOwnProperty("items")) { //Handling async timing issue
							localStorageService.remove('basket');
						}
					}
				}
			}
			categoryOrder = $scope.landing.addPromotionCategoriesToCategoryOrder(categoryOrder, promotionCategories);
			var discountName = 'Members Promos';
			categoryOrder = $scope.landing.addMembershipDiscountToCategoryOrder(categoryOrder, products, discountName);
		
			var allProductsHash = {};
		
			const categoriesAndSubcategories = products.reduce(function(acc, product) {
				if (product.type && !acc[product.type]) {
					acc[product.type] = {};
				}
				if (product.type && product.subType && !acc[product.type][product.subType]) {
					acc[product.type][product.subType] = {};
				}
				if (product.virtualCategory && !acc[product.virtualCategory]) {
					acc[product.virtualCategory] = {};
				}
				if (product.virtualCategory && product.virtualSubCategory && !acc[product.virtualCategory][product.virtualSubCategory]) {
					acc[product.virtualCategory][product.virtualSubCategory] = {};
				}
				return acc;
			}, {});
		
			$scope.landing.initializeCategoryOrderWithAll(categoriesAndSubcategories, categoryOrder);
		
			angular.forEach(products, function(product) {
				product.loading                     = false;
				product.checked                     = false;
				product.quantity                    = 0;
				product.showRemoveBtn               = false;
				var categoryNameWithoutSpaces        = $filter('removeSpaces')(product.type);
				var subCategoryNameWithoutSpaces    = $filter('removeSpaces')(product.subType);
		
				if (product.hasOwnProperty('hasImage') === false){
					product.hasImage = true;
				}
		
				if (basket && basketMap && basketMap.hasOwnProperty(product.name)) {
					product.quantity = basketMap[product.name].quantity;
					product.instructions = basketMap[product.name].instructions;
				}
		
				allProductsHash[product.name] = product;
				allProducts.push(product);
		
				//Sorting data based on type, subType
				if (!categoryOrder.hasOwnProperty(categoryNameWithoutSpaces)
					|| !categoryOrder[categoryNameWithoutSpaces].hasOwnProperty('categories')) {
					categoryOrder[categoryNameWithoutSpaces] = {
						name            :   product.type,
						products        :   [],
						hiddenProducts	: 	[],
						tileProducts    :   [],
						nonTileProducts :   [],
						categories      :   {}
					};
				}
		
				if (!categoryOrder[categoryNameWithoutSpaces].categories.hasOwnProperty(subCategoryNameWithoutSpaces)) {
					categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
						name            :   product.subType,
						products        :   [],
						tileProducts    :   [],
						nonTileProducts :   []
					};
				}
		
				if(product.hasOwnProperty('isHidden') && product.isHidden) {
					categoryOrder[categoryNameWithoutSpaces].hiddenProducts.push(product);
				} else {
					if (!$rootScope.tableSideOrder && product.isTableSideOnly) {
						return;
					}
					if(product.hasImage) {
						categoryOrder[categoryNameWithoutSpaces].tileProducts.push(product);							
						categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);
						if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
							categoryOrder[categoryNameWithoutSpaces].categories['All'].tileProducts.push(product);
						}
					} else {
						categoryOrder[categoryNameWithoutSpaces].nonTileProducts.push(product);
						categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
						if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
							categoryOrder[categoryNameWithoutSpaces].categories['All'].nonTileProducts.push(product);
						}
					}
		
					categoryOrder[categoryNameWithoutSpaces].products.push(product);
					categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);
		
					if (product.membershipDiscount) {
						$scope.landing.addMembershipDiscountProductToCategoryOrder(categoryOrder, product, discountName);
					}
					if (product.virtualCategory) {
						$scope.landing.addPromotionProductToCategoryOrder(categoryOrder, product);
					}
					if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
						categoryOrder[categoryNameWithoutSpaces].categories['All'].products.push(product);
					}
				}
			});
		
			angular.forEach(categoryOrder, function(val, key) {
				if (!val) {
					delete categoryOrder[key];
				} else {
					// Sorting Sub Category Order if enabled in config
					if (ENV.sortSubCategoryOrder) {
						categoryOrder[key].categories = globalFunctions.sortJSONObj(categoryOrder[key].categories);
					}
		
					slides.push({
						category: key,
						title: val.name
					});
		
					// Maintaining Sub Category order if defined in config
					if (subCategoryOrder[key]) {
						var newOrder = {};

                        if (categoryOrder[key].categories['All']) {
                            newOrder['All'] =  categoryOrder[key].categories['All'];
                        }

						angular.forEach(subCategoryOrder[key], function(subVal, subKey){
							if (categoryOrder[key].categories[subKey]) {
								newOrder[subKey] = categoryOrder[key].categories[subKey];
							}
						});
                        
						categoryOrder[key].categories = Object.assign(newOrder, categoryOrder[key].categories);
					}
		
					// Filling the grid with empty tiles For Homepage
					categoryOrder[key].homePageProducts = $scope.landing.addEmptyGridTiles('homePageProducts', categoryOrder[key], $rootScope.screenWidth);
		
					if ($rootScope.tableSideOrder) {
						// Filling the grid with empty tiles for 2 column grid for Order view or Minimal Layout
						categoryOrder[key].menuProducts = $scope.landing.addEmptyGridTiles('orderPage', categoryOrder[key].products, $rootScope.screenWidth);
					}
		
					// Filling the grid with empty tiles to Show all products on Homepage
					if (ENV.showAllProducts) {
						categoryOrder[key].tileProducts = $scope.landing.addEmptyGridTiles('regular', categoryOrder[key].tileProducts, $rootScope.screenWidth);
						categoryOrder[key].nonTileProducts = $scope.landing.addEmptyGridTiles('regular', categoryOrder[key].nonTileProducts, $rootScope.screenWidth);
					}
		
					// Iterating over Sub Categories
					angular.forEach(categoryOrder[key].categories, function (val){
						if (val) {
							if (showTabularView || $rootScope.minimalProductLayout) {
								// Filling the grid with empty tiles for 2 column grid for Order view or Minimal Layout
								val.products = $scope.landing.addEmptyGridTiles('orderPage', val.products, $rootScope.screenWidth);
							}
		
							// Filling the grid with empty tiles for category pages.
							val.tileProducts = $scope.landing.addEmptyGridTiles('regular', val.tileProducts, $rootScope.screenWidth);
							val.nonTileProducts = $scope.landing.addEmptyGridTiles('regular', val.nonTileProducts, $rootScope.screenWidth);
						}
					});
				}
			});
		
			// Sorting the categories alphabetically if flag defined in config
			if (ENV.sortCategoryOrder) {
				categoryOrder = globalFunctions.sortJSONObj(categoryOrder);
			}
		
			if (categoryName) {
				if (!categoryOrder[categoryName]) {
					if (ENV.showProductsPage) {
						$location.url('/products')
					} else {
						$location.url('/order')
					}
				}
			}
		
			if (showTabularView && Object.keys(categoryOrder).length) {
				var urlCategory = $location.search().category;
				if (urlCategory) {
					categoryOrder[urlCategory].loadTab = true;
				} else {
					var firstCategory = Object.keys(categoryOrder)[0];
					$location.search('category', firstCategory);
					categoryOrder[firstCategory].loadTab = true;
				}
			}
		
			if(shortlistFlag || !$scope.landing.config.shortListLoaded || !$scope.landing.data) {
				$scope.landing.data = categoryOrder;
			} else {
				for(var cat in categoryOrder) {
					if($scope.landing.data[cat]) {
						assignExcluding($scope.landing.data[cat], categoryOrder[cat], 'homePageProducts');
					} else {
						$scope.landing.data[cat] = categoryOrder[cat];
					}
				}    
			}
		
			$rootScope.allProductsHash = allProductsHash;
			$scope.landing.allProductsHash = allProductsHash;
			$rootScope.allProducts                  = categoryOrder;
			$scope.landing.allProducts              = allProducts;
			$rootScope.productSlides = slides;
			$scope.landing.categoryCarousel.slides  = slides;
			$scope.landing.populateSubCategoryData();
		
			$scope.landing.initLocationEventListener(searchPage, productId, categoryName, showTabularView);
			void 0;
		
			if(shortlistFlag) {
				$scope.landing.config.shortListLoaded = true;
				void 0;    
			} else {
				$scope.landing.config.fullListLoaded = true;
				$rootScope.fullListLoaded = true;	
				void 0;    
			}
		},
	    getAllProducts(searchPage, productId, categoryName, showTabularView, autoReload) {

			if ($rootScope.loggedIn) {
				$rootScope.$emit('cartUpdated',true);
			}
            hsPromos.getOngoingPromotions($rootScope.currentUser);

			return hsApi.getAllProducts($rootScope.currentUser).then(function(response) {
				$scope.landing.processIntoState(response, false, searchPage, productId, categoryName, showTabularView);
			}).catch(function(err) {
				toastr.error(err.message);
				Promise.reject(err);
			});
	    },
	    getAllProductsShortlist(categoryName, showTabularView) {

			if ($rootScope.loggedIn) {
				$rootScope.$emit('cartUpdated',true);
			}
            hsPromos.getOngoingPromotions($rootScope.currentUser);

			return $timeout(function() {
				return hsApi.getAllProductsShortlist($rootScope.currentUser).then(function(response) {
					$scope.landing.processIntoState(response, true, null, null, categoryName, showTabularView);
				}).catch(function(err) {
					toastr.error(err.message);
					Promise.reject(err);
				});
			}, 0);

			
	    },
		shouldShowMasonryGrid() {
			var targetPriceList = hsMasonryGrid.getTargetPriceList();

			return hsUtils.isObject(targetPriceList) && targetPriceList.useMasonryGridLanding === true;
		},
		initProductLandingData() {
			$scope.landing.data = $rootScope.allProducts;
			$scope.landing.allProductsHash = $rootScope.allProductsHash;
			$scope.landing.allProducts = $rootScope.allProducts;
			$scope.landing.categoryCarousel.slides = $rootScope.productSlides;
			$scope.landing.populateSubCategoryData();
		},
        addPromotionCategoriesToCategoryOrder(categoryOrder, promotionCategories) {
            if (!promotionCategories || typeof promotionCategories !== 'object' || Array.isArray(promotionCategories)) return categoryOrder;
            var categoryKeys = Object.keys(categoryOrder);

            for (var categoryName of Object.keys(promotionCategories).reverse()) {
                var categoryNameWithoutSpaces = $filter('removeSpaces')(categoryName);

                categoryKeys.unshift(categoryNameWithoutSpaces);
            }
            return categoryKeys.reduce(function(acc, key) {
                acc[key] = '';
                return acc;
            }, {});
        },
        addPromotionProductToCategoryOrder(categoryOrder, product) {
            var categoryNameWithoutSpaces = $filter('removeSpaces')(product.virtualCategory);
            var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.virtualSubCategory);

            if (!categoryOrder.hasOwnProperty(categoryNameWithoutSpaces) || !categoryOrder[categoryNameWithoutSpaces].hasOwnProperty('categories')) {
                categoryOrder[categoryNameWithoutSpaces] = {
                    name: product.virtualCategory,
                    products: [],
                    tileProducts: [],
                    nonTileProducts: [],
                    categories: {},
                };
            }
            if (!categoryOrder[categoryNameWithoutSpaces].categories.hasOwnProperty(subCategoryNameWithoutSpaces)) {
                categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
                    name: product.virtualSubCategory,
                    products: [],
                    tileProducts: [],
                    nonTileProducts: [],
                };
            }
            if (product.hasImage) {
                categoryOrder[categoryNameWithoutSpaces].tileProducts.push(product);
                categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);
                if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
                    categoryOrder[categoryNameWithoutSpaces].categories['All'].tileProducts.push(product);
                }
            } else {
                categoryOrder[categoryNameWithoutSpaces].nonTileProducts.push(product);
                categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
                if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
                    categoryOrder[categoryNameWithoutSpaces].categories['All'].nonTileProducts.push(product);
                }
            }
            if (categoryOrder[categoryNameWithoutSpaces].categories['All']) {
                categoryOrder[categoryNameWithoutSpaces].categories['All'].products.push(product);
            }
            categoryOrder[categoryNameWithoutSpaces].products.push(product);
            categoryOrder[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);
        },
		fetchProduct(productName) {

			$http.get(ENV.apiEndPoint+'/product?name='+productName).then(function(response) {
				if (response.status === 404) {
					$location.url('/404');
				}
				$scope.landing.selectedProduct = response.data;
				var product = $scope.landing.selectedProduct;
				if (product.isContainer) {
					product.orderingOptions.forEach(function (item) {
						item.error = "";
						item.choices.forEach(function(choice){
							choice.checked = choice.name === item.defaultChoice;
						});
					});
				}

				if (product.hasModifiers) {
					product.modifiers.forEach(function (item) {
						item.error = "";
						item.options.forEach(function(choice){
							choice.modifierDisplayName = item.displayName;
							choice.checked = choice.name === item.defaultOption;
						});
					});
				}

				$scope.landing.config.categoryUrl = $filter('removeSpaces')(product.type);
				$scope.landing.config.updateSEOdata(
					product.displayName + ' | '+ ENV.name.companyName,
					product.displayName,
					('Order ' + product.displayName +' at '+ ENV.name.companyName + '.'),
					($scope.landing.config.imageBaseUrl + product.name + '.jpg')
				);
				if (!$rootScope.allProducts || !Object.keys($rootScope.allProducts).length) {
					$scope.landing.getAllProducts(false, productName).then(function() {
						$scope.landing.setPageFullyLoaded();
					});
				} else {
					$scope.landing.data = $rootScope.allProducts;
					$scope.landing.setPageFullyLoaded();
				}
			});
		},
        addMembershipDiscountToCategoryOrder(categoryOrder, products, discountName) {
            var categoryKeys = Object.keys(categoryOrder);
            var discountNameWithoutSpaces = $filter('removeSpaces')(discountName);

            for (var product of products) {
                if (product.membershipDiscount && !product.isHidden) {
                    categoryKeys.unshift(discountNameWithoutSpaces);
                    break;
                }
            }
            return categoryKeys.reduce(function(acc, key) {
                acc[key] = '';
                return acc;
            }, {});
        },
        addMembershipDiscountProductToCategoryOrder(categoryOrder, product, discountName) {
            var discountNameWithoutSpaces = $filter('removeSpaces')(discountName);

            if (!categoryOrder.hasOwnProperty(discountNameWithoutSpaces) || !categoryOrder[discountNameWithoutSpaces].hasOwnProperty('categories')) {
                categoryOrder[discountNameWithoutSpaces] = {
                    name: discountName,
                    products: [],
                    tileProducts: [],
                    nonTileProducts: [],
                    categories: {},
                };
                categoryOrder[discountNameWithoutSpaces].categories[discountNameWithoutSpaces] = {
                    name: discountName,
                    products: [],
                    tileProducts: [],
                    nonTileProducts: [],
                };
            }
            if (product.hasImage) {
                categoryOrder[discountNameWithoutSpaces].tileProducts.push(product);
                categoryOrder[discountNameWithoutSpaces].categories[discountNameWithoutSpaces].tileProducts.push(product);
            } else {
                categoryOrder[discountNameWithoutSpaces].nonTileProducts.push(product);
                categoryOrder[discountNameWithoutSpaces].categories[discountNameWithoutSpaces].nonTileProducts.push(product);
            }
            categoryOrder[discountNameWithoutSpaces].products.push(product);
            categoryOrder[discountNameWithoutSpaces].categories[discountNameWithoutSpaces].products.push(product);
        },
		initializeCategoryOrderWithAll(data, categoryOrder) {
			Object.keys(data).forEach(function(categoryName) {
				if (Object.keys(data[categoryName]).length > 1) {
					categoryOrder[$filter('removeSpaces')(categoryName)] = {
						name            :   categoryName,
						products        :   [],
						hiddenProducts	: 	[],
						tileProducts    :   [],
						nonTileProducts :   [],
						'categories': {
							'All': {
								name: 'All',
								products: [],
								tileProducts: [],
								nonTileProducts: []
							}
						}
					}
				}
			});
		},
		handleAddProduct(item) {
			if (hsUtils.isObject(item)) {
				$scope.landing.addedItemFromSearch = true;
			}
		},
		processSearchGAEvent() {
			var searchTerms = new URLSearchParams($location.search()).toString();
			var previousSearchTerm = localStorageService.get('searchQuery');
			var gaEventCategory = aiSearchEvents.getEventCategory();
			if (searchTerms !== previousSearchTerm) {
				if (previousSearchTerm && !$scope.landing.addedItemFromSearch) {
					aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.UNSUCCESSFUL_SEARCH, previousSearchTerm);
				}

				aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.QUERY, searchTerms);
				localStorageService.set('searchQuery', searchTerms);
				$scope.landing.addedItemFromSearch = false;
			}
		},
		processSearch(filters) {

			$scope.landing.config.searching = true;
			$scope.landing.processSearchGAEvent();

			if($scope.landing.config.fullListLoaded) {
				$scope.landing.setPageFullyLoaded();
				var ret = _processSearch(filters);
				return ret;
			} else {
				return $scope.landing.getAllProducts()
				.then(function() { 
					$scope.landing.setPageFullyLoaded();
					return _processSearch(filters);
				});
			}

			function _processSearch(filters) {

				void 0;

				var searchResults = {
					resultsAfterFilters: false,
					departmentFilter: false,
					brandNames: [],
					healthClaims: [],
					allProducts: [],
					categories: [],
					sanitizedCategories: {},
					results: {}
				};

				if (filters && filters.healthClaims && Array.isArray(filters.healthClaims) && filters.healthClaims.length) {
					filters.healthClaims = filters.healthClaims.filter(function(healthClaim) {
						return ($scope.landing.filters && $scope.landing.filters.healthClaims && $scope.landing.filters.healthClaims.displayMap && $scope.landing.filters.healthClaims.displayMap[healthClaim]) || $rootScope.healthClaimsByDisplayName[healthClaim];
					}).map(function(healthClaim) {
						if ($rootScope.healthClaimsByDisplayName[healthClaim]) {
							return $rootScope.healthClaimsByDisplayName[healthClaim].key;
						} else {
							return $scope.landing.filters.healthClaims.displayMap[healthClaim]
						}
					});
				}

				if ($scope.landing.searchedQuery || filters) {
					return hsSearch.search($scope.landing.searchedQuery, filters, null, null, null, false, true)
					.then(function(data) {
						var healthClaims = data.healthClaims;
						$scope.landing.filterHandlers.createHealthClaimsMap(healthClaims);
						var originalData = data.results[0] ? data.results[0] : [];
						var filteredProducts = originalData.slice();

						var categoriesParam = hsSearch.getQueryParamAsArray('categories');
						var subcategoriesParam = hsSearch.getQueryParamAsArray('subcategories');
						var healthClaimsParam = hsSearch.getQueryParamAsArray('healthClaims');
						var searchFilters = {
							organic: healthClaimsParam.includes('Organic'),
							categories: categoriesParam[0],
							subcategories: subcategoriesParam[0]
						};

						if (ENV.isRestaurant) {
							searchResults.results = globalFunctions.restaurantSearch(
								filteredProducts,
								searchResults.results,
								searchFilters.organic,
								searchFilters.categories,
								searchFilters.subcategories
							);
						} else {
							searchResults.results = globalFunctions.allProductSearch(
								filteredProducts,
								searchResults.results,
								searchFilters.organic,
								searchFilters.categories,
								searchFilters.subcategories
							);
						}

						var categoryOrder = JSON.parse(JSON.stringify($scope.landing.config.categoryOrder));
						angular.forEach(searchResults.results, function(val, key) {
							// Generating sidebar search menu for departments
							categoryOrder[key] = {
								key: key,
								name: val.name,
								categories: getSortedSubCategories(val, key),
							};
						});
						searchResults.categories = Object.keys(categoryOrder).filter(function(categoryKey) {
							return categoryOrder[categoryKey];
						}).map(function(categoryKey) {
							return categoryOrder[categoryKey];
						});
						if (ENV.sortCategoryOrder) {
							searchResults.categories.sort(function(a, b) {
								if (a.key < b.key) return -1;
								if (a.key > b.key) return 1;
								return 0;
							});
						}

						function sanitizeCategories(categories) {
							return categories.reduce(function(acc, category) {
								var subcategories = category.categories.reduce(function(subAcc, subcategory) {
									subAcc[subcategory.name] = subcategory.categories || true;
									return subAcc;
								}, {});
								acc[category.name] = subcategories || true;
								return acc;
							}, {});
						}
						searchResults.sanitizedCategories = sanitizeCategories(searchResults.categories);

						function toTitleCase(str) {
							return str.trim().split(/\s+/).map(function(word) {
								if (word) {
									return word[0].toUpperCase() + word.substr(1).toLowerCase();
								}
							}).join(' ');
						}
						searchResults.brandNames = Object.keys(filteredProducts.reduce(function(acc, product) {
							if (product.brand) {
								acc[toTitleCase(product.brand)] = true;
							}
							return acc;
						}, {}));
						searchResults.brandNames = globalFunctions.alphabeticalSort(searchResults.brandNames);

						if (typeof healthClaims === 'object' && Object.keys(healthClaims).length) {
							var healthClaimsList = [];
							Object.keys(healthClaims).forEach(function(healthClaim) {
								if (!healthClaims[healthClaim].disable && !healthClaims[healthClaim].hide) {
									healthClaimsList.push(healthClaims[healthClaim].displayName);
								}
							});
							searchResults.healthClaims = healthClaimsList;
						}
						
						var gridType = $scope.landing.config.showTabularView ? 'orderPage' : 'regular';
						searchResults.allProducts = globalFunctions.addEmptyGridTiles(gridType, filteredProducts, $rootScope.screenWidth);
						searchResults.selectedProducts = searchResults.allProducts.slice(0, 20);
						searchResults.resultsAfterFilters = searchResults.categories.length > 0;
						$scope.landing.foundResults = originalData.length > 0;
						if (searchFilters.categories) {
							searchResults.departmentFilter = true;
						}
						$scope.landing.filters['categories'].data = searchResults.sanitizedCategories;
						$scope.landing.filters['brands'].data = searchResults.brandNames;
						$scope.landing.filters['healthClaims'].data = searchResults.healthClaims;
						$scope.landing.filters = Object.assign({}, $scope.landing.filters);
						$scope.landing.searchData = searchResults;
						void 0;
						return Promise.resolve();
					})
					.catch(function(err) {
						void 0;
					}).finally(function() {
						$scope.landing.filterHandlers.refreshShopByDietState(filters);
						$scope.landing.config.searching = false;
						void 0;
					});

					function getSortedSubCategories(sourceCategory, key) {
						var subCategoryOrder = JSON.parse(JSON.stringify($scope.landing.config.subCategoryOrder));
						var newSubCategoryOrder = {};

						if (subCategoryOrder[key]) {
							Object.assign(newSubCategoryOrder, subCategoryOrder[key]);
						}
						Object.keys(sourceCategory.categories).forEach(function(category) {
							newSubCategoryOrder[category] = {
								key: category,
								name: sourceCategory.categories[category].name
							};
						});
						newSubCategoryOrder = Object.keys(newSubCategoryOrder).filter(function(subCategoryKey) {
							return newSubCategoryOrder[subCategoryKey];
						}).map(function(subCategoryKey) {
							return newSubCategoryOrder[subCategoryKey];
						});

						if (ENV.sortSubCategoryOrder) {
							newSubCategoryOrder.sort(function(a, b) {
								if (a.key < b.key) return -1;
								if (a.key > b.key) return 1;
								return 0;
							});
						}
						return newSubCategoryOrder;
					}
				} else {
					return Promise.reject();
				}
			}

		},
	    searchLoadMore() {
        	if (this.searchData.selectedProducts.length < this.searchData.allProducts.length) {
		        this.searching = true;
        	    var length = $scope.landing.searchData.selectedProducts.length;
        	    var maxLength = length + $scope.landing.searchThreshold;
        	    if (maxLength > $scope.landing.searchData.allProducts.length) {
        	    	maxLength = $scope.landing.searchData.allProducts.length;
	            }
        	    for (var i = length; i < maxLength; i++) {
        	    	if ($scope.landing.searchData.allProducts[i]) {
		                $scope.landing.searchData.selectedProducts.push($scope.landing.searchData.allProducts[i]);
		            }
	            }

        	    this.searching = false;
        	}
	    },
        subCategoryLoadMore(productType) {
            if (!['tileProducts', 'nonTileProducts'].includes(productType)) return;

            var data = $scope.landing.data[$scope.landing.config.selectedCategory]
                .categories[$scope.landing.config.selectedSubCategory][productType];

            if ($scope.landing.subCategoryData[productType].length < data.length) {
                var length = $scope.landing.subCategoryData[productType].length;
                var maxLength = length + $scope.landing.searchThreshold;
                if (maxLength > data.length) {
                    maxLength = data.length;
                }
                for (var i = length; i < maxLength; i++) {
                    if (data[i]) {
                        $scope.landing.subCategoryData[productType].push(data[i]);
                    }
                }
            }
        },
        populateSubCategoryData: function () {
            if ($scope.landing.config.selectedCategory && $scope.landing.data[$scope.landing.config.selectedCategory]) {
                if (!$scope.landing.config.selectedSubCategory) {
                    var categories = Object.keys($scope.landing.data[$scope.landing.config.selectedCategory].categories);
                    $scope.landing.config.selectedSubCategory = categories[0];
            	}
                $scope.landing.subCategoryData.tileProducts = $scope.landing.data[$scope.landing.config.selectedCategory]
                    .categories[$scope.landing.config.selectedSubCategory].tileProducts.slice(0, 20);
                $scope.landing.subCategoryData.nonTileProducts = $scope.landing.data[$scope.landing.config.selectedCategory]
                    .categories[$scope.landing.config.selectedSubCategory].nonTileProducts.slice(0, 20);
            }
        },
        initWithDirectLinkingQueryParams: function() {
            var directLinkingQueryParams = hsMarketingService.getDirectLinkingQueryParams();

            if (directLinkingQueryParams && directLinkingQueryParams.locName) {
                return hsApi.getLocationsV2().then(function(locations) {
                    var locationObj = {
                        allLocations: locations,
                    };
                    var locName = directLinkingQueryParams.locName;
                    var pListName = directLinkingQueryParams.pListName;
                    var locFound = false;
                    var selectedPriceList;
                    for (var loc of locations) {
                        if (locName && hsMarketingService.isMatchingLocation(locName, loc)) {
                            locationObj.selectedLocation = loc;
                            locFound = true;
                            
                            if (ENV.enablePriceList && pListName) {
                                for (var priceList of loc.priceLists) {
                                    if (hsMarketingService.isMatchingPriceList(pListName, priceList)) {
                                        selectedPriceList = priceList;
                                        break;
                                    }
                                }
                            } 

                            if (selectedPriceList) {
                                break;
                            }
                        }
                    }
                    
                    if (locFound) {
                        localStorageService.set('location', locationObj);
                        if (!ENV.enablePriceList) {
                            hsMarketingService.clearDirectLinkingQueryParams();
                            sessionStorage.setItem('hs_session', new Date());
                            $rootScope.$broadcast('locationUpdated');
                            return Promise.resolve();
                        }
                    } else {
                        localStorageService.remove('location');
                        localStorageService.remove('selectedPriceList');
                        $rootScope.location = null;
                        $rootScope.selectedPriceList = null;
                        hsMarketingService.clearDirectLinkingQueryParams();
                        return Promise.reject();
                    }
                    
                    if (selectedPriceList) {
                        localStorageService.set('selectedPriceList', selectedPriceList);
                        sessionStorage.setItem('hs_session', new Date());
                        hsMarketingService.clearDirectLinkingQueryParams();
                        $scope.landing.disablePriceListSelector();
                        $rootScope.$broadcast('locationUpdated');
                    } else {
                        localStorageService.remove('selectedPriceList');
                        return ngDialog.open({
                            template        : 'partials/popup/select-location.html',
                            controller      : 'ModalController',
                            className       : 'ngdialog-theme-default email-capture',
                            showClose       : false,
                            closeByDocument : false,
                            closeByEscape   : false,
                            closeByNavigation: true,
                            scope           : $scope,
                            name            : 'location',
                            id              : 'location'
                        }).closePromise.then(function() {
                            $scope.landing.disablePriceListSelector();
                            hsMarketingService.clearDirectLinkingQueryParams();
                            $rootScope.$broadcast('locationUpdated');
                        })
                    }
                });
            } else {
                return Promise.resolve();
            }
        },
        initShopLanding(categoryPage) {
			$scope.landing.initScrollAnimationMobile();
			$scope.landing.initScrollAnimationTablet();
            var category = $routeParams.category;
            var subCategory = $routeParams.subcategory;

			this.config.selectedCategory = category;
			this.config.selectedSubCategory = subCategory;

	        if (categoryPage) {
		        $scope.landing.config.updateSEOdata(
			        category + ' | '+ ENV.name.companyName +' - '+ ENV.name.tagline,
			        category,
			        ('Order ' + category +' at '+ ENV.name.companyName)
			        // $scope.landing.config.allProducts.categories[category].seoImage
		        );
		        $document.ready(function(event){
			        $document.bind('scroll', function(){
				        var windowTop   = $(window).scrollTop() + 10;
				        var selectedDiv = $('#all-categories');

				        if(selectedDiv && selectedDiv.offset()){
					        var divTop      = selectedDiv.offset().top + 50;
					        if(windowTop >= divTop){
						        $('#all-categories-fixed').css({
							        display: 'block',
							        opacity: 1
						        });
								$timeout(function() {
									$scope.landing.showMainSearchBar = false;
								}, 0);
					        } else if(windowTop < divTop){
						        $('#all-categories-fixed').css({
							        display: 'none',
							        opacity:0
						        });
								$timeout(function() {
									if (!$rootScope.screenWidth.xs) {
										$scope.landing.showMainSearchBar = true;
									}
								}, 0);
					        }
				        }
			        });

			        var getAllProducts = setInterval(function(){ $scope.landing.getAllProducts(false, false, category, false); },3.6e+6);
			        $rootScope.$on( "$routeChangeStart", function(event, next, current) {
				        //..do something  //if you don't want event to bubble up
				        clearInterval(getAllProducts);
			        });
		        });
		        $scope.$on('$destroy', function() {
			        $document.unbind('scroll');
		        });

	        } else {
		        $scope.landing.config.updateSEOdata(
			        subCategory + ' | '+ ENV.name.companyName +' - '+ ENV.name.tagline,
			        subCategory,
			        ('Get ' + subCategory +' delivered to your doorstep today, with '+ ENV.name.companyName +'\'s free same day grocery delivery. Organic, Local & Cheaper Than Grocery Stores.'),
			        $scope.landing.config.allProducts.categories[category].seoImage
		        );
	        }

			var location = localStorageService.get('location');
			var selectedPriceList = localStorageService.get('selectedPriceList');

	        if (ENV.enableLocations) {

                // if has locName, should attempt to get locations either from localStorage or via an API call
                var directLinkingQueryParams = hsMarketingService.getDirectLinkingQueryParams();

                if (directLinkingQueryParams && directLinkingQueryParams.locName) {
                    return $scope.landing.initWithDirectLinkingQueryParams()
                        .then(function() {
                            $scope.landing.checkProductData(category);

                            var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
                                event.preventDefault();
                                $scope.landing.loadLocationsPopup(false, false, function (value) {
                                    sessionStorage.setItem('hs_session', new Date());
                                    $scope.landing.checkProductData(category, true);
                                });
                            });

                            $scope.$on('$destroy', function() {
                                sessionExpired();
                            });
                        }).catch(function(error) {
                            void 0;
                            return $scope.landing.initShopLanding(category);
                        });
                }


		        if (!$rootScope.tableSideOrder && (!$location.search().location && (!location || !location.hasOwnProperty('allLocations')) || $rootScope.showPriceListSelector)) {
			        ngDialog.open({
				        template        : 'partials/popup/select-location.html',
				        controller      : 'ModalController',
				        className       : 'ngdialog-theme-default email-capture',
				        showClose       : false,
				        closeByDocument : false,
				        closeByEscape   : false,
				        closeByNavigation: true,
				        scope           : $scope,
				        preCloseCallback: function(){
							$scope.landing.disablePriceListSelector();
							$rootScope.$broadcast('locationUpdated');
				        	$scope.landing.checkProductData(category, true);
				        },
				        name            : 'location',
				        id              : 'location'
			        });
                } else {
			        $scope.landing.checkProductData(category);
		        }

		        if (ENV.enablePriceList) {
			        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				        event.preventDefault();
				        $scope.landing.loadLocationsPopup(false, false, function (value) {
					        sessionStorage.setItem('hs_session', new Date());
					        $scope.landing.checkProductData(category, true);
				        });
			        });

			        $scope.$on('$destroy', function() {
				        sessionExpired();
			        });
		        }
	        } else if (ENV.enablePriceList) {
		        if ($rootScope.showPriceListSelector || !selectedPriceList) {
			        $scope.searchPage = false;
			        $scope.runUpdate = false;
			        ngDialog.open({
				        template        : 'partials/popup/select-price-list.html',
				        controller      : 'ModalController',
				        className       : 'ngdialog-theme-default email-capture',
				        showClose       : false,
				        closeByDocument : false,
				        closeByEscape   : false,
				        scope           : $scope,
				        name            : 'location',
				        id              : 'location',
					    preCloseCallback : function() {
							$scope.landing.disablePriceListSelector();
							$rootScope.$broadcast('priceListUpdated');
			                $scope.landing.checkProductData(category);
					    }
			        });
		        } else {
			        $scope.landing.checkProductData(category);
		        }

		        var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
			        event.preventDefault();
			        $scope.landing.loadLocationsPopup(false, false, function (value) {
			        	sessionStorage.setItem('hs_session', new Date());
				        $scope.landing.checkProductData(category, true);
			        });
		        });

		        $scope.$on('$destroy', function() {
			        sessionExpired();
		        });
	        } else {
		        $scope.landing.checkProductData(category);
            }
        },
	    checkProductLandingData(searchPage, showTabularView, productId, categoryName) {
			$rootScope.shopByDietApplied = false;
			var onReadyCalled = false;
			if ($rootScope.allProducts && Object.keys($rootScope.allProducts).length) {
				$scope.landing.initLocationEventListener(searchPage, productId, categoryName, showTabularView);
				$scope.landing.filterStates.hasProductsWithHealthClaims =
						$rootScope.allProductsHash
						&& Object.keys($rootScope.allProductsHash)
						&& $scope.landing.filterHandlers.getProductsWithHealthClaims(Object.values($rootScope.allProductsHash)).length;
				$scope.landing.filterHandlers.initHealthClaimsFilterData();
				if (searchPage) {
					var searchParams = hsSearch.resolveSearchURL(false);
					return $scope.landing.processSearch(searchParams).then(function() {
						$scope.landing.setPageFullyLoaded();
					});
				} else {
					$scope.landing.initProductLandingData();
                    
                    // Intentional delay to smooth out the UI
                    setTimeout(function() {
                        $scope.landing.config.searching = false;
                        $scope.landing.setPageFullyLoaded();
                        $scope.$apply();
                    }, 250);
				}
			} else {
				$scope.landing.initLandingPage(searchPage, showTabularView, productId, categoryName).then(function() {
					$scope.landing.filterStates.hasProductsWithHealthClaims =
						$rootScope.allProductsHash
						&& Object.keys($rootScope.allProductsHash)
						&& $scope.landing.filterHandlers.getProductsWithHealthClaims(Object.values($rootScope.allProductsHash)).length;
					$scope.landing.filterHandlers.initHealthClaimsFilterData();
					if (searchPage) {
						var searchParams = hsSearch.resolveSearchURL(false);
						return $scope.landing.processSearch(searchParams).then(function() {
							$scope.landing.setPageFullyLoaded();
						});
					} else {
						$scope.landing.config.searching = false;
						$scope.landing.setPageFullyLoaded();
					}
				});
			}

			onReady();

			function onReady() {
				if (onReadyCalled) {
                    return;
                }

                onReadyCalled = true;
				$document.ready(function(event){
                    $document.bind('scroll', function(){
                        var windowTop   = $(window).scrollTop() + 10;
                        var selectedDiv = $('#all-categories');
    
                        if(selectedDiv && selectedDiv.offset()){
                            var divTop      = selectedDiv.offset().top + 50;
                            if (windowTop >= divTop) {
                                $('#all-categories-fixed').css({
                                    display: 'block',
                                    opacity: 1
                                });
								$timeout(function() {
									$scope.landing.showMainSearchBar = false;
								}, 0);
                            } else if (windowTop < divTop) {
                                $('#all-categories-fixed').css({
                                    display: 'none',
                                    opacity: 0
                                });
								$timeout(function() {
									if (!$rootScope.screenWidth.xs) {
										$scope.landing.showMainSearchBar = true;
									}
								}, 0);
                            }
                        }
                    });

					$scope.$on('$destroy', function() {
						$document.unbind('scroll');
					});
				});
			}
	    },
	    checkProductData(category, forceReload) {
		    if (!$rootScope.allProducts 
				|| !Object.keys($rootScope.allProducts).length 
				|| forceReload 
				|| !$scope.landing.config.fullListLoaded
			) {
			    $scope.landing.getAllProducts(false, false, category).then(function() {
					$scope.landing.config.searching = false;
					$scope.landing.setPageFullyLoaded();
				});
		    } else {
				$scope.landing.initProductLandingData();
			    $scope.landing.initLocationEventListener(false, null, category, false);
			    $scope.landing.populateSubCategoryData(category);
				$scope.landing.setPageFullyLoaded();
		    }
	    },
        initReferLanding() {
            if(!$rootScope.loggedIn){
            	$location.url('/login/?redirect='+$location.url());
            	return;
            }

	        $scope.landing.config.updateSEOdata(
		        'Invite Friends to Homesome - Groceries just became awesome',
		        'Invite a Friend',
		        ('Invite your friend and they will get $10 off $35 and you will too.')
	        );

            hsAuth.getReferCode()
            .then(function(response){
            	void 0;
            	if(response.status === 200){
	            	void 0;
	            	$scope.landing.referral= {
	            		code    : response.data.referralCode,
			            urlLink : "mailto:?subject=Here's $10 Grocery Coupon!&body=Hey, Sign Up for Homesome, www.gethomesome.com using invitation code "+ response.data.referralCode +" and you will receive $10 off groceries."
	            	};
	            }else{
            	    void 0;
	            }
                $scope.landing.setPageFullyLoaded();
            })
            .catch(function(response){
				void 0;
            });
        },
	    showAddCustomItemDialog() {
		    ngDialog.open({
			    template    : 'partials/popup/custom-item-popup.html',
			    controller  : 'ModalController',
			    className   : 'ngdialog-theme-default email-capture',
			    scope       : $scope
		    });
	    },
        showMembershipForm: function(renew) {
            var $newScope = $scope.$new(true);
            $newScope.renew = renew;

            ngDialog.open({
                template: '<div><erewhon-membership-popup '
                    + 'on-close="closeThisDialog()" '
                    + 'renew="renew" '
                    + '></erewhon-membership-popup></div>',
                className: 'ngdialog-theme-default ngdialog-theme-erewhon',
                plain: true,
                scope: $newScope,
            }).closePromise
                .then(function(data) {
                    if (data.value && data.value === 'success') {
                        $route.reload();
                    }
                })
                .catch(function(err) {
                    void 0;
                });
        },
		updateChoiceSelection(optionObj, choiceObj, isCheckbox) {
			angular.forEach(optionObj.choices, function (choice) {
				if(isCheckbox){
					if(choice.name === choiceObj.name) {
						choice.checked = !choice.checked;
					}
				}else{
					if(choice.name === choiceObj.name){
						if (optionObj.selectionRequired) {
							choice.checked = true;
						} else {
							choice.checked = !choice.checked;
						}
					}else{
						if(optionObj.singleSelection){
							choice.checked = false;
						}
					}
				}
			});
		},
		updateOptionSelection(optionObj, choiceObj, isCheckbox) {
			angular.forEach(optionObj.options, function (choice) {
				if(isCheckbox){
					if(choice.name === choiceObj.name) {
						choice.checked = !choice.checked;
					}
				}else{
					if(choice.name === choiceObj.name){
						if (optionObj.selectionRequired) {
							choice.checked = true;
						} else {
							choice.checked = !choice.checked;
						}
					}else{
						if(optionObj.singleSelection){
							choice.checked = false;
						}
					}
				}
			});
	   	},
		calculateAvailableTimeString : function (productObj) {
			return hsCart.calculateAvailableTimeString(productObj, 'product')
		},
        showAvailableTimes(product) {
            var $availableTimesScope = $scope.$new(true);
            $availableTimesScope.product = product;

            ngDialog.open({
                template: '<div><available-times '
                    + 'product="product">'
                    + '</available-times></div>',
                scope: $availableTimesScope,
                plain: true,
                closeByDocument: true,
                closeByNavigation: true,
            });
	    },
        shouldShowMembershipDiscount() {
            return hsPromos.shouldShowMembershipDiscount($scope.landing.selectedProduct, $scope.landing.selectedProduct.promotion);
        },
        shouldShowUnit: function () {
            if ($scope.landing.shouldShowMembershipDiscount() || ENV.hideItemUnit) return false;
            if ($scope.landing.selectedProduct && $scope.landing.selectedProduct.promotion
                && $scope.landing.selectedProduct.promotion.type === hsPromos.types.FREE_ITEM
            ) {
                return false;
            }

            return true;
        },
		showCategorySeperator: function(category) {
			if (!$scope.landing.data) return false;
			var categories = Object.keys($scope.landing.data);
			var lastCategory = categories[categories.length - 1];
			return lastCategory !== category && (!$rootScope.screenWidth.xs || ENV.showAllProducts);
		}
    };
}]);

function assignExcluding(target, source, exclude) {
	for(var k in source) {
		if(k != exclude) target[k] = source[k];
	}
}

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('locationCtrl', [
    '$scope', '$rootScope','$route','$location','$http','globalFunctions','OpenGraphTags','ENV','$sce','$q','scrollToElement','$routeParams','$filter','allProducts','$window','ngDialog','$interval','hsCart', 'hsAuth','$document','toastr','NgMap','haversine','localStorageService',
    function($scope, $rootScope, $route, $location,$http,globalFunctions,OpenGraphTags,ENV,$sce,$q,scrollToElement,$routeParams,$filter, allProducts, $window, ngDialog, $interval, hsCart, hsAuth, $document, toastr, NgMap, haversine, localStorageService){
    
    void 0;
    
    
    $scope.location = {
        config              : {
        	pageFullyLoaded         : false,
        	allProducts             : allProducts,
	        numberOfProducts        : 12,
	        categoryLimit           : 4,
	        message                 : '',
	        messageClass            : '',
	        buttonLoading           : false
        },
	    mapSrc              : '',
	    outOfAreaMessage    : '',
	    radius              : 50,
	    loading             : false,
	    data                : {
        	origin           : {
        		lat : '',
		        lng : ''
	        },
		    allLocations     : [],
		    map              : '',
		    infoWindow       : '',
		    service          : '',
		    markers          : [],
		    locations        : [],
		    outsideLocations : [],
		    locationSelect   : ''
	    },
	    contactData         : {
        	fullAddress         : '',
		    formattedAddress    : '',
		    name                : '',
		    phone               : '',
		    email               : '',
		    operatingHours      : {},
	    },
	    initContactPage     : function () {
		    void 0;

            var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
                event.stopPropagation();
                $route.reload();
            });

            $scope.$on('$destroy', function() {
                LocationEventListener();
            });

		    var location = localStorageService.get('location');
			
		    if(ENV.enableLocations){
		    	if(location && location.hasOwnProperty('selectedLocation') && location.hasOwnProperty('allLocations')) {
				    $scope.location.contactData = {
					    fullAddress         : '',
					    formattedAddress    : '',
                        formattedAddressLine1: '',
                        formattedAddressLine2: '',
					    name                : location.selectedLocation.name,
					    phone               : location.selectedLocation.phone,
					    email               : location.selectedLocation.email,
					    operatingHours      : location.selectedLocation.operatingHours,
					    isVirtual           : location.selectedLocation.isVirtual
				    };
				    
				    if(location.selectedLocation.address.street){
					    $scope.location.contactData.fullAddress = location.selectedLocation.address.street +' '+ location.selectedLocation.address.aptUnit + ' ' + location.selectedLocation.address.city +' '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip;
					
                        $scope.location.contactData.formattedAddressLine1 = location.selectedLocation.address.street + ' ' + location.selectedLocation.address.aptUnit;
                        $scope.location.contactData.formattedAddressLine2 = location.selectedLocation.address.city + ', ' + location.selectedLocation.address.state + ' ' + location.selectedLocation.address.zip;
					    $scope.location.contactData.formattedAddress = location.selectedLocation.address.street +', '+ (location.selectedLocation.address.aptUnit?location.selectedLocation.address.aptUnit + ', ' : '') + location.selectedLocation.address.city +', '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip;
				    }else{
				    	void 0;
				    	$scope.location.contactData.fullAddress = location.selectedLocation.address;
				    	$scope.location.contactData.formattedAddress = location.selectedLocation.address;
				    }

				    if (location.selectedLocation.isVirtual) {
					    $location.url('/products');
					    return;
				    }

			    } else {
				    $scope.runUpdate = false;
				    $scope.updateContactPage = true;
				
				    ngDialog.open({
					    template        : 'partials/popup/select-location.html',
					    controller      : 'ModalController',
					    className       : 'ngdialog-theme-default email-capture',
					    showClose       : false,
					    closeByDocument : false,
					    closeByEscape   : false,
					    closeByNavigation: true,
					    scope           : $scope,
					    name            : 'location',
					    id              : 'location'
				    });
			    }

			    if (ENV.enablePriceList) {
				    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				    	event.preventDefault();
					    $scope.location.loadLocationsPopup(false, false, function (event) {
						    sessionStorage.setItem('hs_session', new Date());
						    $route.reload();
					    });
				    });

				    $scope.$on('$destroy', function() {
					    sessionExpired();
				    });
			    }

		    } else {
			    if(location){
			    	void 0;
				    $scope.location.contactData = {
					    fullAddress     : location.selectedLocation.address.street +' '+ location.selectedLocation.address.aptUnit + ' ' + location.selectedLocation.address.city +' '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip,
					    formattedAddress     : location.selectedLocation.address.street +', '+ (location.selectedLocation.address.aptUnit?location.selectedLocation.address.aptUnit + ', ' : '') + location.selectedLocation.address.city +', '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip,
					    name            : location.selectedLocation.name,
					    phone           : location.selectedLocation.phone,
					    email           : location.selectedLocation.email,
					    operatingHours  : location.selectedLocation.operatingHours,
					    isVirtual       : location.selectedLocation.isVirtual
				    };


				    if (location.selectedLocation.isVirtual) {
					    $location.url('/products');
					    return;
				    }

                } else {
				    $http.get(ENV.apiEndPoint + '/locations')
				    .then(function(res){
					    void 0;
					    if(res.status === 200){
					    	void 0;
					    	var locationData = {
					    		allLocations     : [],
					    		selectedLocation : res.data[0]
						    };
					    	
					    	localStorageService.set('location', locationData);
						
						    $scope.location.contactData = {
							    fullAddress     : locationData.selectedLocation.address.street +' '+ locationData.selectedLocation.address.aptUnit + ' ' + locationData.selectedLocation.address.city +' '+ locationData.selectedLocation.address.state +' '+ locationData.selectedLocation.address.zip,
							    formattedAddress     : locationData.selectedLocation.address.street +', '+ (locationData.selectedLocation.address.aptUnit !== '' ?locationData.selectedLocation.address.aptUnit + ', ' : ' ') + locationData.selectedLocation.address.city +', '+ locationData.selectedLocation.address.state +', '+ locationData.selectedLocation.address.zip,
							    name            : locationData.selectedLocation.name,
							    phone           : locationData.selectedLocation.phone,
							    email           : locationData.selectedLocation.email,
							    operatingHours  : locationData.selectedLocation.operatingHours,
							    isVirtual       : locationData.selectedLocation.isVirtual
						    };

						    if (locationData.selectedLocation.isVirtual) {
							    $location.url('/products');
							    return;
						    }

					    }else{
					    	toastr.error('Something went wrong. Please try again.');
					    }
				    });
                }
		    }

		    NgMap.getMap().then(function(map){
			    $scope.location.data.map = map;
		    });

		    setTimeout(function(){
			    $scope.location.config.pageFullyLoaded = true;
			    $scope.$apply();
		    }, 100);
	    },
	    initAboutPage       : function () {
        	void 0;
        	if(ENV.hideAboutPage) {
        		$location.url('/products');
        		return;
	        }

            var LocationEventListener = $rootScope.$on('locationUpdated', function(event, data) {
                event.stopPropagation();
                $route.reload();
            });

            $scope.$on('$destroy', function() {
                LocationEventListener();
            });

		    var location = localStorageService.get('location');

		    if(ENV.enableLocations){
		    	if(location && location.hasOwnProperty('selectedLocation') && location.hasOwnProperty('allLocations')) {
				    $scope.location.contactData = {
					    fullAddress         : '',
					    formattedAddress    : '',
                        formattedAddressLine1     : '',
					    name                : location.selectedLocation.name,
					    phone               : location.selectedLocation.phone,
					    email               : location.selectedLocation.email,
					    operatingHours      : location.selectedLocation.operatingHours,
					    isVirtual           : location.selectedLocation.isVirtual
				    };

				    if(location.selectedLocation.address.street){
					    $scope.location.contactData.fullAddress = location.selectedLocation.address.street +' '+ location.selectedLocation.address.aptUnit + ' ' + location.selectedLocation.address.city +' '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip;
                        $scope.location.contactData.formattedAddressLine1 = location.selectedLocation.address.street + ' ' + location.selectedLocation.address.aptUnit;
                        $scope.location.contactData.formattedAddressLine2 = location.selectedLocation.address.city + ', ' + location.selectedLocation.address.state + ' ' + location.selectedLocation.address.zip;
					    $scope.location.contactData.formattedAddress = location.selectedLocation.address.street +', '+ (location.selectedLocation.address.aptUnit?location.selectedLocation.address.aptUnit + ', ' : '') + location.selectedLocation.address.city +', '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip;
				    }else{
				    	void 0;
				    	$scope.location.contactData.fullAddress = location.selectedLocation.address;
				    	$scope.location.contactData.formattedAddress = location.selectedLocation.address;
				    }

			    } else {
				    $scope.runUpdate = false;
				    $scope.updateContactPage = true;

				    ngDialog.open({
					    template        : 'partials/popup/select-location.html',
					    controller      : 'ModalController',
					    className       : 'ngdialog-theme-default email-capture',
					    showClose       : false,
					    closeByDocument : false,
					    closeByEscape   : false,
					    closeByNavigation: true,
					    scope           : $scope,
					    name            : 'location',
					    id              : 'location'
				    });
			    }

			    if (ENV.enablePriceList) {
				    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
					    event.preventDefault();
					    $scope.location.loadLocationsPopup(false, false, function (event) {
						    sessionStorage.setItem('hs_session', new Date());
						    $route.reload();
					    });
				    });

				    $scope.$on('$destroy', function() {
					    sessionExpired();
				    });
			    }

		    } else if (ENV.enablePriceList) {
			    var selectedPriceList = localStorageService.get('selectedPriceList');
			    if (!selectedPriceList) {
				    $scope.runUpdate = false;
				    $scope.updateContactPage = true;

				    ngDialog.open({
					    template        : 'partials/popup/select-location.html',
					    controller      : 'ModalController',
					    className       : 'ngdialog-theme-default email-capture',
					    showClose       : false,
					    closeByDocument : false,
					    closeByEscape   : false,
					    closeByNavigation: true,
					    scope           : $scope,
					    name            : 'location',
					    id              : 'location'
				    });
			    } else {
				    $rootScope.$broadcast('priceListUpdated');
			    }

			    var sessionExpired = $rootScope.$on('sessionExpired', function (event) {
				    event.preventDefault();
				    $scope.location.loadLocationsPopup(false, false, function (event) {
					    sessionStorage.setItem('hs_session', new Date());
					    $route.reload();
				    });
			    });

			    $scope.$on('$destroy', function() {
				    sessionExpired();
			    });
		    } else {
			    if(location){
			    	void 0;
				    $scope.location.contactData = {
					    fullAddress     : location.selectedLocation.address.street +' '+ location.selectedLocation.address.aptUnit + ' ' + location.selectedLocation.address.city +' '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip,
					    formattedAddress     : location.selectedLocation.address.street +', '+ (location.selectedLocation.address.aptUnit?location.selectedLocation.address.aptUnit + ', ' : '') + location.selectedLocation.address.city +', '+ location.selectedLocation.address.state +' '+ location.selectedLocation.address.zip,
					    name            : location.selectedLocation.name,
					    phone           : location.selectedLocation.phone,
					    email           : location.selectedLocation.email,
					    operatingHours  : location.selectedLocation.operatingHours,
					    isVirtual       : location.selectedLocation.isVirtual
				    };

                } else {
				    $http.get(ENV.apiEndPoint + '/locations')
				    .then(function(res){
					    void 0;
					    if(res.status === 200){
					    	void 0;
					    	var locationData = {
					    		allLocations     : [],
					    		selectedLocation : res.data[0]
						    };

					    	localStorageService.set('location', locationData);
					    	void 0
						    $scope.location.contactData = {
							    fullAddress     : locationData.selectedLocation.address.street +' '+ locationData.selectedLocation.address.aptUnit + ' ' + locationData.selectedLocation.address.city +' '+ locationData.selectedLocation.address.state +' '+ locationData.selectedLocation.address.zip,
							    formattedAddress     : locationData.selectedLocation.address.street +', '+ (locationData.selectedLocation.address.aptUnit !== '' ?locationData.selectedLocation.address.aptUnit + ', ' : ' ') + locationData.selectedLocation.address.city +', '+ locationData.selectedLocation.address.state +', '+ locationData.selectedLocation.address.zip,
							    name            : locationData.selectedLocation.name,
							    phone           : locationData.selectedLocation.phone,
							    email           : locationData.selectedLocation.email,
							    operatingHours  : locationData.selectedLocation.operatingHours,
							    isVirtual       : locationData.selectedLocation.isVirtual
						    };

					    } else {
					    	toastr.error('Something went wrong. Please try again.');
					    }
				    });
                }
		    }

		    void 0;
		    setTimeout(function(){
			    $scope.location.config.pageFullyLoaded = true;
			    $scope.$apply();
		    }, 100);
	    },
	    loadLocationsPopup  : function (searchPage, runUpdate, callback) {
		    $scope.searchPage = searchPage || false;
		    $scope.runUpdate = runUpdate || false;

		    void 0;
		    if (!ngDialog.isOpen('locationpopup-dialog') && !ngDialog.isOpen('location-dialog')) {
			    var dialogOptions = {
				    template        : 'partials/popup/select-location.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default email-capture',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : false,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'locationPopup',
				    id              : 'locationPopup'
			    };

			    if (callback) {
				    dialogOptions.preCloseCallback = function(value) {
					    callback(value);
				    }
			    }

			    ngDialog.open(dialogOptions);
		    }
	    },
	    selectLocation      : function (selectedLocation) {
        	void 0;
        	void 0;
        	
        	delete selectedLocation['directions'];
        	delete selectedLocation['marker'];
        	
		    var locationData = {
			    allLocations        : [],
			    selectedLocation    : selectedLocation
		    };
		
		    $scope.location.data.allLocations.forEach(function (loc)
		    {
		    	delete loc['directions'];
		    	delete loc['marker'];
		    });
		
		    localStorageService.set('location', locationData);
		
		    $rootScope.$broadcast('locationUpdated', true);
		    $location.url('/products');
	    },
	    searchLocations     : function (addr) {
		    var address = document.getElementById("addressInput").value;
		    var geocoder = new google.maps.Geocoder();
		    geocoder.geocode({address: address}, function(results, status) {
		    	void 0;
			    if (status == google.maps.GeocoderStatus.OK) {
				    $scope.location.searchLocationsNear(results[0].geometry.location);
			    } else {
				    void 0;
			    }
		    });
	    },
	    clearLocations      : function () {
		    this.data.infoWindow.close();
		    for (var i = 0; i < this.data.markers.length; i++) {
			    $scope.location.data.markers[i].setMap(null);
		    }
		    this.data.markers.length = 0;
		
		    this.data.locationSelect.innerHTML = "";
		    var option = document.createElement("option");
		    option.value = "none";
		    option.innerHTML = "See all results:";
		    this.data.locationSelect.appendChild(option);
	    },
	    createOption        : function (name, distance, num) {
		    var option = document.createElement("option");
		    option.value = num;
		    option.innerHTML = name;
		    this.data.locationSelect.appendChild(option);
	    },
	    createMarker        : function (latlng, name, address) {
		    var html = "<b>" + name + "</b> <br/>" + address;
		    var marker = new google.maps.Marker({
			    map         : this.data.map,
			    position    : latlng
		    });
		    
		    google.maps.event.addListener(marker, 'click', function() {
			    $scope.location.data.infoWindow.setContent(html);
			    $scope.location.data.infoWindow.open($scope.location.data.map, marker);
		    });
		    
		    this.data.markers.push(marker);
	    },
	    searchLocationsNear : function (center) {
		    this.clearLocations();
		
		    var radius = document.getElementById('radiusSelect').value;
		    var bounds = new google.maps.LatLngBounds();
			var markerNodes = this.data.allLocations;
		    
		    for (var i = 0; i < markerNodes.length; i++) {
			    var name = markerNodes[i].storeName;
			    var address = markerNodes[i].address;
			    var latlng = new google.maps.LatLng(
				    parseFloat(markerNodes[i].lat),
				    parseFloat(markerNodes[i].lng)
			    );
			
			    $scope.location.createOption(name, 0, i);
			    $scope.location.createMarker(latlng, name, address);
			    bounds.extend(latlng);
		    }
		    $scope.location.data.map.fitBounds(bounds);
		    $scope.location.data.locationSelect.style.visibility = "visible";
		    $scope.location.data.locationSelect.onchange = function() {
			    var markerNum = $scope.location.data.locationSelect.options[$scope.location.data.locationSelect.selectedIndex].value;
			    google.maps.event.trigger($scope.location.data.markers[markerNum], 'click');
		    };
	    },
	    init                : function () {
		    void 0;
		    
		    globalFunctions.setSEOdata("Locations | " + ENV.SEO.title);
		    
		    var companyHome, locations;
		    
		    if(ENV.locations.length > 0){
			    companyHome = {lat: ENV.contact.lat, lng: ENV.contact.lng};
				locations = ENV.locations;
			    this.renderMap(companyHome, locations);
		    }else{
			    $http.get(ENV.apiEndPoint + '/locations')
			    .then(function(res){
				    void 0;
				    if(res.status === 200){
					    res.data.forEach(function(location){
					    	location.storeName = location.name;
						    location.address = location.address.street +' '+ location.address.aptUnit + ' ' +
							    location.address.city +' '+ location.address.state +' '+ location.address.zip;
							
						    location.lat = location.latitude;
						    location.lng = location.longitude;
						    
						    if(location.default === true){
							    companyHome = {lat: location.latitude, lng: location.longitude};
						    }
					    });
					    
					    locations = res.data;
					    $scope.location.renderMap(companyHome, locations);
				    } else{
					    toastr.error('Error retrieving locations.')
				    }
			    });
		    }
	    },
	    renderMap           : function (companyHome, locations) {
        	void 0;
        	void 0;
		    this.data.origin = companyHome;
		    this.data.allLocations = locations;
		    this.data.map = new google.maps.Map(document.getElementById('map'), {
			    center: companyHome,
			    zoom: 12,
			    styles: [{
				    stylers: [{ visibility: 'simplified' }]
			    }, {
				    elementType: 'labels',
				    stylers: [{ visibility: 'off' }]
			    }],
			    gestureHandling: 'cooperative',
			    mapTypeControl: false,
			    fullscreenControl: false
		    });
		    
		    var input = document.getElementById("UserMapInput");
		    var searchBox = new google.maps.places.SearchBox(input);
		    
		    //this.data.map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);
		    this.data.infoWindow    = new google.maps.InfoWindow();
		    this.data.service       = new google.maps.places.PlacesService(this.data.map);
		
		    this.data.allLocations.forEach(function(location){
			    location['directions'] = $sce.trustAsResourceUrl(
				    'https://maps.google.com/maps?q='+location.address
			    );
			    $scope.location.addMarker(location);
		    });
		
		    if (navigator.geolocation) {
		    	void 0;
			    var options = {
				    enableHighAccuracy: true,
				    timeout: 5000,
				    maximumAge: 0
			    };
		    	
		    	$scope.location.loading = true;
			    navigator.geolocation.getCurrentPosition(function(position) {
			    	void 0;
				    var pos = {
					    lat: position.coords.latitude,
					    lng: position.coords.longitude
				    };
				
				    $scope.location.data.infoWindow.setPosition(pos);
				    $scope.location.data.map.setCenter(pos);
				    $scope.location.processMapMarkers(pos.lat, pos.lng, true);
			    }, function(error) {
			    	void 0;
				    $scope.location.processMapMarkers(companyHome.lat, companyHome.lng, true);
				    
			    }, options);
		    } else {
			    // Browser doesn't support Geolocation
			    void 0;
			    $scope.location.processMapMarkers(companyHome.lat, companyHome.lng, true);
		    }
		    
		
		    // Bias the SearchBox results towards current map's viewport.
		    this.data.map.addListener('bounds_changed', function() {
			    searchBox.setBounds($scope.location.data.map.getBounds());
		    });
		
		
		    var markers = [];
		    // Listen for the event fired when the user selects a prediction and retrieve
		    // more details for that place.
		    searchBox.addListener('places_changed', function() {
			    var places = searchBox.getPlaces();
			    void 0;
			
			    if (places.length == 0) {return;}
			
			    // Clear out the old markers.
			    markers.forEach (function ( marker ) {
				    marker.setMap (null);
			    });
			
			    markers = [];
			
			    // For each place, get the icon, name and location.
			    var bounds = new google.maps.LatLngBounds();
			    void 0;
			    
			    places.forEach (function ( place ) {
			    	void 0;
				    if (!place.geometry) {
					    void 0;
					    return;
				    }
				    
				    void 0;
				    if (place.geometry.viewport) {
				    	void 0;
					    // Only geocodes have viewport.
					    bounds.union(place.geometry.viewport);
				    } else {
					    bounds.extend(place.geometry.location);
				    }
				    
					$scope.location.processMapMarkers(place.geometry.location.lat(), place.geometry.location.lng(), true);
			    });
			    //$scope.location.data.map.fitBounds(bounds);
		    });
		    
		    
		    this.data.map.addListener('dragend', function(){
			    var center = $scope.location.data.map.getCenter();
			    $scope.location.processMapMarkers(center.lat(), center.lng(), true);
		    });
		    
	    },
	    processMapMarkers   : function (lat, lng, update) {
        	//console.log(lat, lng);
        	if(update){
        		$scope.location.loading = true;
	        }
		
		    var start = {
			    latitude: lat,
			    longitude: lng
		    };
        	
        	var locations = [];
        	var outsideLocations = [];
		    this.data.markers.forEach(function(loc){
			    var end = {
				    latitude: loc.marker.position.lat(),
				    longitude: loc.marker.position.lng()
			    };
			
			    var distance = parseFloat(haversine(start, end, 'mile'));
			    loc['distance'] = distance.toFixed(2);
			    
			    if(distance < $scope.location.radius){
				    locations.push(loc);
			    }else{
				    outsideLocations.push(loc);
			    }
		    });
		
		    locations.sort(function(a, b){return a.distance - b.distance;});
		    outsideLocations.sort(function(a, b){return a.distance - b.distance;});
		    
		    if(locations.length === 0){
			    this.data.locations = outsideLocations;
		    }else{
			    this.data.locations = locations;
		    }
		
		    var newBounds = new google.maps.LatLngBounds();
		    newBounds.extend(new google.maps.LatLng(lat, lng));
		
		    void 0;
		    
		    for(var i=0; i<5; i++){
		    	void 0;
		    	if($scope.location.data.locations[i]){
				    var loc = $scope.location.data.locations[i].marker.getPosition();
				    void 0;
				    newBounds.extend(loc);
			    }
		    }
		    
		    $scope.location.data.map.fitBounds(newBounds);
		    $scope.$apply();
		    
		    if(update){
			    $scope.location.loading = false;
			    $scope.$apply();
		    }
		    
		    this.config.pageFullyLoaded = true;
	    },
	    addMarker           : function (place) {
		    var marker = new google.maps.Marker({
			    map: this.data.map,
			    position: new google.maps.LatLng(
				    parseFloat(place.lat),
				    parseFloat(place.lng)
			    ),
			    gestureHandling: 'cooperative',
			    animation: google.maps.Animation.DROP
			    /*icon: {
				    url: '../images/maps/trudots-marker.png',
				    anchor: new google.maps.Point(10, 10),
				    scaledSize: new google.maps.Size(30, 18)
			    }*/
		    });
		    
		    google.maps.event.addListener(marker, 'mouseover', function() {
			    var div = '<div class="marker-content-box text-dark-gray text-uppercase">' +
					    '<h4 class="marker-content-title mtopbot0">'+ place.storeName +'</h4>' +
					    '<p class="marker-content-address mtopbot0 text-500">'+ place.address +'</p>' +
					    '<a class="btn btn-primary btn-sm mtop10" target="_blank" href="'+ place.directions +'">Get Directions</a>' +
				    '</div>';
			
			    $scope.location.data.infoWindow.setContent(div);
			    $scope.location.data.infoWindow.open($scope.location.data.map, marker);
		    });
		    
		    place.marker = marker;
		    
		    $scope.location.data.markers.push(place);
	    }
    };
    
    window.prerenderReady = true;
    
}]);

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('loginCtrl',[ '$scope','$rootScope','$location','$http','toastr','hsAuth','localStorageService','ENV','hsCart','globalFunctions', 'hsSocialLogin', 'VALIDATORS', 'hsLogin','hsAdmin', '$routeParams', 'hsUtils', '$timeout',
    function($scope, $rootScope,$location,$http,toastr,hsAuth, localStorageService, ENV, hsCart, globalFunctions, hsSocialLogin, VALIDATORS, hsLogin, hsAdmin, $routeParams, hsUtils, $timeout){

    if($rootScope.loggedIn){
        $location.path('/');
    }

    $rootScope.bgHome = true;

    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
        //..do something  //if you don't want event to bubble up
        $rootScope.bgHome = false;
    });

    var genericError = 'Something went wrong. Please try again.';
    
    $scope.login = {
        config: {
            pageFullyLoaded: false,
            loginError: '',
            localBasket: false,
            buttonLoading: false,
            resetPasswordConfirmed: false,
            memberLogin: null,
            signupFor: globalFunctions.isErewhon() ? 'erewhon' : 'ecrs',
            loginValidationRules: {
                rules: {
                    email: {
                        required: true,
                    },
                    password: {
                        required: true,
                    },
                    resetPasswordCode: {
                        required: true,
                    },
                },
                messages: {
                    email: {
                        required: 'Please enter your email address',
                    },
                    password: {
                        required: 'Please enter a password.',
                    },
                    resetPasswordCode: {
                        required: 'Please enter a reset code.',
                    },
                },
            },
            phoneValidationRules: VALIDATORS.PHONE_NUMBER_VERIFICATION,
        },
        email: '',
        password: '',
        social: {
            callback: false,
            google() {
                window.location.href = hsSocialLogin.getGoogleAuthUrl($scope.login.redirectLink, false);
            },
            fb() {
                window.location.href = hsSocialLogin.getFbAuthUrl($scope.login.redirectLink, false);
            },
            login(data) {
                var apiUrl = ENV.apiEndPoint + '/user/social';
                $http.post(apiUrl, data).then(function (response) {
                    if (response.status === 200) {
                        $scope.login.processLogin(response);
                        toastr.success('Login Successful.');
                        $scope.login.config.buttonLoading = false;
                    } else {
                        toastr.error(genericError);
                        $scope.login.config.loginError = genericError;
                        $location.url('/login');
                        $scope.login.config.buttonLoading = false;
                    }
                });
            },
        },
        initSocialLogin() {
            if ($location.search().code) {
                var fbState = localStorageService.get('fb_state');
                var googleState = localStorageService.get('google_state');
                $scope.login.redirectLink = localStorageService.get('socialRedirect');
                localStorageService.remove('socialRedirect');
                if (fbState) {
                    var fbCallback = hsSocialLogin.getSocialLoginCallback('fb_state', 'facebook', $scope.login.social.login, false);
                    fbCallback($location.search());
                } else if (googleState) {
                    var googleCallback = hsSocialLogin.getSocialLoginCallback('google_state', 'google', $scope.login.social.login, false);
                    googleCallback($location.search());
                } else {
                    $location.url('/login');
                }
            } else {
                $location.url('/login');
            }
        },
        removeSpaces: function (val) {
            $('#email').val(val.trim());
        },
        redirectUser: function (url) {
            void 0;
            if (Object.keys(this.routeParams).length > 0) {
                $location.path(url).search($location.search());
            } else if (this.redirectLink) {
                url = url + '?redirect=' + this.redirectLink;
                $location.url(url);
            } else {
                $location.url(url);
            }
        },
        redirectLink: false,
        routeParams: {},
        init: function () {
            void 0;

            if ($location.search().redirect) {
                this.redirectLink = $location.search().redirect;
            } else {
                this.routeParams = $location.search();
            }

            if ($location.search().loyaltyProgram) {
                $scope.login.loyalty.isVerifyingPhoneNumber = true;
                $scope.login.loyalty.isEnteringCode = false;
            }

            var savedEmail = localStorageService.get('user_email');
            if (savedEmail) {
                this.email = savedEmail;
            }

            var basket = localStorageService.get('basket');
            if (basket) {
                this.config.localBasket = true;
                $rootScope.$emit('cartUpdated');
            }
            globalFunctions.getSelectedLocation(true)
				.then(function(location) {
                    if (location.memberLogin) {
                        $scope.login.config.memberLogin = location.memberLogin;
                    }
                    if (location.membershipStoreSettings) {
                        $scope.login.config.signupFor = 'membershipStore';
                    }
                    $scope.login.config.pageFullyLoaded = true;
                });
        },
        initPassword: function () {
            if ($location.search().redirect) {
                this.redirectLink = $location.search().redirect;
            } else {
                this.routeParams = $location.search();
            }

            var savedEmail = localStorageService.get('user_email');
            if (savedEmail) {
                this.email = savedEmail;
            }
            void 0;
            void 0;
        },
        resetPassword: function (form) {
            if (form.validate()) {
                $scope.login.config.buttonLoading = true;

                var data = {
                    user: {
                        email: form.email.$modelValue.toString().trim().toLowerCase(),
                        password: form.password.$modelValue,
                        resetCode: form.resetPasswordCode.$modelValue,
                    },
                };
                void 0;

                var apiUrl = ENV.apiEndPoint + '/user/password';
                $http.put(apiUrl, data).then(function (response) {
                    void 0;
                    if (response.status === 200) {
                        $scope.login.config.buttonLoading = false;
                        $scope.login.config.resetPasswordConfirmed = true;
                    } else if (response.status === 400) {
                        $scope.login.config.loginError =
                            'Please make sure your email and reset code are correct, '
                            + 'and the new password is at least 6 characters long and try again.';
                        $scope.login.config.buttonLoading = false;
                    } else if (response.status === 401) {
                        $scope.login.config.loginError =
                            'The reset code you provided is invalid, ' + 'please provide the correct code and try again.';
                        $scope.login.config.buttonLoading = false;
                    } else {
                        $scope.login.config.loginError = genericError;
                        $scope.login.config.buttonLoading = false;
                    }
                });
            }
        },
        forgotPassword: function (form) {
            if (form.validate()) {
                $scope.login.config.buttonLoading = true;

                var data = {
                    user: {
                        email: form.email.$modelValue.toString().trim().toLowerCase(),
                    },
                };

                var apiUrl = ENV.apiEndPoint + '/user/password';
                $http.post(apiUrl, data).then(function (response) {
                    void 0;
                    if (response.status === 200) {
                        if ($scope.login.redirectLink) {
                            $location.url('/password/reset?redirect=' + $scope.login.redirectLink);
                        } else {
                            $location.url('/password/reset');
                        }
                        $scope.login.config.buttonLoading = false;
                    } else if (response.status === 400) {
                        $scope.login.config.loginError = 'Please make sure your email address is correct and try again.';
                        $scope.login.config.buttonLoading = false;
                    } else if (response.status === 404) {
                        $scope.login.config.loginError =
                            "Couldn't find the account associated with the email you provided."
                            + ' Please make sure the email address is correct or if you wish to create a new account '
                            + '<a href="/signup">Sign Up</a>.';
                        $scope.login.config.buttonLoading = false;
                    } else {
                        $scope.login.config.loginError = genericError;
                        $scope.login.config.buttonLoading = false;
                    }
                });
            }
        },
        removeSpace($event) {
            if ($event.keyCode === 32) {
                $event.preventDefault();
                return;
            }
        },
        loginUser: function (form) {
            if (form.validate()) {
                $scope.login.config.buttonLoading = true;

                var data = {
                    user: {
                        emailId: form.email.$modelValue.trim().toString().toLowerCase(),
                        password: form.password.$modelValue.toString(),
                    },
                };

                var apiUrl = ENV.apiEndPoint + '/user/login';
                $http.post(apiUrl, data).then(function (response) {
                    void 0;
                    if (response.status === 200) {
                        $scope.login.processLogin(response);
                        $scope.login.config.buttonLoading = false;
                    } else if (response.status === 400) {
                        $scope.login.config.loginError = 'Please make sure your email and password are correct and try again.';
                        $scope.login.config.buttonLoading = false;
                    } else if (response.status === 401) {
                        $scope.login.config.loginError = 'Incorrect username and/or password. Please try again.';
                        $scope.login.config.buttonLoading = false;
                    } else {
                        $scope.login.config.loginError = genericError;
                        $scope.login.config.buttonLoading = false;
                    }
                });
            }
        },
        processLogin: function (response) {
            delete $scope.login.routeParams.loyaltyProgram;
            hsLogin.processLogin(response, $scope.login.redirectLink, $scope.login.routeParams);
        },
        showLoginOptions: function() {
            return $rootScope.ENV.enableFacebookLogin || $rootScope.ENV.enableGoogleLogin
                || $scope.login.loyalty.showMemberLogin();
        },
        loyalty: {
            form: null,
            error: '',
            verificationCode: null,
            verificationPhoneNumber: null,
            verificationCodeWasResent: false,
            isEnteringCode: false,
            needToSignUp: false,
            isEcrsMemberLogin: function() {
                return $scope.login.loyalty.showMemberLogin() && $scope.login.loyalty.isVerifyingPhoneNumber;
            },
            showMemberLogin: function() {
                if ($scope.login.config.memberLogin) {
                    return $scope.login.config.memberLogin.enabled;
                }
                return false;
            },
            shouldHideEmailLogin: function() {
                if ($location.search().showEmailLogin) {
                    return false;
                }
                if ($scope.login.config.memberLogin && typeof $scope.login.config.memberLogin.hideEmailLogin === 'boolean') {
                    return $scope.login.config.memberLogin.hideEmailLogin;
                }
                return false;
            },
            getMemberLoginText: function() {
                if ($scope.login.config.memberLogin.text) {
                    return $scope.login.config.memberLogin.text;
                } 
                return $rootScope.ENV.name.companyName + ' Member Login';
            },
            showVerifyPhoneNumber: function() {
                $location.search('loyaltyProgram', 'true');
            },
            handlePhoneNumberChange: function() {
                $scope.login.loyalty.error = '';
                $scope.login.loyalty.verificationCode = null;
                $scope.login.loyalty.verificationCodeWasResent = false;
                $scope.login.loyalty.isEnteringCode = false;
                $scope.login.loyalty.needToSignUp = false;
            },
            sendCode: function(resend, shouldCallToReceiveCode) {
                $scope.login.loyalty.error = '';

                if (shouldCallToReceiveCode || $scope.login.loyalty.form.validate()) {
                    // suppressing the loader here since when making a phone call to the user
                    $scope.login.config.buttonLoading = shouldCallToReceiveCode ? false : true;
                    $scope.login.loyalty.verificationCode = null;
                    $scope.login.loyalty.verificationCodeWasResent = !!resend;

                    var apiUrl = ENV.apiEndPoint + '/phonenumber/code';
                    $http.post(apiUrl, { phoneNumber: $scope.login.loyalty.verificationPhoneNumber, shouldCall: !!shouldCallToReceiveCode })
                        .then(function(res) {
                            if (res.status === 200) {
                                $scope.login.loyalty.isEnteringCode = true;
                            } else {
                                $scope.login.loyalty.error = genericError;
                            }
                            void 0;
                        })
                        .catch(function(err) {
                            void 0;
                            $scope.login.loyalty.error = genericError;
                        })
                        .finally(function() {
                            $scope.login.config.buttonLoading = false;
                        });
                }
            },
            verifyCode: function() {
                $scope.login.loyalty.error = '';

                if ($scope.login.loyalty.form.validate()) {
                    $scope.login.config.buttonLoading = true;

                    var apiUrl = ENV.apiEndPoint + '/phonenumber/verify';
                    var data = {
                        phoneNumber: $scope.login.loyalty.verificationPhoneNumber,
                        code: $scope.login.loyalty.verificationCode,
                        for: $scope.login.config.signupFor,
                    };
                    $http.post(apiUrl, data)
                        .then(function(res) {
                            if (res.status === 404) {
                                // renaming here to reuse UI error
                                $scope.login.loyalty.error = 'Incorrect code.';
                                return;
                            } else if (res.status !== 200) {
                                var message = res.data && res.data.message ? res.data.message : genericError;
                                $scope.login.loyalty.error = message;
                                return;
                            }
                            $scope.login.loyalty.processLoyaltyResponse(res.data);
                        })
                        .catch(function(err) {
                            void 0;
                            $scope.login.loyalty.error = genericError;
                        })
                        .finally(function() {
                            $scope.login.config.buttonLoading = false;
                        });
                }
            },
            processLoyaltyResponse: function(data) {
                void 0;
                $rootScope.verifiedPhoneNumber = $scope.login.loyalty.verificationPhoneNumber;

                if (data.redirect) {
                    $location.url('/signup');
                } else if ('user' in data) {
                    $scope.login.processLogin({ data: data.user });
                } else if ('loyaltyAccount' in data) {
                    var account = data.loyaltyAccount;
                    $rootScope.loyaltyAccount = account;

                    $location.url('/signup/ecrs');

                } else {
                    $scope.login.loyalty.needToSignUp = true;
                    $scope.login.loyalty.isEnteringCode = false;
                }
            },
        },
        initAppLogin: function() {
            var params = $location.search() || {};

            var email = params.email;
            var authToken = params.authToken;
            var redirect = params.redirect;

            // Default value is set here because httpInterceptor in app.js
            // will require 'redirect' in $location.search() to appropriately
            // redirect to /login?redirect=<path>
            if (!hsUtils.isNonEmptyString(redirect)) {
                $location.search('redirect', 'admin/manager-dashboard');
                redirect = 'admin/manager-dashboard';
            }
            
            var loginUrl = new URL('login', window.location.origin);
            loginUrl.searchParams.append('redirect', redirect);

            if(!hsUtils.isNonEmptyString(email) || !hsUtils.isNonEmptyString(authToken)) {
                $location.url(loginUrl.pathname + loginUrl.search);
            }

            $scope.login.redirectLink = redirect;
            
            var user = {
                email,
                authToken,
            };
            
            if ($rootScope.loggedIn) {
                var redirectUrl = new URL(window.location.pathname, window.location.origin);
                redirectUrl.searchParams.append('email', email);
                redirectUrl.searchParams.append('authToken', authToken);    
                redirectUrl.searchParams.append('redirect', redirect);
                hsAuth.logoutUser(redirectUrl.pathname + redirectUrl.search);
            }
            
            localStorageService.set('user', user);

            hsAdmin.getUserDetails(email, null)
                .then(function(response) {
                    if(response.status === 200) {
                        $scope.login.processLogin(response);
                    } else {
                        localStorageService.remove('user');
                        $location.url(loginUrl.pathname + loginUrl.search);
                    }
                })
                .catch(function(err) {
                    localStorageService.remove('user');
                    $location.url(loginUrl.pathname + loginUrl.search);
                })
                .finally(function() {
                    $scope.login.config.pageFullyLoaded = true;
                });
        },
        initUserAppLogin: function() {
            var params = $location.search() || {};

            var email = params.email;
            var authToken = params.authToken;
            var redirect = params.redirect;

            // Default value is set here because httpInterceptor in app.js
            // will require 'redirect' in $location.search() to appropriately
            // redirect to /login?redirect=<path>
            if (!hsUtils.isNonEmptyString(redirect)) {
                $location.search('redirect', '/products');
                redirect = '/products';
            }
            
            var loginUrl = new URL('login', window.location.origin);
            loginUrl.searchParams.append('redirect', redirect);

            if(!hsUtils.isNonEmptyString(email) || !hsUtils.isNonEmptyString(authToken)) {
                $location.url(loginUrl.pathname + loginUrl.search);
            }

            $scope.login.redirectLink = redirect;
            
            var user = {
                email,
                authToken,
            };
            
            if ($rootScope.loggedIn) {
                var redirectUrl = new URL(window.location.pathname, window.location.origin);
                redirectUrl.searchParams.append('email', email);
                redirectUrl.searchParams.append('authToken', authToken);    
                redirectUrl.searchParams.append('redirect', redirect);
                hsAuth.logoutUser(redirectUrl.pathname + redirectUrl.search);
            }
            
            localStorageService.set('user', user);

            hsLogin.getUserForAppLogin(email)
                .then(function(response) {
                    if(response.status === 200) {
                        $scope.login.processLogin(response);
                    } else {
                        localStorageService.remove('user');
                        $location.url(loginUrl.pathname + loginUrl.search);
                    }
                })
                .catch(function(err) {
                    localStorageService.remove('user');
                    $location.url(loginUrl.pathname + loginUrl.search);
                })
                .finally(function() {
                    $scope.login.config.pageFullyLoaded = true;
                });
        }
    };
    
}]);

'use strict';

/* Controllers */

hsApp.controller('ModalController', ['$scope','$rootScope','ngDialog','ENV','$http','localStorageService','hsAuth','hsCart','toastr','$location',
    'hsAdmin','$filter','haversine','globalFunctions','$sce','scrollToElement','address', '$route','$q', 'hsSearch', '$timeout', 'hsTableSideOrders', 'hsUpc', 'hsPromos', 'hsUtils',
	'$routeParams', 'scannerUtils', 'hsPickingApp', 'hsMarketingService', 'aiSearchEvents',
    function($scope,$rootScope,ngDialog,ENV,$http,localStorageService, hsAuth, hsCart, toastr, $location,
        hsAdmin, $filter, haversine, globalFunctions, $sce, scrollToElement, address, $route, $q, hsSearch, $timeout, hsTableSideOrders, hsUpc, hsPromos, hsUtils, 
		$routeParams, scannerUtils, hsPickingApp, hsMarketingService, aiSearchEvents) {

    $scope.itemName = '';
    $scope.itemPrice = '';
    $scope.itemUpc = '';

    $scope.popup = {
        config                      : {
        	loading                 : true,
			pageFullyLoaded         : false,
			imageBaseUrl            : globalFunctions.imageBaseUrl,
	        message                 : '',
	        messageClass            : '',
	        buttonLoading           : false,
	        showZoomContainer       : false,
	        zoomContainerHeight     : 0,
	        scrollTo                : function(container, section){
        		container = container || 'html, body';
		        var element = $(section);
		        var offset = $(element).offset();
		        var scrollAmount = offset.top;
		        //console.log('Scroll amount is:'+scrollAmount);
		        // scrollAmount -= 155;
		        //console.log('New Scroll amount is:'+scrollAmount);
		        // Scroll
		        $(container).animate({scrollTop: scrollAmount}, 'slow');
	        },
	        stafferValidationRules   : {
		        rules               : {
			        firstName         : {
				        required    : true
			        },
			        lastName         : {
				        required    : true
			        }
		        },
		        messages            : {
			        firstName         : {
				        required    : "Please enter first name"
			        },
			        lastName         : {
				        required    : "Please enter last name"
			        }
		        }
	        },
	        packerValidationRules   : {
		        rules               : {
			        newPackerName         : {
				        required    : true
			        }
		        },
		        messages            : {
			        newPackerName         : {
				        required    : "Please enter a name"
			        }
		        }
	        },
	        refundValidationRules   : {
		        rules               : {
			        amount         : {
				        required    : true,
				        number      : true,
                        gt: 0,
			        }
		        },
		        messages            : {
			        amount         : {
				        required    : "Please enter valid amount",
				        number      : "Please enter numbers only"
			        }
		        }
	        },
	        itemValidationRules     : {
		        rules               : {
			        itemInstructions   : {
				        maxLength   : 200
			        }
		        },
		        messages            : {
			        itemInstructions  : {
				        maxLength   : "Please limit instructions to 200 characters."
			        }
		        }
	        },
	        receiptValidationRules  : {
		        rules               : {
			        email         : {
				        email       : true
			        }
		        },
		        messages            : {
			        email         : {
				        email       : 'Invalid email'
			        }
		        }
	        },
	        tipsValidationRules     : {
		        rules               : {
			        tip         : {
				        required    : true,
				        number      : true
			        }
		        },
		        messages            : {
			        tip         : {
				        required    : "Please enter a valid number",
				        number      : "Please enter numbers only"
			        }
		        }
	        },
	        bottleFeeValidationRules: {
		        rules               : {
			        fee         : {
				        required    : true,
				        number      : true
			        }
		        },
		        messages            : {
			        fee         : {
				        required    : "Please enter a valid number",
				        number      : "Please enter numbers only"
			        }
		        }
	        },
	        bagsValidationRules     : {
		        rules               : {
			        bags         : {
				        required    : true,
                        number      : true,
                        min         : 0
			        }
		        },
		        messages            : {
			        bags         : {
				        required    : "Please enter a valid number",
				        number      : "Please enter numbers only"
			        }
		        }
	        },
	        ageVerificationValidationRules     : {
		        rules               : {
			        dobDay         		: {
				        required    : true,
				        number      : true,
						min			: 1,
						max			: 31,
			        },
			        dobMonth        : {
				        required    : true,
				        number      : true,
						min			: 1,
						max			: 12,
			        },
			        dobYear        : {
				        required    : true,
				        number      : true,
						min			: 1900,
						max			: 2050
			        }
		        },
		        messages            : {
			        dobDay         : {
				        required    : "Please enter a valid number",
				        min    		: "Please enter a valid Date",
				        max    		: "Please enter a valid Date",
				        number      : "Please enter numbers only"
			        },
			        dobMonth         : {
				        required    : "Please enter a valid number",
				        min    		: "Please enter a valid Month",
				        max    		: "Please enter a valid Month",
				        number      : "Please enter numbers only"
			        },
			        dobYear         : {
				        required    : "Please enter a valid number",
				        min    		: "Please enter a Full Year YYYY format",
				        max    		: "Please enter a Full Year YYYY format",
				        number      : "Please enter numbers only"
			        }
		        }
	        },
	        deliveryValidationRules : {
		        rules               : {
			        email         : {
				        required    : true,
				        email       : true
			        }
		        },
		        messages            : {
			        email         : {
				        required    : "Please enter a valid email",
				        email      : "Please enter a valid email"
			        }
		        }
	        },
	        IPValidationRules       : {
		        rules               : {
			        ip              : {
				        required    : true,
				        ipv4        : true
			        }
		        },
		        messages            : {
			        ip              : {
				        required    : "A valid IP address is required",
				        ipv4        : "Please enter a valid IP address"
			        }
		        }
	        },
	        bankAccountValidationRules  : {
		        rules               : {
			        bankAccountNumber   : { required : true, number: true },
			        bankRoutingNumber   : { required : true, number: true },
			        businessName        : { required : true },
			        businessTaxId       : { required : true },
			        last4SSN            : { required : true, number: true, minlength: 4, maxlength: 4},
			        firstName           : { required : true },
			        lastName            : { required : true },
			        dobDay              : { required : true, number: true, min:1, max:31},
			        dobMonth            : { required : true, number: true, min:1, max: 12},
			        dobYear             : { required : true, number: true, minlength: 4, maxlength: 4},
			        addressStreet1      : { required : true},
			        addressCity         : { required : true},
			        addressState        : { required : true},
			        addressZip          : { required : true, number: true, minlength: 5, maxlength: 5},
			        addressCountry      : { required : true}
		        },
		        messages            : {
			        bankAccountNumber: {
				        required    : "Please enter a valid bank account number",
				        number      : "Please enter a valid bank account number",
			        },
			        bankRoutingNumber: {
				        required    : "Please enter a valid bank account routing number",
				        number      : "Please enter a valid bank account routing number",
			        },
			        businessName    : {
				        required    : "Valid business name required"
			        },
			        businessTaxId   : {
				        required    : "Valid business tax id required"
			        },
			        last4SSN        : {
				        required    : "Please enter Last 4 of your SSN",
				        number      : "Please enter valid Last 4 of your SSN",
				        minLength   : "Please enter valid Last 4 of your SSN",
				        maxLength   : "Please enter valid Last 4 of your SSN",
			        },
			        firstName       : {
				        required    : "Please enter representative legal first name"
			        },
			        lastName        : {
				        required    : "Please enter representative legal last name"
			        },
			        dobDay          : {
				        required    : "Please enter day of your D.O.B",
				        number      : "Please enter valid day of your D.O.B",
				        min         : "Please enter valid day of your D.O.B",
				        max         : "Please enter valid day of your D.O.B",
			        },
			        dobMonth        : {
				        required    : "Please enter month of your D.O.B",
				        number      : "Please enter valid month of your D.O.B",
				        min         : "Please enter valid month of your D.O.B",
				        max         : "Please enter valid month of your D.O.B",
			        },
			        dobYear         : {
				        required    : "Please enter year of your D.O.B",
				        number      : "Please enter valid year of your D.O.B",
				        minLength   : "Please enter full year in YYYY format",
				        maxLength   : "Please enter full year in YYYY format",
			        },
			        addressStreet1  : {
				        required    : "Please enter business street address"
			        },
			        addressCity     : {
				        required    : "Please enter business address city"
			        },
			        addressState    : {
				        required    : "Please enter business address state"
			        },
			        addressZip      : {
				        required    : "Please enter business address zip code",
				        number      : "Please enter valid zip code",
				        minLength   : "Please enter valid zip code",
				        maxLength   : "Please enter valid zip code",
			        },
			        addressCountry  : {
				        required    : "Please enter business address country"
			        },
		        }
	        },
	        shippingQuoteValidationRules   : {
		        rules               : {
			        length          : {
				        required    : true,
				        number      : true,
				        min         : 0.1
			        },
			        width           : {
				        required    : true,
				        number      : true,
				        min         : 0.1
			        },
			        height          : {
				        required    : true,
				        number      : true,
				        min         : 0.1
			        },
			        weight          : {
				        required    : true,
				        number      : true,
				        min         : 0.1
			        }
		        },
		        messages            : {
			        length          : {
				        required    : "Please enter a valid length",
				        number      : "Please enter a valid number",
				        min         : "Please enter a number greater than 0"
			        },
			        width           : {
				        required    : "Please enter a valid width",
				        number      : "Please enter a valid number",
				        min         : "Please enter a number greater than 0"
			        },
			        height          : {
				        required    : "Please enter a valid height",
				        number      : "Please enter a valid number",
				        min         : "Please enter a number greater than 0"
			        },
			        weight          : {
				        required    : "Please enter a valid weight",
				        number      : "Please enter a valid number",
				        min         : "Please enter a number greater than 0"
			        }
		        }
	        }
        },
	    confirmHeader               : 'Attention',
	    confirmMessage              : 'Removing items or reducing the quantity may cause the change in fees, if any, associated with the order.',
	    updateItemInOrder(item, quantity, itemInstructions) {
		    void 0;

		    void 0;
		    var data = {
			    order: {
				    key: $scope.popup.product.order.key,
				    itemName: item.name,
				    itemQuantity: parseFloat(quantity),
                    // uncomment after the backend is fixed 07DEC2020
				    // instructions: itemInstructions || ''
			    }
		    };

		    if (item.selectedModifiers) {
			    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
				    return modifier.name || modifier;
			    });
		    }

		    void 0;

		    hsAdmin.updateOrder(data)
			    .then(function (response) {
				    switch (response.status) {
					    case 200:
						    void 0;
						    toastr.success('Updated quantity successfully.');
						    item.quantity = data.order.itemQuantity;
						    $scope.closeThisDialog();
						    break;
					    case 402:
						    toastr.error('Your credit card was declined, please make sure there are enough funds on your card or ask your bank to authorize the transaction and retry.');
						    break;
					    case 403:
						    globalFunctions.showConfirmationDialog(globalFunctions.userOrderChanges.heading, globalFunctions.userOrderChanges.subHeading,
							    'Confirm', '', function (err, success) {
								    void 0;
								    ngDialog.close();
							    });
						    toastr.error('Can not make changes anymore.');
						    break;

					    case 406:
						    toastr.error(globalFunctions.errorMsg.minOrder);
						    break;
					    default:
						    toastr.error('Error updating quantity.');
						    break;
				    }

				    item.isUpdating = false;
				    item.loading = false;
			    });
	    },
	    calculateProductPrice       : function (productObj) {
        	return hsCart.calculateProductPrice(productObj)
	    },
        generatePreorderString: function (productObj, promotionObj) {
            if (promotionObj && promotionObj.type === 'preorder') {
                if (promotionObj.fulfillmentStartDate && promotionObj.fulfillmentEndDate) {
                    var startDate =
                        promotionObj.fulfillmentStartDate.month + '/'
                        + promotionObj.fulfillmentStartDate.date + '/' 
                        + promotionObj.fulfillmentStartDate.year;
                    var endDate =
                        promotionObj.fulfillmentEndDate.month + '/'
                        + promotionObj.fulfillmentEndDate.date + '/'
                        + promotionObj.fulfillmentEndDate.year;
                    
                    if (startDate === endDate) {
                        return 'This item is available on ' + startDate;
                    } else {
                        return 'This item is available from ' + startDate + ' to ' + endDate;
                    }
                }
            }

            return;
        },
        calculateAvailableTimeString : function (productObj) {
        	return hsCart.calculateAvailableTimeString(productObj, 'product')
	    },
        showAvailableTimes(product) {
            var $availableTimesScope = $scope.$new(true);
            $availableTimesScope.product = product;

            ngDialog.open({
                template: '<div><available-times '
                    + 'product="product">'
                    + '</available-times></div>',
                scope: $availableTimesScope,
                plain: true,
                closeByDocument: true,
                closeByNavigation: true,
            });
	    },
	    calculatePricePerQuantity   : function (productObj) {
        	return hsCart.calculatePricePerQuantity(productObj)
	    },
        calculateUnitQuantity: function(item) {
            return hsCart.calculateUnitQuantity(item);
        },
	    closeDialog                 : function () {
        	ngDialog.close();
	    },
	    deliveryArea                : {
        	allLocations            : [],
        	status                  : '',
		    userInput               : '',
		    alert                   : {
        		class               : '',
			    message             : '',
			    btnCta              : ''
		    },
		    location                : null,
		    getLocations            : function () {
			    $http.get(ENV.apiEndPoint + '/locations')
				    .then(function(res){
					    void 0;
					    if (res.status === 200) {
						    $scope.popup.deliveryArea.allLocations = res.data;
					    }
				    });
		    },
		    closeDialog             : function () {
        		$scope.popup.deliveryArea.status = '';
			    $scope.popup.deliveryArea.userInput = '';
			    $scope.popup.deliveryArea.alert = {
		            class               : '',
				    message             : '',
				    btnCta              : ''
			    };

			    ngDialog.close();
		    },
		    orderBtnClicked         : function () {
        		if (ENV.enableLocations) {
			        var locationObj = localStorageService.get('location');
			        if (locationObj) {
				        locationObj.selectedLocation = $scope.popup.deliveryArea.location;
			        } else {
				        locationObj = {};
				        locationObj.allLocations = $scope.popup.deliveryArea.allLocations;
				        locationObj.selectedLocation = $scope.popup.deliveryArea.location;
			        }

        			localStorageService.set('location', locationObj);
		        }

        		ngDialog.close();
			    $rootScope.$emit('locationUpdated', true);
			    $location.url('/products');
			},
			pickupBtnClicked: function() {
				ngDialog.close();
				$location.url('/products');
			}
	    },
	    customItemQuantity          : 1,
	    selectedCustomItemType      : '',
        customItemUnitTypes         : ['count', 'lb', 'bunch'],
        customItemUnitType          : '',
	    isCustomItemTaxable         : false,
	    showPriceListSection        : false,
        quantity                    : 1,
	    itemInstructions            : '',
        adminCustomDialog           : false,
	    itemToReplace               : false,
        adminData                   : {},
	    adminCtrl                   : {},
		forUserAddItemsCtrl			: {},
		addItemsToQuoteCtrl			: {},
        data                        : {},
        shippingData				: {
        	orderData				: [],
        	shipments				: [],
	        customQuote             : {
        		showForm            : false,
		        formData            : {
        			length          : 0,
        			width           : 0,
        			height          : 0,
        			weight          : 0
		        },
		        resetQuoteForm () {
        			$scope.popup.shippingData.customQuote.formData = {
				        length          : 0,
				        width           : 0,
				        height          : 0,
				        weight          : 0
			        };
		        }
	        },
	        shipmentPackages        : globalFunctions.shippingPackages,
	        selectedPackage         : {},
	        quoteData               : {},
			parent					: {}
		},
		announcementData			: {},
		product                     : {},
        originalProduct             : {},
	    printerData                 : {
		    loading: false,
		    showAddPrinterSection: false,
		    ip: '',
		    data: {
		    	admin: {},
		    	updatePrinterTag: false,
			    printers: [],
			    printersExtended: []
		    },
		    notification: {
			    message: '',
			    messageClass: ''
		    },
		    togglePrint(printer, index, value) {
			    $scope.popup.printerData.data.printersExtended[index].print = value;
			    void 0;
		    },
		    updateQuantity(printer, index, type) {
			    switch (type) {
				    case 'subtract' :
					    if (printer.quantity !== 0) {
						    $scope.popup.printerData.data.printersExtended[index].quantity--;
					    }
					    break;
				    case 'add' :
					    $scope.popup.printerData.data.printersExtended[index].quantity++;
					    break;
			    }
		    },
		    print() {
                if (!$scope.popup.printerData.data.printersExtended.length) {
                    ngDialog.close();
                    return;
                }
                var printed = 0;

                for (var i = 0; i < $scope.popup.printerData.data.printersExtended.length; i++) {
                    var printer = $scope.popup.printerData.data.printersExtended[i];

                    if (!printer.quantity || !printer.print) continue;

                    $scope.popup.printerData.printReceipt(printer.printerIP, printer.quantity, function () {
                        printed++;

                        if (printed >= $scope.popup.printerData.data.printersExtended.length) {
                            return;
                        }
                    });
                }
			    ngDialog.close();
		    },
		    printReceipt(ip, copies, callback) {
                void 0;
			    var orderObj = $scope.popup.printerData.data.adminData.orderDetails.order;
			    var userObj = $scope.popup.printerData.data.adminData.orderDetails.userData;

			    var ePosDev = new epson.ePOSDevice();
			    var copiesPrinted = 0;

			    ePosDev.connect(ip, null, function (result) {

				    void 0;

				    var deviceId = 'local_printer';
				    var options = {
					    'crypto': true,
					    'buffer': true
				    };

				    void 0;

				    if (result == 'OK' || result == 'SSL_CONNECT_OK') {

					    if (result !== 'SSL_CONNECT_OK') {
						    options.crypto = false;
					    }

					    void 0;

					    //Retrieves the Printer object
					    ePosDev.createDevice(deviceId, ePosDev.DEVICE_TYPE_PRINTER, options,
						    function (deviceObj, errorCode) {
								

							    if (deviceObj === null) {
								    //Displays an error message if the system fails to retrieve the Printer object
								    void 0;
								    return;
							    }

							    var printer = deviceObj;

							    //Registers the print complete event
							    printer.onreceive = function (response) {
								    if (response.success) {
									    void 0;

									    copiesPrinted++;
									    toastr.success('Printed receipt successfully');

									    if (copiesPrinted >= copies) {

										    ePosDev.deleteDevice(printer, function (err) {
											    // at the end
											    void 0;
											    ePosDev.disconnect();
											    callback();
										    });

										    return;

									    } else {
										    printWorker();
									    }
								    } else {
									    void 0;
									    toastr.error('Error printing receipt');
									    return;
								    }
							    };

							    void 0;

								function getTextWordWrapped(wordsArray) {

									if (Array.isArray(wordsArray) !== true) {
										// not an array
										return;
									}
							
									var i = 0;
									
									while (i < wordsArray.length) {
							
										var textToPrint = '';
										var feederCharCount = 2;
										var charCounter = feederCharCount;
							
										// start on the new line
										printer.addFeedLine(2);
										
										for (var k = 0; k < feederCharCount; k++) {
											textToPrint += ' ';
										}
							
										while (charCounter < 42) {
							
											if (i >= wordsArray.length) {
							
												// done with all the words
												// see if we have anything to
												// print
												if (charCounter !== feederCharCount) {
													// if we have something to print
													printer.addText(textToPrint.trimRight());
												}
							
												// done with this line and
												// all the words fit
												break;
							
											} else if ((charCounter + wordsArray[i].length + 1) < 42) {
							
												textToPrint += (wordsArray[i] + ' ');
												charCounter += (wordsArray[i].length + 1);
												i++;
							
											} else if (charCounter === feederCharCount) {
							
												// if the word is more than 25 characters
												// it is unlikely but not impossible
												textToPrint += wordsArray[i];
												printer.addText(textToPrint.trimRight());
												i++;
												break;
												// so we move to the next line
												// with the new iteration
												// of the outer loop
							
											} else {
							
												// new word won't fit on the current
												// line, put it on the new line
												printer.addText(textToPrint.trimRight());
												// so we move to the next line
												// with the new iteration
												// of the outer loop
												break;
											}
										}   
									}
								};

								function getNameTruncated(name){
        
									var retVal = '';
									
									if (!name || typeof name !== 'string') { 
										return '';
									} else if (name.length >= 14){
										return name.substring(0, 14);
									}
							
									var diff = 14 - name.length
									if (diff % 2 !== 0) {
										var rightPad = Math.floor(diff / 2);
										retVal = ' '.repeat(rightPad);
										retVal += name;
										retVal = retVal.padEnd(14);
									} else {
										retVal = ' '.repeat(diff / 2);
										retVal += name;
										retVal = retVal.padEnd(14);
									}
									return retVal;
								}

								function getTextTruncated(orderItem, length) {
									if (!orderItem || typeof orderItem !== 'string') {
										return '';
									} 
									
									return orderItem.substring(0, length);   
								}


								function getQuantity(product) {
									if (product.unit === 'lb' && !product.sellByQty) {
										return product.quantity + 'LB ';
									}
									return product.quantity + 'x ';
								}

								function getItemName(product) {
									return product.receiptAlias || product.receiptDisplayName || product.displayName;
								}

							    function printWorker() {
									// console.log(orderObj);
									// return;

								    printer.addTextSmooth(true);

									printer.addFeedLine(3);
									printer.addTextAlign(printer.ALIGN_CENTER);
									printer.addTextFont(printer.FONT_A);
									printer.addTextSize(2, 2);
									printer.addTextStyle(false, false, true, printer.COLOR_1);
									if (typeof orderObj.tableNumber === 'string') {
										printer.addText('Tableside Order');
									} else {
										printer.addText('Online Order');
									}

									printer.addFeedLine(3);
									var firstName =  getNameTruncated(userObj.firstName);
        							var lastName =  getNameTruncated(userObj.lastName);

									if (firstName) {
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextSize(3, 3);
										printer.addTextStyle(true, false, true, printer.COLOR_1);
										printer.addText(firstName)
										printer.addFeedLine(2);
									}

									if (lastName) {
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextSize(3, 3);
										printer.addTextStyle(true, false, true, printer.COLOR_1);
										printer.addText(lastName)
									}

									printer.addFeedLine(3);
									printer.addTextStyle(false, false, true, printer.COLOR_1);
									printer.addTextAlign(printer.ALIGN_CENTER);
									printer.addTextSize(2, 2);
									printer.addTextFont(printer.FONT_B);
									printer.addText(userObj.phoneNumber);

									printer.addFeedLine(3);
									if (orderObj.hasOwnProperty('tableNumber')) {
										printer.addTextStyle(false, false, true, printer.COLOR_1);
										printer.addTextFont(printer.FONT_A);
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextSize(3, 3);
										printer.addText('TABLE' + orderObj.tableNumber);
									} else {
										printer.addTextStyle(false, false, true, printer.COLOR_1);
										printer.addTextFont(printer.FONT_A);
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextSize(3, 3);
										printer.addText(orderObj.fulfillmentMethod.toUpperCase());
										printer.addFeedLine(3);	
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextFont(printer.FONT_B);
										printer.addTextSize(2, 2);
										printer.addText(orderObj.deliveryDate);
										printer.addFeedLine(2);	
										printer.addTextAlign(printer.ALIGN_CENTER);
										printer.addTextFont(printer.FONT_B);
										printer.addTextSize(2, 2);
										printer.addText(orderObj.deliveryTime);
									}

									orderObj.items.sort(function(a, b) {

										if (a.type < b.type) {
											return -1;
										} else if (a.type > b.type) {
											return 1;
										} else if (a.subType < b.subType) {
											return -1;
										} else if (a.subType > b.subType) {
											return 1;
										}
							
										return 0;
									});

								    printer.addFeedLine(1);

									var sdpTextSize = orderObj.locationObj.sdpTextSize || 2;

								    for (var i = 0; i < orderObj.items.length; i++) {
										printer.addFeedLine(2);	
										printer.addTextAlign(printer.ALIGN_LEFT);
										printer.addTextSize(sdpTextSize, sdpTextSize);
										printer.addTextStyle(false, true, true, printer.COLOR_2);

										var quantityString = getQuantity(orderObj.items[i]);
										var displayName = getItemName(orderObj.items[i]);

										if (sdpTextSize === 1) {
											printer.addTextFont(printer.FONT_A);
											printer.addText(getTextTruncated(quantityString + displayName, 33).toUpperCase());	
										} else {
											printer.addTextFont(printer.FONT_B);
											printer.addText(getTextTruncated(quantityString + displayName, 28 - quantityString.length))
										}
										

										if (orderObj.items[i].selectedModifiers && Array.isArray(orderObj.items[i].selectedModifiers) === true &&
										orderObj.items[i].selectedModifiers.length > 0) {

											var selectedMods = orderObj.items[i].selectedModifiers;

											var modifierItems = {};

											for (var modCounter = 0; modCounter < selectedMods.length; modCounter++) {
												if (!modifierItems.hasOwnProperty(selectedMods[modCounter].modifierDisplayName)) {
													modifierItems[selectedMods[modCounter].modifierDisplayName] = [];                     
												}
												if (selectedMods[modCounter].receiptAlias){
													modifierItems[selectedMods[modCounter].modifierDisplayName].push(selectedMods[modCounter].receiptAlias);
												} else {
													modifierItems[selectedMods[modCounter].modifierDisplayName].push(selectedMods[modCounter].displayName);
												}
												
											}
											for (var mainModifier in modifierItems) {

												printer.addFeedLine(2);
												printer.addTextAlign(printer.ALIGN_LEFT);
												printer.addTextSize(sdpTextSize, sdpTextSize);
												printer.addTextStyle(false, false, false, printer.COLOR_2);
												if (sdpTextSize === 1){
													printer.addTextFont(printer.FONT_A);
													printer.addText(getTextTruncated('  - ' + mainModifier, 42))
												} else {
													printer.addTextFont(printer.FONT_B);
													printer.addText(getTextTruncated('  - ' + mainModifier, 28))
												}

												for (var modifierSpec of modifierItems[mainModifier]) {

													printer.addFeedLine(2);
													printer.addTextAlign(printer.ALIGN_LEFT);
													printer.addTextSize(sdpTextSize, sdpTextSize);
													printer.addTextStyle(false, false, false, printer.COLOR_2);
													if (sdpTextSize === 1){
														printer.addTextFont(printer.FONT_A);
														printer.addText(getTextTruncated('    > ' + modifierSpec, 42))
													} else {
														printer.addTextFont(printer.FONT_B);
														printer.addText(getTextTruncated('    > ' + modifierSpec, 28))
													}
												}
											}
										}

										if (orderObj.items[i].instructions) {

											printer.addTextFont(printer.FONT_A);
											printer.addTextStyle(false, false, false, printer.COLOR_2);
											printer.addTextSize(1, 1);

											var instructions =  'Spl Inst: ' + orderObj.items[i].instructions;
											var instrWordsArray = instructions.split(" ");
											getTextWordWrapped(instrWordsArray);
											printer.addTextStyle(false, false, false, printer.COLOR_1);
										}

								    }

								    // three new lines at the end
								    printer.addFeedLine(3);

								    printer.addCut(printer.CUT_FEED);

								    void 0;
								    printer.send();
							    };

							    printWorker();
						    });
				    } else {
					    void 0;
					    toastr.error('Error connecting to the printer ' + ip);
				    }
			    });
		    },
		    updatePrinterTag() {
                if ($scope.popup.printerData.loading) return;
		    	if ($scope.popup.printerData.data.printers.length) {
			        ngDialog.close();
			    }
		    },
		    addPrinter(form, extended) {
			    if (form.validate()) {
				    $scope.popup.printerData.notification = {
					    message: '',
					    messageClass: ''
				    };

				    $scope.popup.printerData.loading = true;
				    var printers = $scope.popup.printerData.data.printers;
				    printers.push({
				    	ip: $scope.popup.printerData.ip,
				    	name: $scope.popup.printerData.name,
				    });
				    var data = {
					    printers: printers
				    };

				    $http.put(ENV.apiEndPoint + '/location', data)
					    .then(function (res) {
						    void 0;
						    if (res.status === 200) {
							    $scope.popup.printerData.notification.message = 'Printer added successfully.';
							    $scope.popup.printerData.notification.messageClass = 'alert-success';
							    toastr.success('Printer added successfully.');

							    $scope.popup.printerData.toggleAddPrinterSection();
							    $scope.popup.addPrinterInit(extended).then(function () {
                                    $scope.popup.printerData.loading = false;
                                });
						    } else {
							    $scope.popup.printerData.notification.message = 'Error adding printer. Please try again.';
							    $scope.popup.printerData.notification.messageClass = 'alert-danger';
							    toastr.error('Error adding printer. Please try again.');
    						    $scope.popup.printerData.loading = false;
						    }
					    });
			    }
		    },
		    removePrinter(printer, index) {
			    void 0;
			    $scope.popup.printerData.loading = true;
			    $scope.popup.printerData.data.printers.splice(index, 1);
			    var printers = $scope.popup.printerData.data.printers;

			    var data = {
				    printers: printers
			    };

			    $http.put(ENV.apiEndPoint + '/location', data)
				    .then(function (res) {
					    void 0;
					    if (res.status === 200) {
						    $scope.popup.printerData.notification.message = 'Printer removed successfully.';
						    $scope.popup.printerData.notification.messageClass = 'alert-success';
						    toastr.success('Printer removed successfully.');
						    $scope.popup.addPrinterInit();
					    } else {
						    $scope.popup.printerData.notification.message = 'Error removing printer. Please try again.';
						    $scope.popup.printerData.notification.messageClass = 'alert-danger';
						    toastr.error('Error removing printer. Please try again.');
					    }
					    $scope.popup.printerData.loading = false;
				    });
		    },
		    toggleAddPrinterSection() {
			    $scope.popup.printerData.showAddPrinterSection = !$scope.popup.printerData.showAddPrinterSection;
			    if ($scope.popup.printerData.showAddPrinterSection) {
				    $scope.popup.printerData.resetAddPrinterForm();
			    }
		    },
		    resetAddPrinterForm() {
			    $scope.popup.printerData.ip = '';
                $scope.popup.printerData.name = '';
			    $scope.popup.printerData.notification = {
				    message: '',
				    messageClass: ''
			    };
		    }
	    },
	    refund                      : {
        	done                    : false,
		    order                   : {},
		    parent                  : {},
		    amount                  : '',
            availableToRefund: 0,
	    },
	    bags                        : {
        	updatePrinterTag        : false,
		    quantity                : 1,
		    order                   : {},
		    parent                  : {}
	    },
	    delivery                    : {
        	date                    : '',
        	orderGroupIds           : {},
		    driversEmail            : '',
		    radioModel              : 0,
		    drivers                 : [],
		    parent                  : {},
		    selectedDriver          : '',
		    newDriverName           : '',
		    newDriverEmail          : '',
		    dummyDrivers            : [
			    { name: 'Tajinder', email: "driver@driver.com", id: '2342db-asd21b-213bsd-23324hd'},
			    { name: 'Rahul', email: "driver@driver.com", id: '2342db-asd21b-213bsd-23324hd'},
			    { name: 'Add New', email: "driver@driver.com", id: '2342db-asd21b-21sd-23324hd'},
		    ]
	    },
	    taxPopupData                : {},
	    locationData                : {
        	parent              : {},
		    origin              : {
			    lat          : '',
			    lng          : ''
		    },
		    loading             : true,
		    runUpdate           : false,
		    searchPage          : false,
		    showTabularView     : false,
		    openingFromCheckout : false,
		    locationProcessed   : false,
		    showNavigatorOption : true,
		    locations           : [],
		    selectedLocation    : {},
		    savedSelectedLocation: {}
	    },
	    thermalPrinting             : {
        	parent                  : {},
		    orderData               : {},
		    userData                : {},
		    ip                      : ''
	    },
		selectionModel				: {},
	    renderFulfillmentMethods    : false,
	    selectedLocation            : {},
		ageVerification				: {
        	error: '',
        	order: {},
        	parent: {},
        	idTypes: [
        		'state_id', 'drivers_license', 'passport'
			],
			idTypeDisplayName: {
				state_id: 'State Id',
				drivers_license: 'Driver\'s License',
				passport: 'Passport'
			},
        	dob: {
        		dd: '',
        		mm: '',
        		yyyy: ''
			},
			id: {
        		number: '',
				type: ''
			}
		},
	    orderDelivery               : {
        	order                   : false,
		    data                    : true,
		    init                    : function () {
			    this.order = $scope.$parent.admin.adminData.orderDetails.order;
			    this.data = this.order.managedDeliveries || [];
			    void 0;
		    }
	    },
	    staff                       : {
        	addType: '',
		    error: '',
        	firstName: '',
        	lastName: '',
        	driver: false,
        	packer: false,
		    toggleCheck(type) {
        		if (type === 'Driver') {
        			this.driver = !this.driver;
		        }

        		if (type === 'Packer') {
        			this.packer = !this.packer;
		        }
		    },
		    roles: {
        		Driver: 'Delivery Rep',
        		Packer: 'Order Picker'
		    },
		    parent: {},
        	init() {
        		void 0;
        		this.parent = $scope.$parent.admin;
	        },
		    add(form) {
        		if (form.validate()) {
			        $scope.popup.staff.error = '';

        			if (!this.packer && !this.driver) {
			            $scope.popup.staff.error = 'Please assign at least one role to the staff member.';
			            return;
			        }

        			var data = {
        				staffData: {
        					firstName: $scope.popup.staff.firstName,
        					lastName: $scope.popup.staff.lastName,
					        roles: [],
					        operationType: 'Add'
				        }
			        };

        			if (this.packer) {
        				data.staffData.roles.push($scope.popup.staff.roles['Packer']);
			        }

        			if (this.driver) {
        				data.staffData.roles.push($scope.popup.staff.roles['Driver']);
			        }

        			void 0;
        			hsAdmin.updateStaffer(data)
				        .then(function (res) {
				        	if (res.status === 200) {
				        		toastr.success('Staff Member Added Successfully');
				        		$scope.closeThisDialog(true);
					        } else {
				        		$scope.popup.staff.error = 'Error Adding Staff Member';
				        		toastr.error('Error Adding Staff Member');
					        }
				        });
		        }
		    }
	    },
	    packer                      : {
        	packers: [],
		    parent: {},
		    error: '',
		    selectedPacker: '',
		    newPackerName: '',
		    orderPicker: 'Order Picker',
		    isLoading: false,
		    init() {
        		this.parent = {
        			admin: $scope.$parent.admin,
			        order: $scope.$parent.admin.adminData.orderDetails.order
		        };
        		this.packers = $scope.$parent.packers;
        		this.selectedPacker = this.packers[0];
        		$scope.popup.config.pageFullyLoaded = true;
        		void 0;
		    },
		    assignPacker(packerForm) {
        		void 0;
        		if ($scope.popup.packer.isLoading) return;

        		if (packerForm.validate()) {
        			$scope.popup.packer.isLoading = true;
        		    void 0;
        		    void 0;
        		    var data = {
			            order: {
				            key: $scope.popup.packer.parent.order.key,
				            packer: {
					            staffId: $scope.popup.packer.selectedPacker.id
				            }
			            }
		            };

        		    void 0;

			        hsAdmin.assignPacker(data)
				        .then(function(res) {
					        if (res.status === 200) {
						        toastr.success('Assigned packer successfully.');
						        $scope.closeThisDialog(true);
					        } else {
						        $scope.popup.packer.error = 'Something went wrong assigning packer to the order. Please try again.';
						        toastr.error('Something went wrong assigning packer to the order. Please try again.')
					        }
				        })
				        .finally(function () {
				        	$scope.popup.packer.isLoading = false;
				        });
		        }
	        }
	    },
        assignPacker: {
            error: '',
            name: '',
            timeSlot: 'All',
            orderStatus: 'All',
            packingStatus: 'All',
            timeSlots: ['All'],
            orderStatusList: ['All'],
            packingStatusList: ['All'],
            originalOrders: [],
            filteredOrders: [],
            selectedOrders: [],
            packers: [],
            init() {
                hsAdmin.getLocation()
                    .then(function(res) {
                        if (res.status === 200) {
                            $scope.popup.assignPacker.packers = res.data.staff.filter(function(staff) {
                                return staff.roles.includes('Order Picker');
                            });
                            if ($scope.popup.assignPacker.packers.length) {
                                $scope.popup.assignPacker.packer = $scope.popup.assignPacker.packers[0];
                            } else {
                                toastr.error('No Packers available.');
                            }
                        } else {
                            toastr.error('Couldn\'t get list of packers. Please try again.');
                        }
                    });

                $scope.$parent.admin.adminData.selectedOrderType.forEach(function(order) {
                    if (order.state !== 'Cancelled') {
                        if (!$scope.popup.assignPacker.timeSlots.includes(order.deliveryTime)) {
                            $scope.popup.assignPacker.timeSlots.push(order.deliveryTime);
                        }
                        if (!$scope.popup.assignPacker.orderStatusList.includes(order.state)) {
                            $scope.popup.assignPacker.orderStatusList.push(order.state);
                        }
                        if (!$scope.popup.assignPacker.packingStatusList.includes(order.packingStatus)) {
                            $scope.popup.assignPacker.packingStatusList.push(order.packingStatus);
                        }
                        $scope.popup.assignPacker.originalOrders.push(order);
                    }
                });
                this.filterOrders();
            },
            selectOrder(orderToSelect) {
                orderToSelect.checked = !orderToSelect.checked;
                if (orderToSelect.checked) {
                    $scope.popup.assignPacker.selectedOrders.push(orderToSelect.key);
                } else {
                    $scope.popup.assignPacker.selectedOrders.splice($scope.popup.assignPacker.selectedOrders.indexOf(orderToSelect.key), 1);
                }
            },
            filterOrders() {
                if (this.name || this.timeSlot !== "All" || this.packingStatus !== 'All') {
                    var filteredOrders = JSON.parse(JSON.stringify(this.originalOrders));

                    if ($scope.popup.assignPacker.name) {
                        filteredOrders = $filter('filter')(filteredOrders, {'userObj': {fullName: $scope.popup.assignPacker.name}});
                    }
                    if ($scope.popup.assignPacker.timeSlot !== 'All') {
                        filteredOrders = $filter('filter')(filteredOrders, {'deliveryTime': $scope.popup.assignPacker.timeSlot});
                    }
                    if ($scope.popup.assignPacker.packingStatus !== 'All') {
                        filteredOrders = $filter('filter')(filteredOrders, {'packingStatus': $scope.popup.assignPacker.packingStatus});
                    }
                    $scope.popup.assignPacker.filteredOrders = filteredOrders;
                } else {
                    $scope.popup.assignPacker.filteredOrders = JSON.parse(JSON.stringify($scope.popup.assignPacker.originalOrders));
                }
            },
            assign() {
                this.error = '';
                if (this.selectedOrders.length === 0) {
                    this.error = "Please select orders to assign.";
                    return;
                }

                var ordersKeys = this.filteredOrders
                    .filter(function(order) {return order.checked;})
                    .map(function(order) {return order.key;});

                var data = {
                    orderKeys: ordersKeys,
                    packerId: $scope.popup.assignPacker.packer.id,
                };

                hsAdmin.assignStaff(data)
                    .then(function(res) {
                        if (res.status === 200) {
                            toastr.success('Assigned packer successfully.');
                            $scope.closeThisDialog('reload');
                        } else {
                            var message = 'Something went wrong assigning packer to the orders. Please try again.';
                            $scope.popup.assignPacker.error = message;
                            toastr.error(message);
                        }
                    });
            },
            close() {
                $scope.closeThisDialog();
            },
        },
	    assignDelivery              : {
		    parent: {},
		    error: "",
		    order: {},
		    resumeBulkPacking: false,
		    donePacking: false,
		    driver: '',
		    name: '',
		    timeSlot: 'All',
		    orderStatus: 'All',
		    packingStatus: 'All',
		    timeSlots: ['All'],
		    orderStatusList: ['All'],
		    packingStatusList: ['All'],
		    originalOrders: [],
		    selectedOrderType: [],
		    selectedOrders: [],
		    drivers: [],
		    assignDriver() {
			    this.error = '';
			    
			    var data = {
				    order : {
					    keys: [this.order.key],
					    staffId: $scope.popup.assignDelivery.driver.id
				    }
			    };
			    
			    void 0;

			    hsAdmin.assignDriver(data)
				    .then(function(res) {
					    if (res.status === 200) {
						    toastr.success('Assigned driver successfully.');
						    $scope.closeThisDialog(true);
					    } else {
						    $scope.popup.assignDelivery.error = 'Something went wrong assigning driver to the orders. Please try again.';
						    toastr.error('Something went wrong assigning driver to the orders. Please try again.')
					    }
				    });
		    },
		    assign() {
		    	this.error = '';
		    	if (this.selectedOrders.length === 0) {
		    		this.error = "Please select orders to assign.";
		    		return;
			    }

		    	var ordersKeys = this.selectedOrderType
				    .filter(function (order) { return order.checked})
				    .map(function (order) { return order.key});

		    	void 0;
		    	var data = {
		    		order : {
		    			keys: ordersKeys,
					    staffId: $scope.popup.assignDelivery.driver.id
				    }
			    };

		    	hsAdmin.assignDriver(data)
				    .then(function(res) {
				    	if (res.status === 200) {
				    		toastr.success('Assigned driver successfully.');
				    		$scope.closeThisDialog(true);
					    } else {
				    		$scope.popup.assignDelivery.error = 'Something went wrong assigning driver to the orders. Please try again.';
				    		toastr.error('Something went wrong assigning driver to the orders. Please try again.')
					    }
				    });
		    },
		    close() {
		    	this.reset();
		    	$scope.closeThisDialog();
		    },
		    filterOrders() {
			    if (this.name || this.timeSlot !== "All" || this.orderStatus !== 'All') {
				    void 0;
				    var filteredOrders = JSON.parse(JSON.stringify(this.originalOrders));

				    void 0;

				    if ($scope.popup.assignDelivery.name) {
					    filteredOrders = $filter('filter')(filteredOrders, { "userObj": {fullName: $scope.popup.assignDelivery.name}});
					    void 0
				    }

				    if ($scope.popup.assignDelivery.timeSlot !== "All") {
					    filteredOrders = $filter('filter')(filteredOrders, { "deliveryTime": $scope.popup.assignDelivery.timeSlot});
				    }

				    if ($scope.popup.assignDelivery.orderStatus !== "All") {
					    filteredOrders = $filter('filter')(filteredOrders, { "state": $scope.popup.assignDelivery.orderStatus});
				    }

				    $scope.popup.assignDelivery.selectedOrderType = filteredOrders;
			    } else {
				    $scope.popup.assignDelivery.selectedOrderType = JSON.parse(JSON.stringify($scope.popup.assignDelivery.originalOrders));
			    }
		    },
		    init() {
			    this.reset();
			    this.parent = $scope.$parent.admin;
			    this.order = $scope.$parent.admin.adminData.orderDetails.order;
			    hsAdmin.getLocation()
				    .then(function(res) {
					    if (res.status === 200) {
						    void 0;
						    res.data.staff.forEach(function (staff) {
							    if (staff.roles.indexOf('Delivery Rep') !== -1) {
								    $scope.popup.assignDelivery.drivers.push(staff);
							    }
						    });

						    if ($scope.popup.assignDelivery.drivers.length) {
							    $scope.popup.assignDelivery.driver = $scope.popup.assignDelivery.drivers[0];
						    } else {
							    toastr.error("No drivers available.")
						    }
					    } else {
						    toastr.error("Couldn't get list of drivers. Please try again.")
					    }
				    });

			    var originalOrders = $scope.$parent.admin.adminData.selectedOrderType;
			    var timeSlots = [];
			    this.driver = this.drivers[0];

			    originalOrders.forEach(function (order) {
			    	void 0;
			    	if (order.fulfillmentMethod === 'delivery' && order.state !== 'Cancelled') {
					    if ($scope.popup.assignDelivery.timeSlots.indexOf(order.deliveryTime) === -1
						    && timeSlots.indexOf(order.deliveryTime) === -1) {
						    timeSlots.push(order.deliveryTime);
					    }

					    if ($scope.popup.assignDelivery.orderStatusList.indexOf(order.state) === -1) {
						    $scope.popup.assignDelivery.orderStatusList.push(order.state);
					    }

					    $scope.popup.assignDelivery.originalOrders.push(order);
				    }
			    });

			    $scope.popup.assignDelivery.timeSlots = ['All'].concat(timeSlots.sort());
			    this.filterOrders();
		    },
		    selectOrder(event, order) {
			    event.stopPropagation();

			    order.checked = !order.checked;
			    if (order.checked) {
				    $scope.popup.assignDelivery.selectedOrders.push(order.key);
			    } else {
				    $scope.popup.assignDelivery.selectedOrders.splice($scope.popup.assignDelivery.selectedOrders.indexOf(order.key), 1);
			    }


			    this.originalOrders.forEach(function (o) {
			    	if (o.key === order.key) {
			    		o.checked = order.checked;
				    }
			    });
		    },
		    reset() {
			    this.packedItems = [];
			    this.selectedOrderType = [];
			    this.selectedOrders = [];
		    }
	    },
	    bulkPacking                 : {
        	steps: {
        		pickOrders: true,
		        pickItems: false
	        },
		    parent: {},
		    error: "",
		    resumeBulkPacking: false,
		    donePacking: false,
		    selectedOrderType: [],
		    selectedOrders: [],
		    selectedOrdersObj: [],
		    allItems: [],
		    sortedAllItems: {},
		    packedItems: [],
		    allProductsByOrder: {},
		    getAllProducts: function (orderDetails, cb) {
        		if($scope.popup.bulkPacking.allProductsByOrder[orderDetails.key]) {
        			cb(null, $scope.popup.bulkPacking.allProductsByOrder[orderDetails.key]);
        			return;
		        }


			    var productList;
			    var req = {
				    method: 'GET',
				    url: ENV.apiEndPoint + '/product/list',
				    headers: {}
			    };

			    req.headers['location'] = orderDetails.location;

			    if (ENV.enablePriceList) {
				    req.headers['pricelist'] = orderDetails.priceList;
			    }

			    productList = $http(req);

			    $q.all([productList])
				    .then(function (response) {
					    void 0;
					    if (response[0].status === 200) {
						    var data = globalFunctions.getSortedProducts(response[0].data.products);
						    var allProducts = data.allProducts;
						    var hiddenProducts = data.hiddenProducts;
						    var outOfStockProducts = [];
						    var allOutOfStockProducts = data.outOfStockProducts;
						    var sortedData = data.sortedData;

						    var sortedCategories = [];
						    Object.keys(sortedData)
							    .sort()
							    .forEach(function (category, idx) {
								    sortedCategories.push(sortedData[category]);
							    });


						    sortedCategories.forEach(function (category) {
							    angular.forEach(category.categories, function (val, key) {
								    val.products = globalFunctions.filterProducts(val.products, $rootScope.screenWidth);
							    });
						    });

						    var productData = {
							    allProducts : allProducts,
							    outOfStockProducts : outOfStockProducts,
							    originalCategorizedProducts : sortedCategories,
							    categorizedProducts : sortedCategories
						    };
						    
						    $scope.popup.bulkPacking.allProductsByOrder[orderDetails.key] = productData;
						    void 0;

						    cb(null, productData);
					    }
				    })
				    .catch(function (response) {
					    void 0;
					    cb(true, null);
				    });
		    },
		    showAddItemPopup(replaceItem, productData) {
			    $scope.replaceItem = replaceItem;
			    $scope.productData = productData;
			    $scope.fromBulkPacking = true;

			    ngDialog.open({
				    template        : 'partials/popup/add-item-to-order-popup.html',
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default add-item-to-order-dialog',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : true,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'add-item-to-order',
				    id              : 'add-item-to-order',
                    data: {
                        title: 'Replace Item',
                        searchPlaceHolder: 'Search For Replacement',
                    },
				    preCloseCallback(val) {
					    if (replaceItem && val && val.replaced) {
						    $scope.popup.bulkPacking.parent.initOrderDashboard();

						    setTimeout(function() {
							    $scope.popup.bulkPacking.init();
						    }, 1000);
					    }
				    }
			    });
		    },
		    replaceItem(item, category) {
        		void 0;
                // TODO: Figure out if "getAllProducts" call here can be avoided.
        		this.getAllProducts(item.order, function(err, productData) {
        			if (err) {
        				toastr.error('Error getting products for the order. Please try again.');
			        } else {
        				void 0;
        				$scope.popup.bulkPacking.showAddItemPopup(item, productData);
			        }
		        });
		    },
		    updatePackItemQuantity (item, updateType, quantityBtnSelector) {
			    quantityBtnSelector = '#' + quantityBtnSelector;

        		if ((updateType === 'add' && item.quantity === parseFloat($(quantityBtnSelector).val()))
		            || (updateType === 'subtract' && parseFloat($(quantityBtnSelector).val()) === 0)) {
        			return;
		        }
			    hsCart.updateQuantity(item, updateType, quantityBtnSelector);
		    },
		    removeItem(item, category) {
                void 0;

                var $removeItemScope = $scope.$new(true);
                $removeItemScope.isTableSideOrder = item.isTableSideOrder;
                $removeItemScope.removeItem = _removeItem;

                return ngDialog.open({
                    template: '<div><remove-item '
                        + 'is-table-side-order="isTableSideOrder" '
                        + 'on-confirm="removeItem(reason)" '
                        + 'on-close="closeThisDialog(value)" '
                        + '><remove-item/></div>',
                    className: 'ngdialog-theme-default',
                    plain: true,
                    scope: $removeItemScope,
                });

                function _removeItem(reason) {
                    var data = {
                        key: encodeURIComponent(item.orderKey),
                        itemName: encodeURIComponent(item.name),
                        selectedModifiers : item.selectedModifiers || [],
                        reason: reason || '',
                    };

                    return hsAdmin.removeItemFromOrder({ order: data })
                        .then(function(res) {
                            if (res.status === 200) {
                                void 0;
                                void 0;

                                var indexForItemToRemove = $scope.popup.bulkPacking.allItems.findIndex(function(savedItem) {
                                    return (savedItem.orderKey === item.orderKey && savedItem.name === item.name);
                                });

                                $scope.popup.bulkPacking.allItems.splice(indexForItemToRemove, 1);

                                var indexForSortedItemToRemove = $scope.popup.bulkPacking.sortedAllItems[category].products.findIndex(function(savedItem) {
                                    return (savedItem.orderKey === item.orderKey && savedItem.name === item.name);
                                });

                                $scope.popup.bulkPacking.sortedAllItems[category].products.splice(indexForSortedItemToRemove, 1);

                                void 0;
                                void 0;

                                if ($scope.popup.bulkPacking.sortedAllItems[category].products.length === 0) {
                                    delete $scope.popup.bulkPacking.sortedAllItems[category];
                                }
                                return 'success';
                            } else {
                                void 0;
                                item.isUpdating = false;
                                var message = 'Error removing item from cart.';
                                toastr.error(message);
                                return message;
                            }
                        }).catch(function(err) {
                            void 0;
                            var message = 'Something went wrong';
                            toastr.error(message);
                            return message;
                        });
                }
		    },
		    reset() {
        		this.packedItems = [];
			    this.selectedOrderType = [];
				this.selectedOrders = [];
				this.selectedOrdersObj = [];
				this.allItems = [];
				this.sortedAllItems = {};
				this.packedItems = [];
		    },
		    clear() {
			    ngDialog.openConfirm({
				    data: {
					    heading: 'Unsaved Changes',
					    subHeading: 'Are you sure you want to clear the session? All the progress will be deleted.',
					    confirmBtnText: 'Confirm',
					    cancelBtnText: 'Cancel'
				    },
				    template: 'partials/popup/confirm-popup.html'
			    }).then(function (confirm) {
				    localStorageService.remove('bulkPacking');
				    $scope.popup.bulkPacking.selectedOrderType.forEach(function(order) {
					    order.checked = false;
				    });
				    $scope.popup.bulkPacking.parent.orderManager.resumeBulkPacking = false;
				    ngDialog.close();
			    }, function (reject) {
				    void 0;
				    return;
			    });
		    },
		    finish() {
			    localStorageService.remove('bulkPacking');
			    $scope.popup.bulkPacking.selectedOrderType.forEach(function(order) {
				    order.checked = false;
			    });
			    $scope.popup.bulkPacking.parent.orderManager.resumeBulkPacking = false;
			    ngDialog.close();
		    },
		    close() {
			    if ($scope.popup.bulkPacking.packedItems.length !== 0
			        && $scope.popup.bulkPacking.allItems.length === $scope.popup.bulkPacking.packedItems.length) {
			    	$scope.popup.bulkPacking.finish();
			    } else {
				    ngDialog.close();
			    }
		    },
		    backToOrderSelection() {
        		this.changeStep('pickOrders', false);
		    },
		    changeStep(step, init) {
        		angular.forEach($scope.popup.bulkPacking.steps, function(val, key) {
			        $scope.popup.bulkPacking.steps[key] = (key === step);
		        });

			    $scope.popup.bulkPacking.parent.orderManager.resumeBulkPacking = true;

			    if($scope.popup.bulkPacking.steps.pickItems && init) {
				    $scope.popup.bulkPacking.allItems = [];
				    $scope.popup.bulkPacking.sortedAllItems = {};
				    $scope.popup.bulkPacking.packedItems = [];
	                $scope.popup.bulkPacking.initPicking(true);
			    }
	        },
		    pack(item, order, btnId) {
        		if (item.unit !== 'lb') {
			        var quantity = parseFloat($(btnId).val());

			        if (item.quantity !== quantity) {
				        toastr.error('Make sure you are picking the correct quantity needed');
				        return;
			        }
		        }


        		item.packed = true;

        		var allPacked = true;
        		order.products.forEach(function(prod) {
        			if (prod.packed === false) {
        				allPacked = false;
			        }
		        });

        		order.allPacked = allPacked;

			    $scope.popup.bulkPacking.parent.orderManager.resumeBulkPacking = true;
        		$scope.popup.bulkPacking.packedItems.push({name: item.name, orderKey: item.orderKey, exist: true});

        		if ($scope.popup.bulkPacking.packedItems.length > 0
			        && $scope.popup.bulkPacking.allItems.length === $scope.popup.bulkPacking.packedItems.length) {
        			$scope.popup.bulkPacking.donePacking = true;
        			$scope.popup.bulkPacking.selectedOrders = [];
        			$scope.popup.bulkPacking.packedItems = [];
        			$scope.popup.bulkPacking.selectedOrderType.forEach(function(order){
        				order.checked = false;
			        });
			        $scope.popup.bulkPacking.parent.orderManager.resumeBulkPacking = false;
		        }
        		
        		void 0;

        		$scope.popup.bulkPacking.saveState();
		    },
		    saveState() {
        		localStorageService.set('bulkPacking', {
        			selectedOrders: $scope.popup.bulkPacking.selectedOrders,
			        packedItems: $scope.popup.bulkPacking.packedItems
		        });
		    },
		    init() {
        		// clearing/resetting the state to start fresh everytime popup launches
        		this.reset();
			    $scope.popup.bulkPacking.parent = $scope.$parent.admin;
        		$scope.popup.bulkPacking.selectedOrderType = $scope.$parent.admin.adminData.selectedOrderType;
			    $scope.popup.bulkPacking.selectedOrderType.forEach(function(order) {
			    	if (order.checked) {
					    $scope.popup.bulkPacking.selectedOrders.push(order.key);
					    $scope.popup.bulkPacking.selectedOrdersObj.push(order);
				    }
			    });

			    $scope.popup.bulkPacking.initPicking();
		    },
        	initPicking() {
        		// Checking localStorage for packedItems
		        var bulkPacking = localStorageService.get('bulkPacking');
		        if (bulkPacking && bulkPacking.hasOwnProperty('packedItems')) {
			        $scope.popup.bulkPacking.packedItems = bulkPacking.packedItems;
		        }

		        // Checking for selected orders and concatenating them resetting packed status and adding order key to each for tracking purposes
		        $scope.popup.bulkPacking.selectedOrderType.forEach(function(order) {
			        if (order.checked) {
				        order.items.forEach(function(item) {
                            item.order = order;
                            item.bulkPacking = true;
                            item.orderKey = order.key;
                            item.packed = false;
                            item.isTableSideOrder = !!order.tableNumber;
				        });
				        $scope.popup.bulkPacking.allItems = $scope.popup.bulkPacking.allItems.concat(order.items);
			        }
		        });


		        // Iterating through packed items against all items to check packed status.
		        $scope.popup.bulkPacking.packedItems.forEach(function(packedItem) {
		        	packedItem.exist = false;
			        $scope.popup.bulkPacking.allItems.forEach(function(item) {
				        if (item.name === packedItem.name && item.orderKey === packedItem.orderKey) {
					        item.packed = true;
					        packedItem.exist = true;
				        }
			        });
		        });

		        // Removing any previously packed item that's no longer part of allItems array
		        $scope.popup.bulkPacking.packedItems = $scope.popup.bulkPacking.packedItems
			        .filter(function(item) {
			        	return item.exist === true;
			        });

		        // Sorting All Items into categories.
		        $scope.popup.bulkPacking.sortedAllItems = globalFunctions.filterProductsByCategory($scope.popup.bulkPacking.allItems);

		        // Checking if all items in the category are packed.
		        angular.forEach($scope.popup.bulkPacking.sortedAllItems, function(val, key) {
			        var allPacked = true;
			        val.products.forEach(function(product) {
				        if (product.packed === false) {
					        allPacked = false;
				        }
			        });

			        val.allPacked = allPacked;
		        });

		        // Checking if all items are packed to show Done screen.
		        if ($scope.popup.bulkPacking.packedItems.length > 0
			        && $scope.popup.bulkPacking.allItems.length === $scope.popup.bulkPacking.packedItems.length) {
			        $scope.popup.bulkPacking.donePacking = true;
		        }

		        // changing the view to Pick items if there are any packed item in the previous session.
		        if($scope.popup.bulkPacking.packedItems.length > 0) {
			        $scope.popup.bulkPacking.changeStep('pickItems', false);
		        }
	        },
		    selectOrder(event, order) {
			    event.stopPropagation();

			    order.checked = !order.checked;

			    if (order.checked) {
				    $scope.popup.bulkPacking.selectedOrders.push(order.key);
				    $scope.popup.bulkPacking.selectedOrdersObj.push(order);
			    } else {
				    $scope.popup.bulkPacking.selectedOrders.splice($scope.popup.bulkPacking.selectedOrders.indexOf(order.key), 1);
				    $scope.popup.bulkPacking.selectedOrdersObj = $scope.popup.bulkPacking.selectedOrdersObj
					    .filter(function(selectedOrder) {
						    return selectedOrder.key !== order.key;
					    });
			    }

			    $scope.popup.bulkPacking.updateBulkPackingLocalStorage();
		    },
		    updateBulkPackingLocalStorage() {
			    $scope.popup.bulkPacking.error = "";
			    var bulkPacking = localStorageService.get('bulkPacking') || {};

			    bulkPacking.selectedOrders = $scope.popup.bulkPacking.selectedOrders;
			    bulkPacking.packedItems = $scope.popup.bulkPacking.packedItems;

			    localStorageService.set('bulkPacking', bulkPacking);
		    }
	    },
	    scheduleDelivery            : {
        	loading                 : true,
		    processingForm          : false,
        	gotQuote                : false,
		    hideDeliveryOptions     : false,
		    deliveryTimeType        : 'asap',
		    deliveryTime            : '',
		    availableDeliveryTimes  : [],
		    closeDialog             : function () {
        		ngDialog.close();
		    },
		    updateDeliveryTime      : function () {
        		this.deliveryTimeType = 'custom';
		    },
		    message                 : {
        		text                : "",
			    class               : ""
		    },
        	options                 : {
        		order               : {},
		        parent              : {},
		        quote               : {}
	        },
			selectedDeliveryProvider: "",
			providerNames: {
				postmates: 'Uber Eats',
				doordash: 'Doordash',
                uberDaas: 'Uber Eats',
			},
		    confirmDelivery         : function() {
        		this.processingForm = true;
        		var reqBody = {
			        orderKey: this.options.order.key,
					deliveryProvider: $scope.popup.scheduleDelivery.selectedDeliveryProvider,
		        };

        		switch (this.deliveryTimeType) {
			        case 'asap':
				        reqBody.scheduleAsap = true;
			        	break;
			        case 'custom':
				        reqBody.scheduleAsap = false;
				        reqBody.deliveryHour = $scope.popup.scheduleDelivery.deliveryTime.timeOriginal.hours();
				        reqBody.deliveryMin = $scope.popup.scheduleDelivery.deliveryTime.timeOriginal.minutes();
			        	break;
		        }
		        
		        void 0;
			    $http.post(ENV.apiEndPoint + '/order/delivery', reqBody)
				    .then(function(res){
					    void 0;
					    switch (res.status) {
						    case 200:
							    $scope.popup.scheduleDelivery.gotQuote = true;
							    toastr.success('Delivery scheduled successfully.');
							    $scope.popup.scheduleDelivery.options.parent.initOrderDetails();
							    ngDialog.close();
							    break;
						    case 403:
							    toastr.error('Delivery cannot be scheduled for this order at the moment.');
							    $scope.popup.scheduleDelivery.message.text = "Delivery cannot be scheduled for this order at the moment.";
							    $scope.popup.scheduleDelivery.message.class = "alert-danger";
							    $scope.popup.scheduleDelivery.hideDeliveryOptions = true;
							    break;
						    default:
							    toastr.error('Something went wrong. Please try again.');
							    $scope.popup.scheduleDelivery.message.text = "Something went wrong. Please try again.";
							    $scope.popup.scheduleDelivery.message.class = "alert-danger";
							    break;
					    }

					    $scope.popup.scheduleDelivery.processingForm = false;
				    });
		    },
		    getTimeSlots            : function() {
        		var times = [];
        		var today = moment();
        		var endOfToday = moment().endOf('day');
        		var duration = moment.duration(endOfToday.diff(today));

        		// if at least 1 hr is available in the day then try to calculate time
        		if (duration.asHours() > 1) {
        			// adding 1 hour to the current time and rounding it up to the next 30min or 60min mark
			        var firstTime = today.add(1, 'hours');
			        if (firstTime.minutes() > 30) {
				        firstTime = firstTime.add(60 - firstTime.minutes(), 'minutes').seconds(0);
			        } else {
				        firstTime = firstTime.add(30 - firstTime.minutes(), 'minutes').seconds(0);
			        }

			        // adding first entry in the dropdown with the rounded up time
			        times.push({
				        formatted: firstTime.format("hh:mm A"),
				        timeOriginal: firstTime
			        });

			        // calculating the difference from the first value to create 30 mins intervals for remaining time
			        var nextDuration = moment.duration(endOfToday.diff(firstTime));
			        var timeDurationCounter = parseInt(nextDuration.asHours()) * 2;
			        var nextDurationMins = moment(nextDuration.asMilliseconds()).format('mm');

			        // after checking for hours checking for minutes to see if more than 30 mins available so we can create an interval
			        if (nextDurationMins > 30) {
			        	timeDurationCounter++;
			        }


			        // setting a start time and updating it in the loop to keep track of the previous interval
			        var startTime = moment(firstTime);
			        for(var i = 0; i < timeDurationCounter; i++) {
				        startTime = startTime.add(30, 'minutes').seconds(0);
				        times.push({
					        formatted: startTime.format("hh:mm A"),
					        timeOriginal: moment(startTime)
				        });
			        }
			        
			        void 0;

			        $scope.popup.scheduleDelivery.availableDeliveryTimes = times;
			        $scope.popup.scheduleDelivery.deliveryTime = times[0];
		        } else {
			        $scope.popup.scheduleDelivery.message.text = "Delivery cannot be scheduled for this order at the moment.";
			        $scope.popup.scheduleDelivery.message.class = "alert-danger";
			        $scope.popup.scheduleDelivery.gotQuote = false;
		        }
		    },
			getCheapestProvider: function(deliveryQuotes) {
				
				var selectedProvider = '';
				var cheapestProvider = Number.POSITIVE_INFINITY;

				for (var provider in deliveryQuotes) {
					if (deliveryQuotes[provider].quote && deliveryQuotes[provider].quote.fee < cheapestProvider) {
						cheapestProvider = deliveryQuotes[provider].quote.fee;
						selectedProvider = provider;
					}
				}
				return selectedProvider;
			},
		    getDeliveryQuote        : function (orderKey) {
        		var requestBody = {
			        orderKey: orderKey
		        };
				
        		void 0;

			    $http.post(ENV.apiEndPoint + '/order/delivery/quoteMultiple', requestBody)
				    .then(function(res){
					    void 0;
					    switch (res.status) {
						    case 200:
						    	$scope.popup.scheduleDelivery.options.quote = res.data;
						    	$scope.popup.scheduleDelivery.gotQuote = true;
								$scope.popup.scheduleDelivery.selectedDeliveryProvider = $scope.popup.scheduleDelivery.getCheapestProvider(res.data);
						    	break;
						    case 403:
							    $scope.popup.scheduleDelivery.gotQuote = false;
							    $scope.popup.scheduleDelivery.message.text = "Delivery cannot be scheduled for this order at the moment.";
							    $scope.popup.scheduleDelivery.message.class = "alert-danger";
						    	break;
						    default:
							    $scope.popup.scheduleDelivery.gotQuote = false;
							    $scope.popup.scheduleDelivery.message.text = "Something went wrong. Please try again.";
							    $scope.popup.scheduleDelivery.message.class = "alert-danger";
						    	break;
					    }

					    $scope.popup.scheduleDelivery.loading = false;
				    });
		    },
			selectDeliveryProvider: function (name) {
				$scope.popup.scheduleDelivery.selectedDeliveryProvider = name;
			},
			getProviderDisplayName: function (name) {
				return $scope.popup.scheduleDelivery.providerNames[name] || '';
			},
			hasMultipleDeliveryProviders: function() {
				return Object.keys($scope.popup.scheduleDelivery.options.quote).length > 1;
			},
			getScheduleButtonDisplayName: function() {
				var multipleProviders = $scope.popup.scheduleDelivery.hasMultipleDeliveryProviders();
				var provider = $scope.popup.scheduleDelivery.selectedDeliveryProvider
				var providerDisplayName = $scope.popup.scheduleDelivery.getProviderDisplayName(provider);
				if (multipleProviders) {
					return 'Deliver with ' + providerDisplayName;
				} else {
					return 'Deliver';
				}
			},
        	init                    : function () {
		        this.options.order = $scope.$parent.admin.adminData.orderDetails.order;
		        this.options.parent = $scope.$parent.admin;
		        this.getTimeSlots();
		        this.getDeliveryQuote(this.options.order.key);
		        void 0;
	        }
	    },
	    categoryFilter              : {
		    order: {},
		    sortedItems: {},
		    parent: {},
		    filters: [],
		    init() {
			    this.order = $scope.$parent.admin.adminData.orderDetails.order;
			    this.sortedItems = JSON.parse(JSON.stringify($scope.$parent.admin.adminData.orderDetails.order.sortedItems));
			    angular.forEach(this.sortedItems, function(category, key) {
				    if (category.checked) {
					    $scope.popup.categoryFilter.filters.push(category.name);
				    }
			    });
			    void 0;
			    this.parent = $scope.$parent.admin;
		    },
		    toggleCheckbox(category) {
			    category.checked = !category.checked;
			    if (category.checked) {
				    this.filters.push(category.name);
			    } else {
				    this.filters.splice(this.filters.indexOf(category.name), 1);
			    }
		    },
		    apply() {
			    if (this.filters.length) {
				    angular.forEach($scope.popup.categoryFilter.order.sortedItems, function(category, key) {
					    category.checked = $scope.popup.categoryFilter.filters.indexOf(category.name) >= 0;
				    });

				    $scope.popup.categoryFilter.parent.categoryFilter = $scope.popup.categoryFilter.filters;
				    void 0;
				    ngDialog.close();
			    } else {
				    $scope.popup.categoryFilter.clear();
			    }
		    },
		    clear() {
			    this.filters = [];
			    this.parent.categoryFilter = [];
			    angular.forEach($scope.popup.categoryFilter.order.sortedItems, function(category, key) {
				    category.checked = true;
			    });
			    ngDialog.close();
		    }
	    },
	    replaceItem                 : {
        	parent: {
        		admin: {},
		        replaceItem : {},
		        order: {}
	        },
		    replace() {
        		this.parent.admin.adminData.showAddItemPopup(this.parent.replaceItem, 'replace');
		        $scope.closeThisDialog();
		    },
		    remove () {
        		this.parent.admin.removeItemFromOrder(this.parent.order, this.parent.replaceItem);
		        $scope.closeThisDialog();
		    },
		    init() {
			    void 0;
			    this.parent.admin = $scope.$parent.admin;
			    this.parent.replaceItem = $scope.$parent.replaceItem;
			    this.parent.order = $scope.$parent.admin.adminData.orderDetails.order;
			    void 0;
			    /*this.parent = $scope.$parent.admin;
			    $scope.popup.productData.order = this.parent.adminData.orderDetails.order;
			    $scope.popup.productData.allProducts = this.parent.productData.allProducts;
			    $scope.popup.productData.categorizedProducts = this.parent.productData.categorizedProducts;
			    $scope.popup.productData.outOfStockProducts = this.parent.productData.outOfStockProducts;
			    $scope.popup.productData.originalCategorizedProducts = this.parent.productData.originalCategorizedProducts;

			    $scope.popup.config.pageFullyLoaded = true;*/
		    },
	    },
	    productData                 : {
        	parent: {},
		    activeTabIndex: 0,
		    searchThreshold: 20,
		    order: {},
		    replaceItem: false,
		    fromBulkPacking: false,
		    organic: false,
		    searchResults: false,
		    searching: false,
		    searched: false,
		    searchedQuery: '',
            searchTypes: {
                productName: 'productName',
                upc: 'upc',
            },
            searchedUpc: '',
		    searchQuery: '',
		    category: '',
		    subCategory: '',
		    categoryOrder: [],
		    allProducts: [],
		    outOfStockProducts: [],
		    originalCategorizedProducts: [],
		    searchData: [],
		    tableSideOrder: {
        		error: '',
			    loading: false,
			    showSummary: false,
			    basket: [],
			    toggleSummary() {
                    hsTableSideOrders.refreshSession();

			    	this.showSummary = !this.showSummary;

			    	if (this.showSummary) {
			    		var basket = localStorageService.get('orderBasket');
                        // Removeing this due to inconsistencies with modifier items.
                        // Need to find a way to reconnect the items from the basket to display quantity badges

                        // var basketMap = {};
                        // var connectedBasket = [];

                        // if (basket && basket.length) {
                        //     for (var item of basket) {
                        //         basketMap[item.name] = item;
                        //     }

                        //     main:
                        //     for (var cat of Object.keys($scope.popup.productData.categoryOrder)) {
                        //         var menuProducts = $scope.popup.productData.categoryOrder[cat].menuProducts;
                        //         for (var item of menuProducts) {
                        //             if (item.name in basketMap) {
                        //                 connectedBasket.push(item);
                        //                 delete basketMap[item.name];
                        //                 if (!Object.keys(basketMap).length) break main;
                        //             }
                        //         }
                        //     }

                        //     if (Object.keys(basketMap).length) {
                        //         // these would be container items
                        //         connectedBasket = connectedBasket.concat(Object.values(basketMap));
                        //     }
                        // }

                        // this.basket = connectedBasket || [];
                        this.basket = basket || { items: [] };

                        $scope.popup.productData.tableSideOrder.addPromotionsToItems();
				    }
			    },
                addPromotionsToItems() {
                    if ($scope.popup.productData.tableSideOrder.basket && Array.isArray($scope.popup.productData.tableSideOrder.basket.items)) {
                        var items = $scope.popup.productData.tableSideOrder.basket.items;
                        for (var i = 0; i < items.length; i++) {
                            hsPromos.addPromotionToItem(items[i]);
                        }
                    }
                },
			    getModifierItemName(item) {
				    var nameObj = {
				    	name: item.name,
					    selectedModifiers: []
				    };

				    if (item.selectedModifiers) {
					    item.selectedModifiers.forEach(function(modifier) {
						    nameObj.name += '-' + modifier.name || modifier;

						    if (modifier.name) {
						    	nameObj.selectedModifiers.push(modifier.name);
						    } else {
						    	nameObj.selectedModifiers.push(modifier);
						    }
					    });
				    }
				    return nameObj;
			    },
			    addToOrder() {
			    	var basket = localStorageService.get('orderBasket');

			    	if (!basket || !Array.isArray(basket.items) || !basket.items.length) {
			    		toastr.error('No items to add to the order.');
			    		return;
				    }

				    $scope.popup.productData.tableSideOrder.error = '';
				    $scope.popup.productData.tableSideOrder.loading = true;

                    var data = {
                        key: $scope.popup.productData.order.key,
                        items: basket.items,
                    };

                    hsAdmin.updateOrderDetails({ order: data })
                        .then(function(res) {
                            if (res.status === 200) {
                                toastr.success('Added items to order successfully.');
                                localStorageService.remove('orderBasket');
                                ngDialog.close();
                                return;
                            }
                            $scope.popup.productData.tableSideOrder.error = 'Something went wrong adding items. Please try again.';
                            toastr.error($scope.popup.productData.tableSideOrder.error);
                        })
                        .catch(function(err) {
                            void 0;
                            $scope.popup.productData.tableSideOrder.error = 'Something whent wrong.';
                            toastr.error($scope.popup.productData.tableSideOrder.error);
                        })
                        .finally(function() {
                            $scope.popup.productData.tableSideOrder.loading = false;
                        });
			    },
			    showProductPopup(product) {
				    void 0;
				    var modalClass = '';
				    if(product.hasImage){
					    modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
				    }else{
					    modalClass = 'ngdialog-theme-default email-capture';
				    }

				    ngDialog.open({
					    template: 'partials/popup/product-item/product-item-popup.html',
					    controller:'ModalController',
					    className: modalClass,
					    data: product,
					    preCloseCallback(val) {
					    	var basket = localStorageService.get('orderBasket');
					    	$scope.popup.productData.tableSideOrder.basket = basket;
					    }
				    });
			    },
			    updateQuantity(item, index, updateType, category) {
                    hsTableSideOrders.refreshSession();

				    var quantityBtnSelector = '#quantity-' + index;
				    var updateBtnSelector = '#update-btn-' + index;

				    var quantity = $(quantityBtnSelector).val();

				    if (updateType === 'add'
					    && item.hasOwnProperty('maxQuantity')
					    && item.maxQuantity > 0
					    && quantity >= item.maxQuantity) {
					    item.quantity = item.maxQuantity;
					    if (item.hasOwnProperty('maxQuantityMessage')) {
						    toastr.error(item.maxQuantityMessage);
					    } else {
						    toastr.error(globalFunctions.product.maxQuantityError(item.maxQuantity));
					    }

					    return;
				    }

				    hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
			    },
			    updateItemInCart(item, index, category) {
				    void 0;
				    void 0;

				    var quantity = $('#quantity-' + index).val();
				    quantity = parseFloat(quantity);

				    var basket = localStorageService.get('orderBasket');
				    item.quantity = quantity;

				    if(basket && Array.isArray(basket.items)){
					    var sameItem = false;
					    basket.items.forEach(function (basketItem) {
						    if(basketItem.name === item.name){
							    basketItem.quantity = item.quantity;
							    sameItem = true;

							    if (!item.hasOwnProperty('canReplace')) {
								    item.canReplace = true;
								    item.leaveOut = false;
							    } else {
								    item.leaveOut = !item.canReplace;
							    }
						    }
					    });

					    if (!sameItem) {
						    basket.items.push(item);
						    toastr.success('Quantity updated successfully.');
					    } else {
						    toastr.success('Item added successfully.');
					    }

					    localStorageService.set('orderBasket', basket);
					    $scope.popup.productData.tableSideOrder.basket = basket;

				    } else {
					    basket = { items: [] };
					    basket.items.push(item);
					    localStorageService.set('orderBasket', basket);
					    toastr.success('Item added successfully.');
					    $scope.popup.productData.tableSideOrder.basket = basket;
				    }
                    $scope.popup.productData.tableSideOrder.addPromotionsToItems();

				    $('#update-btn-' + index).addClass('hidden');
			    },
			    removeItem(item) {
				    void 0;
				    void 0;

				    var basket = localStorageService.get('orderBasket');
				    var itemIndex = 0;

				    basket.items.forEach(function (product, idx) {
					    if (product.name === item.name) {

                            if (item.hasModifiers) {
                                var itemModifiers = item.selectedModifiers.map(function(m) { return m.displayName });
                                var productModifiers = product.selectedModifiers.map(function(m) { return m.displayName });
                                if (itemModifiers.length === productModifiers.length) {
                                    var match = itemModifiers.every(function(m) { return productModifiers.includes(m); });
                                    if (match) {
                                        itemIndex = idx;
                                    }
                                }
                                
                            } else {
                                itemIndex = idx;
                            }
					    }
				    });

				    basket.items.splice(itemIndex, 1);

				    this.basket = basket;

				    localStorageService.set('orderBasket', basket);

				    item.quantity = 0;
				    item.showRemoveBtn = false;

                    var orderItem = $scope.popup.productData.order && $scope.popup.productData.order.items.find(function(i) {
                        return i.name === item.name;
                    });
                    if (orderItem) {
                        void 0
                        item.quantity = orderItem.quantity;
                    }
                    $scope.popup.productData.tableSideOrder.addPromotionsToItems();
			    },
        		close() {
        			ngDialog.close();
                    hsTableSideOrders.refreshSession();
		        }
		    },
		    closeDialogsExceptBulkPacking() {
        		ngDialog.getOpenDialogs().forEach(function(dialog) {
        			if (dialog !== 'bulkpacking-dialog') {
				        ngDialog.close(dialog, {replaced: true});
			        }
		        });
		    },
		    showMobileSearchFilters: false,
		    searchMobile : {
			    category: '',
			    subCategory: '',
			    organic: false,
			    clearFilters: false,
			    selectCategory() {
				    this.subCategory = '';
			    },
			    selectSubCategory(category) {
				    this.category = category;
			    },
			    apply() {
				    void 0;
				    void 0;
				    void 0;
				    $scope.popup.productData.organic = this.organic;

				    if (this.subCategory) {
					    $scope.popup.productData.category = this.category;
					    $scope.popup.productData.subCategory = this.subCategory;
				    } else if(this.category) {
					    $scope.popup.productData.category = this.category;
					    $scope.popup.productData.subCategory = '';
				    }

				    if (this.clearFilters) {
					    $scope.popup.productData.resetSearchFilter('department');
				    }
				    $scope.popup.productData.toggleMobileSearchFilters();
                    var searchTypes =$scope.popup.productData.searchTypes;
                    var searchType = $scope.popup.productData.searchedUpc ? searchTypes.upc : searchTypes.productName;
				    $scope.popup.productData.processSearch(false, searchType);
			    },
			    clear() {
				    this.organic = false;
				    this.category = '';
				    this.subCategory = '';
				    $scope.popup.productData.toggleMobileSearchFilters();
				    $scope.popup.productData.resetSearchFilter('all');
			    }
		    },
		    initUser(user) {
			    this.parent = $scope.$parent.account;
			    void 0;
			    $scope.popup.productData.order = $scope.$parent.order;
			    void 0;
                // $scope.popup.productData.categoryOrder is used for Add Item in my-account order
			    $scope.popup.productData.categoryOrder = this.parent.productData.categoryOrder;
			    $scope.popup.productData.allProducts = this.parent.productData.allProducts;
			    $scope.popup.productData.categorizedProducts = this.parent.productData.categorizedProducts;
			    $scope.popup.productData.outOfStockProducts = this.parent.productData.outOfStockProducts;
			    $scope.popup.productData.originalCategorizedProducts = this.parent.productData.originalCategorizedProducts;
			    void 0;

                if ($rootScope.tableSideOrder && $location.search().showAddItemSummary) {
                    $scope.popup.productData.tableSideOrder.toggleSummary();
                }
                if (!user.id) {
                    user.id = $scope.popup.productData.order.userId;
                }

                hsPromos.getOngoingPromotions(user, true, $scope.popup.productData.order.key).then(function () {
                    if ($rootScope.tableSideOrder) {
                        $scope.popup.productData.tableSideOrder.addPromotionsToItems();
                    }
                });

			    $scope.popup.config.pageFullyLoaded = true;
		    },
		    replaceItemFromOrder() {
                void 0;
                var $removeItemScope = $scope.$new(true);
                $removeItemScope.isTableSideOrder = !!$scope.popup.productData.order.tableNumber;
                $removeItemScope.removeItem = _removeItem;

                ngDialog.open({
                    template: '<div><remove-item '
                        + 'is-table-side-order="isTableSideOrder" '
                        + 'on-confirm="removeItem(reason)" '
                        + 'on-close="closeThisDialog(value)" '
                        + '><remove-item/></div>',
                    className: 'ngdialog-theme-default',
                    plain: true,
                    scope: $removeItemScope,
                }).closePromise
                    .then(function(data) {
                        void 0;
                        if (data.value === 'success') {
                            if ($scope.popup.productData.fromBulkPacking) {
                                $scope.popup.productData.closeDialogsExceptBulkPacking();
                            } else {
                                ngDialog.close(null, { replaced: true });
                            }
                        }
                    })
                    .catch(function(err) {
                        void 0;
                    });

                function _removeItem(reason) {
                    void 0;
                    if ($scope.popup.productData.fromBulkPacking) {
                        var data = {
                            key: encodeURIComponent($scope.popup.productData.order.key),
                            itemName: encodeURIComponent($scope.popup.productData.replaceItem.name),
                            selectedModifiers : $scope.popup.productData.replaceItem.selectedModifiers || [],
                            reason: reason || '',
                        };

                        return hsAdmin.removeItemFromOrder({ order: data })
                            .then(function(res) {
                                if (res.status === 200) {
                                    void 0;
                                    toastr.success('Item removed successfully.');
                                    return 'success';
                                }
                                void 0;
                                var message = 'Error removing item from cart.';
                                toastr.error(message);
                                return message;
                            });
                    }

                    return $scope.popup.productData.parent.removeItemFromOrder(
                        $scope.popup.productData.order, $scope.popup.productData.replaceItem, reason
                    );
                }
		    },
		    toggleMobileSearchFilters() {
			    this.showMobileSearchFilters = !this.showMobileSearchFilters;
		    },
		    resetSearchFilter(type, matchAllWords, useV2) {
			    switch(type) {
				    case 'all':
					    $scope.popup.productData.category = null;
					    $scope.popup.productData.subCategory = null;
					    $scope.popup.productData.organic = null;
					    break;
				    case 'department':
					    $scope.popup.productData.category = null;
					    $scope.popup.productData.subCategory = null;
					    break;
			    }
                var searchTypes =$scope.popup.productData.searchTypes;
                var searchType = $scope.popup.productData.searchedUpc ? searchTypes.upc : searchTypes.productName;
			    this.processSearch(matchAllWords, searchType, useV2);
		    },
		    applySearchFilter(type, category, subCategory) {
			    switch(type) {
				    case 'category':
					    $scope.popup.productData.category = category;
					    $scope.popup.productData.subCategory = null;
					    break;
				    case 'subCategory':
					    $scope.popup.productData.category = category;
					    $scope.popup.productData.subCategory = subCategory;
					    break;
				    case 'organic':
					    $scope.popup.productData.organic = !$scope.popup.productData.organic;
					    break;
			    }
                var searchTypes =$scope.popup.productData.searchTypes;
                var searchType = $scope.popup.productData.searchedUpc ? searchTypes.upc : searchTypes.productName;
			    this.processSearch(false, searchType);
		    },
		    activateTab: function (subCategory, index) {
			    if ($scope.popup.productData.categorizedProducts[index]) {
				    $scope.popup.productData.categorizedProducts[index].loadTab = true;
			    }
		    },
		    fillEmptyOrderProducts (products, property) {
			    var productsToModify = JSON.parse(JSON.stringify(products[property]));
			    var productLength = productsToModify.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach($rootScope.screenWidth, function(width, key){
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' :
				    case 'md' :
				    case 'sm' : {
					    if (productLength % 2) {
						    maxGridLength = 1;
					    } else {
						    maxGridLength = 0;
					    }
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = 0;
					    break;
				    }
			    }

			    if (maxGridLength) {
				    productsToModify.push({
					    renderEmptyTile : true
				    });
			    }

			    return productsToModify;
		    },
		    processSearch (matchAllWords, type, useV2) {
			    if (!$scope.popup.productData.searchedQuery && !$scope.popup.productData.searchedUpc) return;

                var searchTypes = $scope.popup.productData.searchTypes;
                type = searchTypes[type] || searchTypes.productName;
                if (type === searchTypes.productName) {
                    $scope.popup.productData.searchedUpc = '';
                } else if (type === searchTypes.upc) {
                    $scope.popup.productData.searchQuery = '';
                    $scope.popup.productData.searchedQuery = '';
                }

			    $scope.popup.productData.searching = true;
			    var start = Date.now();

			    this.searched = true;
			    var department = this.category;
			    var subCategory = this.subCategory;
			    var isOrganic = this.organic;
			    if($rootScope.screenWidth.xs) {
				    $scope.popup.productData.searchMobile.organic = this.organic;
			    }
			    var brands = this.brands;
			    if (brands) {
				    brands = brands.split(',');
			    }

			    var searchResults = {
				    resultsAfterFilters: false,
				    departmentFilter: false,
				    brandNames: [],
				    allProducts: [],
				    categories: [],
				    results: {}
			    };
			    // Need to get the order if search was triggered from my-orders, or admin manage orders.
			    // Otherwise, the search will commence from the selected location and not the order location.
			    var order = null;
				var includeAllItems = false;
			    if ($scope.$parent) {
			    	if ($scope.$parent.account && $scope.$parent.account.selectedOrder) {
			    		order = $scope.$parent.account.selectedOrder;
			    	} else if ($scope.$parent.admin && $scope.$parent.admin.adminData
			    		&& $scope.$parent.admin.adminData.orderDetails && $scope.$parent.admin.adminData.orderDetails.order
			    	) {
			    		order = $scope.$parent.admin.adminData.orderDetails.order;
						includeAllItems = true;
			    	}
			    }
                var filters = {};
                if ($scope.popup.productData.searchedUpc) {
                    filters.upcs = [$scope.popup.productData.searchedUpc];
                };

                hsSearch.search($scope.popup.productData.searchedQuery, filters, order, matchAllWords, includeAllItems, false, useV2)
                    .then(function(data) {

                        var filteredProducts = data.results.reduce(function(acc, item) {
                            return acc.concat(item);
                        }, []);

                        if (ENV.isRestaurant) {
                            searchResults.results = globalFunctions.restaurantSearch(
                                filteredProducts, searchResults.results, isOrganic, department, subCategory
                            );
                        } else {
                            searchResults.results = globalFunctions.allProductSearch(
                                filteredProducts, searchResults.results, isOrganic, department, subCategory
                            );
                        }
	                    var categoryOrder = JSON.parse(JSON.stringify(ENV.categoryOrder));

	                    angular.forEach(searchResults.results, function(val, key) {
	                        // Generating sidebar search menu for departments
	                        categoryOrder[key] = {
	                            key: key,
	                            name: val.name,
	                            categories: getSortedSubCategories(val, key),
	                        };
	                    });

	                    searchResults.categories = Object.keys(categoryOrder).filter(function(categoryKey) {
	                        return categoryOrder[categoryKey];
	                    }).map(function(categoryKey) {
	                        return categoryOrder[categoryKey];
	                    });

	                    if (ENV.sortCategoryOrder) {
	                        searchResults.categories.sort(function(a, b) {
	                            if (a.key < b.key) return -1;
	                            if (a.key > b.key) return 1;
	                            return 0;
	                        });
	                    }

                        var gridType = ENV.showOrderPage ? 'orderPage' : 'regular';
                        searchResults.allProducts = globalFunctions.addEmptyGridTiles(gridType, filteredProducts, $rootScope.screenWidth);
                        searchResults.selectedProducts = searchResults.allProducts.slice(0, 20);

                        searchResults.resultsAfterFilters = searchResults.categories.length > 0;

                        if (department) {
                            searchResults.departmentFilter = true;
                        }
                        $scope.popup.productData.searchData = searchResults;
                        $scope.popup.productData.searching = false;
                        void 0;
                    })
                    .catch(function(err) {
                        void 0;
                    });

                function getSortedSubCategories(sourceCategory, key) {
                    var subCategoryOrder = JSON.parse(JSON.stringify(ENV.subCategoryOrder));
                    var newSubCategoryOrder = {};

                    if (subCategoryOrder[key]) {
                        Object.assign(newSubCategoryOrder, subCategoryOrder[key]);
                    }
                    Object.keys(sourceCategory.categories).forEach(function(category) {
                        newSubCategoryOrder[category] = {
                            key: category,
                            name: sourceCategory.categories[category].name
                        };
                    });
                    newSubCategoryOrder = Object.keys(newSubCategoryOrder).filter(function(subCategoryKey) {
                        return newSubCategoryOrder[subCategoryKey];
                    }).map(function(subCategoryKey) {
                        return newSubCategoryOrder[subCategoryKey];
                    });

                    if (ENV.sortSubCategoryOrder) {
                        newSubCategoryOrder.sort(function(a, b) {
                            if (a.key < b.key) return -1;
                            if (a.key > b.key) return 1;
                            return 0;
                        });
                    }
                    return newSubCategoryOrder;
                }
		    },
		    searchLoadMore() {
			    if ($scope.popup.productData.searchData.selectedProducts.length < $scope.popup.productData.searchData.allProducts.length) {
				    this.searching = true;
				    var length = $scope.popup.productData.searchData.selectedProducts.length;
				    var maxLength = length + $scope.popup.productData.searchThreshold;
				    if (maxLength > $scope.popup.productData.searchData.allProducts.length) {
					    maxLength = $scope.popup.productData.searchData.allProducts.length;
				    }
				    for (var i = length; i < maxLength; i++) {
					    if ($scope.popup.productData.searchData.allProducts[i]) {
						    $scope.popup.productData.searchData.selectedProducts.push($scope.popup.productData.searchData.allProducts[i]);
					    }
				    }

				    this.searching = false;

				    $rootScope.$emit('lazyImg:refresh');
			    }
		    },
        	init() {
        		this.parent = $scope.$parent.admin;
        		void 0;
        		if ($scope.$parent.fromBulkPacking) {
			        this.replaceItem = $scope.$parent.replaceItem;
			        this.fromBulkPacking = $scope.$parent.fromBulkPacking || false;
			        $scope.popup.productData.order = this.replaceItem.order;
			        $scope.popup.productData.allProducts = $scope.$parent.productData.allProducts;
			        $scope.popup.productData.categorizedProducts = $scope.$parent.productData.categorizedProducts;
			        $scope.popup.productData.outOfStockProducts = $scope.$parent.productData.outOfStockProducts;
			        $scope.popup.productData.originalCategorizedProducts = $scope.$parent.productData.originalCategorizedProducts;
		        } else {
			        this.replaceItem = $scope.$parent.replaceItem || false;
			        $scope.popup.productData.order = this.parent.adminData.orderDetails.order;
			        $scope.popup.productData.allProducts = this.parent.productData.allProducts;
			        $scope.popup.productData.categorizedProducts = this.parent.productData.categorizedProducts;
			        $scope.popup.productData.outOfStockProducts = this.parent.productData.outOfStockProducts;
			        $scope.popup.productData.originalCategorizedProducts = this.parent.productData.originalCategorizedProducts;
		        }
                if (!$scope.popup.productData.order.userObj.id) {
                    $scope.popup.productData.order.userObj.id = $scope.popup.productData.order.userId;
                }
                hsPromos.getOngoingPromotions($scope.popup.productData.order.userObj, true, $scope.popup.productData.order.key).catch(console.error);

        		void 0;

		        $scope.popup.config.pageFullyLoaded = true;
	        },
		    showAddCustomItemDialog: function (replaceItem) {
			    $scope.adminCustomDialog = true;
			    $scope.adminData = this.parent.adminData.orderDetails;
			    $scope.addItemToOrder = true;
			    $scope.replaceItem = replaceItem || false;

			    ngDialog.open({
				    template: 'partials/popup/admin-custom-item-popup.html',
				    controller: 'ModalController',
				    className: 'ngdialog-theme-default email-capture',
				    scope: $scope
			    });
		    },
		    searchProduct (query, matchAllWords, useV2) {
                this.searchResults = false;
                this.searched = false;
                this.searchData = {};
                if (query) {
                    this.searchedQuery = query;
                    this.searchedUpc = '';
                    this.resetSearchFilter('all', matchAllWords, useV2);
                } else {
                    this.searchQuery = '';
                    this.searchedQuery = '';
                }
		    },
		    filterProducts: function (products, screenWidth) {
			    angular.forEach(products, function (val, key, idx) {
				    if (val.hasOwnProperty('renderEmptyTile')) {
					    products.splice(idx, 1);
				    }
			    });

			    var productLength = products.length;
			    var selectedWidth;
			    var maxGridLength;

			    angular.forEach(screenWidth, function (width, key) {
				    width === true ? selectedWidth = key : '';
			    });

			    switch (selectedWidth) {
				    case 'lg' : {
					    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
					    break;
				    }
				    case 'md' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'sm' : {
					    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					    break;
				    }
				    case 'xs' : {
					    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
					    break;
				    }
			    }

			    var objectsToAdd = [];
			    for (var i = 0; i < maxGridLength; i++) {
				    objectsToAdd.push({
					    renderEmptyTile: true
				    });
			    }

			    return products.concat(objectsToAdd);
		    },
	    },
	    tips                        : {
        	order : {},
		    tip: '',
		    error: '',
		    admin: false,
            type: '',
        	init() {
        		void 0;
        		this.order = $scope.ngDialogData.order;
        		this.admin = $scope.ngDialogData.admin || false;
                this.type = $scope.ngDialogData.type || 'tip'
	        },
		    submit(tipForm) {
        		if (tipForm.validate()) {
        			void 0;
        			if ($rootScope.currentUser.isAdminRestricted
				        && $scope.popup.tips.tip > $scope.popup.tips.order.tip) {
        				$scope.popup.tips.error = "Tips amount cannot be more than current tip amount.";
        				toastr.error("Tips amount cannot be more than current tip amount.");
        				return;
			        }

			        /*if ($scope.popup.tips.tip > (0.3 * $scope.popup.tips.order.subTotal)) {
				        $scope.popup.tips.error = "Tip is more than 30% of the total order.";
				        toastr.error("Tip is more than 30% of the total order.");
				        return;
			        }*/

			        var data = {
				        order: {
					        key: $scope.popup.tips.order.key
				        }
			        };

                    data["order"][$scope.popup.tips.type] = parseFloat($scope.popup.tips.tip);
        			
        			void 0;

        			hsAdmin.updateOrderDetails(data)
				        .then(function(res){
					        switch (res.status) {
						        case 200 :
							        toastr.success('Updated Tips Successfully.');
							        $scope.closeThisDialog(true);
							        break;
						        case 402 :
						        	var error = '';
						        	if ($scope.popup.tips.admin) {
						        		error = "Tip amount can not be more than 30% of the order total.";
							        } else {
						        		error = "Error processing tip due to payment errors.";
							        }

							        $scope.popup.tips.error = error;
							        toastr.error(error);
							        break;
						        default :
							        $scope.popup.tips.error = "Error Updating Tips.";
							        toastr.error('Error Updating Tips.');
							        break;
					        }
				        });

		        }
		    }
	    },
	    bottleFee                   : {
        	parent                  : {
        		admin : {},
        		order : {}
	        },
		    fee: '',
		    error: '',
        	init() {
        		this.parent.admin = $scope.$parent.admin;
        		this.parent.order = this.parent.admin.adminData.orderDetails.order;
	        },
		    submit(bottleFeeForm) {
        		if (bottleFeeForm.validate()) {

			        var data = {
				        order: {
					        key: $scope.popup.bottleFee.parent.order.key,
					        bottleFee: parseFloat($scope.popup.bottleFee.fee)
				        }
			        };

			        void 0;

        			hsAdmin.updateOrderDetails(data)
				        .then(function(res){
					        switch (res.status) {
						        case 200 :
							        toastr.success('Updated Bottle Fees Successfully.');
							        ngDialog.close();
							        break;
						        default :
							        $scope.popup.bottleFee.error = "Error Updating Bottle Fees.";
							        toastr.error('Error Updating Bottle Fees.');
							        break;
					        }
				        });

		        }
		    }
	    },
	    salesReport                 : {
        	report: {},
        	init() {
        		this.report = $scope.ngDialogData;
        		void 0;
	        }
	    },
	    userOrderChanges            : {
		    order : {},
		    item : {},
		    instructions: '',
		    error: '',
		    loading: false,
        	init() {
        		this.order = $scope.ngDialogData.order;
        		if ($scope.ngDialogData.item) {
			        this.item = $scope.ngDialogData.item;
			        this.instructions = this.item.instructions;
		        } else {
        			this.instructions = this.order.deliveryInstructions;
		        }
        		
        		void 0;
	        },
		    submit() {
			    if (!this.instructions || this.instructions === '') {
				    $scope.popup.userOrderChanges.error = "Item Description is required.";
				    toastr.error("Item Description is required.");
				    return;
			    }

			    $scope.popup.userOrderChanges.loading = true;

			    var data = {
				    order: {
					    key: $scope.popup.userOrderChanges.order.key,
					    itemName: $scope.popup.userOrderChanges.item.name,
					    instructions: $scope.popup.userOrderChanges.instructions
				    }
			    };

			    void 0;

			    hsAdmin.updateOrder(data)
				    .then(function(res){
					    switch (res.status) {
						    case 200 :
							    toastr.success('Updated Instructions Successfully.');
							    $scope.closeThisDialog(true);
							    break;
						    default :
							    $scope.popup.userOrderChanges.error = "Error Updating Instructions.";
							    toastr.error('Error Updating Instructions.');
							    break;
					    }

					    $scope.popup.userOrderChanges.loading = false;
				    });
		    },
		    submitDeliveryInstructions() {
			    if (!this.instructions || this.instructions === '') {
				    $scope.popup.userOrderChanges.error = "Order delivery instructions can not be empty.";
				    toastr.error("Order delivery instructions can not be empty.");
				    return;
			    }

			    $scope.popup.userOrderChanges.loading = true;

			    var data = {
				    order: {
					    key: $scope.popup.userOrderChanges.order.key,
					    deliveryInstructions: $scope.popup.userOrderChanges.instructions
				    }
			    };

			    void 0;

			    hsAdmin.updateOrderDetails(data)
				    .then(function(res){
					    switch (res.status) {
						    case 200 :
							    toastr.success('Updated Delivery Instructions Successfully.');
							    $scope.closeThisDialog(true);
							    break;
						    default :
							    $scope.popup.userOrderChanges.error = "Error Updating Delivery Instructions.";
							    toastr.error('Error Updating Delivery Instructions.');
							    break;
					    }

					    $scope.popup.userOrderChanges.loading = false;
				    });
		    }
	    },
	    deliveryPopupInit() {
		    void 0;
		    void 0;
		    this.delivery.drivers = this.delivery.dummyDrivers;
		    this.delivery.selectedDelivery = this.delivery.drivers[0];
		    this.delivery.orderGroupIds = $scope.$parent.admin.orderGroups;
		    this.delivery.date = $scope.$parent.admin.datePicker.model;
		    this.delivery.radioModel = Object.keys(this.delivery.orderGroupIds)[0];
		    void 0;
	    },
	    receipt                     : {
		    order : {},
			sendConfirmation: null,
		    email1: '',
		    email2: '',
		    tip: '',
		    error: '',
		    admin: false,
		    loading: false,
		    init() {
			    void 0;
			    this.order = $scope.ngDialogData.order;
				this.sendConfirmation = $scope.ngDialogData.sendConfirmation;
		    },
		    submit(receiptForm) {
			    if (receiptForm.validate()) {
			    	$scope.popup.receipt.loading = true;
				    $scope.popup.receipt.error = '';
				    var data = {
					    order: {
						    key: $scope.popup.receipt.order.key
					    }
				    };

				    var ccList = [];

				    if ($scope.popup.receipt.email1) {
				    	ccList.push($scope.popup.receipt.email1);
				    }

				    if ($scope.popup.receipt.email2) {
				    	ccList.push($scope.popup.receipt.email2);
				    }

				    if(ccList.length) {
				    	data.order.ccList = ccList;
				    }

				    void 0;	
					data.order.sendConfirmation = $scope.popup.receipt.sendConfirmation;			
				    hsAdmin.sendOrderReceipt(data)
					    .then(function(res){
						    switch (res.status) {
							    case 200 :
								    toastr.success($scope.popup.receipt.sendConfirmation ? 'Sent Order Confirmation successfully.' : 'Sent receipt successfully.');
								    $scope.closeThisDialog(true);
								    break;
							    default :
								    var error = $scope.popup.receipt.sendConfirmation ? 'Error sending order confirmation.' : 'Error sending receipt.';
								    $scope.popup.receipt.error = error;
								    toastr.error(error);
								    break;
						    }

						    $scope.popup.receipt.loading = false;
					    });

			    }
		    }
	    },
	    initHowItWorks() {
		    var location = localStorageService.get('location');
		    if(location){
		    	void 0;
			    $scope.popup.selectedLocation = location.selectedLocation;
			    $scope.popup.renderFulfillmentMethods = true;
		    }else{
			    this.loadLocations();
		    }
	    },
	    loadLocations() {
		    $http.get(ENV.apiEndPoint + '/locations')
			    .then(function(res){
				    void 0;
				    if (res.status === 200) {
					    $scope.popup.selectedLocation = res.data[0];
					    $scope.popup.renderFulfillmentMethods = true;
				    }
			    });
	    },
	    getFulfillmentIcon(key) {
		    switch (key) {
			    case 'shipping' :
				    return 'fa-cube';
			    case 'pickup' :
				    return 'fa-shopping-bag';
			    case 'delivery' :
				    return 'fa-truck';
		    }
	    },
	    getContainerSize() {
        	var fulfillmentMethodLength = Object.keys(this.selectedLocation.fulfillment).length;
        	
		    switch (fulfillmentMethodLength) {
			    case 1 :
			    	$('.ng-content').css({
						'width': 'auto!important'
					});
				    return 'col-xs-12';
			    case 2 :
			    	$('.ng-content').css({
						'width': 'auto!important',
						'max-width': '1000px!important'
					});
				    return 'col-sm-6 col-xs-12';
			    case 3 :
			    	$('.ng-content').css({
						'width': 'auto!important',
						'max-width': '1200px!important'
					});
				    return 'col-sm-4 col-xs-12';
		    }
	    },
	    addPrinterInit(sortData) {
        	void 0;
        	if($scope.$parent.hasOwnProperty('admin')) {
		        $scope.popup.printerData.data.admin = $scope.$parent.admin;
	        	$scope.popup.printerData.data.adminData = $scope.$parent.admin.adminData;
	        }

        	$scope.popup.printerData.data.updatePrinterTag = $scope.$parent.updatePrinterTag;

			return $http.get(ENV.apiEndPoint + '/location')
			.then(function (res) {
				if (res.status === 200){
					void 0;
					if(sortData) {
						var printersExtended = res.data.tagPrinters.map(function (printer) {
							return {
								printerIP: printer.ip,
                                printerName: printer.name || '',
								print: true,
								quantity: 1,
							};
						});

						$scope.popup.printerData.data.printersExtended = printersExtended;
					}
					$scope.popup.printerData.data.printers = res.data.tagPrinters;
                    if ($scope.$parent.hasOwnProperty('admin')) {
                        $scope.$parent.admin.printers = res.data.tagPrinters;
                    }
				} else {
					toastr.error('Error Retrieving Printers')
				}
			})
	    },
	    addBankAccountInit() {
			$http.get(ENV.apiEndPoint + '/location')
			.then(function (res) {
				if (res.status === 200){
					void 0;
					if(Object.keys(res.data.account).length) {
						$scope.popup.bankAccountData.data = res.data;
						$scope.popup.bankAccountData.hasAccountInfo = true;

						$scope.popup.bankAccountData.form = {
							bankAccountNumber   : '',
							bankRoutingNumber   : '',
							businessName        : res.data.account.businessName,
							businessTaxId       : res.data.account.businessTaxId,
							firstName           : res.data.account.firstName,
							lastName            : res.data.account.lastName,
							dobDay              : res.data.account.dobDate,
							dobMonth            : res.data.account.dobMonth,
							dobYear             : res.data.account.dobYear,
							address             : {
								street1         : res.data.account.businessAddress.street,
								street2         : res.data.account.businessAddress.aptUnit,
								city            : res.data.account.businessAddress.city,
								state           : res.data.account.businessAddress.state,
								zip             : res.data.account.businessAddress.zip,
								country         : '',
							}
						};
					}
				} else {
					toastr.error('Error Retrieving Printers')
				}
			})
	    },
	    initProcessShipping() {
		    void 0;
		    void 0;
		    this.shippingData.orderData	= $scope.$parent.orderData;
		    this.shippingData.shipments = $scope.$parent.orderData.shipments;
		    this.shippingData.parent	= $scope.$parent.admin;


		    var ShipmentEventListener = $rootScope.$on('orderDataUpdated', function(event, data) {
			    event.stopPropagation();
			    $scope.popup.shippingData.orderData = data;
			    $scope.popup.shippingData.shipments = data.shipments;
		    });

		    $scope.$on('$destroy', function() {
			    ShipmentEventListener();
		    });
	    },
	    selectShippingPackage(shippingPackage) {
		    this.shippingData.quoteData = {};
		    this.config.buttonLoading = false;

        	this.shippingData.shipmentPackages.forEach(function(shipment) {
        		if(shipment.value === shippingPackage.value) {
        		    shipment.checked = true;
        		    $scope.popup.shippingData.selectedPackage = shippingPackage;

        		    if(shippingPackage.value === 'custom') {
			            $scope.popup.shippingData.customQuote.resetQuoteForm();
			            $scope.popup.shippingData.customQuote.showForm = true;
		            } else {
			            $scope.popup.shippingData.customQuote.showForm = false;
						$scope.popup.shippingData.customQuote.resetQuoteForm();
		            }
		        } else {
        		    shipment.checked = false;
		        }
	        });
	    },
	    purchaseShippingLabel() {
		    this.config.buttonLoading = true;
        	var data = {};
        	if (this.shippingData.selectedPackage.value === 'custom') {
        		data = {
			        orderKey: $scope.popup.shippingData.orderData.key,
			        shippingBox: {
				        length: parseFloat($scope.popup.shippingData.customQuote.formData.length), // number
				        width: parseFloat($scope.popup.shippingData.customQuote.formData.width), // number
				        height: parseFloat($scope.popup.shippingData.customQuote.formData.height), // number
				        weight: parseFloat($scope.popup.shippingData.customQuote.formData.weight)// number
			        }
		        }
	        } else {
		        data = {
			        orderKey: $scope.popup.shippingData.orderData.key,
			        shippingBox: {
				        predefinedSize: $scope.popup.shippingData.selectedPackage.value
			        }
		        }
	        }

	        void 0;


		    var apiUrl = ENV.apiEndPoint + '/order/shipping';

		    $http.put(apiUrl, data)
		    .then(function(response){
			    void 0;
			    if (response.status === 200) {
			        $scope.popup.shippingData.parent.initOrderDetails(true);
				    toastr.success('Label purchased successfully');
				    $('#shipping-tabs a[data-target="#shipping-labels"]').tab('show');
				    $scope.popup.shippingData.customQuote.resetQuoteForm();
				    $scope.popup.shippingData.customQuote.showForm = false;
				    $scope.popup.shippingData.quoteData = {};
				    $scope.popup.shippingData.selectedPackage = {};
				    $scope.popup.shippingData.shipmentPackages.forEach(function(shipPackage){
				    	shipPackage.checked = false;
				    });
			    } else {
			    	toastr.error('Error purchasing the label. Please try again.')
			    }

			    $scope.popup.config.buttonLoading = false;
		    });
	    },
	    getShippingQuote() {
		    $scope.popup.config.buttonLoading = true;

		    var apiUrl = ENV.apiEndPoint + '/order/shipping?orderKey=';
		    apiUrl += encodeURIComponent($scope.popup.shippingData.orderData.key);
		    apiUrl = apiUrl + '&predefinedSize=';
		    apiUrl += encodeURIComponent($scope.popup.shippingData.selectedPackage.value);

		    $http.get(apiUrl)
		    .then(function(response){
			    void 0;
			    if (response.status === 200) {
			        $scope.popup.shippingData.quoteData = response.data;
			    } else {
			    	toastr.error('Error getting the quote. Please try again.')
			    }
			    $scope.popup.config.buttonLoading = false;
		    });
	    },
	    getCustomShippingQuote(form) {
		    if(form.validate()) {
			    void 0;
			    $scope.popup.config.buttonLoading = true;

			    var apiUrl = ENV.apiEndPoint + '/order/shipping?orderKey=';
			    apiUrl += encodeURIComponent($scope.popup.shippingData.orderData.key);
			    apiUrl = apiUrl + '&length=';
			    apiUrl += encodeURIComponent($scope.popup.shippingData.customQuote.formData.length);
			    apiUrl = apiUrl + '&width=';
			    apiUrl += encodeURIComponent($scope.popup.shippingData.customQuote.formData.width);
			    apiUrl = apiUrl + '&height=';
			    apiUrl += encodeURIComponent($scope.popup.shippingData.customQuote.formData.height);
			    apiUrl = apiUrl + '&weight=';
			    apiUrl += encodeURIComponent($scope.popup.shippingData.customQuote.formData.weight);

			    void 0;

			    $http.get(apiUrl)
			    .then(function(response){
			        void 0;
			        if (response.status === 200) {
			            $scope.popup.shippingData.quoteData = response.data;
			        } else {
			        	toastr.error('Error getting the quote. Please try again.')
			        }

				    $scope.popup.config.buttonLoading = false;
			    });
		    }
	    },
        refundShippingLabel(shipment) {
	        ngDialog.openConfirm({
		        data        : {
			        heading         : 'Confirm Refund Shipping',
			        subHeading      : 'Are you sure you want to refund this shipping label?',
			        confirmBtnText  : 'Confirm',
			        cancelBtnText   : 'Cancel'
		        },
		        template    : 'partials/popup/confirm-popup.html'
	        }).then(function (confirm) {
		        void 0;
		        var data = {
			        refundShipping: {
				        orderKey: $scope.popup.shippingData.orderData.key,
				        shipmentIds: [shipment.shipmentId]
			        }
		        };
		        void 0;

		        hsAdmin.processRefund(data)
			        .then(function (res) {
				        void 0;
				        if(res.status === 200) {
					        toastr.success('Label refunded Successfully');
					        $scope.popup.shippingData.parent.initOrderDetails(true);
				        } else {
					        toastr.error('Error process the refund for the label');
				        }
			        });
	        }, function(reject) {
		        void 0;
		        return;
	        });


		},
        initAnnoucementPopup() {
        	void 0;
        	this.announcementData = $rootScope.globalNotification.data;
        	this.config.pageFullyLoaded = true;
		},
	    toggleShowZoomContainer(parentContainer, zoomContainer) {
        	if(ENV.enablePopupImageZoom){
		        if(!$scope.popup.config.showZoomContainer){
			        var parentHeight = document.querySelector(parentContainer).offsetHeight;
			        document.querySelector(zoomContainer.toString()).style.height = parentHeight+'px';
		        }
		        $scope.popup.config.showZoomContainer = !$scope.popup.config.showZoomContainer;
	        }
	    },
	    initSelectLocation          : function (updateLocation, locationName) {
			void 0;
        	this.locationData.runUpdate = $scope.$parent.runUpdate;
        	this.locationData.searchPage = $scope.$parent.searchPage;
        	this.locationData.showTabularView = $scope.$parent.showTabularView;
        	this.locationData.openingFromCheckout = $scope.$parent.openingFromCheckout;
        	if ($scope.$parent.runUpdate) {
		        this.locationData.parent = $scope.$parent.landing;
	        }
        	void 0;

            $http.get(ENV.apiEndPoint + '/locations')
            .then(function(res) {
            	void 0;
            	if(res.status === 200) {
            		var selectedLocation;
            		var savedSelectedLocation = localStorageService.get('location');
            		void 0;
                    var locationsActive = res.data.filter(function(loc) {
                        return !loc.isDisabled;
                    });
            		res.data.forEach(function(location, index) {
                        location['directions'] = $sce.trustAsResourceUrl(
                            'https://maps.google.com/maps?q='+
                            location.address.street +' '+
                            location.address.city +' '+ location.address.state +' '+ location.address.zip
                        );

                        if (ENV.enablePriceList && !$scope.popup.locationData.openingFromCheckout
	                        && savedSelectedLocation
                            && savedSelectedLocation.selectedLocation.uniqueName === location.uniqueName) {
                        	location.showPriceList = true;
	                        $scope.popup.showPriceListSection = true;

							if (locationsActive.length < 2) {
								$scope.popup.initPricelistContainer(location);
							}
                        } else {
                            location.showPriceList = false;
                        }

                        if (savedSelectedLocation && location.uniqueName === savedSelectedLocation.selectedLocation.uniqueName) {
                        	$scope.popup.locationData.savedSelectedLocation = location;
						}

                        if (updateLocation) {
							if(locationName === location.uniqueName) {
								selectedLocation = location;
							}
                        }
                    });

            		void 0;
            		$scope.popup.locationData.locations = res.data;

            		if(updateLocation){
            			$scope.popup.selectLocation(selectedLocation);
					} else {
                        $scope.popup.initAutoComplete();
                        $scope.popup.locationData.locationProcessed = false;
                        $scope.popup.locationData.loading = false;
					}
	            } else {
            		toastr.error('Error retrieving locations.')
	            }
            });
	    },
	    initCheckDeliveryArea() {
        	this.config.loading = false;
        	this.locationData.runUpdate = $scope.$parent.runUpdate;
        	this.locationData.searchPage = $scope.$parent.searchPage;
        	this.locationData.showTabularView = $scope.$parent.showTabularView;

        	var location = localStorageService.get('location');
        	void 0;
        	if (!location || !location.allLocations) {
        		$scope.popup.deliveryArea.getLocations();
	        }
	    },
	    checkDeliveryArea() {
        	var addressObj;
		    if (typeof(this.deliveryArea.userInput) !== 'string') {
			    var autoCompleteObject  = this.deliveryArea.userInput;
			    var autoCompleteAddress = address.getAutoCompleteAddress(autoCompleteObject);
			    addressObj = {
				    address : {
					    street          : autoCompleteAddress.street1,
					    aptUnit         : autoCompleteAddress.street2,
					    city            : autoCompleteAddress.city,
					    state           : autoCompleteAddress.state,
					    zip             : autoCompleteAddress.zip
				    }
			    };
		    } else {
		    	return;
		    }

        	$scope.popup.config.loading = true;
        	$scope.popup.deliveryArea.status = '';
        	$scope.popup.deliveryArea.alert = {
		        class               : '',
		        message             : '',
		        btnCta              : false
	        };

		    hsCart.verifyAddress(addressObj)
			    .then(function(res){
				    if(res.status === 200){
				    	void 0;
					    if(res.data.canDeliver) {
					    	$scope.popup.deliveryArea.status = 'success';
						    $scope.popup.deliveryArea.alert = {
							    class               : 'alert-success',
							    message             : '<b class="text-x-lg">Hurray!</b><br> Delivery is available for your address.',
							    btnCta              : true
						    };
						    $scope.popup.deliveryArea.location = res.data.location;
					    } else {
					    	$scope.popup.deliveryArea.status = 'error';
						    $scope.popup.deliveryArea.alert = {
							    class               : 'alert-danger',
							    message             : '<b class="text-x-lg">Pick Up Available</b><br> Delivery is not available for your address at the moment. Please check back later or choose In-Store Pick Up.',
							    btnCta              : false
						    };
					    }
				    } else {
					    $scope.popup.deliveryArea.status = 'error';
					    $scope.popup.deliveryArea.alert = {
						    class               : 'alert-danger',
						    message             : '<b class="text-x-lg">Uh-oh!</b><br> Please enter a valid address.',
						    btnCta              : false
					    };
				    }

				    $scope.popup.config.loading = false;
			    })
	    },
	    initSelectPriceList() {
		    this.locationData.runUpdate = $scope.$parent.runUpdate;
		    this.locationData.searchPage = $scope.$parent.searchPage;
		    this.locationData.showTabularView = $scope.$parent.showTabularView;
			if($scope.$parent.runUpdate){
			    this.locationData.parent = $scope.$parent.landing;
		    }

			var selectedLocation = $rootScope.globalFunctions.getSelectedLocationFromStorage();
			if (selectedLocation && selectedLocation.priceLists) {
				$scope.popup.data = selectedLocation.priceLists;
				$scope.popup.config.loading = false;
			} else {
				$http.get(ENV.apiEndPoint + '/locations')
					.then(function(res) {
						void 0;
						if (res.status === 200) {
							$scope.popup.data = res.data[0].priceLists;
						} else {
							toastr.error('Error retrieving locations.')
						}
						$scope.popup.config.loading = false;
					});
			}
	    },
	    togglePriceList(location, index) {
        	$('#price-list-'+ index)
		        .removeClass('slideInRight')
		        .addClass('slideOutRight')
		        .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function() {
		        $(this).removeClass('slideOutRight');
		        location.showPriceList = false;
		        $scope.popup.showPriceListSection = false;
        	    void 0;
		        $scope.$apply();
	        });
	    },
		createCustomPopup(needAllButton) {
			var user;
			if ($rootScope.currentUser) {
				user = $rootScope.currentUser;
			} else {
				user = localStorageService.get('user');
			}
			
			var adminPriceLists;
			if (user.hasOwnProperty('adminPriceLists') && Array.isArray(user.adminPriceLists)) {
				adminPriceLists = user.adminPriceLists;
			} else {
				adminPriceLists = [];
			}


			if(!$rootScope.ENV.enableLocations && $rootScope.ENV.enablePriceList) {
				globalFunctions.getSelectedLocation().then(function (selectedLocation) {
					var allPriceLists = selectedLocation.priceLists;
					var authorizedPriceLists = globalFunctions.getAuthorizedPriceLists(adminPriceLists, allPriceLists, needAllButton);
					void 0;

					$scope.popup.data = authorizedPriceLists;
					$scope.popup.config.loading = false;
				});
			} else {
				
				var location = localStorageService.get('location');
			
				var allPriceLists = location.selectedLocation.priceLists;
				var authorizedPriceLists = globalFunctions.getAuthorizedPriceLists(adminPriceLists, allPriceLists, needAllButton);

				
				void 0;

				if (location) {
					this.data           = authorizedPriceLists;
					this.config.loading = false;
					void 0;
				} else {
					ngDialog.close();
				}
			}
		},
	    initAdminSelectPriceList() {

			var currentPage = $scope.ngDialogData;

			if (currentPage && currentPage.pageName === 'dashboard') {
				this.createCustomPopup(true);
			} else if (currentPage && currentPage.pageName === 'product-dashboard') {
				this.createCustomPopup(false);
			} else if (currentPage && currentPage.pageName === 'promotions') {
				this.createCustomPopup(false);
			} else if (currentPage && currentPage.pageName === 'modifiers') {
				this.createCustomPopup(false);
			} else {
				var location        = localStorageService.get('location');
				if (location) {
					this.data           = location.selectedLocation.priceLists;
					this.config.loading = false;
					void 0;
				} else {
					ngDialog.close();
				}
			}	
	    },
	    selectAdminPriceList(event, selectedPriceList) {
		    event.stopPropagation();
		    event.preventDefault();

		    localStorageService.set('adminSelectedPriceList', selectedPriceList);
			$rootScope.adminFilterPriceList = selectedPriceList;
			$scope.closeThisDialog();
	    },
	    initAdminSelectLocation() {
            $http.get(ENV.apiEndPoint + '/locations')
            .then(function(res) {
            	void 0;
            	if (res.status === 200) {
					var user = localStorageService.get('user');
					var adminLocations = [];
            		res.data.forEach(function(location) {
                        if (user.adminLocations.indexOf(location.uniqueName) !== -1) {
	                        location['directions'] = $sce.trustAsResourceUrl(
		                        'https://maps.google.com/maps?q='+
		                        location.address.street +' '+
		                        location.address.city +' '+ location.address.state +' '+ location.address.zip
	                        );

                        	adminLocations.push(location);
                        }
                    });

            		$scope.popup.locationData.locations = adminLocations;
		            $scope.popup.initAutoComplete();
		            $scope.popup.locationData.locationProcessed = false;
		            $scope.popup.locationData.loading = false;
	            } else {
            		toastr.error('Error retrieving locations.')
	            }
            });
	    },
	    getBrowserLocation() {
		    if (navigator.geolocation) {
			    void 0;
			    var options = {
				    enableHighAccuracy: true,
				    timeout: 5000,
				    maximumAge: 0
			    };

			    navigator.geolocation.getCurrentPosition(function(position) {
				    void 0;

				    $scope.popup.locationData.origin.lat = position.coords.latitude;
				    $scope.popup.locationData.origin.lng = position.coords.longitude;
				    $scope.popup.processLocations(true);
			    }, function(error) {
				    void 0;
				    $scope.popup.processLocations();
				    toastr.error('Error getting your location. Please try again.');
			    }, options);
		    } else {
			    // Browser doesn't support Geolocation
			    void 0;
			    toastr.error('Error getting your location. Please try again.');
		    }
	    },
	    initAutoComplete() {
		    // Create the autocomplete object, restricting the search to geographical
		    // location types.
		    var autocomplete = new google.maps.places.Autocomplete(
			    /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),
			    {types: ['geocode']});

		    // When the user selects an address from the dropdown, populate the address
		    // fields in the form.
		    autocomplete.addListener('place_changed', function(){
			    $scope.popup.locationData.origin = {
				    lat : autocomplete.getPlace().geometry.location.lat(),
				    lng : autocomplete.getPlace().geometry.location.lng()
			    };

			    $scope.popup.processLocations(true);
		    });
	    },
		initPricelistContainer(location) {
			//Map number of lines in the first two pricelist description to the height of the scroll we need to keep
			var heightMap = {
				'2' : 385,
				'3' : 425,
				'4' : 450,
				'5' : 470,
				'6' : 500
			};
			var pricelistsOnLocation = location.priceLists;
			var heightDescriptor = 0;
			if (pricelistsOnLocation.length > 1){
				for (var i = 0; i < 2; i++) {
					var numberOfLines = (pricelistsOnLocation[i].description).split('<br>').length;
					heightDescriptor = heightDescriptor + numberOfLines;
				}
			}
			if (heightDescriptor >= 2 && heightDescriptor < 7) {
				var finalHeight = heightMap[heightDescriptor.toString()];
				var dialogHeight = finalHeight + 50;
				document.getElementsByClassName('ngdialog-content')[0].style.height = (dialogHeight.toString() + "px");
				setTimeout(function(){
					document.getElementsByClassName('price-list-container')[0].style.height = (finalHeight.toString() + "px");
				}, 0);
			}
		},
	    processLocations(updateScope) {
        	var start 		= {
		        latitude: this.locationData.origin.lat,
		        longitude: this.locationData.origin.lng
	        };
		    var locations 	= [];
		    this.locationData.locations.forEach(function(loc){
			    var end = {
				    latitude: loc.latitude,
				    longitude: loc.longitude
			    };

			    var distance = parseFloat(haversine(start, end, 'mile'));
			    loc['distance'] = parseFloat(distance.toFixed(2));

			    locations.push(loc);
		    });

		    locations.sort(function(a, b){return a.distance - b.distance;});

		    this.locationData.locations = locations;
		    this.locationData.loading = false;
            $scope.popup.locationData.locationProcessed = true;

		    if(updateScope){
			    $scope.$apply();
		    }

	    },
	    selectPriceList(event, selectedPriceList) {
        	event.stopPropagation();
		    event.preventDefault();

		    localStorageService.set('selectedPriceList', selectedPriceList);
		    if(this.locationData.runUpdate){
			    if ($scope.popup.locationData.showTabularView) {
				    $scope.popup.locationData.parent.getAllProducts($scope.popup.locationData.searchPage, null, null, true);
			    } else {
				    $scope.popup.locationData.parent.getAllProducts($scope.popup.locationData.searchPage);
			    }
		    }

		    if(this.locationData.updateContactPage){
			    $scope.popup.locationData.parent.initContactPage();
		    }

		    $rootScope.$emit('priceListUpdated', true);
		    $scope.closeThisDialog();
	    },
	    selectLocation(event, selectedLocation, selectedPriceList) {
        	event.stopPropagation();
		    event.preventDefault();
            var locationsActive = $scope.popup.locationData.locations.filter(function (loc) { 
                return !loc.isDisabled; 
            });

        	if (!ENV.enablePriceList) {
        		this.processSelectLocation(selectedLocation)
	        } else if ($location.search().pListName) {
				var newPL;
				selectedLocation.priceLists.forEach(function(pl) {
					if (hsMarketingService.isMatchingPriceList($location.search().pListName, pl)) {
						$rootScope.selectedPriceList = pl;
						newPL = pl;
					}
				});
				$location.search('pListName', null);
				if (hsUtils.isObject(newPL)) {
					this.processSelectLocation(selectedLocation, newPL);
				} else {
					$location.path('/products');
				}
				return;
			} else {
				if (locationsActive.length < 2) {
					$scope.popup.initPricelistContainer(selectedLocation);
				}
        		if ($scope.popup.locationData.openingFromCheckout) {
        			var savedPriceList = localStorageService.get('selectedPriceList');
        			if (savedPriceList && savedPriceList.title) {
        				var newPriceList = null;
        				selectedLocation.priceLists.forEach(function(pl) {
        					if (pl.title.toLowerCase() === savedPriceList.title.toLowerCase()) {
        						newPriceList = pl;
							}
						});

        				if (newPriceList) {
        					this.processSelectLocation(selectedLocation, newPriceList);
        					return;
						}
					}
				}

        		if (selectedPriceList) {
        			this.processSelectLocation(selectedLocation, selectedPriceList);
		        } else {
        			selectedLocation.showPriceList = true;
			        $scope.popup.showPriceListSection = true;
        			setTimeout(function () {
                        var location = localStorageService.get('location');
                        var allLocations = location && location.allLocations || [];
                        var plIndex = allLocations.findIndex(function(loc) {
                            return loc.uniqueName === selectedLocation.uniqueName;
                        });
                        
				        var parentDiv = $('#location-list');
				        var innerItem = $('#price-list-' + plIndex);

				        var scrollTop = parentDiv.scrollTop() + (innerItem.position().top - parentDiv.position().top) - (parentDiv.height()/2) + (innerItem.height()/2);
				        parentDiv.animate({
					        scrollTop: scrollTop
				        }, 300);
			        }, 0);
		        }
	        }
	    },
	    processSelectLocation(selectedLocation, selectedPriceList) {

			var selectedLocationFromStorage = globalFunctions.getSelectedLocationFromStorage();
			var selectedPriceListFromStorage = globalFunctions.getSelectedPriceListFromStorage();
			if (selectedLocationFromStorage && selectedLocation.uniqueName === selectedLocationFromStorage.uniqueName
				&& selectedPriceListFromStorage && selectedPriceList.uniqueName === selectedPriceListFromStorage.uniqueName)
			{

				if ($location.$$url === '/') {
					$location.url('/products');
				}
		
				$scope.closeThisDialog();
				return;
			}

		    var locationData = {
			    allLocations    	: $scope.popup.locationData.locations,
			    selectedLocation	: selectedLocation
		    };

		    localStorageService.set('location', locationData);
		    if (this.locationData.runUpdate) {
		    	if ($scope.popup.locationData.showTabularView) {
			        $scope.popup.locationData.parent.getAllProducts($scope.popup.locationData.searchPage, null, null, true);
			    } else {
			        $scope.popup.locationData.parent.getAllProducts($scope.popup.locationData.searchPage);
			    }
		    }

		    if(this.locationData.updateContactPage) {
			    $scope.popup.locationData.parent.initContactPage();
		    }

		    if (selectedPriceList) {
		    	localStorageService.set('selectedPriceList', selectedPriceList);
		    }

		    $rootScope.$emit('locationUpdated', true);
		    void 0;

		    if ($location.$$url === '/') {
		    	$location.url('/products');
		    }

		    sessionStorage.setItem('hs_session', new Date());

		    $scope.closeThisDialog();
	    },
	    selectAdminLocation(selectedLocation) {
		    var locationData = {
			    allLocations    	: $scope.popup.locationData.locations,
			    selectedLocation	: selectedLocation
		    };
		    
		    void 0;

		    localStorageService.set('location', locationData);
	        localStorageService.set('adminLocationSelected', true);

	        // setting first pricelist in the array as default when admin changes location
		    if (ENV.enablePriceList) {
			    localStorageService.set('selectedPriceList', {
				    uniqueName: locationData.selectedLocation.priceLists[0].uniqueName
			    });
		    }

		    sessionStorage.setItem('hs_session', new Date());
			
			var message = {
				type: hsPickingApp.REACT_NATIVE_EVENT_TYPES.LOCATION_UPDATE,
				payload: {
					locationData: locationData
				}
			};
			
			hsPickingApp.postMessage(message);

			$rootScope.$emit('locationUpdated', true);
		    ngDialog.close();
		    $route.reload();
	    },
        showCreateCustomItemSection: function () {
            if (!ENV.adminCustomItem) {
                return false;
            }

            return !$rootScope.currentUser.isAdminRestricted || $rootScope.currentUser.isAdminRestricted && ENV.canPackersCreateCustomItem;
        },
	    processRefund(refundForm) {
            if ($scope.popup.config.buttonLoading || !refundForm || !refundForm.validate()) return;

        	void 0;
        	this.config.message         = '';
        	this.config.messageClass    = '';

        	if(this.refund.amount > this.refund.order.total){
		        this.config.message         = 'Refund amount is greater than original amount.';
		        this.config.messageClass    = 'alert-danger';
		        toastr.error('Refund amount is greater than original amount.');
				return;
	        }

        	this.config.buttonLoading = true;

        	var data = {
		        refund: {
			        orderKey    : this.refund.order.key,
			        amount      : parseFloat(this.refund.amount)
		        }
	        };

        	hsAdmin.processRefund(data)
	        .then(function(res){
	            switch (res.status){
		            case 200 :
		            	void 0;
			            $scope.popup.config.message      = 'Refund processed successfully.';
			            $scope.popup.config.messageClass = 'alert-success';
			            toastr.success('Refund processed successfully.');
			            $scope.popup.refund.done = true;
			            // ngDialog.close();
			            break;
		            case 402 :
		            	toastr.error('Refund amount is greater original amount.');
			            $scope.popup.config.message      = 'Refund amount is greater original amount.';
			            $scope.popup.config.messageClass = 'alert-danger';
		            	break;
		            default:
		            	toastr.error('Refund cannot be applied.');
			            $scope.popup.config.message      = 'Refund cannot be applied.';
			            $scope.popup.config.messageClass = 'alert-danger';
		            	break;
	            }

	            $scope.popup.config.buttonLoading = false;
	        });
        },
        delayOrderInit: function() {
            $scope.popup.orderDelays = [].concat($scope.$parent.admin.adminData.orderDetails.order.delays);
            if ($scope.popup.orderDelays.length) {
                $scope.popup.orderDelay = $scope.popup.orderDelays[0];
                $scope.popup.orderDelays.push({ displayValue: 'Other', value: 15 });
            }
        },
        delayOrder: function(delay) {
            if (!delay || delay <= 0) {
                $scope.closeThisDialog();
            }

            $scope.popup.delayingOrder = true;

            var orderData = {
                key: $scope.$parent.admin.adminData.orderDetails.order.key,
                delay: delay,
            };

            var fulfillmentMethod = $scope.$parent.admin.adminData.orderDetails.order.fulfillmentMethod;
            return hsAdmin.updateOrderDetails({ order: orderData }).then(function(resp) {
                $scope.popup.delayingOrder = false;
                if (resp.status === 200) {
                    var message = 'This order\'s ' + fulfillmentMethod + ' time has been delayed by ' + delay + ' mins';
                    toastr.success(message);
                    $scope.closeThisDialog(resp.data);
                } else if (resp.status === 400 && resp.data.message.toLowerCase().includes('no longer be delayed')) {
                    toastr.error('This order can no longer be delayed');
                } else if (resp.status === 400 && resp.data.message.toLowerCase().includes('tomorrow')) {
                    toastr.error('Orders cannot be delayed such that the new ' + fulfillmentMethod + ' time would be tomorrow');
                } else if (resp.status === 500) {
                    toastr.error('There was an error delaying this order, please try again');
                }
            })
        },
        packingCompletedInit: function() {
            void 0;
            var orderState = $scope.$parent.admin.adminData.orderDetails.order.state;
            if (orderState === 'Completed' || orderState === 'Cancelled') {
                $scope.closeThisDialog();
                return;
            }
            function findNextStep() {
                var prevIndex = $scope.popup.packingCompleted.stepIdx;
                var nextStep = $scope.popup.packingCompleted.steps.findIndex(function(step, idx) {
                    return idx > prevIndex && step.shouldShow();
                });

                if (nextStep === -1) {
                    $scope.closeThisDialog();
                    return;
                }
                $scope.popup.packingCompleted.stepLoading = false;
                $scope.popup.packingCompleted.errorMessage = '';
                $scope.popup.packingCompleted.stepIdx = nextStep;
                $scope.popup.packingCompleted.currentStep = $scope.popup.packingCompleted.steps[nextStep];
            }

            $scope.popup.bagsPopupInit();
            $scope.popup.packingCompleted = {
                stepIdx: -1,
                stepLoading: false,
                errorMessage: '',
                steps: [
                    {
                        name: 'setBagQty',
                        title: 'Bag Quantity',
                        subTitle: 'How many bags were used to pack this order?',
                        btnText: 'Update',
                        formValidation: {
                            name: 'bags',
                            rules: $scope.popup.config.bagsValidationRules,
                        },
                        handleSubmit: function(formData, value) {
                            void 0;
                            if (formData.validate()) {
                                $scope.popup.bags.quantity = value;
                                $scope.popup.packingCompleted.errorMessage = '';
                                $scope.popup.packingCompleted.stepLoading = true;
                                $scope.popup.updateBagsQuantity(formData, false).then(function (resp) {
                                    $scope.popup.packingCompleted.stepLoading = false;
                                    if (resp && resp.status !== 200) {
                                        $scope.popup.packingCompleted.errorMessage = 'There was an issue updating the bag quantity, please try again';
                                        return;
                                    } 
                                    findNextStep();
                                });
                            }
                        },
                        handleSkip: function() {
                            findNextStep();
                        },
                        shouldShow: function() {
                            return ENV.enableBagCount;
                        }
                    },
                    {
                        name: 'printTags',
                        title: 'Print Tags',
                        btnText: 'Print',
                        handleSubmit: function() {
                            void 0;
                            $scope.$parent.admin.openPrintTagPopup($scope.popup.bags.quantity);
                            findNextStep();
                        },
                        handleSkip: function() {
                            findNextStep();
                        },
                        shouldShow: function() {
                            return $scope.$parent.admin.printers.length && $scope.popup.bags.quantity
                        }
                    },
                    {
                        name: 'markOrderProcessed',
                        title: 'Mark Order As Processed',
                        btnText: 'Processed',
                        handleSubmit: function() {
                            void 0;
                            $scope.popup.packingCompleted.errorMessage = '';
                            $scope.popup.packingCompleted.stepLoading = true;
                            $scope.$parent.admin.updateOrderStatus($scope.$parent.admin.adminData.orderDetails.order, 'Processed')
                                .then(function(resp) {
                                    $scope.popup.packingCompleted.stepLoading = false;
                                    if (resp && resp.status !== 200) {
                                        $scope.popup.packingCompleted.errorMessage = 'There was an issue marking the order as Processed, please try again';
                                        return;
                                    }
                                    findNextStep();
                                });
                        },
                        handleSkip: function() {
                            findNextStep();
                        },
                        shouldShow: function() {
                            return orderState !== 'Processed';
                        }
                    },
                    { 
                        name: 'scheduleDelivery',
                        /* other attributes left empty. schedule delivery template is in admin-completed-packing-popup.html */
                        shouldShow: function() {
                            var isDelivery = $scope.$parent.admin.adminData.orderDetails.order.fulfillmentMethod === 'delivery';
                            var allowDelivery = $scope.$parent.admin.adminData.orderDetails.order.allowDelivery;
                            return isDelivery && allowDelivery;
                        }
                    },
                ],
            };

            findNextStep();
        },
	    refundPopupInit             : function () {
		    void 0;
            var order = $scope.$parent.order;
            $scope.popup.refund.order = order;
            $scope.popup.refund.parent = $scope.$parent.admin;

            var refunded = 0;

            if (hsUtils.isNonEmptyArray(order.refunds)) {
                refunded = order.refunds.reduce(function(sum, refund) {
                    return sum + refund.amount;
                }, 0) || 0;
            }
            $scope.popup.refund.availableToRefund = order.amountCharged - refunded;
	    },
	    bagsPopupInit() {
		    void 0;
		    void 0;
		    this.bags.order = $scope.$parent.admin.adminData.orderDetails.order;
		    this.bags.parent = $scope.$parent.admin;
		    this.bags.quantity = this.bags.order.bagCount || '';
		    if ($scope.$parent.updatePrinterTag) {
		    	this.bags.updatePrinterTag = $scope.$parent.updatePrinterTag;
		    }
		    void 0;
	    },
	    ageVerificationPopupInit	: function () {
		    void 0;
		    void 0;
		    this.ageVerification.order = $scope.$parent.admin.adminData.orderDetails.order;
		    this.ageVerification.parent = $scope.$parent.admin;
		    this.config.loading = false;

		    if(this.ageVerification.order.hasOwnProperty('ageVerification')) {
		    	this.ageVerification.dob = {
		    		dd: this.ageVerification.order.ageVerification.dob.dd,
		    		mm: this.ageVerification.order.ageVerification.dob.mm,
		    		yyyy: this.ageVerification.order.ageVerification.dob.yyyy
				};

		    	this.ageVerification.id = {
		    		number: this.ageVerification.order.ageVerification.id.number,
		    		type: this.ageVerification.order.ageVerification.id.type
				}
			} else {
				this.ageVerification.id.type = this.ageVerification.idTypes[0];
			}

		    void 0;
		    void 0;
	    },
		updateAgeVerificationIdType(type) {
        	this.ageVerification.id.type = type;
		},
	    updateAgeVerification: function (form) {
		    if(form.validate()){
				$scope.popup.ageVerification.error = '';
				$scope.popup.config.loading = true;

			    var data = {
				    order: {
					    key: $scope.popup.ageVerification.order.key,
					    ageVerification: {
					    	dob: {
								dd: parseInt($scope.popup.ageVerification.dob.dd),
								mm: parseInt($scope.popup.ageVerification.dob.mm),
								yyyy: parseInt($scope.popup.ageVerification.dob.yyyy)
							},
							id: {
								number: $scope.popup.ageVerification.id.number,
								type: $scope.popup.ageVerification.id.type
							}
						}
				    }
			    };

			    void 0;

			    hsAdmin.updateAgeVerification(data)
			    .then(function(res){
				    void 0;
				    switch (res.status){
					    case 200 :
						    void 0;
						    toastr.success('Updated Age Verification Information Successfully.');
						    ngDialog.close();
						    $scope.popup.ageVerification.parent.initOrderDetails(false);
						    break;
					    default :
						    $scope.popup.ageVerification.error = 'Please make sure the date information is valid and that the customer is of age 21 or more.';
						    toastr.error('Please make sure the date information is valid and that the customer is of age 21 or more.');
						    break;
				    }

				    $scope.popup.config.loading = false;
			    });
		    }
	    },
	    updateBagsQuantity: function (form, closeDialog) {
            if(form.validate()) {
                var data = {
                    order: {
                        key: $scope.popup.bags.order.key,
                        bagCount: parseInt($scope.popup.bags.quantity)
                    }
                };
                void 0;

                return hsAdmin.updateBagsQuantity(data)
                    .then(function(res) {
                        void 0;
                        switch (res.status) {
                            case 200:
                                void 0;
                                toastr.success('Updated Bags Quantity Successfully.');
                                if (closeDialog) {
                                    $scope.closeThisDialog('success');
                                }
                                $scope.popup.bags.parent.processOrderData(res.data);
                                break;
                            default:
								var message = res.data.message ? res.data.message : 'Error Updating Bags Quantity.';
                                toastr.error(message);
                                break;
                        }
                        return res;
                    })
                    .catch(function(err) {
                        void 0;

                        if (err.message) {
                            toastr.error(err.message);
                        } else {
                            toastr.error('Something went wrong.');
                        }
                    });
            }
            return $q.resolve();
        },
	    taxPopupInit                : function () {
		    void 0;
		    void 0;
			this.taxPopupData = $scope.ngDialogData;
	    },
	    sendOrderGroup(form) {
        	if(form.validate()) {
        		var data = {
			        group: {
				        id: parseInt($scope.popup.delivery.radioModel),
				        date: $filter('date')($scope.popup.delivery.date, 'dMMMy'),
				        driverEmail: $scope.popup.delivery.driversEmail
			        }
		        };

		        void 0;

		        hsAdmin.assignDelivery(data)
		        .then(function(res){
			        void 0;
			        switch (res.status){
				        case 200 :
					        void 0;
					        toastr.success('Deliveries Assigned Successfully.');
					        ngDialog.close();
					        break;
				        default :
					        toastr.error('Error Assigning Deliveries.');
					        break;
			        }
		        });
	        }
	    },
        productPopupInit() {
        	void 0;
            if ($scope.$parent.account && $scope.$parent.account.selectedOrder) {
                this.selectedOrder = $scope.$parent.account.selectedOrder;
            }
	        this.product                = $scope.ngDialogData;
	        this.originalProduct        = _.cloneDeep($scope.ngDialogData);
        	this.itemInstructions       = this.product.instructions || "";
        	this.adminCtrl				= $scope.$parent.admin;
			this.forUserAddItemsCtrl	= $scope.$parent.forUserAddItemsCtrl;
			this.addItemsToQuoteCtrl	= $scope.$parent.addItemsToQuoteCtrl;
	        var interval = globalFunctions.getQuantityInterval(this.product);
	        var minQuantity = this.product.sellByQty && this.product.unit === 'lb' 
                ? 1
                : this.product.minQuantity;
	        if (minQuantity && minQuantity > interval) {
				interval = minQuantity;
	        }

        	if (this.product.hasModifiers) {
        	    this.quantity               = interval;
	        } else {
        	    this.quantity               = this.product.quantity || interval;
	        }

        	if (this.product.order && this.product.order.isTableSideOrder) {
        	    this.quantity               = interval;
                var basket = localStorageService.get('orderBasket');

                if (basket && Array.isArray(basket.items)) {
                    var basketItem = basket.items.find(function(i) { return i.name === $scope.popup.product.name; });
                    if (basketItem) {
                        this.quantity = basketItem.quantity;
                        this.inCart = true;
                    }
                }
	        }

        	void 0;
        	void 0;

        	if(this.product.isContainer) {
        		this.product.orderingOptions.forEach(function (item) {
        			item.error = "";
					item.choices.forEach(function(choice){
						choice.checked = choice.name === item.defaultChoice;
					});
                });
			}

        	if(this.product.hasModifiers) {
		        this.product.modifiers.forEach(function (item) {
			        item.error = "";
			        item.options.forEach(function(choice){
				        choice.modifierDisplayName = item.displayName;
				        choice.checked = choice.name === item.defaultOption;
			        });
		        });
			}

            var promotion = hsPromos.getVisiblePromotion($scope.popup.product);
            if (promotion) {
                $scope.popup.promotion = promotion;
            }
            var volumePromotions = hsPromos.getVisibleVolumePromotions($scope.popup.product);
            if (volumePromotions) {
                $scope.popup.volumePromotions = volumePromotions;
            }

			void 0;
        },
        getProductDisplayName: function (item) {
            return hsCart.getProductDisplayName(item);
        },
        addContainerItemInCart		: function (item, itemInstructions) {
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement);
			if (validationError) {
				toastr.error(validationError);
				return;
			}
        	var interval = globalFunctions.getQuantityInterval(item);
        	void 0;
        	var productApiOption = "name=" + encodeURIComponent(item.name);
			var error = true;
        	item.orderingOptions.forEach(function (option){
        		if (option.selectionRequired) {
        			error = true;
        			option.choices.forEach(function(choice) {
        				if(choice.checked) {
        					error = false;
        					productApiOption += "&choice=" + encodeURIComponent(choice.name);
						}
					});

        			if (error) {
                        option.error = "Please select an option below."
					}
				} else {
                    error = false;
                    option.choices.forEach(function(choice) {
                        if(choice.checked) {
                            productApiOption += "&choice=" + encodeURIComponent(choice.name);
                        }
                    });
				}
			});
        	
        	if(!error){
		        hsCart.getProductWithOrderingOption(productApiOption)
			        .then(function(res){
			        	void 0;
				        if(res.status === 200){
					        if ($scope.popup.product.adminAddingItemToOrder) {
						        var data = {
							        order   : {
								        key             : $scope.popup.adminCtrl.adminData.orderDetails.order.key,
								        itemName        : res.data.name,
								        itemQuantity    : parseFloat(inputElement.val()),
								        isCustomItem    : res.data.isCustom || res.data.isCustomItem || false,
								        isOrganicItem   : res.data.organic
							        }
						        };

						        $scope.popup.adminCtrl.addItemToExistingOrder(data);
						        ngDialog.close();
					        } else {
					        	void 0;
					        	if ($scope.popup.product.order) {
							        var isTableSideOrder = $scope.popup.product.order && $scope.popup.product.order.isTableSideOrder;

							        void 0;
							        if (isTableSideOrder) {
                                        res.data.quantity = parseFloat(inputElement.val());

								        $scope.popup.updateTableSideItems(res.data, itemInstructions);
								        return;
							        }

							        var data = {
								        order   : {
									        key             : $scope.popup.product.order.key,
									        itemName        : res.data.name,
									        itemQuantity    : parseFloat(inputElement.val()),
									        isCustomItem    : res.data.isCustom || res.data.isCustomItem || false,
									        isOrganicItem   : res.data.organic
								        }
							        };

							        var itemExistInOrder = false;

							        $scope.popup.product.order.items.forEach(function(orderItem) {
							        	if (res.data.name === orderItem.name) {
							        		itemExistInOrder = true;
								        }
							        });

							        void 0;
							        void 0;
							        
							        if (itemExistInOrder) {
								        $scope.popup.updateItemInOrder(res.data, data.order.itemQuantity, itemInstructions);
							        } else {
								        $scope.popup.addItemToExistingOrder(data);
							        }
						        } else {
							        $scope.popup.updateItemInCart(res.data, itemInstructions);
						        }
					        }
				        } else {
					        toastr.error('Error adding item to the cart. Please try again.');
				        }
			        });
			} else{
				toastr.error('Error adding item to the cart. Please try again.');
			}
		},
	    addModifierItemInCart       : function (item, itemInstructions) {
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement);
			if (validationError) {
				toastr.error(validationError);
				return;
			}
		    var interval = globalFunctions.getQuantityInterval(item);
        	void 0;
        	var productModifierOption = [];
			var errors = [];
        	item.modifiers.forEach(function (modifier) {
        		modifier.error = '';
        		var minSelection = modifier.minSelections;
        		var maxSelection = modifier.maxSelections;
        		var selections = [];
        		if (modifier.selectionRequired) {
        			var error = true;
        			modifier.options.forEach(function(choice) {
        				if(choice.checked) {
        					error = false;
        					productModifierOption.push(choice);
					        selections.push(choice);
						}
					});

        			if (error) {
                        modifier.error = "Please select an option below.";
				        errors.push(true);
					}
				} else {
                    error = false;
                    modifier.options.forEach(function(choice) {
                        if(choice.checked) {
                            productModifierOption.push(choice);
                            selections.push(choice);
                        }
                    });
				}

        		if (!modifier.singleSelection) {
        			if (minSelection && (selections.length < minSelection)) {
        				void 0;
				        errors.push(true);
        				modifier.error = "Please select at least " + minSelection + " items.";
			        } else if (maxSelection && (selections.length > maxSelection)) {
        				void 0;
				        errors.push(true);
				        modifier.error = "Max " + maxSelection + " items are allowed.";
			        }
		        }
			});
        	
        	void 0;

        	if (!errors.length){
                if ($scope.popup.product.isQuoteAddItem) {

                    if (itemInstructions) {
                        item.instructions = itemInstructions;
                    }

                    if (productModifierOption.length) {
                        item.selectedModifiers = productModifierOption;
                    }

                    $scope.popup.addItemsToQuoteCtrl.updateItemFromPopup(item, parseFloat(inputElement.val()))
                        .then(function() {
                            ngDialog.close();
                        })
                        .catch(function(err) {
                            void 0;
                        });
                } else if ($scope.popup.product.adminForUserAddItem) {
					
					if (itemInstructions) {
						item.instructions = itemInstructions;
					}

					if (productModifierOption.length) {
						item.selectedModifiers = productModifierOption;
			        }

					$scope.popup.forUserAddItemsCtrl.setCartQuantity(item, parseFloat(inputElement.val()))
						.then(function() {
							ngDialog.close();
						})
						.catch(function(err) {
							void 0;
						});
				} else if ($scope.popup.product.adminAddingItemToOrder) {
			        var data = {
				        order   : {
					        key             : $scope.popup.adminCtrl.adminData.orderDetails.order.key,
					        itemName        : item.name,
					        itemQuantity    : parseFloat(inputElement.val()),
					        isCustomItem    : item.isCustom || item.isCustomItem || false,
					        isOrganicItem   : item.organic,
					        instructions    : itemInstructions || ''
				        }
			        };

			        if (productModifierOption.length) {
			        	data.order.selectedModifiers = productModifierOption.map(function(option) {
			        		return option.name;
				        });
			        }
			        $scope.popup.adminCtrl.addItemToExistingOrder(data);
			        ngDialog.close();
		        } else {
		        	if ($scope.popup.product.addItemToOrder || $scope.popup.product.order) {
				        var isTableSideOrder = $scope.popup.product.order && $scope.popup.product.order.isTableSideOrder;

				        void 0;
				        if (isTableSideOrder) {
                            delete item.order;
                            item = JSON.parse(JSON.stringify(item));
					        item.quantity = parseFloat($('#quantity').val());

				        	item.selectedModifiers = productModifierOption;
                            item.instructions = itemInstructions || '';

					        $scope.popup.updateTableSideItems(item, itemInstructions, productModifierOption);
					        return;
				        }

		        		void 0;
		        		void 0;
				        var data = {
					        order: {
						        key: $scope.popup.product.order.key,
						        itemName: item.name,
						        itemQuantity: parseFloat(inputElement.val()),
						        isCustomItem: item.isCustom || item.isCustomItem || false,
						        isOrganicItem: item.organic,
						        instructions: itemInstructions || ''
					        }
				        };

				        if (productModifierOption.length) {
					        data.order.selectedModifiers = productModifierOption.map(function(option) {
						        return option.name || option;
					        });
				        }

				        if (item.quantity >= interval) {
				        	item.originalSelectedModifiers = productModifierOption || [];
					        item.selectedModifiers = data.order.selectedModifiers || [];

					        if ($scope.popup.product.order) {
						        var itemFound = false;
						        $scope.popup.product.order.items.forEach(function (orderItem) {
							        if (orderItem.name === item.name) {
								        var modifiers = orderItem.selectedModifiers.map(function(option) {
									        return option.name || option;
								        });

								        if (_.isEqual(_.sortBy(modifiers), _.sortBy(data.order.selectedModifiers))) {
									        itemFound = true;
								        }
							        }
						        });
					        }

					        if (itemFound) {
						        $scope.popup.updateItemInOrder(item, data.order.itemQuantity, itemInstructions);
					        } else {
						        $scope.popup.addItemToExistingOrder(data, item);
					        }
				        } else {
					        $scope.popup.addItemToExistingOrder(data, item);
				        }

			        } else {
				        item.selectedModifiers = productModifierOption;
				        $scope.popup.updateItemInCart(item, itemInstructions);
			        }
		        }
			}
		},
	    addItemToExistingOrder(data, item) {
        	void 0;
		    if ($scope.popup.product.replaceItem) {
			    data.order.remove = {
				    itemName: $scope.popup.product.replaceItem.name,
				    selectedModifiers: []
			    };

			    if ($scope.popup.product.replaceItem.selectedModifiers) {
				    data.order.remove.selectedModifiers = $scope.popup.product.replaceItem.selectedModifiers.map(function (modifier) {
					    return modifier.name || modifier;
				    });
			    }
		    }

		    hsAdmin.addItemToOrder(data)
			    .then(function (response) {
				    switch (response.status) {
					    case 200:
						    void 0;
						    toastr.success('Item added to order successfully.');

						    if (item) {
							    item.isUpdating = false;
							    item.loading = false;
							    item.quantity = data.order.itemQuantity;
						    }

						    if ($scope.popup.product.replaceItem) {
						    	if ($scope.popup.product.replaceItem.bulkPacking) {
								    ngDialog.getOpenDialogs().forEach(function(dialog) {
								    	void 0;
									    if (dialog !== 'bulkpacking-dialog') {
										    ngDialog.close(dialog, {replaced: true});
									    }
								    });

								    $scope.closeThisDialog();
							    } else {
							        ngDialog.close(null, { type: 'order-updated', data: response.data });
							    }
						    } else {
							    $scope.closeThisDialog();
								$rootScope.$emit('itemAddedToOrder', { type: 'order-updated', data: response.data });
						    }
                            break;
                        case 406:
                            if (item) {
                                item.isUpdating = false;
							    item.loading = false;
						    }
                            toastr.error('Item selected is only available for Pick Up.');
                            break;
					    case 409:
						    toastr.error('Item already exists in the order.');
						    if (item) {
							    item.isUpdating = false;
							    item.loading = false;
						    }
						    break;
					    case 402:
						    toastr.error('Your credit card was declined, please make sure there are enough funds on your card or ask your bank to authorize the transaction and retry.');
						    break;

					    case 403:
						    if (item) {
							    item.isUpdating = false;
							    item.loading = false;
						    }
						    globalFunctions.showConfirmationDialog(globalFunctions.userOrderChanges.heading, globalFunctions.userOrderChanges.subHeading,
							    'Confirm', '', function (err, success) {
								    void 0;
								    ngDialog.close();
							    });
						    toastr.error('Can not make changes anymore.');
						    break;
					    default:
						    if (item) {
							    item.isUpdating = false;
							    item.loading = false;
						    }
						    toastr.error('Error adding item to order.');
						    break;
				    }
			    });
	    },
	    updateQuantity              : function (item, updateType, admin) {
			var inputElement = $('#quantity');
			if (!admin) {
				var limits = hsCart.checkQuantityLimits(item, inputElement);
				if (updateType === 'add' && limits.max.reached) {
					inputElement.val(limits.max.value);
					toastr.error(limits.max.message);
					return;
				}
				if (updateType === 'subtract' && limits.min.reached) {
					inputElement.val(limits.min.value);
					toastr.error(limits.min.message);
					return;
				}
			}

		    var quantityBtn = '#quantity';
		    var updateBtn = '#update';
		    hsCart.updateQuantity(item, updateType, quantityBtn, updateBtn);
	    },
	    updateTableSideItems(item, itemInstructions) {
		    var itemQuantity = 0;
		    var basket = localStorageService.get('orderBasket');

		    if (basket && Array.isArray(basket.items)) {
			    var sameItem = false;
			    var sameModifiers = false;
			    void 0;
			    basket.items.forEach(function (basketItem) {
				    if(basketItem.name === item.name){
					    if (!basketItem.hasOwnProperty('canReplace')) {
						    basketItem.canReplace = !ENV.isRestaurant;
					    }

					    if (basketItem.selectedModifiers) {
						    item.selectedModifiers.forEach(function (i) { delete i.$$hashKey});

						    if (_.isEqual(basketItem.selectedModifiers, item.selectedModifiers)) {
							    sameModifiers = true;
							    basketItem.selectedModifiers = item.selectedModifiers;
							    basketItem.quantity = item.quantity;
							    itemQuantity += item.quantity;
                                basketItem.instructions = item.instructions;
						    } else {
							    itemQuantity += basketItem.quantity;
						    }
					    } else {
                            basketItem.instructions = item.instructions;
						    basketItem.quantity = item.quantity;
					    }
					    sameItem = true;
				    }
			    });
			    void 0;

			    if (!sameItem || (item.hasOwnProperty('selectedModifiers') && !sameModifiers)){
                    delete item.order;
				    basket.items.push(item);
				    toastr.success('Item added to cart successfully.');
			    } else {
				    toastr.success('Item updated successfully.');
			    }

			    localStorageService.set('orderBasket', basket);

			    if (item.hasOwnProperty('selectedModifiers')) {
				    void 0;
				    if (!sameModifiers) {
					    itemQuantity += item.quantity;
				    }
				    void 0;

				    item.quantity = itemQuantity;
				    void 0;
			    }
		    } else {
			    basket = { items: [] };
			    if (!item.hasOwnProperty('canReplace')) {
				    item.canReplace = !ENV.isRestaurant;
			    }
			    void 0;
                // Can't put into a local storage object with circular references. Not sure if there are consequences to this.
                delete item.order;
			    basket.items.push(item);

			    localStorageService.set('orderBasket', basket);
			    toastr.success('Item added to cart successfully.');
		    }

		    $scope.closeThisDialog();
	    },
		sendAddItemGAEvent(item) {
			var gaEventCategory = aiSearchEvents.getEventCategory();
			aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.ADD_TO_CART, item.name);
			if (gaEventCategory === globalFunctions.GAEventType.SEARCH) {
				aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.SEARCH_ITEM_RANK, item.searchIndex + 1);
			}
		},
	    updateItemInCart(item, itemInstructions) {
        	void 0;
        	var isTableSideOrder = $scope.popup.product.order && $scope.popup.product.order.isTableSideOrder;

            item.instructions = itemInstructions || "";
            var inputElement = $('#quantity');
            var validationError = hsCart.validateQuantity(item, inputElement);

            if (validationError) {
                toastr.error(validationError);
                return;
            }
            var quantity = parseFloat(inputElement.val());
		    var interval = globalFunctions.getQuantityInterval(item);

		    void 0;

		    if (isTableSideOrder) {
                delete item.order;
                item = JSON.parse(JSON.stringify(item));
			    item.quantity = quantity;
			    this.updateTableSideItems(item, itemInstructions);
			    return;
		    }

		    var basket = localStorageService.get('basket');

		    if (!$rootScope.loggedIn) {
			    var itemQuantity = 0;
			    item.quantity = parseFloat(quantity);

			    if (basket) {
				    var sameItem = false;
                    var sameModifiers = false;
                    var wasPickupOnly = basket.some(hsCart.getIsPickupOnly);
				    basket.forEach(function (basketItem) {
					    if(basketItem.name === item.name){

						    if (basketItem.selectedModifiers) {
						    	item.selectedModifiers.forEach(function (i) { delete i.$$hashKey});

						    	if (_.isEqual(basketItem.selectedModifiers, item.selectedModifiers)) {
						    		sameModifiers = true;
									basketItem.instructions = item.instructions;
									if (!basketItem.hasOwnProperty('canReplace')) {
										basketItem.canReplace = !ENV.isRestaurant;
									}
								    basketItem.selectedModifiers = item.selectedModifiers;
								    basketItem.quantity = item.quantity;
							        itemQuantity += item.quantity;
							    } else {
						    		itemQuantity += basketItem.quantity;
							    }
						    } else {
							    basketItem.quantity = item.quantity;
						    }
						    sameItem = true;
					    }
				    });

				    if (!sameItem || (item.hasOwnProperty('selectedModifiers') && !sameModifiers)) {
					    basket.push(item);
					    toastr.success('Item added to cart successfully.');
				    } else {
					    toastr.success('Item updated successfully.');
                    }
                    
                    if (hsCart.getIsPickupOnly(item) && !wasPickupOnly) {
                        toastr.warning('Item added is Pick Up only.');
                    }

			        localStorageService.set('basket', basket);

				    if (item.hasOwnProperty('selectedModifiers')) {
				    	void 0;
				    	if (!sameModifiers) {
				    		itemQuantity += item.quantity;
					    }
				    	void 0;

				    	item.quantity = itemQuantity;
				    	void 0;
				    }
			    } else {
				    var basketArray = [];
				    if (!item.hasOwnProperty('canReplace')) {
					    item.canReplace = !ENV.isRestaurant;
				    }
				    void 0;
				    basketArray.push(item);
			        localStorageService.set('basket', basketArray);
				    toastr.success('Item added to cart successfully.');
			    }

			    $rootScope.$emit('cartUpdated',true);
				$scope.popup.sendAddItemGAEvent(item);
			    $scope.closeThisDialog(item);

		    } else {
			    $scope.popup.config.message = "";
			    $scope.popup.config.messageClass = "";

			    void 0;
			    void 0;

			    item.loading = true;

			    if ($scope.popup.product.order) {
				    var data = {
					    order   : {
						    key             : $scope.popup.product.order.key,
						    itemName        : item.name,
						    itemQuantity    : parseFloat(inputElement.val()),
						    isCustomItem    : item.isCustom || item.isCustomItem || false,
						    isOrganicItem   : item.organic,
						    instructions    : item.instructions || ""
					    }
				    };
				    
				    void 0;

				    if (item.quantity >= interval) {
				    	$scope.popup.updateItemInOrder(item, data.order.itemQuantity, itemInstructions);
				    } else {
				        $scope.popup.addItemToExistingOrder(data, item);
				    }

				    return;
			    }


			    quantity = parseFloat(quantity);

			    var data = {
				    user : hsAuth.getUserAuthObj(),
				    items : [{
					    name            : item.name,
					    quantity        : quantity,
					    isCustomItem    : false,
					    canReplace      : globalFunctions.canReplace(item),
					    instructions    : item.instructions || "",
					    displayName     : item.displayName,
					    type            : item.type,
					    subType         : item.subType,
					    organic         : item.organic,
					    unit            : item.price.unit,
					    selectedModifiers: item.selectedModifiers ?
						    item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
				    }]
			    };
			    void 0;

                var headers = {};

                if ($scope.popup.selectedOrder) {
                    headers.location = $scope.popup.selectedOrder.location;

                    if (ENV.enablePriceList) {
                        headers.pricelist = $scope.popup.selectedOrder.priceList;
                    }
                }
                var wasPickupOnly = basket.isPickupOnly;
			    hsCart.addItemToCart(data, headers)
			    .then(function(response){
				    void 0;
				    if (response.status === 200) {
				    	if (item.hasModifiers) {
				    		var itemQuantity = 0;
				    		var newItem = true;
						    basket.items.forEach(function (basketItem) {
							    if(basketItem.name === item.name){
								    if (basketItem.selectedModifiers) {
								    	var basketModifiers = basketItem.selectedModifiers.map(function(modifier) { return modifier.name});

								    	if (_.isEqual(basketModifiers, data.items[0].selectedModifiers)) {
								    		newItem = false;
								    		itemQuantity += quantity;
									    } else {
								    		itemQuantity += basketItem.quantity;
									    }
								    }
							    }
						    });

						    if (newItem) {
						    	void 0;
						    	itemQuantity += quantity;
						    }

					        item.quantity = itemQuantity;
					    } else {
					        item.quantity = quantity;
                        }
					    void 0;
					    toastr.success('Item added to cart successfully.');
					    $rootScope.$broadcast('cartUpdated');
					    $scope.popup.config.message = "Item added to cart successfully.";
					    $scope.popup.config.messageClass = "alert-success";
                        if (hsCart.getIsPickupOnly(item) && !wasPickupOnly) {
                            toastr.warning('Item added is Pick Up only.');
                        }
						$scope.popup.sendAddItemGAEvent(item);
						$scope.closeThisDialog(item);
				    } else {
						if (response.status === 409) {
							toastr.error('Maximum quantity for product reached');
							$scope.popup.config.message = "Maximum quantity for product reached.";
							$scope.popup.config.messageClass = "alert-danger";
						} else {
							toastr.error('Error adding product.');
							$scope.popup.config.message = "Error adding product.";
							$scope.popup.config.messageClass = "alert-danger";
						}
				    }

				    item.loading = false;
			    });
		    }
	    },
	    addAdminContainerItemInCart : function (item, itemInstructions) {
            var inputElement = $('#quantity');
            var validationError = hsCart.validateQuantity(item, inputElement);

            if (validationError) {
                toastr.error(validationError);
                return;
            }
		    void 0;
		    var productApiOption = "name=" + encodeURIComponent(item.name);
		    var error = true;
		    item.orderingOptions.forEach(function (option){
			    if (option.selectionRequired) {
				    error = true;
				    option.choices.forEach(function(choice) {
					    if (choice.checked) {
						    error = false;
						    productApiOption += "&choice=" + encodeURIComponent(choice.name);
					    }
				    });

				    if (error) {
					    option.error = "Please select an option below."
				    }
			    } else {
				    error = false;
				    option.choices.forEach(function(choice) {
					    if (choice.checked) {
						    productApiOption += "&choice=" + encodeURIComponent(choice.name);
					    }
				    });
			    }
		    });
		    
		    void 0;

		    if(!error){
			    hsCart.getProductWithOrderingOption(productApiOption)
				    .then(function(res){
					    if(res.status === 200){
					    	void 0;

						    var itemReturned = res.data;

                            if ($scope.popup.product.isQuoteAddItem) {

                                if (itemInstructions) {
                                    item.instructions = itemInstructions;
                                }

                                return $scope.popup.addItemsToQuoteCtrl.updateItemFromPopup(item, parseFloat(inputElement.val()))
                                    .then(function() {
                                        ngDialog.close();
                                    })
                                    .catch(function(err) {
                                        void 0;
                                    });

                            } else if ($scope.popup.product.adminForUserAddItem) {

								if (itemInstructions) {
									item.instructions = itemInstructions;
								}

								$scope.popup.forUserAddItemsCtrl.setCartQuantity(item, parseFloat(inputElement.val()))
									.then(function() {
										ngDialog.close();
									})
									.catch(function(err) {
										void 0;
									});

							} else if ($scope.popup.product.adminAddingItemToOrder) {
						    	void 0;
							    var data = {
								    order   : {
									    key             : $scope.popup.adminCtrl.adminData.orderDetails.order.key,
									    itemName        : res.data.name,
									    itemQuantity    : parseFloat(inputElement.val()),
									    isCustomItem    : res.data.isCustom || res.data.isCustomItem || false,
									    isOrganicItem   : res.data.organic,
									    instructions    : itemInstructions || ''
								    }
							    };

							    $scope.popup.adminCtrl.addItemToExistingOrder(data);
							    ngDialog.close();
						    } else if($scope.popup.product.addItemToOrder) {
						    	void 0;
							    var data = {
								    order   : {
									    key             : $scope.popup.product.order.key,
									    itemName        : res.data.name,
									    itemQuantity    : parseFloat(inputElement.val()),
									    isCustomItem    : res.data.isCustom || res.data.isCustomItem || false,
									    isOrganicItem   : res.data.organic
								    }
							    };
							    
							    void 0;
							    $scope.popup.addItemToExistingOrder(data, item);
							    return;
						    } else {
							    $scope.popup.updateItemInCart(res.data, itemInstructions);
						    }

						    $rootScope.$emit('adminOrderUpdated',true);
						    ngDialog.close();
					    }else{
						    toastr.error('Error adding item to the cart. Please try again.');
					    }
				    });
		    } else{
			    toastr.error('Error adding item to the cart. Please try again.');
		    }
	    },
	    updateAdminItemInCart(item, itemInstructions) {
		    item.instructions = itemInstructions || "";
			var inputElement = $('#quantity');
			var validationError = hsCart.validateQuantity(item, inputElement, true);

			if (validationError) {
				toastr.error(validationError);
				return;
			}

			if ($scope.popup.product.isQuoteAddItem) {

                if (itemInstructions) {
                    item.instructions = itemInstructions;
                }

                return $scope.popup.addItemsToQuoteCtrl.updateItemFromPopup(item, parseFloat(inputElement.val()))
                    .then(function() {
                        ngDialog.close();
                    })
                    .catch(function(err) {
                        void 0;
                    });
            } else if ($scope.popup.product.adminForUserAddItem) {

				return $scope.popup.forUserAddItemsCtrl.setCartQuantity(item, parseFloat(inputElement.val()))
					.then(function() {
						ngDialog.close();
					})
					.catch(function(err) {
						void 0;
					});

			} else if ($scope.popup.product.addItemToOrder) {
			    void 0;
			    var data = {
				    order: {
					    key: $scope.popup.product.order.key,
					    itemName: item.name,
					    itemQuantity: parseFloat(inputElement.val()),
					    isCustomItem: item.isCustom || item.isCustomItem || false,
					    isOrganicItem: item.organic,
					    instructions: itemInstructions || ''
				    }
			    };

			    $scope.popup.addItemToExistingOrder(data);

		    } else {
				item.quantity = parseFloat(inputElement.val());
			    var basket = localStorageService.get('adminOrder');

			    if(basket){
				    var sameItem = false;
				    basket.forEach(function (basketItem) {
					    if(basketItem.name === item.name){
						    basketItem.quantity = item.quantity;
						    sameItem = true;
					    }
				    });

				    if(!sameItem){
					    basket.push(item);
				    }

				    localStorageService.set('adminOrder', basket);
			    }else{
				    var basketArray = [];
				    basketArray.push(item);
				    localStorageService.set('adminOrder', basketArray);
			    }

			    $rootScope.$emit('adminOrderUpdated',true);
			    ngDialog.close();
		    }
	    },
        updateChoiceSelection(optionObj, choiceObj, isCheckbox) {
			 angular.forEach(optionObj.choices, function (choice) {
				 if(isCheckbox){
                     if(choice.name === choiceObj.name) {
                         choice.checked = !choice.checked;
                     }
				 }else{
                     if(choice.name === choiceObj.name){
                        if (optionObj.selectionRequired) {
                            choice.checked = true;
                        } else {
                            choice.checked = !choice.checked;
                        }
                     }else{
                         if(optionObj.singleSelection){
                             choice.checked = false;
                         }
                     }
				 }
             });
		},
        updateOptionSelection(optionObj, choiceObj, isCheckbox) {
			 angular.forEach(optionObj.options, function (choice) {
				 if(isCheckbox){
                     if(choice.name === choiceObj.name) {
                         choice.checked = !choice.checked;
                     }
				 }else{
                     if(choice.name === choiceObj.name){
                        if (optionObj.selectionRequired) {
                            choice.checked = true;
                        } else {
                            choice.checked = !choice.checked;
                        }
                     }else{
                         if(optionObj.singleSelection){
                             choice.checked = false;
                         }
                     }
				 }
             });
		},
	    customItemPopupInit() {
        	if ($scope.$parent.adminCustomDialog) {
		        this.adminCustomDialog = $scope.$parent.adminCustomDialog;
		        this.adminData = $scope.$parent.adminData;
		        this.adminCtrl = $scope.$parent.admin;
		        this.itemToReplace = $scope.$parent.replaceItem;
		        void 0;
	        }

            this.customItemUnitType = this.customItemUnitTypes[0];
        	this.selectedCustomItemType = 'regular';
	    },
	    selectCustomItemType(type) {
            this.selectedCustomItemType = type;
	    },
	    selectCustomItemTaxable(type) {
            this.isCustomItemTaxable = type;
	    },
	    addCustomItemInCart(description) {
		    $scope.popup.config.message         = "";
		    $scope.popup.config.messageClass    = "";
		    $scope.popup.config.buttonLoading   = true;

		    void 0;
		    void 0;

		    if(!description){
			    $scope.popup.config.message = "Please enter Description.";
			    $scope.popup.config.messageClass = "alert-danger";
			    $scope.popup.config.buttonLoading   = false;
			    return;
		    }

		    var data = {
			    user : hsAuth.getUserAuthObj(),
			    item : {
				    name            : description,
				    quantity        : this.customItemQuantity,
				    isCustomItem    : true,
				    canReplace      : true,
				    instructions    : "",
				    displayName     : description,
				    type            : '',
				    subType         : '',
				    organic         : false,
				    unit            : "count"
			    }
		    };

		    if(this.selectedCustomItemType === 'organic'){
		    	data.item.organic = true;
		    }

		    void 0;

		    hsCart.addItemToCart(data)
		    .then(function(response){
			    void 0;
			    if(response.status === 200){
				    void 0;
				    toastr.success('Item added to cart successfully.');
				    $rootScope.$broadcast('cartUpdated');
				    $scope.popup.config.message = "Item added to cart successfully.";
				    $scope.popup.config.messageClass = "alert-success";
				    $scope.popup.config.buttonLoading   = false;
			    }else{
				    toastr.error('Error adding product.');
				    $scope.popup.config.message = "Error adding product.";
				    $scope.popup.config.messageClass = "alert-danger";
				    $scope.popup.config.buttonLoading   = false;
			    }
		    });
	    },
        showBarcodeScanner() {
            if ($scope.popup.canShowBarcodeScanner()) {
				var barcodeScanner = scannerUtils.getBarcodeScannerName();
				var $newScope = $scope.$new(true);
				$newScope.scannerType = barcodeScanner;
	
				var scannerTemplate = '<upc-scanner scanner-type="scannerType" on-close="closeThisDialog(value)"></upc-scanner>';

                return ngDialog.open({
                    template: scannerTemplate,
                    plain: true,
                    className: 'ngdialog-theme-default',
                    scope: $newScope,
                    name: 'fullscreen',
                }).closePromise
                    .then(function(data) {
                        if (data.value) {
                            if (data.value instanceof Error) {
                                toastr.error('Something went wrong.');
                                return;
                            }
                            if (['skip', '$closeButton', '$escape'].includes(data.value)) {
                                return;
                            }
                            if (data.value && typeof data.value === 'object' && data.value.result) {
                                if (data.value.result === 'unsupported') {
                                    toastr.error('Camera is not supported.');
                                    return;
                                }
                                if (typeof data.value.result !== 'string' || /[^0-9]/.test(data.value.result)) {
                                    return;
                                }
                                return data.value.result;
                            }
                        }
                    });
            } else {
                return Promise.resolve();
            }
        },
        scanAndProcessCustomItemUpc() {
            return $scope.popup.showBarcodeScanner()
                .then(function(itemUpc) {
                    if (!itemUpc) {
                        return;
                    }
                    $scope.itemUpc = itemUpc;
                    $scope.popup.processItemUpcUpdate();
            });
        },
        isRandomWeightUpc(upc) {
            return hsUpc.isRandomWeightUpc(upc);
        },
        onCustomItemWeightChange() {
            if(hsUpc.isRandomWeightUpc($scope.itemUpc)) {
                var pricePerLB = +$scope.itemPrice / +$scope.popup.itemWeight;

                if (pricePerLB && !isNaN(pricePerLB)) {
                    $scope.popup.itemPricePerLB = +pricePerLB.toFixed(2);
                }
            } else if($scope.popup.customItemUnitType === 'lb') {
                $scope.popup.autoUpdateCustomItemPrice();
            }
        },
        onCustomItemPricePerLBChange() {
            if(hsUpc.isRandomWeightUpc($scope.itemUpc)) {
                var weight = +$scope.itemPrice / +$scope.popup.itemPricePerLB;

                if (weight && !isNaN(weight)) {
                    $scope.popup.itemWeight = +weight.toFixed(4);
                }
            } else if($scope.popup.customItemUnitType === 'lb') {
                $scope.popup.autoUpdateCustomItemPrice();
            }
        },
        autoUpdateCustomItemPrice() {
            var price = +$scope.popup.itemPricePerLB * +$scope.popup.itemWeight;

            if (price && !isNaN(price)) {
                $scope.itemPrice = +price.toFixed(2);
            }
        },
        setRandomWeightDefaults() {
            $scope.popup.customItemUnitType = 'lb';
            $scope.itemPrice = '';
            $scope.popup.itemWeight = '';
            $scope.popup.itemPricePerLB = '';
        },
        processItemUpcUpdate() {
            if (hsUpc.isRandomWeightUpc($scope.itemUpc)) {
                $scope.popup.setRandomWeightDefaults();

                var itemPrice = hsUpc.getPriceFromRandomWeightUpc($scope.itemUpc);
                if (itemPrice !== null) {
                    $scope.itemPrice = itemPrice;
                }
            }
        },
        scanAndSearchForItem() {
            return $scope.popup.showBarcodeScanner()
                .then(function(itemUpc) {
                    if (itemUpc) {
                        $scope.popup.productData.searchedQuery = '';
                        $scope.popup.productData.searchedUpc = itemUpc;
                        $scope.popup.productData.resetSearchFilter('all');
                    }
                });
        },
        canShowBarcodeScanner() {
			var barcodeScanner = scannerUtils.getBarcodeScannerName();
			if (barcodeScanner === 'zebra') {
				return ENV.enableUpcScanner && ($rootScope.screenWidth.xs || $rootScope.screenWidth.sm);
			}
            return window.Dynamsoft && ENV.enableUpcScanner && ($rootScope.screenWidth.xs || $rootScope.screenWidth.sm);
        },
        addCustomItemInOrder() {
		    $scope.popup.config.message         = "";
		    $scope.popup.config.messageClass    = "";
		    $scope.popup.config.buttonLoading   = true;

            var price = $scope.itemPrice;
            var quantity = $scope.popup.customItemQuantity;
            var upc = $scope.itemUpc;

		    if(!$scope.itemName){
			    $scope.popup.config.message = "Please enter Item Name.";
			    $scope.popup.config.messageClass = "alert-danger";
			    $scope.popup.config.buttonLoading = false;
			    return;
		    }

            if(upc && (/[^a-zA-Z0-9]/).test(upc)){
                $scope.popup.config.message = 'Please use only letters or digits for upc.';
                $scope.popup.config.messageClass = 'alert-danger';
                $scope.popup.config.buttonLoading = false;
                return;
            }

            if ($scope.popup.customItemUnitType === 'lb') {
                price = $scope.popup.itemPricePerLB;
                if (!price) {
                    $scope.popup.config.message = 'Please enter price per pound.';
                    $scope.popup.config.messageClass = 'alert-danger';
                    $scope.popup.config.buttonLoading = false;
                    return;
                }
                quantity = $scope.popup.itemWeight;
                if (!quantity || isNaN(quantity) || quantity <= 0) {
                    $scope.popup.config.message = 'Please enter valid item weight.';
                    $scope.popup.config.messageClass = 'alert-danger';
                    $scope.popup.config.buttonLoading = false;
                    return;
                }
                if (hsUpc.isRandomWeightUpc(upc)) {
                    var randomWeightUPC = hsUpc.getCodeFromRandomWeightUpc(upc);
                    if (randomWeightUPC) {
                        // For now we will treat all EAN13 20 encoded random weight products as they are
                        // encoded by Erewhon Santa Monica, and only use 5 digits.
                        upc = '2' + randomWeightUPC.slice(0, 5);
                    }
                }
            }

            if(!price || isNaN(price) || price <= 0) {
                $scope.popup.config.message = "Please enter Item Price.";
                $scope.popup.config.messageClass = "alert-danger";
                $scope.popup.config.buttonLoading   = false;
                return;
            }

            var data = {
                order: {
                    key: $scope.popup.adminData.order.key,
                    price: Number(parseFloat(price).toFixed(2)),
                    itemName: $scope.itemName,
                    itemQuantity: quantity,
                    unit: $scope.popup.customItemUnitType,
                    isCustomItem: true,
                    isOrganicItem: false,
                    isTaxable: $scope.popup.isCustomItemTaxable,
                    upc: upc,
                }
            };

		    if ($scope.popup.itemToReplace) {
			    data.order.remove = {
				    itemName: $scope.popup.itemToReplace.name,
				    selectedModifiers: []
			    };

			    if ($scope.popup.itemToReplace.selectedModifiers) {
				    data.order.selectedModifiers = $scope.popup.itemToReplace.selectedModifiers.map(function (modifier) {
					    return modifier.name
				    });
			    }

			    if ($scope.popup.itemToReplace.order) {
			    	data.order.key = $scope.popup.itemToReplace.order.key;
			    }
		    }

		    void 0;

            globalFunctions.getSelectedLocation()
                .then(function(location) {
                    if (location.customItemRequiresUpc && !upc) {
                        $scope.popup.config.message = 'UPC is required.';
                        $scope.popup.config.messageClass = 'alert-danger';
                        throw 'UPC is required';
                    }
                    return hsAdmin.addCustomItemInOrder(data);
                })
                .then(function(response) {
                    void 0;
                    if(response.status === 200){
                        void 0;
                        toastr.success('Item added to Order successfully.');
                        $scope.popup.config.message = "Item added to Order successfully.";
                        $scope.popup.config.messageClass = "alert-success";
                        if ($scope.popup.itemToReplace) {
                            if ($scope.popup.itemToReplace.bulkPacking) {
                                ngDialog.getOpenDialogs().forEach(function(dialog) {
                                    void 0;
                                    if (dialog !== 'bulkpacking-dialog') {
                                        ngDialog.close(dialog, {replaced: true});
                                    }
                                });

                                $scope.closeThisDialog();
                            } else {
                                ngDialog.close(null);
                                $scope.popup.adminCtrl.initOrderDetails();
                            }
                        } else {
                            $scope.closeThisDialog();
                            $scope.popup.adminCtrl.initOrderDetails();
                        }
                    } else {
                        toastr.error('Error adding product.');
                        $scope.popup.config.message = "Error adding product.";
                        $scope.popup.config.messageClass = "alert-danger";
                    }
                })
                .catch(function(err) {
                    void 0;
                })
                .finally(function() {
                    $scope.popup.config.buttonLoading = false;
                });
	    },
	    updateCustomItemQuantity(updateType) {
		    if(updateType === 'subtract'){
			    if($scope.popup.customItemQuantity !== 1){
				    $scope.popup.customItemQuantity--;
			    }
		    }else if(updateType === 'add'){
			    $scope.popup.customItemQuantity++;
		    }

	    },
	    initSyncPrices: function (data) {
		    if (!data) {
			    data = {};
		    }
		    var syncPrices = {
			    disableShowConfirmation: true,
			    copyIsInStock: data.copyIsInStock ? true : false,
			    addMarkup: data.addMarkup ? data.addMarkup : 0,
			    addProductIfDoesNotExist: data.addProductIfDoesNotExist ? true : false,
		    };
		    if (data.currentLocation && data.allowedStoreLocations && data.targetLocations) {
			    syncPrices.currentLocation = data.currentLocation;
			    syncPrices.allowedStoreLocations = data.allowedStoreLocations;
			    syncPrices.targetLocations = data.targetLocations;
				syncPrices.currentPriceList = data.currentPriceList;
		    } else {
			    syncPrices.currentLocation = $rootScope.location ? $rootScope.location.selectedLocation : null;
				var adminUserLocations = $rootScope.currentUser.adminLocations;
				syncPrices.allowedStoreLocations = ($rootScope.location ? $rootScope.location.allLocations : [])
					.filter(function(location) {
						return adminUserLocations.includes(location.uniqueName)
							&& syncPrices.currentLocation
							&& syncPrices.currentLocation.uniqueName !== location.uniqueName;
					})
					.map(function(location) {
						var obj = Object.assign({}, location);
						obj.priceLists = location.priceLists.map(function(list) {
							return Object.assign({}, list);
						})
						return obj;
					});
				syncPrices.targetLocations = [];
				syncPrices.currentPriceList = localStorageService.get('adminSelectedPriceList');
			}
			this.syncPrices = syncPrices;
			this.updateSelectedLocations();
	    },
	    updateSelectedLocations: function() {
			this.syncPrices.targetLocations = this.syncPrices.allowedStoreLocations
				.filter(function(location) {
					return !!location.selectedToSyncPrices;
				})
				.map(function(location) {
					var obj = Object.assign({}, location);
					obj.priceLists = location.priceLists.map(function(list) {
						return Object.assign({}, list);
					})
					return obj;
				});
			this.syncPrices.targetLocations.forEach(function(location) {
				location.priceLists = location.priceLists.reduce(function(acc, list) {
					if (list.selectedToSyncPrices) {
						acc.push(list);
					}
					return acc;
				}, [])
			});
			if (this.syncPrices.targetLocations.length) {
				if (ENV.enablePriceList) {
					this.syncPrices.disableShowConfirmation = this.syncPrices.targetLocations.some(function(location) {
						return !location.priceLists.length;
					});
				} else {
					this.syncPrices.disableShowConfirmation = false;
				}
			} else {
				this.syncPrices.disableShowConfirmation = true;
			}
		},
		submitSyncPrices: function() {
			var message = {
				sourceLocation: {
					locationName: this.syncPrices.currentLocation.uniqueName,
				},
				targetLocations: this.syncPrices.targetLocations.reduce(function(acc, location) {
					var locations = [];
					if (ENV.enablePriceList) {
						locations = location.priceLists.map(function(priceList) {
							return {
								locationName: location.uniqueName,
								priceListName: priceList.uniqueName,
							}
						});
					} else {
						locations.push({
							locationName: location.uniqueName,
						})
					}
					return acc.concat(locations);
				}, []),
				options: {
					copyIsInStock: this.syncPrices.copyIsInStock,
					addMarkup: this.syncPrices.addMarkup,
					addProductIfDoesNotExist: this.syncPrices.addProductIfDoesNotExist,
				},
			};
			if (ENV.enablePriceList) {
				message.sourceLocation.priceListName = this.syncPrices.currentPriceList.uniqueName;
			}
			hsAdmin.syncPrices(message)
				.then(function(res) {
					if (res.status === 200) {
						toastr.success("Request to sync prices was sent.");
						$scope.closeThisDialog();
					} else {
						toastr.error("Couldn't sync prices. Please try again.");
					}
				});
		},
        refreshDelivery: function() {
            hsAdmin.refreshDelivery($scope.popup.orderDelivery.order.key)
                .then(function(res) {
                    if (res.status === 200) {
                        toastr.success('Delivery status was refreshed');
                        return $scope.closeThisDialog({ order: res.data });
                    }
                    void 0;
                    toastr.error('Failed to refresh delivery.');
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to refresh delivery.');
                });
        },
		getPlaceholderText : function() {
			var country = 'US';
			function isCanadian (location) {
				return location.country === 'CA';
			}
			if ($scope.popup.locationData.locations.length > 0) {
				if ($scope.popup.locationData.locations.every(isCanadian)) {
					country = 'CA';
				}
			}

			var codeText = "";
			switch (country) {
				case 'CA' :
					codeText = "postal code";
					break;
				case 'US' :
					codeText = "zipcode";
					break;
				default :
					codeText = "zipcode";
			}

			return "Enter your " + codeText + " or address";
		},
        shouldShowMembershipDiscount() {
            return hsPromos.shouldShowMembershipDiscount($scope.popup.product, $scope.popup.promotion);
        },
        getRelevantPromotionForPrice() {
            return hsPromos.getRelevantPromotionForPrice($scope.popup.product, $scope.popup.promotion);
        },
        shouldShowUnit: function () {
            if (ENV.hideItemUnit) return false;
            if ($scope.popup.promotion && $scope.popup.promotion.type === hsPromos.types.FREE_ITEM) return false;

            return true;
        },
    }
}]);

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('accountCtrl',['$scope','$rootScope','$location','$http','toastr','hsAuth','hsCart','localStorageService','$q',
    'address','globalFunctions','ENV','$filter','ngDialog','hsApi', 'hsAdmin', 'VALIDATORS', 'hsTableSideOrders', 'hsUpc', '$route', 'hsUtils', 'hsPromos',
	'aiSearchEvents',
	function($scope, $rootScope,$location,$http,toastr,hsAuth,hsCart,localStorageService, $q, address, globalFunctions, ENV,
        $filter, ngDialog, hsApi, hsAdmin, VALIDATORS, hsTableSideOrders, hsUpc, $route, hsUtils, hsPromos, aiSearchEvents){
	
	void 0;
	
    $scope.account = {
    	paymentMethods: [],
    	allProductsHash: null,
        config                      : {
	        pageFullyLoaded             : false,
	        showChangeLog               : false,
	        showUpdatedAddressSection   : false,
	        showUpdatedCCSection        : false,
	        showUpdatePhoneSection      : false,
	        billingAddressNonEditable   : false,
	        addressNonEditable          : false,
	        buttonLoading               : false,
	        updateAddressError          : '',
	        updateAddressButtonLoading  : false,
	        showOrderDetails            : false,
	        canEditOrder                : false,
	        accountError                : "",
	        isTableSideOrder            : false,
	        canEditTableSideOrder       : false,
	        updateSEOdata               : function ($title, $keywords, $description, $image) {
		        globalFunctions.setSEOdata($title, $keywords, $description, $image);
	        },
	        phoneValidationRules        : {
		        rules               : {
			        phoneUS         : {
				        required    : true,
				        phoneUS     : true
			        }
		        },
		        messages            : {
			        phoneUS         : {
				        required    : "Please enter valid phone number",
				        phoneUS     : "Please enter valid phone number"
			        }
		        }
	        },
	        addressValidationRules: VALIDATORS.ADDRESS,
            showUpdateCustomUserDataSection: false,
            updateCustomUserDataKey: null,
            updateCustomUserDataSetting: null,
            customUserDataSettings: null,
            membershipStoreSettings: null,
        },
	    // The Entity that represents the user's address
	    address                     : {
		    street1             : "",
		    street2             : "",
		    city                : "",
		    state               : "",
		    zip                 : "",
		    country             : ""
	    },
	    // Object used to control notifications on the View
	    notification                : {
		    isAddressEdit           : true,
		    isAddressError          : false,
		    isVerificationLoading   : false,
		    isRegisterAddrLoading   : false,
		    errMessage              : "",
		    reset                   : function() {
			    this.isAddressError         = false;
			    this.isVerificationLoading  = false;
			    this.isRegisterAddrLoading  = false;
			    this.errMessage             = "";
		    }
	    },
	    changeLogItems              : [],
	    selectedChangeLogItem       : 'All',
	    userData                    : {},
	    allProducts                 : {},
	    coupons                     : {},
	    orderHistory                : [],
	    selectedOrder               : {},
		orders						: {
			getManagedDelivery(order) {
				return order.managedDelivery || null;
			},
			getPostmatesDeliveryStatus(order) {
				var managedDelivery = $scope.account.orders.getManagedDelivery(order);
				if (!managedDelivery) {
					return '';
				}
				return globalFunctions.USER_POSTMATES_STATUS_CODES[managedDelivery.status] || '';
			},
			isPickupOrder(order) {
				return order.fulfillmentMethod === 'pickup';
			},
			padAsapOrderPickupTime(orderDeliveryTime) {
				return hsCart.createTimeRange(orderDeliveryTime, 15);
			},
			isAsapDeliveryOrder(order) {
				return !!order.asapDeliveryTime && order.fulfillmentMethod === 'delivery';
			}
		},
	    orderUpdates                : {
		    confirmHeader: 'Attention',
		    confirmMessage: 'Removing items or reducing the quantity may cause the change in fees, if any, associated with the order.',
		    showLeaveOutPopup() {
			    ngDialog.open({
				    template: 'partials/popup/leave-out-items-popup.html',
				    controller:'ModalController',
				    closeByNavigation: true,
				    className: 'ngdialog-theme-default email-capture'
			    });
		    },
			showInstructionUpdate(item){
				if (item._isUpdating){
					return;
				}
				void 0;
				void 0;
				item._showInstructions = !item._showInstructions;
			},
			updateInstructionsInOrder (item, index, category) {
				if (item._isUpdating) {
					return;
				}

				void 0;
				void 0;
	
				var inputElement = $('#item-in-order-instructions-' + category + '-' + index);
				item.instructions = inputElement.val();
				item._isUpdating = true;
				item._showInstructions = false;
				void 0;

			    var data = {
				    order: {
					    key: $scope.account.selectedOrder.key,
					    itemName: item.name,
					    instructions: item.instructions,
				    }
			    };

				if (item.selectedModifiers) {
				    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
					    return modifier.name;
				    });
			    }


			    void 0;

			    hsAdmin.updateOrder(data)
				    .then(function (response) {
					    void 0;
					    switch (response.status) {
						    case 200:
							    void 0;
							    toastr.success('Updated Instructions successfully.');
							    break;
						    
						    default:
							    $scope.account.init($scope.account.selectedOrder.key);
							    toastr.error('Error updating Instructions.');
							    break;
					    }

					    delete item._isUpdating;
						delete item._showInstructions;

				    });
			},
		    updateItemInstructions(item) {
			    ngDialog.open({
				    template: 'partials/popup/item-instructions-popup.html',
				    controller:'ModalController',
				    closeByNavigation: true,
				    className: 'ngdialog-theme-default email-capture',
				    data: {
					    order: $scope.account.selectedOrder,
					    item: item
				    },
				    preCloseCallback(val) {
					    if (val) {
						    $scope.account.init($scope.account.selectedOrder.key);
					    }
				    }
			    });
		    },
		    updateDeliveryInstructions() {
			    ngDialog.open({
				    template: 'partials/popup/delivery-instructions-popup.html',
				    controller:'ModalController',
				    closeByNavigation: true,
				    className: 'ngdialog-theme-default email-capture',
				    data: {
					    order: $scope.account.selectedOrder
				    },
				    preCloseCallback(val) {
					    if (val) {
						    $scope.account.init($scope.account.selectedOrder.key);
					    }
				    }
			    });
		    },
            updateDeliveryDateTime() {
                var $newScope = $scope.$new(true);
                $newScope.order = $scope.account.selectedOrder;
                ngDialog.open({
                    template: '<div><update-date-time '
                        + 'order="order" '
                        + 'admin="false" '
                        + 'on-close="closeThisDialog()" '
                        +' </update-date-time></div>',
                    plain: true,
                    className: 'ngdialog-theme-default',
                    scope: $newScope,
                    name: 'fullscreen',
                }).closePromise.then(function() {
                    $scope.account.init($scope.account.selectedOrder.key);
                })
                .catch(function(err) {
                    void 0;
                });
            },
		    addTip(type) {
			    ngDialog.open({
				    template: 'partials/popup/add-tip-popup.html',
				    controller: 'ModalController',
				    className: 'ngdialog-theme-default',
				    data: {
					    order: $scope.account.selectedOrder,
                        type: type
				    },
				    preCloseCallback(val) {
					    if (val) {
						    $scope.account.init($scope.account.selectedOrder.key);
					    }
				    }
			    });
		    },
            isSeparateTips() {
                return typeof $scope.account.selectedOrder.shopperTip === 'number';
            },
		    showAddItemPopup() {
			    $scope.order = $scope.account.selectedOrder;
                var template = 'partials/popup/user-add-item-to-order-popup.html';

                if ($scope.order.isTableSideOrder) {
                    template = 'partials/popup/table-side-order-add-item-to-order.html';
                    hsTableSideOrders.refreshSession();
                }

			    ngDialog.open({
				    template: template,
				    controller      : 'ModalController',
				    className       : 'ngdialog-theme-default add-item-to-order-dialog',
				    showClose       : false,
				    closeByDocument : false,
				    closeByEscape   : true,
				    closeByNavigation: true,
				    scope           : $scope,
				    name            : 'add-item-to-order',
				    id              : 'add-item-to-order',
				    preCloseCallback(val) {
                        $location.search('showAddItem', null);
                        $location.search('showAddItemSummary', null);

					    $scope.account.init($scope.account.selectedOrder.key);
				    }
			    });
		    },
		    removeItem(order, item) {
			    void 0;
			    void 0;
			    var data = {
				    order: {
					    key: encodeURIComponent($scope.account.selectedOrder.key),
					    itemName: encodeURIComponent(item.name),
					    selectedModifiers : item.selectedModifiers || []
				    }
			    };

			    void 0;

			    void 0;
			    hsAdmin.removeItemFromOrder(data)
				    .then(function (response) {
					    if (response.status === 200) {
						    void 0;
						    void 0;
						    toastr.success('Item removed successfully.');
						    $scope.account.selectedOrder.items.splice($scope.account.selectedOrder.items.indexOf(item), 1);
						    $scope.account.selectedOrder.sortedItems = globalFunctions.filterProductsByCategory($scope.account.selectedOrder.items);
						    $scope.account.init($scope.account.selectedOrder.key);
					    } else if (response.status === 406) {
						    toastr.error(globalFunctions.errorMsg.minOrder);
					    } else {
						    void 0;
						    void 0;
						    item.isUpdating = false;
						    toastr.error('Error removing item from order');
					    }
				    });
		    },
		    substituteItem(item, leaveOut) {
			    var canReplace = !item.canReplace;
			    item.leaveOut = leaveOut;
			    void 0;

			    var data = {
				    order: {
					    key: $scope.account.selectedOrder.key,
					    itemName: item.name,
					    canReplace: canReplace
				    }
			    };

			    if (item.selectedModifiers) {
				    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
					    return modifier.name;
				    });
			    }

			    void 0;
			    hsAdmin.updateOrder(data)
				    .then(function (response) {
					    switch(response.status) {
						    case 200:
							    void 0;
							    toastr.success('Updated successfully.');
							    item.canReplace = !item.canReplace;
							    // $scope.account.init($scope.account.selectedOrder.key);
							    break;
						    default:
							    void 0;
							    item.leaveOut = !item.leaveOut;
							    toastr.error('Error updating status.');
							    break;
					    }

					    item.isUpdating = false;

				    });
		    },
            getProductDisplayName: function (item) {
                return hsCart.getProductDisplayName(item);
            },
            getProductItemizedTotal: function (item) {
                return hsCart.getProductItemizedTotal(item);
            },
		    updateItemInOrder(item, index, category) {
			    void 0;
			    var inputElement = $('#quantity-' + category +'-'+ index);
			    var quantity = inputElement.val();
				var validationError = hsCart.validateQuantity(item, inputElement);

				if (validationError) {
					toastr.error(validationError);
					return;
				}
			    void 0;
			    var data = {
				    order: {
					    key: $scope.account.selectedOrder.key,
					    itemName: item.name,
					    itemQuantity: parseFloat(quantity)
				    }
			    };

			    if (item.selectedModifiers) {
				    data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
					    return modifier.name;
				    });
			    }

			    void 0;

			    hsAdmin.updateOrder(data)
				    .then(function (response) {
					    void 0;
					    switch (response.status) {
						    case 200:
							    void 0;
							    toastr.success('Updated quantity successfully.');
							    $('#update-btn-'+ category +'-'+ index).addClass('hidden');
							    $scope.account.init($scope.account.selectedOrder.key);

							    break;
						    case 402:
							    toastr.error('Your credit card was declined, please make sure there are enough funds on your card or ask your bank to authorize the transaction and retry.');
							    break;
							case 409:
								toastr.error('Maximum quantity for product reached.');
								$scope.account.init($scope.account.selectedOrder.key);
							    break;
						    case 406:
							    toastr.error(globalFunctions.errorMsg.minOrder);
							    break;
						    case 403:
							    globalFunctions.showConfirmationDialog(globalFunctions.userOrderChanges.heading, globalFunctions.userOrderChanges.subHeading,
								    'Confirm', '', function (err, success) {
									    void 0;
									    $scope.account.init($scope.account.selectedOrder.key);
								    });
							    toastr.error('Can not make changes anymore.');
							    break;
						    default:
							    $scope.account.init($scope.account.selectedOrder.key);
							    toastr.error('Error updating quantity.');
							    break;
					    }

					    item.isUpdating = false;

				    });
		    },
            showUpdateCardPopup() {
                ngDialog.open({
                    template: '<div><order-payment-popup '
                        + 'on-success="account.orderUpdates.updateCreditCardSuccess(paymentMethodPmid, closeThisDialog)" '
                        + 'on-cancel="closeThisDialog()" '
                        + 'payment-processor="$root.paymentProcessor" '
                        + 'user="$root.currentUser" '
                        + '></order-payment-popup></div>',
                    className: 'ngdialog-theme-default',
                    scope: $scope,
                    plain: true,
                });
            },
            updateCreditCardSuccess(paymentMethodPmid, closeThisDialog) {
                var data = {
                    key: $scope.account.selectedOrder.key,
                    updatePaymentMethodPmid: paymentMethodPmid,
                };

                return hsAdmin.updateOrderDetails({ order: data })
                    .then(function(res) {

                        if (res.status === 200) {
                            $scope.account.setUser(res.data.userObj);
                            $scope.account.viewOrderDetails(res.data);
                            closeThisDialog();

                            return ngDialog.openConfirm({
	                            data: {
	                                heading: 'Credit Card Updated',
	                                subHeading: 'Your credit card was successfully updated. We will process your order with the new credit card shortly.',
	                                confirmBtnText: 'Ok',
	                            },
	                            template: 'partials/popup/confirm-popup.html'
	                        }).then(function() {}).catch(function(err) {});
                        }

                        throw new Error('Failed to update the order with the new credit card.');
                    });
            },
            shouldShowUpdateCreditCardButton() {
            	if ($scope.account.config.isTableSideOrder) {
            		return !['Completed', 'Cancelled'].includes($scope.account.selectedOrder.state);
            	}
            	if ($scope.account.selectedOrder.isPreorder && $scope.account.selectedOrder.preorderSteps) {
            		return $scope.account.selectedOrder.preorderSteps.finalAuthStatus === 'Failed';
            	}
				if ($scope.account.selectedOrder.isAdvancedOrder && $scope.account.selectedOrder.advancedOrderSteps) {
            		return $scope.account.selectedOrder.advancedOrderSteps.finalAuthStatus === 'Failed';
            	}
            	return false;
            },
	    },
	    billing 					: {
		    ccNumber				: '',
		    expDate					: '',
		    cvc						: ''
	    },
	    // The Entity that represents the user's billing address
	    billingAddress              : {
		    street1             : "",
		    street2             : "",
		    city                : "",
		    state               : "",
		    zip                 : "",
		    country             : ""
	    },
	    productData                 : {
		    allProducts: [],
		    outOfStockProducts: [],
		    originalCategorizedProducts: [],
		    categorizedProducts: []
	    },
        setUser(userData) {
            if (hsUtils.isObject(userData)) {
                $scope.account.userData = userData;
                $scope.account.paymentMethods = (Array.isArray(userData.paymentMethods) && userData.paymentMethods || []).slice().reverse();
            } else {
                $scope.account.userData = null;
                $scope.account.paymentMethods = [];
            }
        },
	    deleteUser() {
		    ngDialog.openConfirm({
			    data: {
				    heading: 'Are You Sure?',
				    subHeading: 'Please confirm that you want to delete your account permanently. This action cannot be undone.',
				    confirmBtnText: 'Confirm',
				    cancelBtnText: 'Cancel'
			    },
			    template: 'partials/popup/confirm-popup.html',
		    }).then(function (confirm) {
		    	hsApi.deleteUser()
				    .then(function(res) {
				    	if (res.status === 200) {
						    ngDialog.openConfirm({
							    data: {
								    heading: 'Success!',
								    subHeading: 'Success, please allow up to 24 hours for all your data to be deleted from our systems.',
								    confirmBtnText: 'Okay'
							    },
							    template: 'partials/popup/confirm-popup.html',
							    showClose: false,
							    closeByDocument: false,
							    closeByEscape: false
						    }).then(function (confirm) {
						    	hsAuth.logoutUser();
							    ngDialog.close();
						    }, function (reject) {
							    void 0;
							    return;
						    });
					    } else if (res.status === 409) {
				    		toastr.error('Cannot delete account at this time. You have one or more outstanding order. Try again once the order is completed or cancelled.');
					    } else {
				    		toastr.error('Something went wrong. Please try again later.')
					    }
				    });

			    ngDialog.close();
		    }, function (reject) {
			    void 0;
			    return;
		    });
	    },
	    backToOrderHistory() {
		    this.config.showOrderDetails = false;
		    this.config.showChangeLog = false;
		    this.selectedChangeLogItem = 'All';
		    $location.search('order', null);
	    },
	    toggleChangeLog() {
		    this.config.showChangeLog = !this.config.showChangeLog;
	    },
	    showProductPopup(product) {
		    void 0;

		    var modalClass = '';
		    if(product.hasImage){
			    modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
		    }else{
			    modalClass = 'ngdialog-theme-default email-capture';
		    }

		    ngDialog.open({
			    template: 'partials/popup/product-item/product-item-popup.html',
			    controller:'ModalController',
			    className: modalClass,
			    data: product,
                scope: $scope,
		    });
	    },
	    toggleUpdateAddress() {
		    this.config.showUpdatedAddressSection = !this.config.showUpdatedAddressSection;
		
		    this.address = {
			    street1             : "",
			    street2             : "",
			    city                : "",
			    state               : "",
			    zip                 : "",
			    country             : ""
		    };

		    this.config.addressNonEditable = false;
	    },
        hasPaymentMethod() {
            return hsUtils.isNonEmptyArray($scope.account.userData.paymentMethods);
        },
        getMembershipBalance() {
            var balanceString = '';
            var pointsMultiplier = 1;
            var unit = 'money';
			var numDecimalPlaces = 2;
            if ($rootScope.currentUser.membership.loyaltyPoints) {
                if ($rootScope.currentUser.membership.loyaltyPoints.units) {
                    unit = $rootScope.currentUser.membership.loyaltyPoints.units;
                }
                if ($rootScope.currentUser.membership.loyaltyPoints.pointsMultiplier) {
                    pointsMultiplier = $rootScope.currentUser.membership.loyaltyPoints.pointsMultiplier;
                }
				if ($rootScope.currentUser.membership.loyaltyPoints.numDecimalPlaces >= 0) {
					numDecimalPlaces = $rootScope.currentUser.membership.loyaltyPoints.numDecimalPlaces;
				}
            }

            if (unit === 'money') {
                balanceString += '$';
            }
            var balance = ($rootScope.currentUser.membership.balance ? $rootScope.currentUser.membership.balance : 0) * pointsMultiplier;

            balance = balance.toFixed(numDecimalPlaces);
            balanceString += balance;

            return balanceString;
        },
        showMembershipBalance() {
            return $rootScope.currentUser.membership && $rootScope.currentUser.membership.hasOwnProperty('balance') ||  globalFunctions.isErewhon();
        },
        getCardLast4() {
            if ($rootScope.paymentProcessor === 'stripe' || $rootScope.paymentProcessor === 'fiserv') {
                return $scope.account.userData.paymentMethod.cardLast4;
            } else if ($rootScope.paymentProcessor === 'worldpay') {
                return $scope.account.userData.paymentMethod.vgsWorldPay.cardLast4;
            }
        },
        getCardBrand() {
            if ($rootScope.paymentProcessor === 'stripe' || $rootScope.paymentProcessor === 'fiserv') {
                return $scope.account.userData.paymentMethod.cardBrand;
            } else if ($rootScope.paymentProcessor === 'worldpay') {
                return $scope.account.userData.paymentMethod.vgsWorldPay.cardBrand;
            }
        },
	    toggleUpdateCC(toState) {
	    	if (typeof toState === 'boolean') {
	    		this.config.showUpdatedCCSection = toState;
	    	} else {
			    this.config.showUpdatedCCSection = !this.config.showUpdatedCCSection;
	    	}
	    },
	    togglePaymentMethodMenu(paymentMethod) {
	    	paymentMethod.showMenu = !paymentMethod.showMenu;

	    	for (var pm of $scope.account.paymentMethods) {
	    		if (pm !== paymentMethod) {
	    			pm.showMenu = false;
	    		}
	    	}
	    },
	    toggleUpdatePhone() {
		    this.config.showUpdatePhoneSection = !this.config.showUpdatePhoneSection;
	    },
        updatePhoneNumber(form) {
            if(form.validate()) {
                globalFunctions.getSelectedLocation()
                    .then(function (location) {
                        if (location.requiresPhoneNumberVerification) {
                            var $newScope = $scope.$new(true);
                            $newScope.phoneNumber = $filter('bcTelephone')(form.phoneUS.$modelValue, 'clean');

                            ngDialog.open({
                                template: '<div><code-verification '
                                    + 'phone-number="phoneNumber" '
                                    + 'on-close="closeThisDialog(value)" '
                                    + 'purpose="updatePhoneNumber" '
                                    + '></code-verification></div>',
                                className: 'ngdialog-theme-default',
                                plain: true,
                                scope: $newScope,
                            }).closePromise
                                .then(function(data) {
                                    void 0;
                                    if (data.value) {
                                        if (data.value.error) {
                                            toastr.error(data.value.error);
                                        } else if (data.value.user) {
                                            hsAuth.saveUserLocal(data.value.user);
                                            $scope.account.setUser(data.value.user);
                                            $scope.account.toggleUpdatePhone();
                                            toastr.success('Phone number updated successfully.');
                                        }
                                    }
                                })
                                .catch(function(err) {
                                    void 0;
                                    toastr.error('Could not verify phone number. Please try again.');
                                });
                        } else {
                            $scope.account._updatePhoneNumber(form);
                        }
                    })
                    .catch(function (err) {
                        toastr.error(err);
                    });
            }
        },
	    _updatePhoneNumber(form) {
		    if(form.validate()){
			    $scope.account.config.buttonLoading = true;
			    void 0;
		    	var data = {
				    user: {
					    phoneNumber: form.phoneUS.$modelValue
				    }
			    };

		    	data.user.phoneNumber = $filter('bcTelephone')(data.user.phoneNumber, 'clean');
			    
			    void 0;
			    
			    hsCart.updateUser(data)
			    .then(function(response){
			    	void 0;
				    if(response.status === 200){
                        hsAuth.saveUserLocal(response.data);
                        $scope.account.setUser(response.data);
					    $scope.account.toggleUpdatePhone();
						toastr.success('Phone number updated successfully.');
				    }else{
						toastr.error('Error updating phone number.');
				    }

                    if(response.status === 403) {
                        $route.reload();
                    }
				
				    $scope.account.config.buttonLoading = false;
			    })
		    }
	    },
        toggleCustomUserData(key, customUserDataSetting) {
            if (
                customUserDataSetting &&
                $scope.account.config.updateCustomUserDataSetting &&
                customUserDataSetting !== $scope.account.config.updateCustomUserDataSetting
            ) {
                $scope.account.config.updateCustomUserDataKey = key;
                $scope.account.config.updateCustomUserDataSetting = customUserDataSetting;
                $scope.account.config.showUpdateCustomUserDataSection = true;
            } else if (!$scope.account.config.updateCustomUserDataSetting) {
                $scope.account.config.updateCustomUserDataKey = key;
                $scope.account.config.updateCustomUserDataSetting = customUserDataSetting;
                $scope.account.config.showUpdateCustomUserDataSection = !$scope.account.config.showUpdateCustomUserDataSection;
            } else {
                $scope.account.config.showUpdateCustomUserDataSection = !$scope.account.config.showUpdateCustomUserDataSection;
            }
        },
        closeCustomUserData() {
            $scope.account.config.showUpdateCustomUserDataSection = false;
        },
        updateCustomUserData(form) {
            if ($scope.account.config.buttonLoading) {
                return;
            }

            $scope.account.config.buttonLoading = true;
            void 0;
            var data = {
                user: {
                    customUserData: {}
                }
            };

            var cudId = $scope.account.config.updateCustomUserDataKey;
            if (form[cudId].$modelValue) {
                data.user.customUserData[cudId] = (form[cudId].$modelValue).toString().trim();
            }

            void 0;
            
            hsCart.updateUser(data)
            .then(function(response){
                void 0;
                if(response.status === 200){
                    hsAuth.saveUserLocal(response.data);
                    $scope.account.setUser(response.data);
                    toastr.success($scope.account.config.updateCustomUserDataSetting.displayName + ' updated successfully.');
                    $scope.account.closeCustomUserData();
                }else{
                    toastr.error('Error updating ' + $scope.account.config.updateCustomUserDataSetting.displayName);
                }

                if(response.status === 403) {
                    $route.reload();
                }
            })
            .finally(function() {
                $scope.account.config.buttonLoading = false;
            });
        },
	    showTaxPopup(order) {
		    var modalClass = 'ngdialog-theme-default email-capture';

		    ngDialog.open({
			    template: 'partials/popup/tax-details-popup.html',
			    controller:'ModalController',
			    className: modalClass,
			    data: order
		    });
	    },
	    showFeePopup(order, feeType) {
		    var modalClass = 'ngdialog-theme-default email-capture';
		    order.feeType = feeType;

		    ngDialog.open({
			    template: 'partials/popup/fee-details-popup.html',
			    controller:'ModalController',
			    className: modalClass,
			    data: order
		    });
	    },
	    filterProducts (products, screenWidth) {
		    angular.forEach(products, function (val, key, idx) {
			    if (val.hasOwnProperty('renderEmptyTile')) {
				    products.splice(idx, 1);
			    }
		    });

		    var productLength = products.length;
		    var selectedWidth;
		    var maxGridLength;

		    angular.forEach(screenWidth, function (width, key) {
			    width === true ? selectedWidth = key : '';
		    });

		    switch (selectedWidth) {
			    case 'lg' : {
				    maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
				    break;
			    }
			    case 'md' : {
				    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
				    break;
			    }
			    case 'sm' : {
				    maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
				    break;
			    }
			    case 'xs' : {
				    maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
				    break;
			    }
		    }

		    var objectsToAdd = [];
		    for (var i = 0; i < maxGridLength; i++) {
			    objectsToAdd.push({
				    renderEmptyTile: true
			    });
		    }

		    return products.concat(objectsToAdd);
	    },
	    getAllProducts() {
		    var productList;
		    var req = {
			    method: 'GET',
			    url: ENV.apiEndPoint + '/product/list',
			    headers: {}
		    };

		    req.headers['location'] = $scope.account.selectedOrder.location;

		    if (ENV.enablePriceList) {
			    req.headers['pricelist'] = $scope.account.selectedOrder.priceList;
		    }

		    productList = $http(req);
		    
		    var itemsMap = {};

		    $scope.account.selectedOrder.items.forEach(function (item) {
			    if (!itemsMap.hasOwnProperty(item.name)) {
				    itemsMap[item.name] = {
					    quantity: item.quantity,
					    instructions: item.instructions
				    }
			    } else {
				    itemsMap[item.name].quantity += item.quantity;
			    }
		    });
		    
		    void 0;

		    return $q.all([productList])
			    .then(function (response) {
				    void 0;
				    if (response[0].status === 200) {
					    var categoryOrder = JSON.parse(JSON.stringify(ENV.categoryOrder));
					    var subCategoryOrder = JSON.parse(JSON.stringify(ENV.subCategoryOrder));
					    var data = globalFunctions.getSortedProducts(response[0].data.products, null, true, itemsMap);
					    var allProducts = data.allProducts;
					    var hiddenProducts = data.hiddenProducts;
					    var outOfStockProducts = [];
					    var allOutOfStockProducts = data.outOfStockProducts;
					    var sortedData = data.sortedData;
						
						angular.forEach(sortedData, function(val, key) {
						    if (!val) {
							    delete sortedData[key];
						    } else {
							    // Sorting Sub Category Order if enabled in config
							    if (ENV.sortSubCategoryOrder) {
								    sortedData[key].categories = globalFunctions.sortJSONObj(sortedData[key].categories);
							    }

							    // Maintaining Sub Category order if defined in config
							    if (subCategoryOrder[key]) {
								    var newOrder = {};
								    angular.forEach(subCategoryOrder[key], function(subVal, subKey) {

										var subCategoryData = sortedData[key].categories[subKey];

										/*
										 * This check is added so that only products existing in the product list are added
										 * subcategories in client-config for which no products exist will be skipped
										 */
										if(subCategoryData) {
											newOrder[subKey] = subCategoryData;
										}
										
								    });

								    sortedData[key].categories = newOrder;
							    }

							    // Filling the grid with empty tiles For Homepage
							    sortedData[key].homePageProducts = globalFunctions.addEmptyGridTiles('homePageProducts', sortedData[key], $rootScope.screenWidth);

							    // Filling the grid with empty tiles for 2 column grid for Order view or Minimal Layout
							    sortedData[key].menuProducts = globalFunctions.addEmptyGridTiles('orderPage', sortedData[key].products, $rootScope.screenWidth);

							    // Filling the grid with empty tiles to Show all products on Homepage
							    if (ENV.showAllProducts) {
								    sortedData[key].tileProducts = globalFunctions.addEmptyGridTiles('regular', sortedData[key].tileProducts, $rootScope.screenWidth);
								    sortedData[key].nonTileProducts = globalFunctions.addEmptyGridTiles('regular', sortedData[key].nonTileProducts, $rootScope.screenWidth);
							    }



							    // Iterating over Sub Categories
							    angular.forEach(sortedData[key].categories, function (val){
								    if ($rootScope.minimalProductLayout) {
									    // Filling the grid with empty tiles for 2 column grid for Order view or Minimal Layout
									    val.products = globalFunctions.addEmptyGridTiles('orderPage', val.products, $rootScope.screenWidth);
								    }

								    // Filling the grid with empty tiles for category pages.
								    val.tileProducts = globalFunctions.addEmptyGridTiles('regular', val.tileProducts, $rootScope.screenWidth);
								    val.nonTileProducts = globalFunctions.addEmptyGridTiles('regular', val.nonTileProducts, $rootScope.screenWidth);
							    });

							    if (categoryOrder.hasOwnProperty(key) === false) {
							    	delete categoryOrder[key];
							    }

						        categoryOrder[key] = sortedData[key];
						    }
					    });

					    var categoryData = {};
					    var sortedCategories = [];
					    Object.keys(categoryOrder)
						    .forEach(function (category, idx) {
						    	if (categoryOrder[category]) {
							        sortedCategories.push(categoryOrder[category]);
							        categoryData[category] = categoryOrder[category];
							    }
						    });

					    void 0;

					    sortedCategories.forEach(function (category) {
						    angular.forEach(category.categories, function (val, key) {
							    val.products = $scope.account.filterProducts(val.products, $rootScope.screenWidth);
						    });
					    });

					    $scope.account.allProductsHash = data.allProductsHash;
                        // $scope.account.productData.categoryOrder is used for Add Item in my-account order
                        // I don't know why TJ didn't reuse sortedCategories
					    $scope.account.productData.categoryOrder = categoryData;
					    $scope.account.productData.allProducts = allProducts;
					    $scope.account.productData.outOfStockProducts = outOfStockProducts;
					    $scope.account.productData.originalCategorizedProducts = sortedCategories;
					    $scope.account.productData.categorizedProducts = sortedCategories;

                        if ($scope.account.selectedOrder) {
                            $scope.account.formatOrder($scope.account.selectedOrder);
                        }
				    }
			    })
			    .catch(function (response) {
				    void 0;
			    });
	    },
	    getItemQuantity(item) {
        	if (item.unit === 'lb' && (item.quantity % .5) !== 0) {
		        var inv = 1.0 / 0.5;
		        return Math.round(item.quantity * inv) / inv;
	        } else {
        		return item.quantity;
	        }
	    },
		hasPriceEmbeddedBarcodeAndSoldByLb(item) {
			return (hsUpc.isRandomWeightUpc(item.upc) || hsUpc.isRandomWeightProductUpc(item.upc)) && item.unit === 'lb'; 
		},
	    calculateProductPrice(priceObj) {
		    return hsCart.calculateProductPrice(priceObj);
	    },
	    calculatePricePerQuantity(priceObj) {
		    return hsCart.calculatePricePerQuantity(priceObj);
	    },
	    completeOrder() {
            // Should be able to complete the order regardless of the table side order session.
            if (!$scope.account.selectedOrder.isTableSideOrder || ['Completed', 'Cancelled'].includes($scope.account.selectedOrder.state)) {
                toastr.error('Can only complete an open table side order.');
                return;
            }
            hsTableSideOrders.refreshSession();

            var $newScope = $scope.$new(true);
            $newScope.order = $scope.account.selectedOrder;
            $newScope.onOrderUpdate = $scope.account.viewOrderDetails.bind(this);

            ngDialog.open({
                template: '<div><hs-tip '
                    + 'order="order" '
                    + 'on-close="closeThisDialog()" '
                    + 'on-order-update="onOrderUpdate(order)" '
                    + '><hs-tip/></div>',
                className: 'ngdialog-theme-default',
                plain: true,
                scope: $newScope,
            }).closePromise
                .then(function() {

                    ngDialog.openConfirm({
                        data: {
                            heading: 'All Set?',
                            subHeading: 'Please confirm that you want to complete the order. This action cannot be undone.',
                            confirmBtnText: 'Confirm',
                            cancelBtnText: 'Cancel'
                        },
                        closeByDocument: false,
                        template: 'partials/popup/confirm-popup.html',
                    })
                        .then(function(confirm) {
                            var postData = {
                                order: {
                                    key: $scope.account.selectedOrder.key,
                                    status: 'Completed'
                                }
                            };

                            hsAdmin.updateOrderStatus(postData)
                                .then(function (response) {
                                    void 0;
                                    if (response.status === 200) {
                                        toastr.success('Order completed successfully.');
                                        hsTableSideOrders.endSession();
                                        $scope.account.init($scope.account.selectedOrder.key);
                                        ngDialog.close();
                                    } else {
                                        toastr.error('Error completing order.');
                                    }

                                });

                        })
                        .catch(function(err) { void 0; });
                })
                .catch(function(err) { void 0; });
	    },
        init() {
        	void 0;
	        $scope.account.config.updateSEOdata('Account | ' + ENV.SEO.title);
	        var user = hsAuth.getUser();
            void 0;
            if (user) {

                var locationPromise = Promise.resolve();

                var location = localStorageService.get('location');
                var selectedLocation = location && location.selectedLocation;
                if (ENV.enableLocations && !selectedLocation) {
					locationPromise = ngDialog.open({
                        template        : 'partials/popup/select-location.html',
                        controller      : 'ModalController',
                        className       : 'ngdialog-theme-default email-capture',
                        showClose       : false,
                        closeByDocument : false,
                        closeByEscape   : false,
                        closeByNavigation: true,
                        scope           : $scope,
                        name            : 'location',
                        id              : 'location'
                    }).closePromise;
                } else if (!selectedLocation) {
                    locationPromise = globalFunctions.getSelectedLocation().then(function(loc) {
                        selectedLocation = loc;
                    });
                }
    
                locationPromise.then(function() {
                    var orderKeyParam = $location.search().order;
                    var showAddItem = $location.search().showAddItem;
                    var showAddItemSummary = $location.search().showAddItemSummary;
                    var getUser = hsAuth.getUpdatedUser();
                    var getOrderHistory = hsCart.getOrderHistory();
        
                    $q.all([getUser, getOrderHistory])
                        .then(function(response) {
                            void 0;
                            if(response[0].status === 200 && response[1].status === 200) {
    
                                hsAuth.saveUserLocal(response[0].data);
                                $scope.account.setUser(response[0].data);
    
                                $scope.account.orderHistory = response[1].data.orders;
    
                                if (orderKeyParam) {
                                    var selectedOrder = $scope.account.orderHistory.find(function(order) {
                                        return orderKeyParam === order.key;
                                    });
                                    if (selectedOrder) {
                                        $scope.account.viewOrderDetails(selectedOrder, showAddItem, showAddItemSummary);
                                    } else {
                                        $location.search('order', null);
                                    }
                                }
                            }
                            void 0;
    
                            if (selectedLocation && selectedLocation.customUserDataSettings) {
                                $scope.account.config.customUserDataSettings = selectedLocation.customUserDataSettings;
                            }
                            if (selectedLocation && selectedLocation.membershipStoreSettings) {
                                $scope.account.config.membershipStoreSettings = selectedLocation.membershipStoreSettings;
                            }

                            $scope.account.config.pageFullyLoaded = true;
                        }).catch(function(err) {
                            void 0;
                        });
    
                })

                
            } else {
            	var redirectUrl = '/login?redirect=' + encodeURIComponent($location.url());
            	void 0;
            	
            	hsAuth.invalidateSession(redirectUrl);
            }
        },
        connectChangeLogItems(order) {
            var itemsList = {};

            order.changeLog.forEach(function(item) {
                if (item.itemName && !(item.itemName in itemsList)) {
                    itemsList[item.itemName] = {};
                }
                item.date = new Date(item.time.year, item.time.month, item.time.date, item.time.hours, item.time.minutes);
            });

            if (Object.keys(itemsList).length) {
                $scope.account.productData.allProducts.forEach(function(product) {
                    if (product.name in itemsList) {
                        itemsList[product.name] = product;
                    }
                });
            }

            angular.forEach(order.changeLogItemized, function(changeLogItem) {
                changeLogItem.forEach(function(item) {
                 if (itemsList[item.itemName]) {
                     item.itemObj = itemsList[item.itemName];
                    }
                    item.date = new Date(item.time.year, item.time.month, item.time.date, item.time.hours, item.time.minutes);
                });
            });

            order.changeLog.forEach(function(item) {
                if (itemsList[item.itemName]) {
                    item.itemObj = itemsList[item.itemName];
                }
            });

            order.changeLogItemized.All = order.changeLog;
        },
        formatOrder(order) {
            $scope.account.connectChangeLogItems(order);

            order.sortedItems = globalFunctions.filterProductsByCategory(order.items);
            order.items.forEach(function(item) {
                if (!item.hasOwnProperty('hasImage')) {
                    item.hasImage = true;
                }
            });

            if (order.shipments && order.shipments.length > 0) {
                var labelUrl = '';
                order.shipments.forEach(function(ship, idx) {
                    idx > 0 ? labelUrl += '%2C' + ship.trackingCode : labelUrl += ship.trackingCode;
                });
                order.trackingUrl = "https://tools.usps.com/go/TrackConfirmAction?tLabels=" + labelUrl;
            }
        },
	    viewOrderDetails(order, showAddItem, showAddItemSummary) {
            void 0;
        	this.changeLogItems = ['All'];
        	angular.forEach(order.changeLogItemized, function (val, key) {
        		if (key !== 'All') {
        		    $scope.account.changeLogItems.push(key);
		        }
	        });
            this.selectedOrder = order;
            this.config.showOrderDetails = true;
            $location.search('order', order.key);
            this.config.isTableSideOrder = order.fulfillmentMethod === 'Table Side';

            // TODO: check order.userChangesAllowed. What provisions are there to prevent user from editing order.
            if (order.userChangesAllowed && (!ENV.isRestaurant || ENV.enableTableSideOrder && this.config.isTableSideOrder)) {
            	this.config.canEditOrder = true;
            	this.selectedOrder.items.forEach(function(item) {
		            if (!item.hasOwnProperty('canReplace')) {
			            item.canReplace = !ENV.isRestaurant;
			            item.leaveOut = !item.canReplace;
		            } else {
			            item.leaveOut = !item.canReplace;
		            }
	            });

	            if (this.selectedOrder.isTableSideOrder) {
                    // should not be editable if customer is not at the table, no session
		            $scope.account.config.canEditTableSideOrder = !['Completed', 'Cancelled'].includes($scope.account.selectedOrder.state)
                        && $rootScope.tableSideOrder;
                    if ($scope.account.config.canEditTableSideOrder) {
                        // to prevent customer from going below the already ordered quantity
                        // going to set minQuantity on the item
                        for (var item of $scope.account.selectedOrder.items) {
                            item.minQuantity = item.quantity;
                        }
                    }
	            }

            } else {
            	this.config.canEditOrder = false;
	            $scope.account.config.canEditTableSideOrder = false;
            }
            this.getAllProducts().then(function() {
                if (showAddItem || showAddItemSummary) {
                    $scope.account.orderUpdates.showAddItemPopup();
                }
            });
        },
		shouldShowTBDFulfillmentFee(order) {
			return globalFunctions.hasTBDFulfillmentFees(order.priceList);
		},
	    updateQuantity(item, updateType, quantityBtnSelector) {
		    quantityBtnSelector = '#' + quantityBtnSelector;
		    var updateBtnSelector = quantityBtnSelector.replace('quantity', 'update-btn');

			var inputElement = $(quantityBtnSelector);
			var limits = hsCart.checkQuantityLimits(item, inputElement);
			if (updateType === 'add' && limits.max.reached) {
				inputElement.val(limits.max.value);
				toastr.error(limits.max.message);
				return;
			}
			if (updateType === 'subtract' && limits.min.reached) {
				inputElement.val(limits.min.value);
				var message = limits.min.message;
				if ($scope.account.config.isTableSideOrder) {
					message = 'Ordered quantity can not be reduced.';
				}
				toastr.error(message);
				return;
			}

		    hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
	    },
	    addToCart(item, index, category) {
		    void 0;
		    void 0;

		    if (item.isCustomItem) {
		    	toastr.error('This item cannot be added to the cart.');
		    	return;
		    }

		    if (!item.availableToOrder) {
		    	toastr.error('This product is not available to order.');
		    	return;
		    }

			var inputElement = $('#quantity-'+ category+'-'+index);

		    var isInStock;
            for (var i = 0; i < $scope.account.productData.allProducts.length; i++) {
                if ($scope.account.productData.allProducts[i].name === item.name) {
                    isInStock = $scope.account.productData.allProducts[i].isInStock;
                    break;
                }
            }

            if(!isInStock) {
                toastr.error('The Item is Temporarily Out of Stock. Please Try Again Later.');
                return;
            }
		
		    var quantity = inputElement.val();

		    if (item.hasOwnProperty('maxQuantity')
			    && item.maxQuantity > 0
		        && quantity > item.maxQuantity) {
			    inputElement.val(item.maxQuantity);
			    if (item.hasOwnProperty('maxQuantityMessage')) {
				    toastr.error(item.maxQuantityMessage);
			    } else {
				    toastr.error(globalFunctions.product.maxQuantityError(item.maxQuantity));
			    }
			    return;
		    }

		    if (item.unit === 'lb' && !item.sellByQty) {
		    	var quantityUnit = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
		    	quantity = (Math.ceil(parseFloat((quantity / quantityUnit).toFixed(2))) * quantityUnit).toFixed(2);
		    } else {
			    quantity = parseInt(quantity);
                quantity = quantity <= 0 ? 1 : quantity;
		    }

		    quantity = parseFloat(quantity);

		    var data = {
			    items : [{
				    name            : item.name,
				    quantity        : quantity,
				    isCustomItem    : item.isCustomItem,
				    instructions    : item.instructions || "",
				    displayName     : item.displayName,
				    canReplace      : globalFunctions.canReplace(item),
				    type            : item.type,
				    subType         : item.subType,
				    organic         : item.organic,
				    unit            : item.price.unit,
				    selectedModifiers: item.selectedModifiers ?
					    item.selectedModifiers.map(function(modifier) { return modifier.name}) : []
			    }]
		    };

            var headers = {
                location: $scope.account.selectedOrder.location,
            };

            if (ENV.enablePriceList) {
                headers.pricelist = $scope.account.selectedOrder.priceList;
            }

            void 0;
            hsCart.addItemToCart(data, headers)
                .then(function(response) {
                    void 0;
                    if (response.status === 200) {
                        toastr.success('Item added to cart successfully.');
                        $rootScope.$broadcast('cartUpdated');
						var gaEventCategory = aiSearchEvents.getEventCategory();
						aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.ADD_TO_CART, item.name);
                    } else {
                        toastr.error('Error adding item.');
                    }
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Semething went wrong. Failed to add item.');
                });
        },
        updateCreditCardSuccess(userData) {
            $scope.account.toggleUpdateCC(false);
            hsAuth.saveUserLocal(userData);
            $scope.account.setUser(userData);
        },
	    updateAddress(form, address) {
		    $scope.account.config.updateAddressError = '';
            $scope.$broadcast('validateAddress-my-account-delivery', function(isValid) {
                if (!isValid) return;

                $scope.account.config.updateAddressButtonLoading = true;
                var addressObj              = {
                    user         : {
                        address   :{
                            street          : address.street,
                            aptUnit         : address.aptUnit,
                            city            : address.city,
                            state           : address.state,
                            zip             : address.zip
                        }
                    }
                };
            
                hsCart.updateUser(addressObj)
                .then(function(response){
                    void 0;
                    if(response.status === 200){
                        hsAuth.saveUserLocal(response.data);
                        $scope.account.setUser(response.data);
                    
                        $scope.account.toggleUpdateAddress();
                        $scope.account.config.updateAddressButtonLoading = false;
                    
                        toastr.success('Address Updated Successfully');
                    }else if(response.status === 403) {
                        toastr.error('Error Updating Address');
                        $scope.account.config.updateAddressError = "We do not deliver to the address you provided. " +
                            "Please contact <a href='mailto:support@phontabulous.com'>Customer Support</a> for further assistance.";
                        $scope.account.config.updateAddressButtonLoading = false;
                    }else{
                        toastr.error('Error Updating Address');
                        $scope.account.config.updateAddressError = "Something went wrong updating your address. Please try again";
                        $scope.account.config.updateAddressButtonLoading = false;
                    }
                });
            });
	    },
	    /**
	     * If the supplied object contains a reference to an AutoComplete object, proceed to
	     * filling the rest of the entity fields, otherwise just skip as no autocomplete event
	     * happened.
	     * @param {object} shippingAddr
	     */
	    addressAutoComplete(shippingAddr, property, addr2Label) {
		    // If the value of `street1` is not a string, it means that it is the object
		    // reference as a result of the `ngAutocomplete` functionality, which means we
		    // have to fill out the rest of the entity fields.
		    if (typeof(this[property].street1) !== 'string') {
			    var autoCompleteObject  = shippingAddr.street1;
			    var autoCompleteAddress = address.getAutoCompleteAddress(autoCompleteObject);
			    this[property].street1    = autoCompleteAddress.street1;
			    this[property].street2    = autoCompleteAddress.street2;
			    this[property].city       = autoCompleteAddress.city;
			    this[property].state      = autoCompleteAddress.state;
			    this[property].zip        = autoCompleteAddress.zip;
			    this[property].country    = autoCompleteAddress.country;

				$scope.account.isValidAddressFromGoogleMaps = true;
			    $scope.account.config[property + 'NonEditable'] = true;

			    // Once autocomplete is done populating fields, focus on the Address 2 field
			    // As street2 cannot be auto completed.
			    // Putting it inside a TimeOut to ensure other events don't prevent this from happening
			    setTimeout(function() {
				    angular.element('#' + addr2Label).focus();
			    }, 0);
		    }
	    },
	    /**
	     * Requests backend to verify if User Address is a valid Shipping address and update with
	     * the closest sanitized version of the address.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    verifyAddress(shippingAddr) {
		    void 0;
		    this.notification.reset();
		    this.notification.isVerificationLoading = true;
		
		    address.verify(
			    shippingAddr.street1,
			    shippingAddr.street2,
			    shippingAddr.city,
			    shippingAddr.state,
			    shippingAddr.zip,
			    shippingAddr.country
		    )
		    .success(function(suggestedAddress, responseMap) {
			    // Using the suggested address to update the input values
			    void 0;
			    return suggestedAddress;
		    })
		    .error(function(data, status, headers, config){
			    void 0;
			    return data.success;
		    });
	    },
	    /**
	     * Takes a verified address and submits it for registration and in case there is a
	     * gift redemption, it will attempt to redeem it.
	     * @param {object} shippingAddr Obj reference to `this.address`
	     */
	    submitAddress(shippingAddr) {
		    void 0;
		    var apiUrl   = ENV.tbApiEndPoint + "/api/v1/user/register/address";
		    $scope.myPromise = $http.post(apiUrl, shippingAddr)
		    .success(function(data, status, headers, config){
			    void 0;
			    localStorageService.remove('user');
			    localStorageService.set('user', data);
			
			    $rootScope.signupHeader     = false;
			    $rootScope.showSignupFooter = false;
			
			    //Getting signup progress from the localstorage
			    var signupProgress = localStorageService.get('signupProgress');
			    if(signupProgress){
				    signupProgress.shipping = true;
				    localStorageService.remove('signupProgress');
				    localStorageService.add('signupProgress', signupProgress);
			    }
			
			    $location.url('/tb/my-account');
			    return;
		    })
		    .error(function(data, status, headers, config){
			    $scope.shippingRegistration._handleAddressError(data.code);
		    });
	    },
	    _handleAddressError(errorCode) {
		    this.notification.reset();
		
		    switch(errorCode) {
			    case 200001 :
				    $scope.signup.config.signupError = "Currently, we only serve in United States.";
				    break;
			    case 200002 : // Unable to serve address
				    $scope.signup.config.signupError = "Oopsies, We don't deliver in your state at the moment.";
				    break;
			    case 200003 : // Unable to serve address
				    $scope.signup.config.signupError = "We're unable to verify this as a valid deliverable address. Please contact customer support email at info@naturecarebox.com.";
				    break;
			    default :
				    $scope.signup.config.signupError = "Something went wrong. Please contact customer support email at info@naturecarebox.com.";
				    break;
		    }
		
		    setTimeout(function(){
			    scrollToElement('.address-error-msg');
		    },500);
		
	    },
	    __validateAddress(shippingAddr) {
		    this.notification.reset();
		
		    if ($.trim(shippingAddr.street1) == "") {
			    this.notification.isAddressError = true;
			    this.notification.errMessage     = "Error in address. Address 1 is required";
			    $timeout(function(){
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }
		    if (shippingAddr.country == "US" && (shippingAddr.zip.length != 5 || isNaN(shippingAddr.zip))) {
			    this.notification.isAddressError = true;
			    this.notification.errMessage     = "Error in address. ZIP Code should be 5 digits long";
			    $timeout(function(){
				    scrollToElement('#registration-shipping-error');
			    }, 200);
			    return false;
		    }
		
		    if (!shippingAddr.street2) {
			    shippingAddr.street2 = "";
		    }
		
		    this.notification.isRegisterAddrLoading = false;
		    return true;
	    },
	    __resetAddress() {
		    this.address = {
			    street1 : "",
			    street2 : "",
			    city     : "",
			    state    : "",
			    zip      : "",
			    country  : "US"
		    };
		    this.billingAddress = {
			    street1 : "",
			    street2 : "",
			    city     : "",
			    state    : "",
			    zip      : "",
			    country  : "US"
		    };
	    },
        shouldShowWeightNote(item) {
            return !ENV.hideProductPrice && !ENV.hidePriceEverywhere && (
                item.sellByQty || item.unit === 'lb' || !Number.isInteger(item.quantity)
            );
        },
        showRenewMembershipPopup() {
            var $newScope = $scope.$new(true);

            ngDialog.open({
                template: '<div><erewhon-membership-popup '
                    + 'on-close="closeThisDialog(value)" '
                    + 'renew="true" '
                    + '></erewhon-membership-popup></div>',
                className: 'ngdialog-theme-default ngdialog-theme-erewhon',
                plain: true,
                scope: $newScope,
            }).closePromise
                .then(function(data) {
                    if (data.value && data.value === 'success') {
                        $route.reload();
                        return;
                    }
                    $scope.account.setUser($rootScope.currentUser);
                })
                .catch(function(err) {
                    void 0;
                });
        },
        canUpdateTip(tipType) {
            var order = $scope.account.selectedOrder;

            var cantUpdate = $rootScope.ENV.disableTip || order.isTippingDisabled === true || ['Completed', 'Cancelled'].includes(order.state) || order.isTableSideOrder || 
							// Temporarily added to hide update tip button for doordash. To be removed once update tip is implemented for doordash in BE
							(order.managedDelivery && order.managedDelivery.deliveryProvider === 'doordash');

            if (cantUpdate) return false;

            if (tipType === 'shopperTip') return true;

            var isDelivery = order.fulfillmentMethod === 'delivery';
            var tipWasSet = !!(order.minus && order.minus.thirdPartyTip);

            if (['tip', 'driverTip'].includes(tipType)) return !isDelivery || !tipWasSet;

            return true;
        },
		handleEditAddress: function($event){
			address.handleEditAddress($event, $scope.account);
		},
		roundNumber(number) {
			return hsUtils.roundNumber(number);
		},
        getRelevantPromotionForPrice: function (item) {
            return hsPromos.getRelevantPromotionForPrice(item, item.promotion);
        },
        shouldShowRefunds: function(order) {
            return order && order.state === 'Completed' && order.refunds.length > 0;
        },
        shouldShowRefundsEbt: function(order) {
            return order && order.state === 'Completed' && hsUtils.isNonEmptyArray(order.refundsEbt);
        },
    };
		
	
}]);

hsApp.controller('reportsCtrl', [
    '$scope',
    '$location',
    'globalFunctions',
    'ENV',
    '$filter',
    'toastr',
    'hsAdmin',
    'NgTableParams',
    function ($scope, $location, globalFunctions, ENV, $filter, toastr, hsAdmin, NgTableParams) {
        void 0;

        $scope.reports = {
            allProducts: [],
            lostRevenueReport: {
                report: null,
                ordersLoaded: false,
                metrics: {},
                startDate: {
                    model: new Date(),
                    format: 'MM-dd-yyyy',
                    dateOptions: {
                        showWeeks: false,
                        formatYear: 'yy',
                        maxDate: new Date(),
                        startingDay: 1,
                        showClear: false,
                    },
                    opened: false,
                    open: function () {
                        $scope.reports.lostRevenueReport.startDate.opened = !$scope.reports.lostRevenueReport.startDate.opened;
                    },
                },
                endDate: {
                    model: new Date(),
                    format: 'MM-dd-yyyy',
                    dateOptions: {
                        showWeeks: false,
                        formatYear: 'yy',
                        maxDate: new Date(),
                        startingDay: 1,
                        showClear: false,
                    },
                    opened: false,
                    open: function () {
                        $scope.reports.lostRevenueReport.endDate.opened = !$scope.reports.lostRevenueReport.endDate.opened;
                    },
                },
                csv: {
                    header: ['UPC', 'Item', 'Category', 'Sub Category', 'Type', 'Quantity Replaced/Removed', 'Orders Affected', 'Revenue'],
                    itemsToExport() {
                        var exportData = [];
                        var tableData = $filter('filter')(
                            $scope.reports.lostRevenueReport.tableParams.settings().dataset,
                            $scope.reports.lostRevenueReport.tableParams.filter()
                        );
                        tableData = $filter('orderBy')(tableData, $scope.reports.lostRevenueReport.tableParams.orderBy());
                        for (var item of tableData) {
                            exportData.push({
                                UPC: item.upc,
                                Item: item.displayName,
                                Category: item.category,
                                'Sub Category': item.subCategory,
                                Type: item.type,
                                'Quantity Replaced/Removed': item.quantity,
                                'Orders Affected': item.ordersAffected,
                                Revenue: item.total,
                            });
                        }
                        return exportData;
                    },
                    getFilename: function () {
                        var formattedStartDate = globalFunctions.formatDate($scope.reports.lostRevenueReport.startDate.model, '-');
                        var formattedEndDate = globalFunctions.formatDate($scope.reports.lostRevenueReport.endDate.model, '-');
                        return 'Lost-Revenue_' + formattedStartDate + '-' + formattedEndDate + '.csv';
                    },
                },
                updateReport: function () {
                    $scope.reports.lostRevenueReport.ordersLoaded = false;

                    var dateObj = {
                        startDate: {
                            day: this.startDate.model.getDate(),
                            month: this.startDate.model.getMonth(),
                            year: this.startDate.model.getFullYear(),
                        },
                        endDate: {
                            day: this.endDate.model.getDate(),
                            month: this.endDate.model.getMonth(),
                            year: this.endDate.model.getFullYear(),
                        },
                    };

                    $scope.reports.lostRevenueReport.getReport(dateObj);
                },
                initReport() {
                    if (!ENV.showReports.lostRevenue) {
                        $location.url('/admin/manager-dashboard');
                        return;
                    }

                    globalFunctions.setSEOdata('Lost Revenue Report | ' + ENV.name.companyName);

                    hsAdmin.getAllProducts(null, true).then(function (res) {
                        if (res.status === 200) {
                            $scope.reports.allProducts = res.data.products;
                            $scope.reports.lostRevenueReport.updateReport();
                        } else {
                            void 0;
                            toastr.error('Error getting products');
                        }
                    });
                },
                getReport: function (dateObj) {
                    hsAdmin.getOrderHistoryList(dateObj).then(function (res) {
                        if (res.status === 200) {
                            $scope.reports.lostRevenueReport.report = $scope.reports.lostRevenueReport.processOrders(res.data.orders);
                            void 0;

                            $scope.reports.lostRevenueReport.tableParams = new NgTableParams(
                                {
                                    count: globalFunctions.ngTableConfig.count,
                                },
                                {
                                    counts: globalFunctions.ngTableConfig.counts,
                                    dataset: $scope.reports.lostRevenueReport.report,
                                }
                            );
                            $scope.reports.lostRevenueReport.ordersLoaded = true;
                        } else {
                            void 0;
                            toastr.error('Error getting orders history');
                        }
                    });
                },
                processOrders(orders) {
                    var products = {};
                    var replacedCount = 0;
                    var removedCount = 0;
                    var itemCount = 0;
                    var revenueLost = 0;

                    for (var order of orders) {
                        if (!['Completed'].includes(order.state)) continue; // possible ['Completed', 'Received', 'Cancelled', 'Processed']

                        itemCount += order.items.length;

                        //Replaced
                        for (var item of order.items) {
                            if (item.itemReplaced) {
                                var replaced = item.itemReplaced;
                                var totalDiff = 0;
                                if (replaced.quantity * replaced.price > item.itemizedPrice) {
                                    totalDiff = replaced.quantity * replaced.price - item.itemizedPrice;
                                }
                                if (!products[replaced.name]) {
                                    products[replaced.name] = {
                                        upc: replaced.upc || '',
                                        name: replaced.name,
                                        displayName: replaced.displayName,
                                        category: replaced.type,
                                        subCategory: replaced.subType,
                                        type: 'Replaced',
                                        quantity: replaced.quantity,
                                        ordersAffected: 1,
                                        total: totalDiff,
                                    };
                                } else {
                                    products[replaced.name].quantity += replaced.quantity;
                                    products[replaced.name].ordersAffected++;
                                    products[replaced.name].total += totalDiff;
                                }
                                replacedCount++;
                                revenueLost += totalDiff;
                            }
                        }

                        //Removed
                        for (var j = 0; j < order.changeLogItemized.Removals.length; j++) {
                            var removedItemName = order.changeLogItemized.Removals[j].itemName;
                            var removedQuantity = $scope.reports.lostRevenueReport.getQuantityFromDescription(
                                order.changeLogItemized.Removals[j].description
                            );

                            var found = false;
                            for (var prod in products) {
                                if (prod === removedItemName) {
                                    found = true;
                                    break;
                                }
                            }

                            if (!found) {
                                var removed = $scope.reports.lostRevenueReport.getProductInfo(removedItemName);
                                if (removed) {
                                    if (!products[removed.name]) {
                                        products[removed.name] = {
                                            upc: removed.upc || '',
                                            name: removed.name,
                                            displayName: removed.displayName,
                                            category: removed.type,
                                            subCategory: removed.subType,
                                            type: 'Removed',
                                            quantity: removedQuantity,
                                            ordersAffected: 1,
                                            total: removedQuantity * removed.price,
                                        };
                                    } else {
                                        products[removed.name].quantity += removedQuantity;
                                        products[removed.name].ordersAffected++;
                                        products[emoved.name].total += removedQuantity * removed.price;
                                    }
                                    revenueLost += removedQuantity * removed.price;
                                } else {
                                    if (!products[removedItemName]) {
                                        products[removedItemName] = {
                                            upc: '',
                                            name: removedItemName,
                                            displayName: removedItemName,
                                            category: 'Unknown',
                                            subCategory: 'Unknown',
                                            type: 'Removed',
                                            quantity: removedQuantity,
                                            ordersAffected: 1,
                                            total: 0,
                                        };
                                    } else {
                                        products[removedItemName].quantity += removedQuantity;
                                        products[removedItemName].ordersAffected++;
                                    }
                                }
                                removedCount++;
                            }
                        }
                    }

                    $scope.reports.lostRevenueReport.metrics = {
                        totalOrders: orders.length,
                        avgItemsPerOrder: orders.length === 0 ? 0 : itemCount / orders.length,
                        avgRemovedPerOrder: orders.length === 0 ? 0 : removedCount / orders.length,
                        avgReplacedPerOrder: orders.length === 0 ? 0 : replacedCount / orders.length,
                        avgRevenueLostPerOrder: orders.length === 0 ? 0 : revenueLost / orders.length,
                    };

                    return Object.values(products).map(function (product) {
                        product.total = parseFloat(product.total.toFixed(2));
                        product.quantity = parseFloat(product.quantity.toFixed(2));
                        return product;
                    });
                },
                getProductInfo(product) {
                    return $scope.reports.allProducts.find(function (item) {
                        return item.name == product;
                    });
                },
                getQuantityFromDescription(description) {
                    return parseInt(description.match(/\d+/)[0], 10);
                },
            },
        };
    },
]);

/**
 * Created by MrSingh on 1/17/16.
 */
hsApp.controller('rewardsCtrl', [
    '$scope', '$rootScope','$route','$location','$http','globalFunctions','OpenGraphTags','ENV','$sce','$q','scrollToElement','$routeParams','$filter','$window','ngDialog','$interval','hsCart', 'hsAuth','$document','toastr','localStorageService', 'hsApi',
    function($scope, $rootScope, $route, $location, $http, globalFunctions, OpenGraphTags, ENV, $sce, $q, scrollToElement, $routeParams, $filter, $window, ngDialog, $interval, hsCart, hsAuth, $document, toastr, localStorageService, hsApi){
    
    void 0;
    
    $scope.rewards = {
        config      : {
	        showTabularView         : false,
        	pageFullyLoaded         : false,
	        numberOfProducts        : 12,
	        categoryLimit           : 4,
	        message                 : '',
	        messageClass            : '',
	        buttonLoading           : false,
            scrollTo                : function(section){
	            var element = $(section);
	            var offset = $(element).offset();
	            var scrollAmount = offset.top;
	            //console.log('Scroll amount is:'+scrollAmount);
	            scrollAmount -= 185;
	            //console.log('New Scroll amount is:'+scrollAmount);
	            // Scroll
	            $("html, body").animate({scrollTop: scrollAmount},'slow');
            }
        },
		rewardsData : {},
		allRewards :  [],
	    landing     : ENV.rewardsConfig.landing,
	    initLanding : function () {
		    hsApi.getAllRewards()
			    .then(function(res) {
				    if (res.status === 200) {
					    void 0;
					    $scope.rewards.allRewards = res.data;
					    $scope.rewards.config.pageFullyLoaded = true;

					    setTimeout(function() {
						    var ConfettiSettings = {
							    "target":"confetti",
							    "max":"180",
							    "animate":true,
							    "props":["circle","square","triangle","line"],
							    "colors":[[165,104,246],[230,61,135],[0,199,228],[253,214,126]],
							    "clock":"20"
						    };

						    var Confetti = new ConfettiGenerator(ConfettiSettings);
						    Confetti.render();
					    }, 100);
				    } else {
					    toastr.error('Error Getting Rewards Data.');
				    }
			    });
	    },
	    initMyRewards : function () {
        	if (!$rootScope.loggedIn) {
        		$location.url('/login?redirect=/my-rewards');
        		return;
	        }

        	hsApi.getAllPoints()
		        .then(function(res) {
		        	if (res.status === 200) {
		        		void 0;
		        		if (res.data.totalPoints.lastTransaction) {
		        			res.data.totalPoints.lastTransaction.date = new Date(
						        res.data.totalPoints.lastTransaction.year,
						        res.data.totalPoints.lastTransaction.month,
						        res.data.totalPoints.lastTransaction.date
					        );
				        }

		        		res.data.pointsLog.forEach(function (point) {
		        			point.displayDate = new Date(point.year, point.month, point.date);
				        });

				        res.data.userRewards.forEach(function (reward) {
				        	if (!reward.neverExpires) {
					            reward.displayExpiryDate = new Date(reward.expiry.year, reward.expiry.month, reward.expiry.date);
					        }
				        });

				        if (res.data.pointsToNextReward > 0) {
				            res.data.points = res.data.totalPointsRequiredForNextReward - res.data.pointsToNextReward;
				        }

				        $scope.rewards.rewardsData = res.data;
				        $scope.rewards.config.pageFullyLoaded = true;


				        setTimeout(function() {
					        var rewardsChartCanvas = $('#rewardsChart');
					        var data, backgroundColor;

					        if (res.data.pointsToNextReward === 0) {
						        data = [100];
						        backgroundColor = [ENV.theme.secondary];
					        } else {
					        	if(res.data.totalPoints.totalPoints === 0) {
							        data = [0, res.data.totalPointsRequiredForNextReward];
						        } else {
							        data = [(res.data.totalPointsRequiredForNextReward - res.data.pointsToNextReward), res.data.pointsToNextReward];
						        }

					        	backgroundColor = [
							        ENV.theme.secondary, '#e1e1e1'
						        ];
					        }


					        var rewardsChart = new Chart(rewardsChartCanvas, {
						        type: 'doughnut',
						        data: {
							        datasets: [{
								        data: data,
								        backgroundColor: backgroundColor
							        }],
						        },
						        options: {
							        cutoutPercentage: 70,
							        legend: {
								        display: false
							        },
							        tooltips: {
								        enabled: false
							        },
							        circumference: 2 * Math.PI
						        }
					        });


					        var ConfettiSettings = {
						        "target":"confetti",
						        "max":"180",
						        "animate":true,
						        "props":["circle","square","triangle","line"],
						        "colors":[[165,104,246],[230,61,135],[0,199,228],[253,214,126]],
						        "clock":"20"
					        };

					        var Confetti = new ConfettiGenerator(ConfettiSettings);
					        Confetti.render();
				        }, 100);

			        } else {
		        		toastr.error('Error Getting Rewards Data.');
			        }
		        });
	    }

    };
    
}]);

/**
 * Created by MrSingh on 1/17/16.
 */

hsApp.controller('signupCtrl',[ '$scope','$rootScope','$location','$http','toastr','hsAuth','localStorageService', 'OpenGraphTags','ENV','hsCart',
    'address','$filter', 'globalFunctions', 'hsSocialLogin', 'ngDialog', 'hsUtils',
	function($scope, $rootScope,$location,$http,toastr,hsAuth, localStorageService, OpenGraphTags, ENV, hsCart,
        address, $filter, globalFunctions, hsSocialLogin, ngDialog, hsUtils) {

    if($rootScope.loggedIn){
        $location.path('/'); 
    }

	var location = $location.url();
    location = location.split('?')[0];
	
	switch (location){
		case '/refer':
			OpenGraphTags.setOgTitle("Refer A Friend and get $10 off.");
			OpenGraphTags.setSeoDescription(" Fresher Than Fresh  Free Same Day Delivery  100% Money Back Guarantee");
			OpenGraphTags.setOgImage("/images/social/homesome-v1.jpg");
			$rootScope.OpenGraphTags = OpenGraphTags;
			break;
			
		case '/signup':
			OpenGraphTags.setOgTitle("Signup | " + ENV.name.companyName + " - " + ENV.name.tagline);
			$rootScope.OpenGraphTags = OpenGraphTags;
			break;
	}

    $rootScope.bgHome = true;

    $rootScope.$on( "$routeChangeStart", function(event, next, current) {
        //..do something  //if you don't want event to bubble up
        $rootScope.bgHome = false;
    });
	
	$scope.signup = {
		config      				: {
			requiresPhoneNumber: false,
            memberLogin: null,
            customUserDataSettings: null,
			buttonLoading				: false,
			localBasket                 : false,
			addressNonEditable          : false,
			signupError                 : "",
			signupValidationRules       : {
				rules               : {
					firstName            : {
						required    : true,
						minlength   : 2
					},
					lastName            : {
						required    : true,
						minlength   : 2
					},
					email           : {
						required    : true
					},
					password        : {
						required    : true
					},
					businessName    : {
						required    : true
					},
					street1         : {
						required    : true
					},
					city            : {
						required    : true
					},
					state           : {
						required    : true
					},
					zip             : {
						required    : true,
						number      : true,
						minlength   : 5,
						maxlength   : 5
					},
					phoneUS         : {
						required    : true,
						phoneUS     : true
					}
				},
				messages            : {
					firstName: {
						required: "Please enter your first name",
						minlength: "A minimum length of 2 characters"
					},
					lastName: {
						required: "Please enter your last name",
						minlength: "A minimum length of 2 characters"
					},
					email: {
						required: "Please enter your email address"
					},
					password: {
						required: "Please enter a password."
					},
					businessName   : {
						required    : "Please enter business name"
					},
					street1         : {
						required    : "Please enter your street address"
					},
					city            : {
						required    : "Please enter your city"
					},
					state           : {
						required    : "Please select your state"
					},
					zip             : {
						required    : "Please enter valid zipcode",
						number      : "Please only enter numbers",
						minlength   : "zipcode must be 5 digits",
						maxlength   : "zipcode must be 5 digits"
					},
					phoneUS         : {
						required    : "Please enter valid phone number",
						phoneUS     : "Please enter valid phone number"
					}
				}
			}
		},
        removeSpaces				: function (val) {
            $('#email').val(val.trim());
        },
		removeSpace($event){
			if ($event.keyCode === 32) {
				$event.preventDefault();
				return;
			}
		},
		signupClientPages: {
			TERMS_AND_CONDITIONS: 'terms-and-conditions',
			PRIVACY_POLICY: 'privacy-policy',
		},
		defaultClientPageLink: {
			'terms-and-conditions': '/terms-and-conditions',
			'privacy-policy': '/privacy-policy',
		},
		hasExternalClientPage: function(pageType) {
			for (var clientPage of ENV.clientPages) {
				if (clientPage.type === pageType && clientPage.external) {
					return true;
				}
			}
			return false;
		},
		getClientPageLink: function(pageType) {
            for (var clientPage of ENV.clientPages) {
				if (clientPage.type === pageType && hsUtils.isNonEmptyString(clientPage.href)) {
					return clientPage.href;
				}
			}
			return $scope.signup.defaultClientPageLink[pageType];
        },
        redirectUser				: function (url) {
            void 0;
            if (Object.keys(this.routeParams).length > 0) {
                $location.path(url).search($location.search());
            } else if (this.redirectLink) {
                url = url + '?redirect=' + this.redirectLink;
                $location.url(url);
            } else {
                $location.url(url);
            }
        },
		social                      : {
			google(){
                window.location.href = hsSocialLogin.getGoogleAuthUrl($scope.signup.redirectLink, true);
	        },
        	fb() {
                window.location.href = hsSocialLogin.getFbAuthUrl($scope.signup.redirectLink, true);
            },
			login(data) {
				var apiUrl = ENV.apiEndPoint + '/user/social';
				$http.post(apiUrl, data)
					.then(function(response){
						if (response.status === 200) {
                            $scope.signup.processSignup(response);
                            toastr.success('Login Successful.');
                        } else {
                            toastr.error('Something went wrong. Please try again.');
                            $scope.signup.config.loginError = "Something went wrong. Please try again.";
                            $location.url('/signup');
                            $scope.signup.config.buttonLoading = false;
						}
					});
			}
		},
        initSocialLogin() {
            if ($location.search().code) {
                var fbState = localStorageService.get('fb_state');
                var googleState = localStorageService.get('google_state');
                $scope.signup.redirectLink = localStorageService.get('socialRedirect');
                localStorageService.remove('socialRedirect');
                if (fbState) {
                    var fbCallback = hsSocialLogin.getSocialLoginCallback('fb_state', 'facebook', $scope.signup.social.login, true);
                    fbCallback($location.search());
                } else if (googleState) {
                    var googleCallback = hsSocialLogin.getSocialLoginCallback('google_state', 'google', $scope.signup.social.login, true);
                    googleCallback($location.search());
                } else {
                    $location.url('/signup');
                }
            } else {
                $location.url('/signup');
            }
        },
		enableRewards               : false,
		redirectLink				: false,
        routeParams					: {},
        referralCode				: false,
		firstName					: '',
		lastName					: '',
		email						: '',
		password					: '',
		phoneNumber					: '',
		businessName				: '',
		// The Entity that represents the user's address
		address                     : {
			street1             : "",
			street2             : "",
			city                : "",
			state               : "",
			zip                 : "",
			country             : ""
		},
		// Object used to control notifications on the View
		notification                : {
			isAddressEdit           : true,
			isAddressError          : false,
			isVerificationLoading   : false,
			isRegisterAddrLoading   : false,
			errMessage              : "",
			reset                   : function() {
				this.isAddressError         = false;
				this.isVerificationLoading  = false;
				this.isRegisterAddrLoading  = false;
				this.errMessage             = "";
			}
		},
		init        				: function () {
            $scope.signup.config.buttonLoading = true;
			if (ENV.hideSignupBtn) {
				$location.url('/login');
				return;
			}

			this.referralCode = localStorageService.get('referralCode');
			if(this.referralCode) {
				$scope.signup.signupCode = this.referralCode;
			}

			if (ENV.enableRewards && $location.search().rewards) {
				this.enableRewards = true;
			}

            if ($location.search().redirect) {
                this.redirectLink = $location.search().redirect;
            } else if ($location.search().rewards) {
                // skipping the route params variable for Rewards queryParam
            } else {
                this.routeParams = $location.search();
            }
			
            void 0;
			
			var basket = localStorageService.get('basket');
			if(basket){
				this.config.localBasket = true;
				$rootScope.$emit('cartUpdated');
			}
			globalFunctions.getSelectedLocation(true)
				.then(function(location) {
					$scope.signup.config.requiresPhoneNumber = !!location.signupRequiresPhoneNumber;
					$scope.signup.config.phoneNumberRequiresVerification = !!location.requiresPhoneNumberVerification;
                    if (location.memberLogin) {
                        $scope.signup.config.memberLogin = location.memberLogin;
                    }
                    if (location.customUserDataSettings) {
                        $scope.signup.config.customUserDataSettings = location.customUserDataSettings;
                        for (var key of Object.keys($scope.signup.config.customUserDataSettings)) {
                            var cudSetting = $scope.signup.config.customUserDataSettings[key];
                            if (!$scope.signup.config.signupValidationRules.rules[key]) {
                                $scope.signup.config.signupValidationRules.rules[key] = {};
                                $scope.signup.config.signupValidationRules.messages[key] = {};
                            }
                            if (typeof cudSetting.isRequired === 'boolean') {
                                $scope.signup.config.signupValidationRules.rules[key].required = cudSetting.isRequired;
                                $scope.signup.config.signupValidationRules.messages[key].required = 'Please enter your ' + cudSetting.displayName;
                            }
                            if (cudSetting.type && cudSetting.type === 'number') {
                                $scope.signup.config.signupValidationRules.rules[key].number = true;
                                $scope.signup.config.signupValidationRules.messages[key].number = 'Please only enter numbers';
                            }
                        }
                    }
					if ($rootScope.verifiedPhoneNumber) {
						$scope.signup.phoneNumber = $rootScope.verifiedPhoneNumber;
					}
                    $scope.signup.config.buttonLoading = false;
				});

		},
        signupUser: function(form) {
            if(form.validate()) {
                var previouslyVerified;
                if ($rootScope.verifiedPhoneNumber) {
                    previouslyVerified = $rootScope.verifiedPhoneNumber.toString();
                    previouslyVerified = $filter('bcTelephone')(previouslyVerified, 'clean');
                }
                var phoneNumberModel;
                if (form.phoneUS && form.phoneUS.$modelValue) {
                    phoneNumberModel = form.phoneUS.$modelValue.toString();
                    phoneNumberModel = $filter('bcTelephone')(phoneNumberModel, 'clean');
                }
                if ($scope.signup.config.requiresPhoneNumber && $scope.signup.config.phoneNumberRequiresVerification
                    && (!previouslyVerified || previouslyVerified !== phoneNumberModel)
                ) {
                    var $newScope = $scope.$new(true);
                    $newScope.phoneNumber = form.phoneUS.$modelValue.toString();
                    $newScope.phoneNumber = $filter('bcTelephone')($newScope.phoneNumber, 'clean');

                    ngDialog.open({
                        template: '<div><code-verification '
                            + 'phone-number="phoneNumber" '
                            + 'on-close="closeThisDialog(value)" '
                            + '></code-verification></div>',
                        className: 'ngdialog-theme-default',
                        plain: true,
                        scope: $newScope,
                    }).closePromise
                        .then(function(data) {
                            void 0;
                            if (data.value) {
                                if (data.value.error) {
                                    $scope.signup.config.signupError = data.value.error;
                                } else if (data.value === 'success') {
                                    $scope.signup._signupUser(form);
                                }
                            }
                        })
                        .catch(function(err) {
                            void 0;
                            $scope.signup.config.signupError = 'Could not verify phone number. Please try again.';
                        });
                } else {
                    $scope.signup._signupUser(form);
                }
            }
        },
		_signupUser              	: function (form) {
			$scope.signup.config.signupError = '';
			if(form.validate()) {
				void 0;
				void 0;

				this.config.buttonLoading = true;

				var data = {
					user    :   {
						emailId         : (form.email.$modelValue).trim().toString().toLowerCase(),
						password        : (form.password.$modelValue).toString(),
						firstName       : (form.firstName.$modelValue).trim().toString(),
						lastName        : (form.lastName.$modelValue).trim().toString()
					}
				};

                if ($scope.signup.config.customUserDataSettings) {
                    data.user.customUserData = {};
                    for (var key of Object.keys($scope.signup.config.customUserDataSettings)) {
                        if (form[key].$modelValue) {
                            data.user.customUserData[key] = (form[key].$modelValue).toString().trim();
                        }
                    }
                }

				
				if(ENV.signupFields.businessName){
					data.user.businessName = (form.businessName.$modelValue).trim().toString();
				}
				
				if(ENV.signupFields.address){
					data.user.address = {
						street          : form.street1.$modelValue,
						aptUnit         : form.street2.$modelValue,
						city            : form.city.$modelValue,
						state           : form.state.$modelValue,
						zip             : form.zip.$modelValue
					};
				}
				
				if(ENV.signupFields.phoneNumber || this.enableRewards || $scope.signup.config.requiresPhoneNumber){
					data.user.phoneNumber = (form.phoneUS.$modelValue).toString();
					data.user.phoneNumber = $filter('bcTelephone')(data.user.phoneNumber, 'clean');
				}
				
				void 0;

				/*var basket = localStorageService.get('basket');
				if(basket) {
					basket.forEach(function(item){
						console.log(item.displayName, item.canReplace, item.leaveOut);
					});
				}

				return;*/
				
				var apiUrl = ENV.apiEndPoint + '/user';
				
				$http.post(apiUrl,data)
				.then(function(response){
					void 0;
					if(response.status === 200){
                        $scope.signup.processSignup(response);
                        toastr.success('Signup Successful.');
					} else if (response.status === 400) {
						var errMessage = 'Please make sure your name, and email are correct and that '
							+ 'the password is at least 6 characters long, and try again.'
						toastr.error(errMessage);
						$scope.signup.config.signupError = errMessage;
						setTimeout(function () {
							$scope.signup.config.buttonLoading = false;
						}, 0);
					}else if(response.status === 403){
						toastr.error('We do not deliver to your ZIP Code yet. You will be invited by an email when we start service to your area. Thanks for your patience.');
						$scope.signup.config.signupError = "We do not deliver to your ZIP Code yet. You will be invited by an email when we start service to your area. Thanks for your patience.";
                        setTimeout(function () {
							$scope.signup.config.buttonLoading = false;
						}, 0);

                    }else if(response.status === 409){
						var errMessage = 'An account already exists with the email you provided, '
							+ 'please provide a different email address and try again.'
                        if (response.data && response.data.message && response.data.message.toLowerCase().includes('phone')) {
                            errMessage = 'An account already exists with the phone number you provided, '
                            + 'please provide a different phone number and try again.';
                        }
						toastr.error(errMessage);
						$scope.signup.config.signupError = errMessage;
                        setTimeout(function () {
							$scope.signup.config.buttonLoading = false;
						}, 0);

                    }else{
						toastr.error('Something went wrong. Please try again.');
						$scope.signup.config.signupError = 'Something went wrong. Please try again.';
                        setTimeout(function () {
							$scope.signup.config.buttonLoading = false;
						}, 0);
                    }
				});
			}
		},
        processSignup: function(response) {
            hsAuth.saveUserLocal(response.data);
            $rootScope.currentUser = response.data;
            $rootScope.loggedIn = true;

            void 0;
            void 0;

            var basket = localStorageService.get('basket');
            if(basket){
                hsCart.addItemToCart({
                    items: basket.map(function(item){
                        return {
                            name            : item.name,
                            quantity        : item.quantity,
                            isCustomItem    : false,
                            canReplace      : item.canReplace,
                            instructions    : item.instructions || "",
                            displayName     : item.displayName,
                            type            : item.type,
                            subType         : item.subType,
                            organic         : item.organic,
                            unit            : item.unit,
                            selectedModifiers: item.selectedModifiers ? item.selectedModifiers.map(function(option){ return option.name}) : []
                        };
                    })
                }).then(function(res) {
                    void 0;
                    if (res.status === 200) {
                        toastr.success('Cart updated successfully.');
                        localStorageService.remove('basket');

                        if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                            window.location.href = ENV.noOrderingConfig.signupRedirect;
                            return;
                        }

                        if ($scope.signup.redirectLink) {
                            $location.url($scope.signup.redirectLink);
                        } else if (Object.keys($scope.signup.routeParams).length > 0) {
                            var urlParams = {};
                            for (var prop in $scope.signup.routeParams) {
                                if (prop !== 'multipleParams' && prop !== 'urlPath') {
                                    urlParams[prop] = $scope.signup.routeParams[prop];
                                }
                            }
                            
                            $location.path($scope.signup.routeParams['urlPath']).search(urlParams);
                            setTimeout(function () {
                                $scope.signup.config.buttonLoading = false;
                            }, 300);
                        } else {
                            $location.url('/products');
                            setTimeout(function () {
                                $scope.signup.config.buttonLoading = false;
                            }, 300);
                        }

                        $rootScope.$emit('cartUpdated', true);
                    } else {
                        void 0;
                        $location.url('/products');
                        setTimeout(function () {
                            $scope.signup.config.buttonLoading = false;
                        }, 300);
                    }
                });
            } else {
                $rootScope.$emit('cartUpdated', true);
                if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                    window.location.href = ENV.noOrderingConfig.signupRedirect;
                    return;
                }

                if($scope.signup.redirectLink){
                    $location.url($scope.signup.redirectLink);
                    setTimeout(function () {
                        $scope.signup.config.buttonLoading = false;
                    }, 300);
                } else if (Object.keys($scope.signup.routeParams).length > 0) {
                    var urlParams = {};
                    for (var prop in $scope.signup.routeParams) {
                        if(prop !== 'multipleParams' && prop !== 'urlPath') {
                            urlParams[prop] = $scope.signup.routeParams[prop];
                        }
                    }
                    $location.path($scope.signup.routeParams['urlPath']).search(urlParams);
                    setTimeout(function () {
                        $scope.signup.config.buttonLoading = false;
                    }, 300);
                } else{
                    $location.url('/products');
                    setTimeout(function () {
                        $scope.signup.config.buttonLoading = false;
                    }, 300);
                }
            }
        },
		addressAutoComplete     	: function (shippingAddr) {
			// If the value of `street1` is not a string, it means that it is the object
			// reference as a result of the `ngAutocomplete` functionality, which means we
			// have to fill out the rest of the entity fields.
			if (typeof(this.address.street1) !== 'string') {
				var autoCompleteObject  = shippingAddr.street1;
				var autoCompleteAddress = address.getAutoCompleteAddress(autoCompleteObject);
				this.address.street1    = autoCompleteAddress.street1;
				this.address.street2    = autoCompleteAddress.street2;
				this.address.city       = autoCompleteAddress.city;
				this.address.state      = autoCompleteAddress.state;
				this.address.zip        = autoCompleteAddress.zip;
				this.address.country    = autoCompleteAddress.country;
				
				$scope.signup.config.addressNonEditable = true;
				$scope.signup.isValidAddressFromGoogleMaps = true;
				
				// Once autocomplete is done populating fields, focus on the Address 2 field
				// As street2 cannot be autocompleted.
				// Putting it inside a TimeOut to ensure other events don't prevent this from happening
				setTimeout(function(){angular.element('#street2').focus();}, 0);
				
			}
			
			//need to null this var so we get new value everytime
			$scope.details = null;
		},
        showLoginOptions: function() {
            return $rootScope.ENV.enableFacebookLogin || $rootScope.ENV.enableGoogleLogin
                || $scope.signup.showMemberLogin();
        },
        showMemberLogin: function() {
            if ($scope.signup.config.memberLogin) {
                return $scope.signup.config.memberLogin;
            } 
            return false;
        },
        getMemberLoginText: function() {
            if ($scope.signup.config.memberLogin.text) {
                return $scope.signup.config.memberLogin.text;
            } 
            return $rootScope.ENV.name.companyName + '  Member Login';
        },
		handleEditAddress: function($event){
			address.handleEditAddress($event, $scope.cart);
		},
	};
 
}]);


/**
 * Created by MrSingh on 1/30/16.
 */

'use strict';
var hsFac = angular.module('homesome.factories',[]);

var CACHE_INTERVAL = 600000;
var cache = {};

hsFac.factory('hsApi', ["$http", "$q", "localStorageService", "$rootScope", "$location", "ENV", "hsTableSideOrders", "$injector", "$routeParams", "hsMarketingService", function($http, $q, localStorageService, $rootScope, $location, ENV, hsTableSideOrders, $injector, $routeParams, hsMarketingService) {

	function getCacheInvalidationKey(userGroupsParams) {
		var locationId = '', pricelistId = '';
		if ($rootScope.tableSideOrder) {
			var tsoSession = hsTableSideOrders.getSession();
			locationId = tsoSession ? tsoSession.location : '';
			pricelistId = tsoSession ? tsoSession.pricelist: '';
		}
	    if(ENV.enableLocations && !locationId) {
			var location = localStorageService.get('location');
			locationId = location && location.selectedLocation ? 
				location.selectedLocation.uniqueName : '';
	    }
		if (ENV.enablePriceList && !pricelistId) {
		    var selectedPriceList = localStorageService.get('selectedPriceList');
			pricelistId = selectedPriceList ? selectedPriceList.uniqueName : '';
	    }
		return locationId + '/' + pricelistId + '/' + userGroupsParams;
	}

	function invalidateCacheIfNeeded(userGroupsParams) {
		var invalidationKey = getCacheInvalidationKey(userGroupsParams);
		if(cache.invalidationKey !== invalidationKey) {
            void 0;
			cache = { invalidationKey: invalidationKey };
		}
	}

	function getCacheObject(cacheKey) {
		cache[cacheKey] = cache[cacheKey] || { ts: 0 };
		return cache[cacheKey];
	}

	function getFromCache(cacheKey, userGroupsParams, loader) {

		invalidateCacheIfNeeded(userGroupsParams);

		function isReady(cobj) {
			return cobj.response && cobj.ts + CACHE_INTERVAL > Date.now();
		}

		var cobj = getCacheObject(cacheKey);
		if(cobj.promise) return cobj.promise;
		if(isReady(cobj)) return Promise.resolve(cobj.response);

		cobj.promise = loader().then(function(response) {

			if(!response) return Promise.reject('null response');

			// is there already newer data?
			var newerObj = getCacheObject(cacheKey);	
			if(cobj !== newerObj) {
				if(newerObj.promise) return newerObj.promise;
				if(isReady(newerObj)) return newerObj.response;
			}

			cobj.promise = null;
			cobj.ts = Date.now();
			cobj.response = response;
			return response;
		});
		return cobj.promise;
	}

	return {
		deleteUser          : function () {
			var dfd = $q.defer();

			$http.delete(ENV.apiEndPoint + '/user')
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		getNews             : function () {
			var dfd = $q.defer();

			$http.get(ENV.apiEndPoint + '/news')
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		getAllRewards       : function () {
			var dfd = $q.defer();

			$http.get(ENV.apiEndPoint + '/loyalty/reward')
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		getLocations       : function (includeAdminRestrictedData) {
            var dfd = $q.defer();

			var url = new URL(ENV.apiEndPoint + '/locations');

			if (includeAdminRestrictedData) {
				url.searchParams.append('includeAdminRestrictedData', 'true');
			}
            
			$http.get(url.toString())
            .then(function(response){
                dfd.resolve(response);
            })
            .catch(function(error){
                dfd.resolve(error);
            });
			return dfd.promise;
		},
        getLocationsV2: function() {
            var location = localStorageService.get('location');
            void 0;

            if (location && location.allLocations) {
                return Promise.resolve(location.allLocations);
            }
            
            return this.getLocations().then(function (response) {
                return response.data;
            });
        },
		getAllPoints        : function (phone) {
			var dfd = $q.defer();
			var api = ENV.apiEndPoint + '/loyalty/points';

			if (phone) {
				api += '?targetUserPhoneNumber=' + phone;
			}

			$http.get(api)
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		addItemToCart               : function (data) {
			var dfd = $q.defer();

			$http.post(ENV.apiEndPoint + '/user/basket', data)
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					dfd.resolve(error);
				});
			return dfd.promise;
		},
        getProduct: function (productName, isAdminDashboard, targetHeaders) {
            void 0;
            return $q(function(resolve, reject) {
                if (!productName) {
                    return reject(new Error('missing product name'));
                }
                var headers = {};
                if (isAdminDashboard) {
                    var adminSelectedPriceList = localStorageService.get('adminSelectedPriceList');
                    if (ENV.enablePriceList && adminSelectedPriceList && adminSelectedPriceList.uniqueName) {
                        headers = {"pricelist" : adminSelectedPriceList.uniqueName};
                    }
                }
                if (targetHeaders) {
                    headers = targetHeaders;
                }
                return $http.get(ENV.apiEndPoint + '/product?name=' + encodeURIComponent(productName), {headers})
                    .then(function(response) {
                        if (response.status === 200) {
                            return resolve(response.data);
                        }
                        void 0;
                        reject(new Error('There was an error fetching product with name = ', productName));
                    }
                );
            });
        },
		getAllProducts: function(user) {
            var hsPromos = $injector.get('hsPromos');
            var url = new URL('/product/list', ENV.apiEndPoint);
            var userGroupsParams = hsPromos.getUserGroupsParams(user);

            if (userGroupsParams) {
                url.searchParams.append('userGroups', userGroupsParams)
            }

			if ($location.search().pListName) {
				hsMarketingService.setMarketingQueryPriceList();
				return $http.get(url.toString());
			}

			return getFromCache('allProducts', userGroupsParams, function() {
				return $http.get(url.toString());
			});
		},
		getAllProductsShortlist: function(user) {
            var hsPromos = $injector.get('hsPromos');
            var url = new URL('/product/list', ENV.apiEndPoint);
            url.searchParams.append('shortList', true);
            var userGroupsParams = hsPromos.getUserGroupsParams(user);

            if (userGroupsParams) {
                url.searchParams.append('userGroups', userGroupsParams);
            }

			if ($routeParams.pListName) {
				hsMarketingService.setMarketingQueryPriceList();
				return $http.get(url.toString());
			}

			return getFromCache('allProductsShortlist', userGroupsParams, function() {
				return $http.get(url.toString());
			});
		}
	}
}]);

hsFac.factory('hsRouteGuardService',["$http", "$q", "localStorageService", "$rootScope", "$location", "ENV", function($http, $q,localStorageService, $rootScope, $location, ENV) {
    return {
        showDealsPage: function () {
            return ENV.showDealsPage;
        }
    }
}]);

hsFac.factory('hsAuth',["$http", "$q", "localStorageService", "$rootScope", "$location", "ENV", "hsPickingApp", "hsUtils", function($http, $q,localStorageService, $rootScope, $location, ENV, hsPickingApp, hsUtils) {
    var cachedToken;
    return {
        logoutUser: function (url, skipRedirectAfterLogout, sendAppEvent) {
	        var user = localStorageService.get('user');
	        localStorageService.clearAll();
	        sessionStorage.removeItem('hs_session');
	        if (user) {
	            localStorageService.set('user_email', user.email);
	        }

            $rootScope.currentUser = null;
            $rootScope.loggedIn = false;
	        $rootScope.cartGlobal = false;
	        $rootScope.location = false;
	        $rootScope.openOrder = null;

			$rootScope.$broadcast('logout');

			if (sendAppEvent) {
				var message = {
					type: hsPickingApp.REACT_NATIVE_EVENT_TYPES.LOGOUT,
				};
				hsPickingApp.postMessage(message);
			}

			$location.search({});

	        if (url) {
	            $location.url(url);
	        } else {
				if (!skipRedirectAfterLogout) {
					$location.path('/');
				}
	        }

        },
        /**
         * Helper function to check that the Session variable is in the local storage, and if it
         * is not, redirect to the Login page
         */
        validateSession: function() {

            var user = localStorageService.get('user');
            var token = localStorageService.get('token');

            if(token){
                if (!user) {
                    this.invalidateSession();
                }else{
                    $rootScope.currentUser = user;
                    $rootScope.loggedIn = true;
                }
            }else{
                this.invalidateSession();
            }
        },

        /**
         * Check if session is valid, return true/false accordingly.
         */
        isSessionValid: function() {
            var user = localStorageService.get('user');

            if (!user) {
	            $rootScope.currentUser = null;
	            $rootScope.loggedIn = false;
            }else{
	            $rootScope.currentUser = user;
	            $rootScope.loggedIn = true;
            }
        },

        /**
        * Helper function to remove the Session variable from the local storage and redirect
        * to the Login page
        * @param {string} [redirectPath] Optional string to specify a redirect path
        */
        invalidateSession : function(redirectPath) {
            localStorageService.clearAll();
            $rootScope.loggedIn = false;
            $rootScope.cartGlobal = false;

            if (redirectPath) {
            	void 0;
                $location.url(redirectPath);
            } else {
                $location.url('/login');
            }
        },
        getToken : function() {
            if(!cachedToken){
                var user = localStorageService.get('user');
                if(user){
                    cachedToken = user.authToken;
                }
            }
            return cachedToken;
        },
        getUser : function() {
            var user = localStorageService.get('user');
            return user || false;
        },
	    getUpdatedUser    : function (){
		    var dfd = $q.defer();

		    $http.get(ENV.apiEndPoint + '/user')
		    .then(function(response){
			    if(response.status === 403){
				    hsAuth.invalidateSession('/');
			    }
			    dfd.resolve(response);
		    })
		    .catch(function(error){
			    dfd.resolve(error);
		    });
		    return dfd.promise;
	    },
	    getReferCode      : function (data){
		    var dfd = $q.defer();

		    $http.get(ENV.apiEndPoint + '/user/referralCode')
		    .then(function(response){
			    if(response.status === 403){
				    hsAuth.invalidateSession('/');
			    }
			    dfd.resolve(response);
		    })
		    .catch(function(error){
			    dfd.resolve(error);
		    });
		    return dfd.promise;
	    },
        getUserAuthObj : function(forUser) {
			var user;
			if (hsUtils.isObject(forUser)) {
				user = forUser;
			} else {
				user = localStorageService.get('user');
			}
            if(user){
	            return {
		            emailId       : user.email,
			        authToken   : user.authToken
	            };
            }else{
                return false;
            }
        },
        saveUserLocal : function(user) {
	        localStorageService.add('user', user);
	        $rootScope.currentUser = user;
	        $rootScope.loggedIn = true;
        },
		loginSSO : function(headers) {
			var dfd = $q.defer();

			$http.post(ENV.apiEndPoint + '/user/login/sso', {}, {headers: headers})
			.then(function(response) {
				dfd.resolve(response);
			})
			.catch(function(error){
			    dfd.resolve(error);
		    });
		    return dfd.promise;
		},
		requiredPermissionByPath: {
			'/admin/dashboard': ['canManageOrders'],
			'/admin/order-history': ['canManageOrders'],
			'/admin/tip-summary': ['canManageOrders'],
			'/admin/dashboard/orders': ['canManageOrders'],
			'/admin/order': ['canManageOrders'],
			'/admin/create-order': ['canManageOrders'],
			'/admin/create-order/cart': ['canManageOrders'],
			'/admin/create-order/checkout': ['canManageOrders'],
			'/admin/create-order/confirmation': ['canManageOrders'],
			'/admin/create-order/add-items': ['canManageOrders'],
			'/admin/quote': ['canManageOrders'],
			'/admin/deliveries': ['canManageOrders'],
			'/admin/reports': ['canViewReports'],
			'/admin/reports/sales': ['canViewReports'],
			'/admin/reports/sales/daily': ['canViewReports'],
			'/admin/reports/sales/weekly': ['canViewReports'],
			'/admin/reports/sales/monthly': ['canViewReports'],
			'/admin/reports/movement': ['canViewReports'],
			'/admin/reports/movement/daily': ['canViewReports'],
			'/admin/reports/movement/weekly': ['canViewReports'],
			'/admin/reports/movement/monthly': ['canViewReports'],
			'/admin/reports/lostRevenue': ['canViewReports'],
			'/admin/reports/stripe': ['canViewReports', 'canManageBankAccount'],
			'/admin/view-dashboards': ['canViewDashboards'],
			'/admin/view-dashboards/dashboard': ['canViewDashboards'],
			'/admin/users/all': ['canManageUsers',  'canViewReports'],
			'/admin/users/update': ['canManageUsers'],
			'/admin/users/approve': ['canManageUsers'],
			'/admin/location': ['canManageLocation'],
			'/admin/location/settings': ['canManageLocation'],
			'/admin/location/staff': ['canManageLocation'],
			'/admin/location/bank-account': ['canManageBankAccount'],
			'/admin/promotions': ['canManagePromotions'],
			'/admin/coupons': ['canManageCoupons'],
			'/admin/products/bulk-ops/add': ['canManageProducts'],
			'/admin/products': ['canManageProducts'],
			'/admin/products/all': ['canManageProducts'],
			'/admin/products/out-of-stock': ['canManageProducts'],
			'/admin/products/auto-added': ['canManageProducts'],
			'/admin/products/inactive': ['canManageProducts'],
			'/admin/products/homepage': ['canManageProducts'],
			'/admin/products/bulk-ops': ['canManageProducts'],
			'/admin/products/bulk-update': ['canManageProducts'],
			'/admin/products/add': ['canManageProducts'],
			'/admin/modifiers': ['canManageProducts'],
			'/admin/modifiers/create': ['canManageProducts'],
			'/admin/modifiers/edit': ['canManageProducts'],
			'/admin/modifiers/product': ['canManageProducts'],
			'/admin/loyalty-dashboards': ['canViewDashboards'],
			'/admin/loyalty-dashboards/loyalty-analytics': ['canViewDashboards'],
			'/admin/loyalty-dashboards/electronic-journal': ['canViewDashboards'],
		},
		checkPermissionsForAdminRoutes: function(nextLocation) {
			if (!hsUtils.isObject(nextLocation)) {
				return;
			}

			var nextLocationPath = nextLocation.originalPath;
			if (!hsUtils.isNonEmptyString(nextLocationPath)) {
				return;
			}

			if (!nextLocationPath.startsWith('/admin')) {
				return;
			}
		
			var redirectUrl = '/';
			var redirectUser = false;
			var user = this.getUser();

			if (!hsUtils.isObject(user)) {
				redirectUser = true;
				redirectUrl = '/login';
			} else if (!user.isAdmin) {
				redirectUser = true;
			} else {
				var permissions = user.permissions;
				// user.permissions should always be an object. It is added 
				// when userData is sanitized in BE during the GET /user API call.
				// Added this check because permissions object will only be added
				// when user refreshes page and a new API call is made.
				// This will only matter just after this feature is released for 
				// users who have not yet refreshed their browser page
				if (hsUtils.isObject(permissions)) {
					// not all path's require a special admin permission.
					// therefore adding || [] prevents undefined case
					var requiredPermissions = this.requiredPermissionByPath[nextLocationPath] || [];
					for (var requiredPermission of requiredPermissions) {
						if (!permissions[requiredPermission]) {
							redirectUser = true;
							redirectUrl = '/admin/manager-dashboard';
							break;
						}
					}
				}
			}

			if (redirectUser) {
				$location.url(redirectUrl);
			}
		},

		sendUserVerificationCode: function(phoneNumber, shouldCall) {
			var apiUrl = ENV.apiEndPoint + '/phonenumber/code';
			return $http.post(apiUrl, { phoneNumber: phoneNumber, shouldCall: shouldCall })
				.then(function(res) {
					if (res.status !== 200) {
						throw new Error('Failed to get verification code');
					}
				})
				.catch(function(err) {
					throw new Error('Failed to get verification code');
				})
		},
		verifyUserVerificationCode: function(phoneNumber, verificationCode, purpose) {
			var apiUrl = ENV.apiEndPoint + '/phonenumber/verify';
			var data = {
				phoneNumber: phoneNumber,
				code: verificationCode,
				for: purpose
			};

			return $http.post(apiUrl, data)
				.then(function(res) {
					if (res.status === 404) {
						throw new Error('The verification code you entered does not match.'
							+' Please make sure you have entered the correct phone number and code.');
					}
					if (res.status === 400 && res.data && res.data.message && res.data.message.includes('Incorrect code')) {
						throw new Error('The verification code you entered does not match.'
							+ ' Please make sure you have entered the correct code and try again.');
					}
					if (res.status === 400 && res.data && res.data.message && res.data.message.includes('expired')) {
						throw new Error('Code expired. Please try again.');
					}
					if (res.status === 409) {
						throw new Error('Phone number is already associated with another account.');
					}
					if (res.status !== 200) {
						throw new Error ('Failed to verify phone number.');
					}
					return res;
				})
				.catch(function(err) {
					throw new Error (err.message);
				})
		}
    }
}]);

hsFac.factory('hsCart',["$http", "$q", "localStorageService", "$rootScope", "$location", "hsAuth", "ENV", "globalFunctions", "hsPromos", "hsUtils", function($http, $q,localStorageService, $rootScope, $location, hsAuth, ENV, globalFunctions, hsPromos, hsUtils) {
	return {
        updateCartOptions: function (data, headers) {
            return $http.post(ENV.apiEndPoint + '/user/basket/options', data, {headers: headers})
                .catch(function (err) {
                    return err;
                });
        },
		addItemToCart: function (data, headers, promotionId) {
			var url = new URL('/user/basket', ENV.apiEndPoint);

			if (promotionId) {
				url.searchParams.append('promotionId', promotionId);
			}
			
			return $http.post(url.toString(), data, {headers: headers})
			.then(function(response){
				if(response.status !== 200) {
					throw response.data;
				} else {
					return response;
				}
			})
			.catch(function(error){
				throw hsUtils.getMessageFromError(error, 'Failed to add/update item to cart.');
			});
        },
		removeItemFromCart          : function (data, headers, promotionId) {
			var apiUrl = new URL('/user/basket', ENV.apiEndPoint);

			if (data.itemName) {
				apiUrl.searchParams.append('itemName', data.itemName);
			}

			if (promotionId) {
				apiUrl.searchParams.append('promotionId', promotionId);
			}

			if (data.selectedModifiers) {
				data.selectedModifiers.forEach(function (modifier) {
					apiUrl.searchParams.append('selectedModifiers', modifier.name);
				});
			}
			void 0;
			
			return $http.delete(apiUrl.toString(), { headers: headers })
			.then(function(response){
				if(response.status !== 200) {
					throw response.data;
				} else {
					return response;
				}
			})
			.catch(function(error){
				void 0;
				throw hsUtils.getMessageFromError(error, 'Failed to remove item to cart.');
			});
		},
		getOrderHistory             : function (NumberOfOrders) {
			var dfd = $q.defer();

			var apiUrl = ENV.apiEndPoint + '/user/orders';

			if (NumberOfOrders) {
				apiUrl += '?orderCount=' + NumberOfOrders;
			}

			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getProductWithOrderingOption: function (param) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/product?' + param;

			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		addCreditCard               : function (data) {
			var dfd = $q.defer();
			
			$http.post(ENV.apiEndPoint + '/user/paymentmethod', data)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		updateUser                  : function (data) {
			var dfd = $q.defer();
			
			$http.put(ENV.apiEndPoint + '/user', data)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		verifyAddress               : function (data) {
			var dfd = $q.defer();
			
			$http.post(ENV.apiEndPoint + '/address', data)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		placeOrder                  : function (data) {
			var dfd = $q.defer();
			
			$http.post(ENV.apiEndPoint + '/user/order', data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
        },
		getCartItems                : function (rewardId, liteCall, snapAmount) {
			var dfd = $q.defer();
			var discount = localStorageService.get('discountCode');
			var selectedReward = localStorageService.get('selectedReward');

            var url = new URL('/user/basket', ENV.apiEndPoint);

            if (liteCall) {
                url.searchParams.append('lite', true);
            }

            if (selectedReward) {
                url.searchParams.append('rewardid', selectedReward.id);
            }

            if (discount !== null) {
                url.searchParams.append('coupon', discount);
            }

            if (snapAmount) {
                url.searchParams.append('ebtSnapAmount', snapAmount);
            }

			$http.get(url.toString())
			.then(function(response){
				if(response.status === 403){
					hsAuth.invalidateSession('/');
				}
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		calculateProductPrice       : function (priceObj) {
			if(!priceObj){return;}
			
			if (priceObj.price <= 0 || priceObj.unit == null || priceObj.unitQuantity <= 0) {
				return ""
			}
			
			var priceLabelText = "$"+ priceObj.price.toFixed(2);
			
			return priceLabelText || " ";
		},
        calculateAvailableTimeString : function (availableObj, str) {
            if(!availableObj || !Array.isArray(availableObj.availableTimes)) {
                return;
            }

            var timezone = globalFunctions.getLocationTimezone();
            var today = dayjs.tz(dayjs(), timezone);
            for (var i = 0; i < availableObj.availableTimes.length; i++) {
                var avail = availableObj.availableTimes[i];
                var startTime = dayjs.tz(avail.startTime, 'HH:mm', timezone);
                var endTime = dayjs.tz(avail.endTime, 'HH:mm', timezone);
                if (startTime <= today && today <= endTime) {
                    return "This "+str+" is available till "+globalFunctions.getFormattedTime(avail.endTime);
                }
            }

            for (var i = 0; i < availableObj.availableTimes.length; i++) {
                var avail = availableObj.availableTimes[i];
                var startTime = dayjs.tz(avail.startTime, 'HH:mm', timezone);
                if (today <= startTime) {
                    return "This "+str+" will be available at "+globalFunctions.getFormattedTime(avail.startTime);
                }
            };

            return "This "+str+" is available tomorrow at "+globalFunctions.getFormattedTime(availableObj.availableTimes[0].startTime);
        },
        filterTimeSlots: function (timeSlots, products) {
            var filteredSlot = JSON.parse(JSON.stringify(timeSlots));
            var timezone = globalFunctions.getLocationTimezone();
            for (var i = 0; i < products.length; i++) {
                var product = products[i];
                var validSlots = [];
                for (var j = 0; j < product.availableTimes.length; j++) {
                    
                    var startMoment = dayjs.tz(product.availableTimes[j].startTime, 'HH:mm', timezone);
                    var endMoment = dayjs.tz(product.availableTimes[j].endTime, 'HH:mm', timezone);
                    for (var k = 0; k < filteredSlot.length; k++) {
                        var slot = filteredSlot[k];
                        var slotSplit = slot.split(' - ');
                        if (slotSplit.length === 2) {
                            var startSlot = globalFunctions.changeTimeString(slotSplit[0]);
                            var endSlot = globalFunctions.changeTimeString(slotSplit[1]);
                            var startSlotMoment = dayjs.tz(startSlot, 'HH:mmA', timezone);
                            var endSlotMoment = dayjs.tz(endSlot, 'HH:mmA', timezone);
                            if (startSlotMoment < endMoment && startMoment < endSlotMoment) {
                                void 0;
                                validSlots.push(slot);
                            }
                        } else if (slotSplit.length === 1) {
                            var currentSlot = globalFunctions.changeTimeString(slotSplit[0]);
                            var currentSlotMoment = dayjs.tz(currentSlot, 'HH:mmA', timezone);
                            if (startMoment < currentSlotMoment && currentSlotMoment < endMoment) {
                                validSlots.push(slot);
                            }
                        } else {
                            validSlots.push(slot);
                        }
                    }
                }
                filteredSlot = validSlots;
            }
            return filteredSlot;
        },
		convertFirstTimeSlotToAsap: function(timeSlots) {
			var timezone = globalFunctions.getLocationTimezone();
			var currentTime = dayjs().tz(timezone);
			var firstSlot = globalFunctions.changeTimeString(timeSlots[0]);
			var firstSlotMoment = dayjs.tz(firstSlot, 'HH:mmA', timezone);
			var firstSlotBuffer = firstSlotMoment.diff(currentTime, 'minutes');
			var expandedSlot;
			if (timeSlots.length === 1) {
				expandedSlot =  'ASAP (' + firstSlotBuffer + ' - ' + (firstSlotBuffer+15) + ' Min.)';
			} else {
				var secondSlot = globalFunctions.changeTimeString(timeSlots[1]);
				var secondSlotMoment = dayjs.tz(secondSlot, 'HH:mmA', timezone);
				var secondSlotBuffer = secondSlotMoment.diff(currentTime, 'minutes');
				var intervalEnd = Math.min(firstSlotBuffer+15, secondSlotBuffer);
				expandedSlot =  'ASAP (' + firstSlotBuffer + ' - ' + intervalEnd + ' Min.)';
			}
			timeSlots = timeSlots.map(function(timeSlot, index) {
				return index ? timeSlot : expandedSlot;
			});
			return timeSlots;
		},
		addTime: function(timeString, minutesToAdd) {
			var timezone = globalFunctions.getLocationTimezone();
			var time = globalFunctions.changeTimeString(timeString);
			var timeMoment = dayjs.tz(time, 'HH:mmA', timezone);
			var paddedMoment = timeMoment.add(minutesToAdd, 'minutes');
			var formattedTime = paddedMoment.format('h:mmA');
			return formattedTime;
		},
		createTimeRange(timeString, minutesToAdd) {
			return timeString + ' - ' + this.addTime(timeString, minutesToAdd);
		},
		calculatePricePerQuantityV2  : function (productObj) {
			if (!productObj || productObj.unit === 'count') return '';

			var perUnitQuantity = '';

			if (productObj.unitQuantity > 1) {
				perUnitQuantity = productObj.unitQuantity + ' ';
			}

			// $1.99 /lb or $4.49 /16 oz pack
			return ' /' + perUnitQuantity + productObj.unit;
		},
		calculatePricePerQuantity   : function (priceObj, perWord) {
			if(!priceObj){return;}
			if(!perWord && perWord !== ''){ perWord = 'per'}
			var pricePerQuantity = "";
			
			if (priceObj.unit === "count") {
				
				if (priceObj.unitQuantity > 1) {
					// for example $5.99 per 5 count
					pricePerQuantity = " "+ perWord + " "+ priceObj.unitQuantity +" count"
				} else {
					pricePerQuantity = " each"
				}
			} else {
				if (priceObj.unitQuantity > 1) {
					// $6.99 per 5 lb
					if ((priceObj.unitQuantity - Math.floor(priceObj.unitQuantity)) < 0.001) {
						pricePerQuantity = " "+ perWord + " "+ priceObj.unitQuantity + " " + priceObj.unit;
					} else {
						pricePerQuantity = " "+ perWord + " "+ priceObj.unitQuantity + " " + priceObj.unit;
					}
				} else {
					// $1.99 per lb. or $4.49 per 16 oz pack
					pricePerQuantity = " "+ perWord + " " + priceObj.unit;
				}
			}
      
			return pricePerQuantity || " ";
		},
		calculateUnitQuantity       : function (item) {
			if(!item){return;}
      
			var unitQuantity    = item.unitQuantity;
			var unit            = item.unit;
			var Qty             = item.quantity;
			var Quantity        = '';
			if(ENV.hideItemUnit){
				Quantity = Qty;
			} else if (item.sellByQty) {
                Quantity =  item.quantity + ' - count';
                if (item.packed) {
                    Quantity += ' (' + parseFloat(item.quantityWeight.toFixed(2)) + ' lb)';
                }
            } else {
				if (unitQuantity === 1) {
					Quantity = parseFloat(Qty.toFixed(2)) + ' - ' + unit;
				} else {
					var unitString = unitQuantity + ' ' + unit;
					Quantity = parseFloat(Qty.toFixed(2)) + ' of ' + unitString;
				}
			}
			
			return Quantity || " ";
		},
		updateQuantity              : function (item, updateType, quantityBtn, updateBtn, quantityBtns) {
			var hasAdditionalQuantityButtons = Array.isArray(quantityBtns) && quantityBtns.length;
			var inputElement = $(quantityBtn);
			var valid = this.getValidQuantityWithUnits(item, inputElement.val());
			var quantity = valid.value;
			var quantityUnit = valid.unit;
			var setQuantityButtonValues = function(quantity) {
				inputElement.val(quantity);
				if (hasAdditionalQuantityButtons) {
					quantityBtns.forEach(function(quantityBtn) {
						$(quantityBtn).val(quantity);
					});
				}
			};
			if (updateType === 'subtract') {
				if (quantity === quantityUnit) {
					setQuantityButtonValues(quantity);
					return;
				} else {
					if (quantity < quantityUnit) {
						setQuantityButtonValues(quantityUnit);
					} else {
						quantity = parseFloat((quantity - quantityUnit).toFixed(2));
						setQuantityButtonValues(quantity);
					}
				}
			} else if (updateType === 'add') {
				quantity = parseFloat((quantity + quantityUnit).toFixed(2));
				setQuantityButtonValues(quantity);
			} else {
				// this is needed to keep the input unchanged and trigger "show button"
				quantity = inputElement.val()
			}

			if(quantity !== item.quantity){
				$(updateBtn).removeClass('hidden');
			}else{
				$(updateBtn).addClass('hidden');
			}
		},
		getValidQuantityWithUnits: function(item, qty) {
			var quantity = qty;
			var quantityUnit;
			if (!item.sellByQty && (item.price.unit === 'lb' || item.unit === 'lb')) {
				quantity = parseFloat(quantity);
				quantityUnit = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
				quantity = Math.ceil(parseFloat((quantity / quantityUnit).toFixed(2))) * quantityUnit;
				quantity = parseFloat(quantity.toFixed(2));
			} else {
				quantity = parseInt(quantity);
				quantityUnit = 1;
			}
			if (isNaN(quantity)) {
				quantity = quantityUnit;
			}
			return {
				value: quantity,
				unit: quantityUnit,
				isValid: quantity === parseFloat(qty),
			};
		},
        getProductDisplayName: function (item) {
            var displayName = item.displayName;
            if (item.sellByQty) {
                displayName += ' (1 Count)';
            }

            return displayName;
        },
        getProductItemizedTotal: function (item) {
            var lines = [
                (item.sellByQty && !item.packed ? 'Estimated ' : '') + 'Itemized Subtotal: ',
            ];
            if (!Array.isArray(item.priceBreakdown)) {
                var price = item.price;
                var weight = 0;
                var modifiersPrice = 0;

                if (item.membershipDiscount && item.membershipDiscountApplied) {
                    price = (item.price - item.price * item.membershipDiscount / 100).toFixed(2);
                } else if (item.promotion && hsPromos.isValidPrice(item.promotion.promotionPrice) && !item.adminChangedPrice) {
                    price = item.promotion.promotionPrice;
                }
                if (item.sellByQty && item.packed) {
                    weight = item.quantityWeight;
                } else if (item.sellByQty) {
                    weight = item.avgWeight * item.quantity;
                }
                if (Array.isArray(item.selectedModifiers) && item.selectedModifiers.length) {
                    modifiersPrice = item.selectedModifiers.reduce(function (acc, mod) {
                        return acc + (mod.price || 0);
                    }, 0);
                }
                var line = getLine(item, price, item.quantity, weight, modifiersPrice);
                lines.push(line);
            } else {

                for (var i = 0; i < item.priceBreakdown.length; i++) {
                    var tier = item.priceBreakdown[i];
                    var line = (i ? '+ ' : '') + getLine(item, tier.price, tier.quantity, tier.weight, tier.modifiersPrice);
                    lines.push(line);
                }
            }
            lines.push('= $' + item.itemizedPrice.toFixed(2));

            return lines.map(function (l) { return l.replace(/\s/g, '&nbsp;'); }).join(' ');

            function getLine(item, price, quantity, weight, modifiersPrice) {
                var str = '';
                str += parseFloat((weight ? weight : quantity).toFixed(2));

                if (item.unit === 'lb') {
                    str += 'LB';
                }
                str += ' x ';

                if (modifiersPrice) {
                    str += '(';
                }
                str += '$' + price.toFixed(2);

                if (modifiersPrice) {
                    // Show zero modifiers price for a free item
                    var actualPrice = modifiersPrice && price ? modifiersPrice : 0;
                    str += ' + $' + parseFloat(actualPrice.toFixed(2)) + ')';
                }

                return str;
            }
        },
		checkQuantityLimits: function(item, element) {
			var result = {
				max: {
					value: item.maxQuantity ? item.maxQuantity : 0,
					reached: false,
					exceeded: false,
					message: '',
				},
				min: {
					value: item.minQuantity ? item.minQuantity : 0,
					reached: false,
					exceeded: false,
					message: '',
				},
			};
			var quantity = parseFloat(element.val());

			if (result.max.value > 0 && result.max.value <= quantity) {
				result.max.reached = true;
				result.max.exceeded = result.max.value < quantity;
				result.max.message = item.maxQuantityMessage
					? item.maxQuantityMessage
					: globalFunctions.product.maxQuantityError(result.max.value);
			}
			if (result.min.value > 0 && result.min.value >= quantity) {
				result.min.reached = true;
				result.min.exceeded = result.min.value > quantity;
				result.min.message = item.minQuantityMessage
					? item.minQuantityMessage
					: globalFunctions.product.minQuantityError(result.min.value);
			}
			return result;
		},
		validateQuantity: function(item, inputElement, admin) {
			var quantity = parseFloat(inputElement.val());

			if (isNaN(quantity) || quantity <= 0) {
				return 'Please enter a valid quantity.';
			}
			if (!admin) {
				var limits = this.checkQuantityLimits(item, inputElement);

				if (limits.max.exceeded) {
					inputElement.val(limits.max.value);
					return limits.max.message;
				}
				if (limits.min.exceeded) {
					inputElement.val(limits.min.value);
					return limits.min.message;
				}
			}
			var qty = this.getValidQuantityWithUnits(item, inputElement.val());

			if (!qty.isValid) {
				inputElement.val(qty.value);
				return 'Value should be in the increments of ' + qty.unit;
			}
		},
		getUpdatedQuantity           : function (item, updateType, quantity) {
			var quantityUnit;
			//Setting Increment/Decrement amount based on unit
			if(!item.sellByQty && (item.price.unit === 'lb' || item.unit.toLowerCase() === 'lb')){
				quantity = parseFloat(quantity);
				quantityUnit = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
				quantity = Math.ceil(parseFloat((quantity / quantityUnit).toFixed(2))) * quantityUnit;
				quantity = parseFloat(quantity.toFixed(2));
			}else{
				quantity = parseInt(quantity);
				quantityUnit = 1;
			}
			if (isNaN(quantity)) {
				quantity = 0;
			}
			if(updateType === 'subtract'){
				if (quantity <= quantityUnit){
					return quantityUnit;
				}else {
					quantity = parseFloat((quantity - quantityUnit).toFixed(2));
				}
			}else if(updateType === 'add'){
				quantity = parseFloat((quantity + quantityUnit).toFixed(2));
			}

			return quantity;
		},
        isSameItem(item1, item2) {
            if (!item1 || !item2) return false;
            if (typeof item1 !== 'object' || typeof item2 !== 'object') return false;
            if (Array.isArray(item1) || Array.isArray(item2)) return false;
            if (item1.name !== item2.name) return false;
            if (item1.hasModifiers !== item2.hasModifiers) return false;
            if (!item1.hasModifiers) return true;
            if (Array.isArray(item1.selectedModifiers) !== Array.isArray(item2.selectedModifiers)) return false;
            if (!Array.isArray(item1.selectedModifiers)) return true;
            if (item1.selectedModifiers.length !== item2.selectedModifiers.length) return false;

            main:
            for (var i1 = 0; i1 < item1.selectedModifiers.length; i1++) {
                var mod1 = item1.selectedModifiers[i1];

                for (var i2 = 0; i2 < item2.selectedModifiers.length; i2++) {
                    var mod2 = item2.selectedModifiers[i2];

                    if (mod1.name === mod2.name && mod1.quantity === mod2.quantity) continue main;
                }
                return false;
            }
            return true;
        },
		calculateEstimatedPricePerItem: function (priceObj, isLg) {
			if(!priceObj) return;
            var isSellByQtyItem = priceObj.sellByQty && priceObj.unit === 'lb';
            if (!isSellByQtyItem) return;

            var pricePerItem;
            if ('itemizedPrice' in priceObj) {
                pricePerItem = (priceObj.itemizedPrice/ priceObj.quantity).toFixed(2);
            } else {
                pricePerItem = (priceObj.avgWeight * priceObj.price).toFixed(2);
            }

			if (pricePerItem > 0){
				if (isLg) {
					return 'This item is sold by quantity and charged by weight. The estimated price per item is $' + pricePerItem + '.'	
				}
				return 'Estimated price per item is $' + pricePerItem + '.'
			}
			return " ";
		},
		getSelectedPriceList: function() {
			var selectedPriceList = null;
			if (ENV.enableLocations && ENV.enablePriceList) {
				selectedPriceList = localStorageService.get('selectedPriceList');
			} else {
				var selectedLocation = $rootScope.location.selectedLocation;

				if (!hsUtils.isObject(selectedLocation)) return selectedPriceList;

				for (var pricelist of selectedLocation.priceLists) {
					if (!pricelist.isDisabled) {
						selectedPriceList = pricelist;
					}
				}
			}
			return selectedPriceList;
		},
		getTipLabel: function(managedDeliveryTipShare) {
			if (managedDeliveryTipShare === 1 || ENV.enableSeparateTips) {
				return 'Delivery Driver Tip';
			} else if (managedDeliveryTipShare === 0) {
				return 'Shopper Tip';
			}
			return 'Tip';
		},
		getTipDisclaimer: function(managedDeliveryTipShare) {
			if (!isNaN(managedDeliveryTipShare)
				&& Number(managedDeliveryTipShare) > 0
				&& Number(managedDeliveryTipShare) < 1
				&& !ENV.enableSeparateTips
			) {
				return 'Shared between Personal Shopper and Delivery Rep';
			}
			return '';
		},
		getIsPickupOnly: function(item) {
			
			var isPickupOnlyMod = function(modElement) {return modElement.isPickupOnly};
			
			return item.isPickupOnly 
				||  (hsUtils.isNonEmptyArray(item.selectedModifiers)
					&& item.selectedModifiers.some(isPickupOnlyMod));
		},
	}
}]);

hsFac.factory('hsAdmin',["$http", "$q", "localStorageService", "$rootScope", "$location", "hsAuth", "ENV", "toastr", "globalFunctions", "hsUtils", function($http, $q,localStorageService, $rootScope, $location, hsAuth, ENV, toastr, globalFunctions, hsUtils) {
	return {
		adminDiscountTypes: {
			PERCENT: 'percent',
			DOLLAR: 'dollar',
		},
		getUnapprovedUsers          : function () {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/users/approvals';
			
			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		approveUser                 : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user';
			
			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateUser: function (data) {
			return $http.put(ENV.apiEndPoint + '/user', { targetUser: data })
		},
		getProductList: function(headers, includeAllItems) {
			var apiUrl = new URL(ENV.apiEndPoint + '/product/list');
			if (includeAllItems) {
				apiUrl.searchParams.append('includeAllItems', includeAllItems);
			}

			return $http.get(apiUrl.toString(), { headers: headers })
				.then(function(res) {
					if (res.status === 200) {
						return res.data.products || [];
					} else {
						void 0;
						throw 'Failed to get product list.';    
					}
				})
				.catch(function(err) {
					throw hsUtils.getMessageFromError(err, 'Failed to get product list.');
				});
		},
        getAllProducts: function(priceListUniqueName, includeAllItems) {
            var headers = {};
            if (priceListUniqueName) {
                headers.pricelist = priceListUniqueName;
            }

            var dfd = $q.defer();
			var apiUrl = new URL(ENV.apiEndPoint + '/product/list');
			if (includeAllItems === true) {
                apiUrl.searchParams.append('includeAllItems', includeAllItems);
            }
			
			$http.get(apiUrl.toString(), { headers: headers })
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getOrderList                : function (data, getTodaysOrders, priceListDetails) {
			
			if (!priceListDetails) {
				priceListDetails = globalFunctions.getPriceListDetails()
			}

			var dfd = $q.defer();
			var apiUrl = '';

			if (getTodaysOrders) {
                apiUrl = ENV.apiEndPoint + '/orders?today=true'
			} else if(data){
				apiUrl = ENV.apiEndPoint + '/orders?day='+ data.day +'&month='+ data.month +'&year=' + data.year;
			}else{
				apiUrl = ENV.apiEndPoint + '/orders?status=open'
			}

			if (priceListDetails.filterByPriceList) {
				apiUrl += '&priceList=' + priceListDetails.priceList;
			}
			
			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getOrderHistoryList         : function (data, priceListDetails) {

			if (!priceListDetails) {
				priceListDetails = globalFunctions.getPriceListDetails()
			}

			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/orderhistory?';
			apiUrl += 'startday='+ data.startDate.day +'&startmonth='+ data.startDate.month +'&startyear='+ data.startDate.year;
			apiUrl += '&endday='+ data.endDate.day +'&endmonth='+ data.endDate.month +'&endyear='+ data.endDate.year;

			if (priceListDetails.filterByPriceList) {
				apiUrl += '&priceList=' + priceListDetails.priceList;
			}
			
			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getSalesReport         : function (data, type) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/metric';

			switch (type) {
				case 'daily':
					apiUrl += '?metricName=dailyReport&day='+ data.day + '&month=' + data.month + '&year='+ data.year;
					break;
				case 'weekly':
					apiUrl += '?metricName=weeklyReport&startDay='+ data.day + '&startMonth=' + data.month + '&startYear='+ data.year;
					break;
				case 'monthly':
					apiUrl += '?metricName=monthlyReport&month='+ data.month + '&year=' + data.year;
					break;
				default:
					toastr.error('Invalid Metric type');
					return;
			}

			void 0;

			$http.get(apiUrl)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getOrderDetails             : function (orderId) {
			var dfd = $q.defer();
			
			$http.get(ENV.apiEndPoint + '/user/order?orderKey='+ orderId)
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		getUserDetails              : function (emailId, query) {
			var dfd = $q.defer();
			
			$http.get(ENV.apiEndPoint + '/user?targetUserEmailId='+ encodeURIComponent(emailId) + (query ? '&' + query : ''))
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
        getOrderSlots               : function (orderId) {
            var dfd = $q.defer();

            $http.get(ENV.apiEndPoint + '/order/slots?orderKey='+ encodeURIComponent(orderId))
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		updateItemPriceInOrder      : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/item';
			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		assignDelivery              : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/ordergroup';
			
			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateBagsQuantity          : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';
			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateAgeVerification          : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateOrderDetails          : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		assignPacker                : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		processRefund               : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/refund';
			
			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		addCustomItemInOrder        : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/item';
			
			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		addItemToOrder              : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/item';
			
			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		addRewardPoints             : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/loyalty/points';

			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		redeemRewards               : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/loyalty/reward';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateProductImage: function(imageFormData){
			
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/image?type=product';

			$http.post(apiUrl, imageFormData, {
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			})
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateProduct               : function (data, target) {
			var dfd = $q.defer();
			var req = {
				method: 'PUT',
				url: ENV.apiEndPoint + '/product',
				data: data,
				headers: {}
			};

			if (ENV.enablePriceList) {
				var adminPriceList = localStorageService.get('adminSelectedPriceList');
				if (adminPriceList) {
					req.headers['pricelist'] = adminPriceList.uniqueName;
				}
			}

			if (target) {
				req.headers.location = target.locationUniqueName;
				req.headers.pricelist = target.priceListUniqueName;
			}

			$http(req)
			.then(function(response){
				void 0;
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		syncProducts				: function (data) {
			var apiUrl = ENV.apiEndPoint + '/syncproducts';
			return $http.post(apiUrl, data);
		},
		createAddProductList        : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/product/list';

			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateBulkProduct           : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/product/list';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		addProduct                  : function (data) {
			var dfd = $q.defer();
			var req = {
				method: 'POST',
				url: ENV.apiEndPoint + '/product',
				data: data,
				headers: {}
			};

			if (ENV.enablePriceList) {
				var adminPriceList = localStorageService.get('adminSelectedPriceList');
				if (adminPriceList) {
					req.headers['pricelist'] = adminPriceList.uniqueName;
				}
			}

			$http(req)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		assignDriver                : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/driver';

			$http.post(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
        assignStaff: function(data) {
            var dfd = $q.defer();
            var apiUrl = ENV.apiEndPoint + '/order/staff';

            $http.post(apiUrl, data)
            .then(function(response){
                dfd.resolve(response);
            })
            .catch(function(error){
                void 0;
                dfd.resolve(error);
            });
            return dfd.promise;
        },
		updateOrder                 : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/item';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateOrderAddress          : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';

			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		updateOrderStatus           : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/user/order';
			
			$http.put(apiUrl, data)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				void 0;
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		removeItemFromOrder         : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/order/item?orderKey='+ data.order.key + '&itemName=' + encodeURIComponent(data.order.itemName);

			if (data.order.selectedModifiers) {
				data.order.selectedModifiers.forEach(function (modifier) {
					apiUrl += '&selectedModifiers=' + encodeURIComponent(modifier.name);
				});
			}

            if (data.order.reason) {
                apiUrl += '&reason=' + encodeURIComponent(data.order.reason);
            }
			
			$http.delete(apiUrl)
			.then(function(response){
				dfd.resolve(response);
			})
			.catch(function(error){
				dfd.resolve(error);
			});
			return dfd.promise;
		},
		createOrderForUser          : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/admin/order';

			$http.post(apiUrl, data)
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					void 0;
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		updateStaffer               : function (data) {
			var dfd = $q.defer();
			var apiUrl = ENV.apiEndPoint + '/location';

			$http.put(apiUrl, data)
				.then(function(response){
					dfd.resolve(response);
				})
				.catch(function(error){
					void 0;
					dfd.resolve(error);
				});
			return dfd.promise;
		},
		getLocation                 : function (locationUniqueName) {
			var dfd = $q.defer();
			var headers = {};

			if (locationUniqueName) {
				headers.location = locationUniqueName;
			}
			$http.get(ENV.apiEndPoint + '/location', { headers: headers })
			.then(function(response){
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
        saveLocationSettings: function (data) {
			var dfd = $q.defer();
			$http.put(ENV.apiEndPoint + '/location', data)
				.then(function(response) {
					dfd.resolve(response);
				})
				.catch(function(error) {
					dfd.resolve(error);
				});
			return dfd.promise;
        },
		getCartItems                : function (data) {
			var dfd = $q.defer();

			var config = {
			    headers:  {
                    'authtoken' : data.authToken,
                    "emailid"   : data.emailId
			    }
			};

			$http.get(ENV.apiEndPoint + '/basket', config)
			.then(function(response){
				if(response.status === 403){
					hsAuth.invalidateSession('/');
				}
                dfd.resolve(response);
			})
            .catch(function(error){
				dfd.resolve(error);
            });
			return dfd.promise;
        },
		syncPrices: function (data) {
			var dfd = $q.defer();
			$http.post(ENV.apiEndPoint + '/syncprices', data)
				.then(function(response) {
					dfd.resolve(response);
				})
				.catch(function(error) {
					dfd.resolve(error);
				});
			return dfd.promise;
        },
		sendOrderReceipt: function (data) {
			var dfd = $q.defer();
			$http.post(ENV.apiEndPoint + '/order/receipt', data)
				.then(function(response) {
					dfd.resolve(response);
				})
				.catch(function(error) {
					dfd.resolve(error);
				});
			return dfd.promise;
        },
        getBarcodeTrackingFlag: function() {
            return globalFunctions.getSelectedLocation()
                .then(function(location) {
                    return !!location.enableBagsBarcodes;
                });
        },
        refreshDelivery: function(orderKey) {
            var data = {
                orderKey: orderKey,
            };
            return $http.post(ENV.apiEndPoint + '/order/delivery/refresh', data);
        },
        getSelectedPriceList: function() {
            var service = this;
            return $q(function(resolve, reject) {
                if (ENV.enablePriceList) {
                    var location = localStorageService.get('location');
                    if (!location) reject('Location is not selected');

                    var priceList = localStorageService.get('adminSelectedPriceList');
                    if (!priceList) {
                        return service.selectAdminPricelist()
                            .then(function(priceList) {
                                resolve(priceList);
                            })
                            .catch(function(err) {
                                reject(err);
                            });
                    }
                    $rootScope.adminSelectedPriceList = priceList;
                    resolve(priceList);
                } else {
                    resolve(null);
                }

            });
        },
        selectAdminPricelist: function() {
            return $q(function(resolve, reject) {
                globalFunctions.showAdminPriceListPopup('promotions', function(err, success) {
                    if (success) {
                        var priceList = localStorageService.get('adminSelectedPriceList');
                        $rootScope.adminSelectedPriceList = priceList;
                        resolve(priceList);
                    } else {
                        reject('Failed to set price list.');
                    }
                });
            });
        },
		getConversationFlags: function() {
            return globalFunctions.getSelectedLocation()
                .then(function(location) {
                    return location.conversations;
                });
        },
		isHomesomeAccount: function() {
			const homesomeEmails = ['@homesome.com', '@gethomesome.com', '@phontabulous.com'];
			var currentUserEmail = $rootScope.currentUser.email;
			for (var email of homesomeEmails) {
				if (currentUserEmail.endsWith(email)) {
					return true;
				}
			}
			return false;	
		},
		initAdminPage: function(currentPage, isRestrictedAdminAllowed) {
			var deffered = $q.defer();
			if (!$rootScope.currentUser) {
				$location.url('/login');
			}
			if (!isRestrictedAdminAllowed && $rootScope.currentUser.isAdminRestricted) {
				$location.url('/admin/manager-dashboard');
			}
			if (ENV.enableLocations && !localStorageService.get('adminLocationSelected')) {
				// For simplicity, if adminLocationSelected is false, we will redirect to the 
				// manager dashboard to initialize there. 
				$location.url('/admin/manager-dashboard');	
			}
			if (!localStorageService.get('adminSelectedPriceList')) {
				if (!ENV.enablePriceList) {
					if (!Array.isArray($rootScope.currentUser.adminPriceLists)) {
						// For simplicity, if user has no adminPriceLists, we will redirect to
						// the manager dashboard to initialize there
						$location.url('/admin/manager-dashboard');
					} else {
						localStorageService.set('adminSelectedPriceList', $rootScope.currentUser.adminPriceLists[0]);
						deffered.resolve();
					}
				} else {
					globalFunctions.showAdminPriceListPopup(currentPage, function(err, success) {
						if (err) {
							deffered.reject(err);
						}
						if (success) {
							deffered.resolve();
						}
					});
				}
			} else {
				deffered.resolve();
			}

			return deffered.promise;
		},
        getUsersPastOrders(headers) {
            var apiUrl = new URL(ENV.apiEndPoint + '/user/items');

            return $http.get(apiUrl.toString(), { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                });
        },
		currentUserHasLocationAdminPermissions: function(locationUniqueName) {
			if (!$rootScope.currentUser.isAdmin) return false;
			return hsUtils.isArray($rootScope.currentUser.locationsPermissions[locationUniqueName]);
		},
		currentUserHasPriceListAdminPermissions: function(locationUniqueName, priceListUniqueName) {
			if (!$rootScope.currentUser.isAdmin) return false;

			var locationsPermissions = $rootScope.currentUser.locationsPermissions;
			if (hsUtils.isArray(locationsPermissions[locationUniqueName])) {
				return (
					hsUtils.isEmptyArray(locationsPermissions[locationUniqueName])
					|| locationsPermissions[locationUniqueName].includes(priceListUniqueName)
				);
			}

			return false;
		},
		shouldShowSyncPriceListsPopup: function(locationsOnly) {
			if (!$rootScope.currentUser.isAdmin) return false;

			var service = this;

			var userAdminLocations = 0;
			var userAdminPriceLists = 0;

			if (ENV.enableLocations) {

				var allLocations = globalFunctions.getAllLocationsFromStorage() || [];

				for (var location of allLocations) {
					var hasLocationPermissions = service.currentUserHasLocationAdminPermissions(location.uniqueName);
					if (hasLocationPermissions) {
						userAdminLocations += 1;
					}

					if (ENV.enablePriceList && !locationsOnly) {
						for (var priceList of location.priceLists) {
							if (service.currentUserHasPriceListAdminPermissions(location.uniqueName, priceList.uniqueName)) {
								userAdminPriceLists += 1;
							}
						}
					} else if (hasLocationPermissions) {
						userAdminPriceLists += 1;
					}

					if (userAdminLocations > 1 || userAdminPriceLists > 1) {
						return true;
					}
				}
			}

			return false;
		}
	};
}]);

hsFac.factory('address', ['ENV', '$http',
		function(ENV, $http) {
			function _createResponseObj(response) {
				return {
					data    :response.data,
					status  :response.status,
					headers :response.headers,
					config  :response.config
				};
			}
			return {
                isValidAddress: function (address) {
                    if (!address) {
                        return false;
                    }
                    return ['street', 'city', 'state', 'zip'].every(function (key) {
                        return key in address && address[key];
                    });
                },
				/**
				 * Returns an object containing the parsed address from the AutoComplete object.
				 * Object structure is as follows:
				 * {
             *     address1 : string,
             *     address2 : string,
             *     city     : string,
             *     state    : string,
             *     zip      : string,
             *     country  : string,
             * }
				 * @param {object} autoCompleteObj
				 * @returns {object}
				 */
				getAutoCompleteAddress : function(autoCompleteObj) {
					var addressComponentList = autoCompleteObj.address_components;
					// Map used to retrieve the value form that we need from the auto complete component list
					var componentValueMap    = {
						street_number               : 'short_name',
						route                       : 'short_name',
						locality                    : 'long_name',
						sublocality                 : 'long_name',
						administrative_area_level_1 : 'short_name',
						country                     : 'short_name',
						postal_code                 : 'short_name'
					};
					
					var autocompleteAddress = {
						street1 : "",
						street2 : "",
						city     : "",
						locality : "",
						sublocality : "",
						state    : "",
						zip      : "",
						country  : ""
					};
					
					for (var i = 0; i < addressComponentList.length; i++) {
						var addressComponent = addressComponentList[i];
						var componentType    = addressComponent.types[0];

						if(componentType.indexOf('sublocality') !== -1) {
							componentType = "sublocality";
						}

						if (!componentValueMap[componentType]) {
							continue;
						}
						
						var componentValueForm = componentValueMap[componentType];
						var componentValue     = addressComponent[componentValueForm];
						switch(componentType) {
							case "street_number" :
								autocompleteAddress.street1 = componentValue + ' ' + autocompleteAddress.street1;
								break;
							case "route" :
								autocompleteAddress.street1 = autocompleteAddress.street1 + componentValue;
								break;
							case "locality" :
								autocompleteAddress.locality = componentValue;
								break;
							case "sublocality" :
								autocompleteAddress.sublocality = componentValue;
								break;
							case "postal_code" :
								autocompleteAddress.zip = componentValue;
								break;
							case "country" :
								autocompleteAddress.country = componentValue;
								break;
							case "administrative_area_level_1" :
								autocompleteAddress.state = componentValue;
								break;
						}
					}

					if (autocompleteAddress.locality) {
						autocompleteAddress.city = autocompleteAddress.locality;
					} else if (autocompleteAddress.sublocality) {
						autocompleteAddress.city = autocompleteAddress.sublocality;
					}

					return autocompleteAddress;
				},

				getAutoCompleteAddressFromCa : function(autoCompleteObj) {
					var addressComponentList = autoCompleteObj.address_components;
					// Map used to retrieve the value form that we need from the auto complete component list
					var componentValueMap = {
						street_number: 'short_name',
						route: 'short_name',
						locality: 'long_name',
						administrative_area_level_1: 'short_name',
						country: 'short_name',
						postal_code: 'short_name'
					};
					
					var autocompleteAddress = {
						street1: "",
						street2: "",
						city: "",
						province: "",
						zip: "",
						country: ""
					};
					
					for (var i = 0; i < addressComponentList.length; i++) {
						var addressComponent = addressComponentList[i];
						var componentType = addressComponent.types[0];
						
						if (!componentValueMap[componentType]) {
							continue;
						}
						
						var componentValueForm = componentValueMap[componentType];
						var componentValue = addressComponent[componentValueForm];
						
						switch(componentType) {
							case "street_number" :
								autocompleteAddress.street1 = componentValue + ' ' + autocompleteAddress.street1;
								break;
							case "route" :
								autocompleteAddress.street1 = autocompleteAddress.street1 + componentValue;
								break;
							case "locality" :
								autocompleteAddress.city = componentValue;
								break;
							case "postal_code" :
								autocompleteAddress.zip = componentValue;
								break;
							case "country" :
								autocompleteAddress.country = componentValue;
								break;
							case "administrative_area_level_1" :
								autocompleteAddress.province = componentValue;
								break;
						}
					}
					
					return autocompleteAddress;
				},
				
				
				/**
				 * Usage
				 *  address.verify(scannerId, setId, includeReferenceData = null)
				 *  .success(function(suggestedAddress, responseMap) {
             *      // Structures are as follows:
             *      suggestedAddress : {
             *          street1 : "123 Main St"
             *          street2 : "APT 987"
             *          city     : "Test City"
             *          state    : "CA"
             *          country  : "US"
             *          zip      : "55555"
             *      };
             *
             *  })
				 *  .error(function(data, status, headers, config){
             *      // Standard error response from Backend
             *      // Known errors
             *      // * 200005 : Country Not Allowed
             *      // * 203003 : Unverifiable address
             *  });
				 *
				 * @param {string} srcAddress1
				 * @param {string} srcAddress2
				 * @param {string} srcCity
				 * @param {string} srcState
				 * @param {string} srcZipCode
				 * @param {string} srcCountry
				 * @returns {$http.promise} The angular's $http promise object
				 */
				verify : function(srcAddr) {
					var jsonData = {
						street1 : srcAddr.street1,
						street2 : srcAddr.street2,
						city     : srcAddr.city,
						state    : srcAddr.state,
						zip      : srcAddr.zip,
						country  : srcAddr.country
					};
					
					// Obtaining the promise object from the Angular HTTP POST call
					var promise = $http.post(API_ENUM.VERIFY, jsonData);
					
					// Overriding the default `success` function with ours so return have a different
					// callback function structure that will have an object with the suggested address
					promise.success = function(fn) {
						promise.then(function(response){
							var suggestedAddress = response.data;
							var responseMap      = _createResponseObj(response);
							
							// Invoking user supplied function with the parsed data
							fn(suggestedAddress,responseMap);
						});
						return promise;
					};
					
					return promise;
				},
				handleEditAddress: function($event, controllerObject){
					controllerObject.isValidAddressFromGoogleMaps = false;
				},
				
			};
		}
	]);

hsFac.factory('scrollToElement', [function() {
	return function(scope, elem, attrs) {
		var element = $(scope);
		var offset = $(element).offset();
		var scrollAmount = offset.top;
		scrollAmount -= 120;

		$("html, body").animate({scrollTop: scrollAmount},'slow');
	};
}]);

hsFac.factory('notificationService', ["toastr", function (toastr){
	return {
		showToastrMessage           : function (type, message) {
			switch(type) {
				case 'success':
					toastr.success(message);
					break;
				case 'error':
					toastr.error(message);
					break;
			}
		}
	};
}]);

hsFac.factory('promise', function () {

	return {
		allSettled: function(promises) {
			var mappedPromises = promises.map(function(promise) {
				return promise.then(function(value) {
					return {
						status: 'fulfilled',
						value
					};
				})
				.catch(function(reason) {
					return {
						status: 'rejected',
						reason
					};
				});
			});
			return $q.all(mappedPromises);
		}
	};

});

hsFac.factory('globalFunctions', ["$rootScope", "OpenGraphTags", "ENV", "$filter", "$location", "toastr", "$http", "$sce", "localStorageService", "ngDialog", "$window", "hsAuth", "hsApi", "$q", "hsUtils", function ($rootScope, OpenGraphTags, ENV, $filter, $location, toastr, $http, $sce, localStorageService, ngDialog, $window, hsAuth, hsApi, $q, hsUtils) {
	function copyTextToClipboard(str) {
		var el = document.createElement('textarea'); 
		el.value = str;                         
		el.setAttribute('readonly', '');
		el.style.position = 'absolute';
		el.style.left = '-9999px';
		document.body.appendChild(el);
		var selected =
			document.getSelection().rangeCount > 0
				? document.getSelection().getRangeAt(0)
				: false;
		el.select();    
		document.execCommand('copy');                   
		document.body.removeChild(el);                  
		if (selected) {                                 
			document.getSelection().removeAllRanges();  
			document.getSelection().addRange(selected); 
		}
		toastr.success('Copied To Clipboard.');
	}
	return {
		preventSpaceInput($event){
			if ($event.keyCode === 32) {
				$event.preventDefault();
				return;
			}
		},
		errorMsg: {
			minOrder: 'Total will go below the minimum required amount for this order.'
		},
		bottleFeeMessage     : 'We charge bottle deposit fees in accordance with the local laws.',
		showTooltipPopup     : function (heading, message) {
			var modalClass = 'ngdialog-theme-default email-capture';

			ngDialog.open({
				template: 'partials/popup/tooltip-popup.html',
				controller:'ModalController',
				className: modalClass,
				closeByNavigation: true,
				data: {
					heading: heading,
					message: message
				}
			});
		},
		userOrderChanges: {
			heading: 'You can no longer add more items to the order.',
			subHeading: 'You have either reached a maximum limit for the item additions or you are within 4 hours of the delivery time. As a result no more items can be added to the order.',
		},
		showConfirmationDialog(heading, subHeading, confirmBtnText, cancelBtnText, cb) {
			ngDialog.openConfirm({
				data: {
					heading: heading,
					subHeading:  subHeading,
					confirmBtnText: confirmBtnText,
					cancelBtnText: cancelBtnText
				},
				template: 'partials/popup/confirm-popup.html'
			}).then(function (confirm) {
				cb(null, true);
			}, function (reject) {
				cb(true, null);
			});
		},
		getQuantityInterval(item) {
			return item.unit === 'lb' ? 0.5 : 1;
		},
		orderPoints: {
			title: 'Thank you for your order!',
			subTitle: "Here's What's Next",
			points: (function() {
				if (ENV.customOrderPoints) {
					var points = ENV.customOrderPoints;
				} else {
					var points = [
						{
							title: 'Credit Card Charges',
							image: 'credit-card.svg',
							desc: 'When you place your order, instead of immediately charging your card, we place a temporary authorization hold for an amount slightly higher than your order total at checkout. We place this authorization hold in case your total turns out to be higher due to added items, replacement items, or weight adjustments. After the order is complete, the hold will drop off, and your card will be charged for the final total as shown in the email receipt.',
							longDesc: 'When you place your order, instead of immediately charging your card, we place a temporary authorization hold for an amount slightly higher than your order total at checkout. We place this authorization hold in case your total turns out to be higher due to added items, replacement items, or weight adjustments. After the order is complete, the hold will drop off, and your card will be charged for the final total as shown in the email receipt.'
						},
						{
							title: 'Fulfillment',
							image: 'fulfillment.svg',
							desc: 'When our staff picks your order, they follow the Substitution preferences as selected by you during the checkout process. Before finalizing the charge, your order total is adjusted as per any item replacements or removals. This way you are charged exactly for the items in your final order, nothing more or less. You can also review any changes made to your order <a href=\'/my-account\'>here</a>.',
							longDesc: 'When our staff picks your order, they follow the Substitution preferences as selected by you during the checkout process. Before finalizing the charge, your order total is adjusted as per any item replacements or removals. This way you are charged exactly for the items in your final order, nothing more or less. You can also review any changes made to your order <a href=\'/my-account\'>here</a>.'
						},
						{
							title: 'Editing Order',
							image: 'editing-order.svg',
							desc: 'Once the order is placed, you can make changes to your order <a href=\'/my-account\'>here</a>. Note that the system allows changes till the store starts picking your order or few hours before the Pick Up or Delivery time.',
							longDesc: 'Once the order is placed, you can make changes to your order <a href=\'/my-account\'>here</a>. Note that the system allows changes till the store starts picking your order or few hours before the Pick Up or Delivery time.',
							restaurantDesc: 'Once the order is placed, you will need to call the restaurant to make any changes.',
							restaurantLongDesc: 'Once the order is placed, you will need to call the restaurant to make any changes.',
							restaurant: true
						},
					];
				}
				if (!ENV.disableTip && !ENV.hideTipInfo) {
					points.push(
						{
							title: 'Tips',
							image: 'tips.svg',
							desc: 'While placing the order, you can choose to leave a tip. Our system in some cases provides the percentage guidelines to facilitate the tipping. Note that these percentages are for guiding purpose only and any tip that you decide to leave is taken as the absolute dollar value. Once the order is placed, you can change the tip <a href=\'/my-account\'>here</a>.',
							longDesc: 'While placing the order, you can choose to leave a tip. Our system in some cases provides the percentage guidelines to facilitate the tipping. Note that these percentages are for guiding purpose only and any tip that you decide to leave is taken as the absolute dollar value. Once the order is placed, you can change the tip <a href=\'/my-account\'>here</a>.'
						}
					);
				}
				return points;
			})()
		},
		canReplace(item) {
			void 0;
			if (item.hasOwnProperty('canReplace')) {
				return item.canReplace;
			} else {
				return !ENV.isRestaurant;
			}
		},
		addDecimal($event, id, decimal) {
			if ($event.key === 'Enter' || $event.key === 'Backspace') {
				return;
			} else {
				var keys = ['0','1','2','3','4','5','6','7','8','9'];
				if (keys.indexOf($event.key) !== -1) {
					$event.preventDefault();
					if (!decimal) { decimal = 2;}

					var quantity = $(id).val();
					quantity = quantity.toString().replace('.', '');
					var key = $event.key.toString();
					quantity += key;
					quantity = parseFloat(quantity);
					quantity = quantity/100;
					quantity = quantity.toFixed(decimal);
					$(id).val(quantity);
				}
			}
		},
		checkAndUpdateSession() {
			void 0;
			var user = localStorageService.get('user');
			var session = sessionStorage.getItem('session_global');
			var update = false;

			// If session cookie exist check for the expiration
			if (session) {
				var sessionDate = new Date(session);
				var now = new Date();
				var diffTime = now - sessionDate;
				var hourInterval = 60 * 60 * 1000;

				// Session expired
				if (diffTime > hourInterval) {
					update = true;
				}
			} else {
				// No session cookie must run the update check
				update = true;
			}

			// If update is needed
			if (update) {
				void 0;
				void 0;
				// If user is logged in fetch the latest user info from API and update in localStorage
				if (user) {
					this.updateUserInStorage();
				}

				// If client have multiple locations enabled fetch latest locations from API and update in localStorage
				if(ENV.enableLocations) {
					this.updateLocationsInStorage();
				}

				// If user is not logged in and client doesn't have multiple locations then simply just drop the session cookie
				if (!user && !ENV.enableLocations) {
					sessionStorage.setItem('session_global', new Date());
				}
			} else {
				void 0;
			}
		},
		updateUserInStorage() {
			return hsAuth.getUpdatedUser()
				.then(function(res) {
					if (res.status === 200) {
						// Save the user in localStorage
						hsAuth.saveUserLocal(res.data);

						// If Client doesn't have multi location then drop the session cookie
						if (!ENV.enableLocations) {
							sessionStorage.setItem('session_global', new Date());
						}
					}
				});
		},
		updateLocationsInStorage() {
			void 0;
			hsApi.getLocations()
				.then(function(res) {
					void 0;
					if (res.status === 200) {
						var location = localStorageService.get('location');
						var priceList = null;
						void 0;

						// If location obj exist in localStorage
						if (location) {
							// Constructing the metadata to store.
							var locationObj = {
								allLocations: res.data,
								selectedLocation: null
							};

							void 0;
							// Check to see if the Current saved location exist in the API response
							res.data.forEach(function(loc) {
								// If location exist
								if (loc.uniqueName === location.selectedLocation.uniqueName) {
									// set the selected location to the latest from API response
									locationObj.selectedLocation = loc;

									// If Client have pricelist enabled
									if (ENV.enablePriceList) {
										var selectedPriceList = localStorageService.get('selectedPriceList');
										// if pricelist is saved check that it exist in the selected location
										if (selectedPriceList) {
											loc.priceLists.forEach(function(pl) {
												if (selectedPriceList.uniqueName === pl.uniqueName) {
													priceList = pl;
												}
											});
										}
									}
								}
							});

							// If the saved location was found in the API response
							if (locationObj.selectedLocation) {
								// Save the new location payload in local storage and set it in Global variable
								localStorageService.set('location', locationObj);
								$rootScope.location = locationObj;

								if (ENV.enablePriceList) {
									// If pricelist was not found set it to the first pricelist in the location's priceLists array
									if (!priceList) {
										priceList = locationObj.selectedLocation.priceLists[0];
									}

									// save the pricelist in the local storage and set it in Global variable
									localStorageService.set('selectedPriceList', priceList);
									$rootScope.selectedPriceList = priceList;
								}
								
							} else {
								/**
								 * If location was not found in the new payload then clear location and pricelist from local storage
								 * Also fire 'sessionExpired' event so the pages can listen to it and show the location dialog appropriately
								 */

								localStorageService.remove('location');
								localStorageService.remove('selectedPriceList');
								$rootScope.location = null;
								$rootScope.selectedPriceList = null;
								$rootScope.$broadcast('sessionExpired', {});
							}

							/**
							 * Drop the session cookie either way. If the location is found the session should start
							 * and if the location was not found then we have successfully cleared the localStorage
							 * which will force user to select a location before continuing.
							 */
							sessionStorage.setItem('session_global', new Date());
						}
					}
				});
		},
		ngTableConfig               : {
			count: 15,
			counts: [15, 30, 50],
		},
		product                     : {
			maxQuantityError: function(max) {
				return 'At the moment, you can only purchase maximum ' + max + ' quantity of this product.'
			},
			minQuantityError: function(min) {
				return 'At the moment, you can only purchase minimum ' + min + ' quantity of this product.'
			}
		},
		GAEventType                 : {
			FEATURE_CHECK: 'Feature Check',
			BTN_CLICK: 'Button Click',
			USER_JOURNEY: 'User Journey',
			TWILIO: 'Twilio',
			SEARCH: 'Search',
			PRODUCT_LANDING: 'Product Landing',
			PRODUCT_CATERGORY: 'Product Category',
			MY_ACCOUNT: 'My Account',
			CHECKOUT_CONFIRM: 'Checkout/ Confirm',
			UNKNOWN: 'Unknown',
		},
        POSTMATES_STATUS_CODES: {
            'pending': 'Finding Driver',
            'pickup': 'Driver En Route',
            'dropoff': 'Out For Delivery',
			'pickup_complete': 'Out For Delivery',
            'delivered': 'Delivered',
            'canceled': 'Cancelled',
            'returned': 'Returned',
        },
		USER_POSTMATES_STATUS_CODES: {
			'pending': 'Preparing Order',
   			'pickup': 'Preparing Order',
   			'pickup_complete': 'Order Picked Up',
   			'dropoff': 'Out For Delivery',
   			'delivered': 'Delivered',
			'canceled': 'Preparing Order'
		},
		sendGAEvent                 : function(category, action, label) {
			ga('send', {
				hitType: 'event',
				eventCategory: category,
				eventAction: action,
				eventLabel: label
			});
		},
		darkModeUrls                : ['/about', '/contact', '/deals', '/', '/my-account', '/account-settings', '/login', '/signup', '/password/forgot', '/password/reset', '/terms-and-conditions', '/privacy-policy', '/faq'],
		shippingPackages            : [
			{
				name                : "Small Flat Rate Box",
				value               : "SmallFlatRateBox",
				dimensionsText      : '8 11/16" x 5 7/16" x 1 3/4"',
				checked             : false
			},
			{
				name                : "Medium Flat Rate Box",
				value               : "MediumFlatRateBox",
				dimensionsText      : '11 1/4" x 8 3/4" x 6" or 14" x 12" x 3 1/2"',
				checked             : false
			},
			{
				name                : "Large Flat Rate Box",
				value               : "LargeFlatRateBox",
				dimensionsText      : '12 1/4" x 12 1/4" x 6"',
				checked             : false
			},
			{
				name                : "Custom Box",
				value               : "custom",
				dimensionsText      : 'L x W x H',
				checked             : false
			}
		],
		checkPriceList              : function () {
			var session = sessionStorage.getItem('hs_session');
			if (!session) {
				sessionStorage.setItem('hs_session', new Date());
			}

			var location = localStorageService.get('location');
			if (location && location.hasOwnProperty('allLocations')) {
				if (session) {
					var sessionDate = new Date(session);
					var now = new Date();
					var diffTime = now - sessionDate;
					var hourInterval = 2*60*60*1000;

					if (diffTime > hourInterval) {
						$rootScope.$broadcast('sessionExpired', {});
					}
				} else {
					$rootScope.$broadcast('sessionExpired', {});
				}
			} else {
				sessionStorage.setItem('hs_session', new Date());
			}
		},
		checkIfOrderingDisabled() {
			var orderingDisabled = false;
			var location = localStorageService.get('location');
			if (location && location.hasOwnProperty('allLocations')) {
				orderingDisabled = location.selectedLocation.orderingDisabled;
			}
			$rootScope.orderingDisabled = ENV.disableOrdering || orderingDisabled;

			// Redirecting user to products page if they are on Category page and select a location where online ordering is disabled
			if ($rootScope.orderingDisabled
				&& $location.url().indexOf('/shop') !== -1
				&& $location.url().indexOf('/admin') === -1) {
				$location.url('/products');
			}
		},
		showAdminLocationsPopup     : function (callback) {
			ngDialog.open({
				template        : 'partials/popup/select-admin-location.html',
				controller      : 'ModalController',
				className       : 'ngdialog-theme-default email-capture',
				showClose       : false,
				closeByDocument : false,
				closeByEscape   : false,
				preCloseCallback: callback
			});
		},
		showAdminPriceListPopup     : function (pageName, callback) {
			ngDialog.open({
				template        : 'partials/popup/select-admin-pricelist.html',
				controller      : 'ModalController',
				className       : 'ngdialog-theme-default email-capture',
				showClose       : false,
				closeByDocument : false,
				closeByEscape   : false,
				data : {
					"pageName": pageName,
				},
				preCloseCallback: function () {
					callback(null, true);
				}
			});
		},
	    removeSpaces				: function (val) {
	        return val.trim();
        },
		preventDefault              : function (event, onAdminPage) {
			if(onAdminPage) {
				event.preventDefault();
			}
		},
	    goToUrl         			: function (url) {
	        $location.url(encodeURIComponent(url));
        },
        checkLocationParam			: function () {
			var locationName = $location.search().location;
	    	if (locationName && $location.path().indexOf('/admin') === -1) {
                $http.get(ENV.apiEndPoint + '/locations')
                    .then(function(res) {
                        if(res.status === 200){
                            var selectedLocation;

                            res.data.forEach(function(location) {
                                location['directions'] = $sce.trustAsResourceUrl(
                                    'https://maps.google.com/maps?q='+
                                    location.address.street +' '+
                                    location.address.city +' '+ location.address.state +' '+ location.address.zip
                                );

                                if(locationName === location.uniqueName) {
                                    selectedLocation = location;
                                }
                            });

                            if(selectedLocation){
                                var locationData = {
                                    allLocations    	: res.data,
                                    selectedLocation	: selectedLocation
                                };

                                localStorageService.set('location', locationData);
                                $rootScope.$emit('locationUpdated', true);
							}
                        }else{
                            void 0
                        }
                    });
			}
		},
		getAnnoucements				: function () {
	    	$http.get(ENV.apiEndPoint + '/announcement')
			.then(function (res) {
				if(res.status === 200 && res.data.length > 0 && $location.path().indexOf('/admin') === -1) {
					var today = new Date();
					var date = new Date(res.data[0].expYear, res.data[0].expMonth, res.data[0].expDate);
					
					if (date >= today) {
						var hideNotification = sessionStorage.getItem('hideNotification');
						if (!hideNotification) {
							$rootScope.globalNotification = {
								data 			: res.data[0],
								show 			: true,
								hideCloseBtn	: ENV.hideAnnouncementBanner
							};
						}
					}
				}else {
                    $rootScope.globalNotification = {
                        data 			: null,
                        show 			: false,
						hideCloseBtn	: ENV.hideAnnouncementBanner
                    }
				}
			})
			.catch(function (error) {
				void 0;
                $rootScope.globalNotification = {
                    data 			: null,
                    show 			: false,
                    hideCloseBtn	: ENV.hideAnnouncementBanner
                }
			});
		},
        copyToClipboard				: function (str) {
            var el = document.createElement('textarea');  // Create a <textarea> element
            el.value = str;                                 // Set its value to the string that you want copied
            el.setAttribute('readonly', '');                // Make it readonly to be tamper-proof
            el.style.position = 'absolute';
            el.style.left = '-9999px';                      // Move outside the screen to make it invisible
            document.body.appendChild(el);                  // Append the <textarea> element to the HTML document
            var selected =
                document.getSelection().rangeCount > 0        // Check if there is any content selected previously
                    ? document.getSelection().getRangeAt(0)     // Store selection if found
                    : false;                                    // Mark as false to know no selection existed before
            el.select();                                    // Select the <textarea> content
            document.execCommand('copy');                   // Copy - only works as a result of a user action (e.g. click events)
            document.body.removeChild(el);                  // Remove the <textarea> element
            if (selected) {                                 // If a selection existed before copying
                document.getSelection().removeAllRanges();    // Unselect everything on the HTML document
                document.getSelection().addRange(selected);   // Restore the original selection
            }

            toastr.success('Discount code copied successfully.');
        },
		reverseCamelCase: function(str) {
			return str.replace(/([a-z](?=[A-Z]))/g, '$1 ');
		},
		toTitleCase: function(str) {
			return str.trim().split(/\s+/).map(function(word) {
				if (word) {
					return word[0].toUpperCase() + word.substr(1).toLowerCase();
				}
			}).join(' ');
		},
		sortJSONObj                 : function (obj) {
			var sortedCategoryOrder = {};
			Object.keys(obj).sort().forEach(function(category){
				sortedCategoryOrder[category] = obj[category];
			});

			return sortedCategoryOrder;
		},
		clearKeys: function(obj) {
			Object.getOwnPropertyNames(obj).forEach(function(prop) {
				delete obj[prop];
			});
		},
		copyKeys: function(sourceObj, targetObj) {
			if (!sourceObj || !targetObj 
				|| typeof sourceObj !== 'object' || typeof targetObj !== 'object' 
				|| Array.isArray(sourceObj) || Array.isArray(targetObj))
			{
				throw new Error('Unable to copy keys: Please provide two valid objects.');
			}

			var keys = Object.keys(sourceObj);
			for (var key of keys) {
				if (typeof sourceObj[key] !== 'object' && !Array.isArray(sourceObj[key])) {
					targetObj[key] = sourceObj[key];
				} else {
					if (Array.isArray(sourceObj[key])) {
						targetObj[key] = sourceObj[key].map(function(item) {
							return item;
						});
					} else {
						targetObj[key] = angular.copy(sourceObj[key]);
					}
				}
			}
		},
		areEqualObjects: function(obj1, obj2) {

			if (typeof obj1 !== typeof obj2) {
				return false;
			}
	
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				return obj1.every(function(key) {
							return obj2.includes(key);
						})
						&& obj2.every(function(key) {
							return obj1.includes(key);
						});
			} else if (typeof obj1 === 'object' && typeof obj2 === 'object') {
				var obj1Keys = Object.keys(obj1);
				var obj2Keys = Object.keys(obj2);
				var identicalKeys = 
					obj1Keys.every(function(key) {
						return obj2Keys.includes(key);
					}) && obj2Keys.every(function(key) {
						return obj1Keys.includes(key);
					});
				if (!identicalKeys) {
					return false;
				}
				for (var key of obj1Keys) {
					if (typeof obj1[key] !== 'object') {
						if (obj1[key] !== obj2[key]) {
							return false;
						}
					} else {
						return $rootScope.globalFunctions.areEqualObjects(obj1[key], obj2[key]);
					}
				}
				return true;
			} else {
				return obj1 === obj2;
			} 
		},
		invertMap: function(obj, sourceKey) {
			var result = {};
			if (typeof obj !== "object" || Array.isArray(obj)) {
				throw new Error('Error. Please provide a valid object to invert.');
			}
			Object.keys(obj).forEach(function(key) {
				if (key) {
					if (typeof obj[key] === "object") {
						if (!Array.isArray(obj[key])) {
							if (obj[key][sourceKey] && typeof obj[key][sourceKey] !== "object") {
								var newKey = obj[key][sourceKey];
								delete obj[key][sourceKey];
								result[newKey] = obj[key];
							}
						} else {
							if (Number.isInteger(sourceKey)) {
								if (obj[key][sourceKey] && typeof obj[key][sourceKey] !== "object") {
									result[obj[key][sourceKey]] = obj[key].splice(sourceKey, 1, key);
								}
							}
						}
					} else if (typeof obj[key] === "number" || typeof obj[key] === "string" || typeof obj[key] === "boolean") {
						result[obj[key]] = key;
					}
				}
			});
			return result;
		},
		intersectObjects(obj1, obj2) {
			var resultObj = {};
			if (typeof obj1 !== "object" || typeof obj2 !== "object") {
				return resultObj;
			}

			Object.keys(obj2).forEach(function(key) {
				if ($rootScope.globalFunctions.isTruthyProductValue(obj2[key]) && obj2[key] !== obj1[key]) {
					resultObj[key] = obj2[key];
				}
			});

			return resultObj;
		},
		isTruthyProductValue(val) {
			return val || val === '' || val === 0 || val === false;
		},
		getTruthyProductKeys(obj) {
			return Object.keys(obj).filter(function(key) {
				return $rootScope.globalFunctions.isTruthyProductValue(obj[key]);
			});
		},
		showNotificationCarousel    : function () {
			ngDialog.open({
				template    : 'partials/popup/announcement-popup.html',
				controller  : 'ModalController',
				closeByDocument : false,
				className   : 'ngdialog-theme-default email-capture'
			});
		},
		filterProducts: function (products, screenWidth) {
			angular.forEach(products, function (val, key, idx) {
				if (val.hasOwnProperty('renderEmptyTile')) {
					products.splice(idx, 1);
				}
			});

			var productLength = products.length;
			var selectedWidth;
			var maxGridLength;

			angular.forEach(screenWidth, function (width, key) {
				width === true ? selectedWidth = key : '';
			});

			switch (selectedWidth) {
				case 'lg' : {
					maxGridLength = (Math.ceil(productLength / 5) * 5) - productLength;
					break;
				}
				case 'md' : {
					maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					break;
				}
				case 'sm' : {
					maxGridLength = (Math.ceil(productLength / 3) * 3) - productLength;
					break;
				}
				case 'xs' : {
					maxGridLength = (Math.ceil(productLength / 2) * 2) - productLength;
					break;
				}
			}

			var objectsToAdd = [];
			for (var i = 0; i < maxGridLength; i++) {
				objectsToAdd.push({
					renderEmptyTile: true
				});
			}

			return products.concat(objectsToAdd);
		},
		getHomePageGridLength(selectedWidth, productLength) {
			switch (selectedWidth) {
				case 'lg' : {
					var tileLength = 0;
					productLength <=4 ? tileLength = 4 : tileLength = 5;
					return (Math.ceil(productLength/tileLength) * tileLength) - productLength;
				}
				case 'md' : {
					return (Math.ceil(productLength/3) * 3) - (productLength + 1);
				}
				case 'sm' : {
					return (Math.ceil(productLength/3) * 3) - (productLength + 1);
				}
				case 'xs' : {
					return (Math.ceil(productLength/2) * 2) - productLength;
				}
			}
		},
		getOrderPageGridLength(selectedWidth, productLength) {
			switch (selectedWidth) {
				case 'lg' :
				case 'md' :
				case 'sm' : {
					if (productLength % 2) {
						return 1;
					} else {
						return 0;
					}
				}
				case 'xs' : {
					return 0;
				}
			}
		},
		getMaxGridLength(selectedWidth, productLength) {
			switch (selectedWidth) {
				case 'lg' : {
					return (Math.ceil(productLength/5) * 5) - productLength;
				}
				case 'md' : {
					return (Math.ceil(productLength/3) * 3) - productLength;
				}
				case 'sm' : {
					return (Math.ceil(productLength/3) * 3) - productLength;
				}
				case 'xs' : {
					return (Math.ceil(productLength/2) * 2) - productLength;
				}
			}
		},
		addEmptyGridTiles(type, products, screenWidth) {
			var homePageProducts;
			var productLength;
			if (type === 'homePageProducts') {
				if (products.tileProducts.length < 4) {
					if(products.tileProducts.length >= products.nonTileProducts.length){
						homePageProducts = products.tileProducts;
					}else{
						homePageProducts = products.nonTileProducts;
					}
				}else{
					homePageProducts = products.tileProducts;
				}

				productLength = homePageProducts.length;
			} else {
				productLength = products.length;
			}

			var selectedWidth;
			var maxGridLength;

			angular.forEach(screenWidth, function(width, key) {
				width === true ? selectedWidth = key : '';
			});

			switch (type) {
				case 'homePageProducts' : {
					maxGridLength = this.getHomePageGridLength(selectedWidth, productLength);
					break;
				}
				case 'orderPage' : {
					maxGridLength = this.getOrderPageGridLength(selectedWidth, productLength);
					break;
				}
				case 'regular' : {
					maxGridLength = this.getMaxGridLength(selectedWidth, productLength);
					break;
				}
			}

			if (type === 'homePageProducts'
				&& selectedWidth === 'lg'
				&& (productLength > 4 && productLength < 9)) {
				return homePageProducts.slice(0,4);
			} else{
				var objectsToAdd = [];
				for (var i = 0; i < maxGridLength; i++) {
					objectsToAdd.push({
						renderEmptyTile : true
					});
				}

				if (type === 'homePageProducts') {
					return homePageProducts.concat(objectsToAdd);
				} else {
					return products.concat(objectsToAdd);
				}

			}
		},
		restaurantSearch(products, results, isOrganic, brands, department, subCategory) {
			for (var i = products.length - 1; i >= 0; i--) {
				var product = products[i];
				var keepProduct = true;

				if (brands) {
					keepProduct = brands.indexOf(product.brand) !== -1
				}

				if (department && subCategory) {
					keepProduct = product.type === department && product.subType === subCategory;
				} else if(department) {
					keepProduct = product.type === department;
				} else if (subCategory) {
					keepProduct = product.subType === subCategory;
				} else if (hsUtils.isObject($rootScope.allProductsHash) && !$rootScope.allProductsHash.hasOwnProperty(product.name)) {
					keepProduct = false;
				}

				if (keepProduct) {
					if (isOrganic && !product.organic) {
						products.splice(i, 1);
						continue;
					}

					if (product.isHidden || !$rootScope.tableSideOrder && product.isTableSideOnly) {
						products.splice(i, 1);
					} else {
                        var categoryNameWithoutSpaces = $filter('removeSpaces')(product.type);
                        var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.subType);

                        if (!results.hasOwnProperty(categoryNameWithoutSpaces)) {
                            results[categoryNameWithoutSpaces] = {
                                name:   product.type,
                                products: [],
                                tileProducts: [],
                                nonTileProducts: [],
                                categories: {}
                            };
                        }

                        if (!results[categoryNameWithoutSpaces].categories.hasOwnProperty(subCategoryNameWithoutSpaces)) {
                            results[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
                                name: product.subType,
                                products: [],
                                tileProducts: [],
                                nonTileProducts: []
                            };
                        }

						if(product.hasImage){
							results[categoryNameWithoutSpaces].tileProducts.push(product);
							results[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);

						}else{
							results[categoryNameWithoutSpaces].nonTileProducts.push(product);
							results[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
						}

						results[categoryNameWithoutSpaces].products.push(product);
						results[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);
					}
				} else {
					products.splice(i, 1);
				}
			}

			return results;
		},
		allProductSearch(products, results, isOrganic, department, subCategory) {
			for (var i = products.length - 1; i >= 0; i--) {
				var product = products[i];
				var keepProduct = true;

				if (department && subCategory) {
					keepProduct = product.type === department && product.subType === subCategory;
				} else if(department) {
					keepProduct = product.type === department;
				} else if(subCategory) {
					keepProduct = product.subType === subCategory;
				} else if (hsUtils.isObject($rootScope.allProductsHash) && !$rootScope.allProductsHash.hasOwnProperty(product.name)) {
					keepProduct = false;
				}

				if (keepProduct) {

					if (isOrganic && product.healthClaims && !product.healthClaims.includes('organic')) {
						products.splice(i, 1);
						continue;
					}

					if (product.isHidden || !$rootScope.tableSideOrder && product.isTableSideOnly) {
						products.splice(i, 1);
					} else {
                        var categoryNameWithoutSpaces = $filter('removeSpaces')(product.type);
                        var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.subType);

                        if (!results.hasOwnProperty(categoryNameWithoutSpaces)) {
                            results[categoryNameWithoutSpaces] = {
                                name: product.type,
                                products: [],
                                categories: {}
                            };
                        }

                        if (!results[categoryNameWithoutSpaces].categories.hasOwnProperty(subCategoryNameWithoutSpaces)) {
                            results[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
                                name: product.subType
                            };
                        }
						results[categoryNameWithoutSpaces].products.push(product);
					}
				} else {
					products.splice(i, 1);
				}
			}
			return results;
		},
		getSortedProducts           : function (products, productName, clientSide, basketMap) {
			var allProducts = [];
			var hiddenProducts = [];
			var outOfStockProducts = [];
            var inactiveProducts = [];
			var autoAddedProducts = [];
			var subCategories = [];
			var selectedProduct = {};
			var sortedData = {};
			var allProductsHash = {};
            var homepageProducts = [];

			angular.forEach(products, function (product) {
				product.loading = false;
				product.checked = false;
				product.isCustom = false;
                // clientSide is passed from my-account to set the initial basket quantity for an item.
				product.quantity = clientSide ? 0 : 1;
				product.showRemoveBtn = false;
				product.inStock = product.isInStock ? 'Yes': 'No';

				var categoryNameWithoutSpaces = $filter('removeSpaces')(product.type);
				var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.subType);

				if (basketMap && basketMap.hasOwnProperty(product.name)) {
					product.quantity = basketMap[product.name].quantity;
					product.instructions = basketMap[product.name].instructions;
				}

				if (product.hasOwnProperty('hasImage') === false) {
					product.hasImage = true;
				}

				if (product.hasOwnProperty('isHidden') && product.isHidden) {
					hiddenProducts.push(product);
				} else {
					allProducts.push(product);
                    if (product.hasOwnProperty('isInactive') && product.isInactive) {
                        inactiveProducts.push(product);
                    } else if (product.hasOwnProperty('isInStock') && product.isInStock === false) {
						outOfStockProducts.push(product);
					}
					
					if (product.hasOwnProperty('isAutoAdded') && product.isAutoAdded && !product.wasReviewed) {
						autoAddedProducts.push(product);
					} 
                    
                    if (product.hasOwnProperty('isOnHomepage') && product.isOnHomepage) {
                        homepageProducts.push(product);
                    }
				}

				if (productName && productName === product.name) {
					selectedProduct = product;
				}

				allProductsHash[product.name] = product;

				//Sorting data based on type, subType
				if (!sortedData.hasOwnProperty(categoryNameWithoutSpaces)){
					sortedData[categoryNameWithoutSpaces] = {
						name: product.type,
						id: categoryNameWithoutSpaces,
						checked: false,
						products: [],
						tileProducts    :   [],
						nonTileProducts :   [],
						hiddenProducts: [],
						outOfStockProducts: [],
                        inactiveProducts: [],
						autoAddedProducts: [],
                        homepageProducts: [],
						categories: {},
						subCategories: {},
					};
				}

				if (!sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces]) {
					sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces] = {
						name: product.subType,
						id: subCategoryNameWithoutSpaces,
						products: [],
						checked: false,
						outOfStockProducts: [],
                        inactiveProducts: [],
						autoAddedProducts: [],
                        homepageProducts: [],
						tileProducts    :   [],
						nonTileProducts :   [],
						limit: 10
					};
				}

				if (product.hasOwnProperty('isHidden') && product.isHidden) {
					sortedData[categoryNameWithoutSpaces].hiddenProducts.push(product);
				} else {
					sortedData[categoryNameWithoutSpaces].products.push(product);
					sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].products.push(product);

                    if (product.hasOwnProperty('isInactive') && product.isInactive) {
                        sortedData[categoryNameWithoutSpaces].inactiveProducts.push(product);
                        sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].inactiveProducts.push(product);
                    } else if (product.hasOwnProperty('isInStock') && product.isInStock === false) {
						sortedData[categoryNameWithoutSpaces].outOfStockProducts.push(product);
						sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].outOfStockProducts.push(product);
					}
					
					if (product.hasOwnProperty('isAutoAdded') && product.isAutoAdded && !product.wasReviewed) {
						sortedData[categoryNameWithoutSpaces].autoAddedProducts.push(product);
						sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].autoAddedProducts.push(product);
					}
					

                    if (product.hasOwnProperty('isOnHomepage') && product.isOnHomepage) {
                        sortedData[categoryNameWithoutSpaces].homepageProducts.push(product);
                        sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].homepageProducts.push(product);
                    }

					if(product.hasImage){
						sortedData[categoryNameWithoutSpaces].tileProducts.push(product);
						sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].tileProducts.push(product);
					}else{
						sortedData[categoryNameWithoutSpaces].nonTileProducts.push(product);
						sortedData[categoryNameWithoutSpaces].categories[subCategoryNameWithoutSpaces].nonTileProducts.push(product);
					}
				}

			});

			angular.forEach(sortedData, function (val, key) {
				subCategories = subCategories.concat(Object.values(val.categories));
			});

			return {
				selectedProduct: selectedProduct,
				hiddenProducts: hiddenProducts,
				outOfStockProducts: outOfStockProducts,
                inactiveProducts: inactiveProducts,
				autoAddedProducts: autoAddedProducts,
                homepageProducts: homepageProducts,
				allProducts: allProducts,
				subCategories: subCategories,
				sortedData: sortedData,
				allProductsHash: allProductsHash,
			};
		},
		filterProductsByCategory    : function (basket) {
			var sortedBasketData = {};
			var categoryOrder = JSON.parse(JSON.stringify(ENV.categoryOrder));
			angular.forEach(categoryOrder, function(val, key){
				categoryOrder[key] = ''
			});
			basket.forEach(function(product) {
				if(product.hasOwnProperty('hasImage') !== true) {
					product.hasImage = true;
				}
				
				var categoryNameWithoutSpaces = $filter('removeSpaces')(product.type);
				if(!sortedBasketData.hasOwnProperty(categoryNameWithoutSpaces)) {
					sortedBasketData[categoryNameWithoutSpaces] = {
						name            : product.type,
						checked         : false,
						allPacked       : false,
						products        : []
					};
				}
				
				sortedBasketData[categoryNameWithoutSpaces].products.push(product);
			});

			angular.forEach(sortedBasketData, function(val, key){
				if(categoryOrder.hasOwnProperty(key)){
					if(sortedBasketData[key].products.length > 0){
						categoryOrder[key] = sortedBasketData[key];
					}else{
						delete categoryOrder[key];
					}
				}else{
					categoryOrder[key] = sortedBasketData[key];
				}
			});
			
			angular.forEach(categoryOrder, function(val, key){
				if(!categoryOrder[key]) {
					delete categoryOrder[key];
				}
			});

			return categoryOrder;
		},
		alphabeticalSort: function(list) {
			return list.sort(function(a, b) {
				if (a < b) return -1;
				else if (a > b) return 1;
				return 0;
			});
		},
		scrollToElement 			: function (elem, amount) {
			var offset = $(elem).offset();
			var scrollAmount = offset.top;
			//console.log('Scroll amount is:'+scrollAmount);
			scrollAmount -= amount || 50;
			void 0;
			//console.log('New Scroll amount is:'+scrollAmount);
			// Scroll
			$("html, body").animate({scrollTop: scrollAmount},'slow');
		},
		orderStatusEnum 			: {
			PROCURING   : "Procuring",
			RECEIVED    : "Received",
			PROCESSED   : "Processed",
			INPROGRESS  : "In Progress",
			COMPLETED   : "Completed",
			CANCELLED   : "Cancelled"
		},
		isOrderInTerminalState(order) {
			var terminalStates = [this.orderStatusEnum.COMPLETED, this.orderStatusEnum.CANCELLED];
			return terminalStates.includes(order.state);
		},
		imageBaseUrl    			: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/',
		imageBaseUrlThumbnail		: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages_tn/',
		// imageBaseUrl    			: 'https://d2h0pt6mau2p5e.cloudfront.net/productimages/',
		// imageBaseUrlThumbnail		: 'https://d2h0pt6mau2p5e.cloudfront.net/productimages_tn/',
		createImageUrl(image, ext) {
			ext = ext || '.jpg';
			return this.imageBaseUrl + encodeURIComponent(image) + ext;
		},
		getImageErrorUrl(product) {

			if (product['mainImage']) {
				return this.imageBaseUrl + product.name + '.jpg';
			}
			return '../images/ui-v2/nophoto-v2.svg';
		},
		getImageUrl(product, isThumbnail) {

			var baseUrl = isThumbnail ? this.imageBaseUrlThumbnail : this.imageBaseUrl;

			if (product['mainImage']) {
				return baseUrl + encodeURIComponent(product.mainImage) + '.jpg';
			}
			return baseUrl + encodeURIComponent(product.name) + '.jpg';
		},
		setSEOdata($title, $keywords, $description, $image) {
			var host = $location.protocol() +'://'+location.host;
			var defaultPageTitle = ENV.SEO.title;
			var defaultPageDescription = ENV.SEO.description;
			var defaultImage = host + ENV.SEO.image;
			var defaultKeywords = host + ENV.SEO.keywords;
			var canonical = $location.absUrl();


			var title       = $title || defaultPageTitle;
			var description = $description || defaultPageDescription;
			var seoImage    = $image || defaultImage;
			var keywords    = $keywords || defaultPageTitle;

			OpenGraphTags.setOgUrl($location.absUrl());

			if (!title) {
				title = defaultPageTitle;
			}

			if (!description) {
				description = defaultPageDescription;
			}

			if(!seoImage){
				seoImage = defaultImage;
			} else if(seoImage.indexOf('https://') === -1 && seoImage.indexOf('http://') === -1) {
				seoImage = host + seoImage;
			}

			this.createSetTitle(title);
			this.createSetFavicon();
			this.createSetCanonical();

			this.createSetMetaTag('name', 'image', seoImage);
			this.createSetMetaTag('name', 'description', description);
			this.createSetMetaTag('name', 'keywords', keywords);
			this.createSetMetaTag('name', 'url', canonical);

			this.createSetMetaTag('itemprop', 'name', title);
			this.createSetMetaTag('itemprop', 'description', description);
			this.createSetMetaTag('itemprop', 'image', seoImage);
			this.createSetMetaTag('itemprop', 'url', canonical);
			this.createSetMetaTag('itemprop', 'keywords', keywords);

			this.createSetMetaTag('property', 'og:site_name', title);
			this.createSetMetaTag('property', 'og:title', title);
			this.createSetMetaTag('property', 'og:description', description);
			this.createSetMetaTag('property', 'og:image', seoImage);
			this.createSetMetaTag('property', 'og:url', canonical);
			this.createSetMetaTag('property', 'og:type', 'website');

			this.createSetMetaTag('name', 'twitter:title', title);
			this.createSetMetaTag('name', 'twitter:description', description);
			this.createSetMetaTag('name', 'twitter:image', seoImage);
			this.createSetMetaTag('name', 'twitter:url', canonical);
			this.createSetMetaTag('name', 'twitter:card', 'summary');
		},
		createSetFavicon() {
			var element = $('link [rel="icon"]');
			if (element.length === 0) {
				var host = $location.protocol() +'://'+location.host;
				$('head')
					.append('<link rel="icon" type="image/png" href="'+ host +'/images/client-assets/'+ ENV.folderLocation + '/favicon.png">');
			}
		},
		createSetTitle(title) {
			var element = $('title');
			if (element.length === 0) {
				$('head').append('<title>'+ title +'</title>');
			} else {
				$(document).prop('title', title);
			}
		},
		createSetCanonical() {
			var element = $('head').find('link');
			var canonicalExists = false;

			element.each(function (link) {
				if (element[link].rel === 'canonical') {
					element[link].href = $location.absUrl();
				}
			});

			if (!canonicalExists) {
				$('head')
					.append('<link rel="canonical" href="'+ $location.absUrl() +'">');
			}
		},
		createSetMetaTag(prop, propValue, contentValue) {
			var element = $('meta['+ prop +'="'+ propValue +'"]');
			if (element.length === 0) {
				$('head').append('<meta '+ prop +'="'+ propValue +'" content="' + contentValue + '">');
			} else {
				element.attr('content', contentValue);
			}
		},
		formatDate(date, delimiter) {
			delimiter = delimiter || '-';
			return (date.getMonth() + 1) + delimiter + date.getDate() + delimiter + date.getFullYear();
		},
        getSelectedLocation(getDefault) {
            return $q(function(resolve, reject) {
                if ($rootScope.location) {
                    return resolve($rootScope.location.selectedLocation);
                } else if (!ENV.enableLocations || getDefault) {
                    return $http.get(ENV.apiEndPoint + '/location')
                        .then(function(res) {
                            if (res.status === 200) {
                                return resolve(res.data);
                            }
                            void 0;
                            reject(new Error('There was an error retrieving locations.'));
                        });
                }
                reject(new Error('Location is not loaded'));
            });
        },
        isSelectedLocationValid(selectedLocation) {
            return $q(function(resolve, reject) {
                $http.get(ENV.apiEndPoint + '/locations')
                    .then(function(res) {
                        var selectedLocation = (localStorageService.get('location') || {}).selectedLocation;
                        if (!selectedLocation) {
                            return resolve(false);
                        }
                        var isValid = false
                        if (res.status === 200) {
                            var location;
                            for (var i = 0; i < res.data.length; i++) {
                                location = res.data[i];
                                if (!location.isDisabled && location.uniqueName === selectedLocation.uniqueName) {
                                    isValid = true;
                                    localStorageService.set('location', {
                                        allLocations: res.data,
                                        selectedLocation: location,
                                    });
                                    break;
                                }
                            }

                            return resolve(isValid);
                        }
                        void 0;
                        reject(new Error('There was an error retrieving locations.'));
                    }
                );
            });
        },
        createUrlQueryParams(obj) {
            // 0 is a valid query param value, so not included in this fn.
            var isTruthy = function(val) {
                return val || val === 0;
            };
            var queryStr = Object.keys((obj)).reduce(function(acc, key) {
                var val = obj[key];
                
                if (Array.isArray(val) && val.length) {
                    val = val.map(function(v) {
						return key + '[]=' + encodeURIComponent(v);
                    });
                    acc += acc ? '&' : '?';
                    acc += val.join('&');
                } else if (!Array.isArray(val) && isTruthy(val)) {
                    acc += acc ? '&' : '?';
                    acc += key + '=' + encodeURIComponent(val);
                }
                return acc;
            }, '');
            
            return queryStr;
        },
        getLocationTimezone() {
			// bug - this function needs to be promisified if we are going to use a promise within. 
			// need to investigate viable solutions
            if ($rootScope.location && $rootScope.location.selectedLocation) {
                return $rootScope.location.selectedLocation.timezone;
            } else {
                $rootScope.globalFunctions.getSelectedLocation().then(function (location) {
                    return location.timezone;
                });
            }
        },
        getFormattedTime(time) {
            var hours24 = parseInt(time.substring(0,2));
            var hours = ((hours24 + 11) % 12) + 1;
            var amPm = hours24 > 11 ? 'pm' : 'am';
            var minutes = time.substring(3);
        
            return hours + ':' + minutes + amPm;
        },
		getFormattedTimeFromTimestamp(timestamp) {
			if (!timestamp) return '';
			var timezone = $rootScope.globalFunctions.getLocationTimezone();
			var secondsTimestamp = timestamp/1000;
			var dayjsObj = dayjs.unix(secondsTimestamp).tz(timezone);
			return dayjsObj.format('MMM D, YYYY h:mm A');
		},
        changeTimeString: function (str) {
            if (str === 'Noon') {
                str = '12:00PM';
            } else if (str === 'Midnight') {
                str = '12:00AM';
            }
            if (!str.includes(':')) {
                str = str.replace(/(\d+)\s*(\D+)/, '$1:00$2');
            }
            return str;
        },
        isDarkMode(component) {
            if (component === 'header') {
                return ENV.enableDarkMode || ENV.enableDarkModeHeader;
            } else if (component === 'footer') {
                return ENV.enableDarkMode || ENV.enableDarkModeFooter;
            } else if (component === 'signup' || component === 'login') {
                return ENV.enableDarkMode || ENV.enableDarkModeSignup;
            }
            
            return ENV.enableDarkMode;
        },
        doesClientPagesHaveFooterLinks() {
            return Object.values(ENV.clientPages).some(function(obj) {
                return obj.linkLocation === 'footer';
            });
        },
        getClientPagesHaveExternalFooterLinks() {
            return ENV.clientPages.filter(function(obj) {
                return obj.linkLocation === 'footer' && obj.external === true;
            });
        },
		removeSelectedPriceListFromStorage() {
			if (ENV.enablePriceList && !$location.search().loc && !$location.search().plist) {
				localStorageService.remove('selectedPriceList');
			}
		},
        disablePriceListSelector() {
            if (ENV.enablePriceList && $rootScope.hasOwnProperty('showPriceListSelector')) {
				$rootScope.showPriceListSelector = false;
			}
        },
		getAllLocationsFromStorage() {
			var location = localStorageService.get('location');
			return (location && location.hasOwnProperty('allLocations')) ? location.allLocations : null;
		},
		getSelectedLocationFromStorage() {
			if ($rootScope.location && $rootScope.location.selectedLocation) {
				return $rootScope.location.selectedLocation;
			} else {
				var location = localStorageService.get('location');
				return location && location.selectedLocation || null;
			}
		},
		getDefaultPriceListFromLocation(location) {
			if (location && location.priceLists && Array.isArray(location.priceLists)) {
				var numberOfPriceLists = location.priceLists.length;
				for (var i = 0; i < numberOfPriceLists; i++) {
					if (location.priceLists[i].default) {
						return location.priceLists[i];
					}
				}
			}
			return null;
		},
		getLocationNameFromUniqueName(uniqueName, allLocations) {
			return allLocations.filter(function(location) {
				return location.uniqueName === uniqueName;
			})[0].name;
		},
		getUserAdminLocations() {
			if (!$rootScope.currentUser || !$rootScope.currentUser.adminLocations
				|| !$rootScope.location || !$rootScope.location.allLocations)
			{
				return null;
			}
			return $rootScope.currentUser.adminLocations;
		},
		getUserAdminLocationsFromStorage() {
			var user = localStorageService.get('user');
			if (user && Array.isArray(user.adminLocations)) {
				return user.adminLocations;
			}
			return null;
		},
		getAdminSelectedPriceListFromStorage() {
			return localStorageService.get('adminSelectedPriceList');
		},
		getSelectedPriceListFromStorage() {
			return localStorageService.get('selectedPriceList');
		},
		getUserAdminPriceLists() {
			if (!$rootScope.currentUser || !$rootScope.currentUser.adminPriceLists
				|| !Array.isArray($rootScope.currentUser.adminPriceLists))
			{
				return null;
			}
			return $rootScope.currentUser.adminPriceLists;
		},
		getUserAdminPriceListsFromStorage() {
			var user = localStorageService.get('user');
			if (user && Array.isArray(user.adminPriceLists)) {
				return user.adminPriceLists;
			}
			return null;
		},
		getAuthorizedPriceLists(adminPriceLists, tenantPriceLists, needAllButton) {
			void 0;

			var allPriceListsOption = {
				"name": "AllPriceLists",
				"title": "All",
				"description": "Order Details From All Available Price Lists",
				"uniqueName": "",
			}

			if (adminPriceLists.length === 0) {
				if (tenantPriceLists.length > 1 && needAllButton) {
					tenantPriceLists.unshift(allPriceListsOption);
				}
				return tenantPriceLists;
			}
			
			var retVal = [];
			
			for (var tenantPriceList of tenantPriceLists) {
				if (adminPriceLists.includes(tenantPriceList.uniqueName)) {
					retVal.push(tenantPriceList);
				}
			}

			if (retVal.length === 0) {
				if (tenantPriceLists.length > 1 && needAllButton) {
					tenantPriceLists.unshift(allPriceListsOption);
				}
				return tenantPriceLists;
			}

			if (tenantPriceLists.length === retVal.length && needAllButton && retVal.length > 1) {
				retVal.unshift(allPriceListsOption);
			}

			return retVal;
		},
		getPriceListDetails() {
			return {
				"filterByPriceList": false,
				"priceList": '',
			};
		},
		getCountry: function() {
			var country = $rootScope.country;
			return country;
		},
		countryToCurrencyMap: {
			CA: 'cad',
			US: 'usd',
		},
		getEnabledFilters: function(filters) {
			var enabledFilters = {};
			Object.entries(filters).forEach(function(filter) {
				var key = filter[0];
				var value = filter[1];
				if (value.enabled) {
					enabledFilters[key] = value;
				}
			});
			return enabledFilters;
		},
		copyProductUrlToClipboard: function(product, isAdmin) {

			var storeUrl = location.origin;
			var productName = product.name;

			if (!storeUrl || !productName) {
				toastr.error("Failed To Copy");
				return;
			}

			var url = new URL(storeUrl + '/product/' + productName);
			
			if (ENV.enablePriceList && ENV.enableLocations) {
				var priceList = isAdmin ? localStorageService.get('adminSelectedPriceList') : localStorageService.get('selectedPriceList');
				if (!priceList) {
					toastr.error("Failed To Copy");
					return;
				}
				url.searchParams.append('pListName', priceList.name);
			}
			
			copyTextToClipboard(url.toString());
			
		},
        isErewhon: function() {
            return ENV.name.companyName === 'Erewhon';
        },
		isSummerhill: function() {
            return ENV.name.companyName === 'Summerhill Market';
        },
		isMollieStone: function() {
			return ENV.name.companyName === 'Mollie Stone\'s';
		},
		isErewhonStyle: function(){
			return this.isErewhon() || this.isSummerhill();
		},
		hasTBDFulfillmentFees: function(uniqueName) {
			const targetPriceLists = [
				'A83A8286-1A13-4648-913A-05D8B0F80B78',		// prod pierre-part pierre-part shipping
			];
			return targetPriceLists.includes(uniqueName);
		}
	}
}]);

hsFac.factory("guid", function(){function r(r){return Math.random()*r}return{v4:function(){var n,a="";for(n=0;36>n;n++)a+=14===n?"4":19===n?"89ab".charAt(r(4)):8===n||13===n||18===n||23===n?"-":"0123456789abcdef".charAt(r(16));return a}}});

hsFac.directive('onlyDigits', function () {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if (val) {
					var digits = val.replace(/[^0-9.]/g, '');
					
					if (digits.split('.').length > 2) {
						digits = digits.substring(0, digits.length - 1);
					}
					
					if (digits !== val) {
						ctrl.$setViewValue(digits);
						ctrl.$render();
					}
					return parseFloat(digits);
				}
				return undefined;
			}
			ctrl.$parsers.push(inputValue);
		}
	};
});

hsFac.directive('onlyDigitsTwoDecimal', function () {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if (val) {
					var digits = val.replace(/[^0-9.]/g, '')
						.replace(/(?=^\.)/,'0')
						.replace(/^0+([0-9]+)/,'$1')
						.replace(/(^\d+\.\d*)(?:\..*)/, '$1')
						.replace(/(^\d+\.\d{2})(?:.*)/, '$1');
					if (digits !== val) {
						ctrl.$setViewValue(digits);
						ctrl.$render();
					}
					return parseFloat(digits);
				}
				return undefined;
			}
			ctrl.$parsers.push(inputValue);
		}
	};
});

hsFac.directive('onlyIntegers', function () {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if (val) {
					var digits = val.replace(/[^0-9]/g, '').replace(/^0+([0-9]+)/,'$1');
					if (digits !== val) {
						ctrl.$setViewValue(digits);
						ctrl.$render();
					}
					return parseInt(digits);
				}
				return undefined;
			}
			ctrl.$parsers.push(inputValue);
		}
	};
});

hsFac.directive('upcInput', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attr, ctrl) {
            function inputValue(val) {
                if (val) {
                    var digits = val.replace(/[^a-zA-Z0-9]/g, '');
                    if (digits !== val) {
                        ctrl.$setViewValue(digits);
                        ctrl.$render();
                    }
                    return digits;
                }
                return undefined;
            }
            ctrl.$parsers.push(inputValue);
        }
    };
});

hsFac.directive('onlyDigitsThreeDecimal', function () {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if (val) {
					var digits = val.replace(/[^0-9.]/g, '')
						.replace(/(?=^\.)/,'0')
						.replace(/^0+([0-9]+)/,'$1')
						.replace(/(^\d+\.\d*)(?:\..*)/, '$1')
						.replace(/(^\d+\.\d{3})(?:.*)/, '$1');
					if (digits !== val) {
						ctrl.$setViewValue(digits);
						ctrl.$render();
					}
					return parseFloat(digits);
				}
				return undefined;
			}
			ctrl.$parsers.push(inputValue);
		}
	};
});

hsFac.directive('fiveDigitsOnly', function () {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if (val) {
					var digits = val.replace(/[^\d]/g, '').replace(/(^\d{5})(?:.*)/, '$1');
					if (digits !== val) {
						ctrl.$setViewValue(digits);
						ctrl.$render();
					}
					return digits;
				}
			}
			ctrl.$parsers.push(inputValue);
		}
	};
});

hsFac.directive('zipCodeValidation', ["$rootScope", function ($rootScope) {
	return {
		require: 'ngModel',
		restrict: 'A',
		link: function (scope, element, attr, ctrl) {
			function inputValue(val) {
				if(!val) return;
				
				var zipcode;
				var country = $rootScope.country;
				switch(country) {
					case 'CA':
						zipcode = val.replace(/[^a-ceghj-npr-tv-z0-9]/gi, '').replace(/(^.{6})(?:.*)/, '$1').toUpperCase();
						if (zipcode.length > 3) {
							zipcode = zipcode.substring(0, 3) + ' ' + zipcode.substring(3);
						}
						break;
					default: 
						zipcode = val.replace(/[^\d]/g, '').replace(/(^\d{5})(?:.*)/, '$1');
						break;	
				}

				if (zipcode !== val) {
					ctrl.$setViewValue(zipcode);
					ctrl.$render();
				}
				return zipcode;
			}
			ctrl.$parsers.push(inputValue);
		}
	};
}]);

hsFac.directive('imageonload', function() {
	return {
		restrict: 'A',
		link: function(scope, element, attrs) {
			element.bind('load', function() {
				scope.$apply(attrs.imageonload);
			});
		}
	};
});

hsFac.directive('errSrc', function () {
	return {
		link: function (scope, element, attrs) {
			element.bind('error', function () {
				if (attrs.src != attrs.errSrc) {
					attrs.$set('src', attrs.errSrc);
				}
			});
		}
	};
});

// Added this directive to enable a custom action to be taken
// 		when an image src fails to load.
hsFac.directive('onImgErr', function() {
	return {
		restrict: 'A',
		scope: {
			data: '=',
			action: '='
		},
		link: function(scope, element) {
			function onError() {
				scope.action(scope.data);
				element[0].removeEventListener('error', onError);
			}
			element[0].addEventListener('error', onError);
		}
	};
});

hsFac.directive('noDirtyCheck', function() {
	return {
		restrict: 'A',
		require: 'ngModel',
		link: postLink
	};
	function postLink(scope, elem, attrs, ctrl) {
		ctrl.$setDirty = angular.noop;
	}
});

hsFac.directive('backButton', function() {
	return {
		restrict: 'A',
		link: function(scope, element, attrs) {
			element.on('click', function() {
				history.back();
				scope.$apply();
			});
		}
	};
});

hsFac.directive("selectNgFiles", function() {
	return {
	  	require: "ngModel",
	  	link: function postLink(scope, elem, attrs, ngModel) {
			elem.on("change", function(e) {
				try {
					var files = elem[0].files;
		  			ngModel.$setViewValue(files);
				} catch (err) {
					void 0;
				}
		})
	  }
	}
  });
angular.module('homesome.factories').factory('hsAdminOrder', [ '$http', '$q', 'hsApi', 'hsUtils', 'hsCart', 'globalFunctions', 'hsAdmin', 'ngDialog', adminOrderForUserService ]);

function adminOrderForUserService($http, $q, hsApi, hsUtils, hsCart, globalFunctions, hsAdmin, ngDialog) {
    var service = {
        SELECTED_FILTERS: {
            priceList: null,
            user: null,
            paymentMethod: null,
            fulfillmentMethod: null,
            address: null,
            deliveryInstructions: null,
            location: null,
            fulfillmentDate: null,
            fulfillmentTime: null,
            isHouseChargeOrder: false,
        },
        steps: {
            PRICELIST: 'priceList',
            FULFILLMENT_METHOD: 'fulfillmentMethod',
            ADDRESS: 'address',
            DELIVERY_INSTRUCTIONS: 'deliveryInstructions',
            LOCATION: 'location',
            USER: 'user',
            PAYMENT_METHOD: 'paymentMethod',
            FULFILLMENT_DATE_TIME: 'fulfillmentDateTime',
            FULFILLMENT_DATE: 'fulfillmentDate',
            FULFILLMENT_TIME: 'fulfillmentTime',
            HOUSE_CHARGE: 'isHouseChargeOrder',
        },
        fulfillmentMethods: {
            PICKUP: 'pickup',
            DELIVERY: 'delivery',
        },
        paymentProcessors: {
            STRIPE: 'stripe',
            WORLD_PAY: 'worldpay',
            FISERV: 'fiserv',
        },
        fulfillmentMethodDisplayText: {
            'pickup': 'Pickup',
            'delivery': 'Delivery',
        },
        quoteStateDisplayText: {
            'pending': 'Pending',
            'canceled': 'Canceled',
            'expired': 'Expired',
            'completed': 'Completed',
            'invalid': 'Invalid'
        },
        quoteStateTagStyleMap: {
            'pending': 'hs-tag-default',
            'canceled': 'hs-tag-error',
            'expired': 'hs-tag-error-2',
            'completed': 'hs-tag-success',
            'invalid': 'hs-tag-error'
        },
        quoteStates: {
            PENDING: 'pending',
            CANCELED: 'canceled',
            EXPIRED: 'expired',
            COMPLETED: 'completed',
            INVALID: 'invalid',
        },
        errorMessages: {
            STRIPE_ERROR_MESSAGE: 'Sorry, the payment card associated with your account was declined. To proceed with the order, please make sure the billing address and CVC are correct and the card has enough funds, or ask the issuing bank to authorize this transaction or enter a new payment card.'
        },
        options: null,
        availableOptions: null,
        fulfillments: null,
        users: null,
        userSearchQueryResult: null,
        tenantLevelPaymentProcessor: null,
        setInitData: function(data) {
            if (!hsUtils.isObject(data)) {
                throw "Invalid response";
            }
    
            if (!hsUtils.isObject(data.options) || !Array.isArray(data.fulfillments)) {
                throw "Missing required information";
            }
    
            service.options = Object.assign({}, data.options);
            if (!hsUtils.isObject(service.availableOptions)) {
                service.availableOptions = Object.assign({}, data.options);
            }
            service.fulfillments = data.fulfillments;
            service.setTenantLevelPaymentProcessor();
        },
        setTenantLevelPaymentProcessor: function() {
            var paymentProcessorsSet = new Set();
            for (var fulfillment of service.fulfillments) {
                paymentProcessorsSet.add(fulfillment.location.paymentProcessor);
            }

            if (paymentProcessorsSet.size === 1) {
                service.tenantLevelPaymentProcessor = Array.from(paymentProcessorsSet)[0];
            }
        },
        getTenantAvailability: function(address, isQuote) {

            var url = new URL('/tenant/availability', ENV.apiEndPoint);
            url.searchParams.append('authorizedOnly', true);

            if (hsUtils.isObject(address)) {
                url.searchParams.append('street', address.street);
                url.searchParams.append('aptUnit', address.aptUnit);
                url.searchParams.append('city', address.city);
                url.searchParams.append('state', address.state);
                url.searchParams.append('zip', address.zip);
            }
            if (isQuote) {
                url.searchParams.append('isQuote', true);
            }

            return $http.get(url.toString())
                .then(function(response){
                    service.setInitData(response.data);
                    return response;
                })
                .catch(function(error){
                    throw error;
                });
        },
        getSelectedUser() {
            return service.SELECTED_FILTERS.user;
        },
        getSelectedLocation() {
            return service.SELECTED_FILTERS.location || null;
        },
        getSelectedPriceList() {
            var location = service.getSelectedLocation();
            var priceListTitle = service.SELECTED_FILTERS.priceList;

            if (!location || !priceListTitle) return null;

            for (var fulfillment of service.fulfillments) {
                if (fulfillment.location.uniqueName === location.uniqueName && fulfillment.priceList.title === priceListTitle) {
                    return fulfillment.priceList;
                }
            }
            return null;
        },
        getSelectedAddress() {
            return service.SELECTED_FILTERS.address || null;
        },
        isFiltersSelectionComplete(isQuote) {
            return !!(
                service.SELECTED_FILTERS.user
                && service.SELECTED_FILTERS.location
                && service.SELECTED_FILTERS.priceList
                && service.SELECTED_FILTERS.fulfillmentMethod
                && service.SELECTED_FILTERS.fulfillmentDate
                && service.SELECTED_FILTERS.fulfillmentTime
                && (service.SELECTED_FILTERS.fulfillmentMethod !== service.fulfillmentMethods.DELIVERY || service.SELECTED_FILTERS.address)
                && !service.hasUnavailableOptions()
            );
        },
        hasUnavailableOptions() {
            return Object.values(service.availableOptions).some(function (option) {
                return !Array.isArray(option) || !option.length;
            });
        },
        canMakeApiCall() {
            return service.SELECTED_FILTERS.user && service.SELECTED_FILTERS.location && service.SELECTED_FILTERS.priceList;
        },
        getHeaders(skipUser) {
            var headers = {
                location: service.getSelectedLocation().uniqueName,
                pricelist: service.getSelectedPriceList().uniqueName,
            };
            if (!skipUser) {
                headers.targetuseremail = service.getSelectedUser().email;
            }
            return headers;
        },
        getUserCart(discountCode, address, adminDiscount) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var apiUrl = new URL(ENV.apiEndPoint + '/user/basket');

            if (adminDiscount) {
                apiUrl.searchParams.append('adminDiscount', JSON.stringify(adminDiscount));
            }
            if (discountCode) {
                apiUrl.searchParams.append('coupon', discountCode);
            }
            if (hsUtils.isObject(address)) {
                apiUrl.searchParams.append('street', address.street);
                apiUrl.searchParams.append('aptUnit', address.aptUnit);
                apiUrl.searchParams.append('city', address.city);
                apiUrl.searchParams.append('state', address.state);
                apiUrl.searchParams.append('zip', address.zip);
            }
            var headers = service.getHeaders();

            return $http.get(apiUrl.toString(), { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    service.sortCartItems(response.data.basketItems);
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to get user\'s cart.');
                });
        },
        sortCartItems(items) {
            // This ensures that items do not change position in the list from one call to another.
            if (!Array.isArray(items) || !items.length) return;

            items.forEach(function (item) {
                var modifiers = (item.selectedModifiers || []).map(function (mod) { return mod.name; }).join('');
                item._name = item.name + modifiers;
            });
            items.sort(function (a, b) {
                if (a._name > b._name) return 1;
                if (a._name < b._name) return -1;
                return 0;
            })
            items.forEach(function (item) { delete item._name; });
        },
        updateItemInCart(item) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var headers = service.getHeaders();
            var basketItem;

            if (item.isCustomItem) {
                basketItem = {
                    quantity: item.quantity,
                    isCustomItem: item.isCustomItem,
                    canReplace: item.canReplace || false,
                    instructions: item.instructions || '',
                    displayName: item.displayName,
                    organic: item.organic,
                    unit: item.unit,
                    upc: item.upc,
                    price: item.price,
                    isTaxable: item.isTaxable,
                    taxRate: item.taxRate,
                };

                if (hsUtils.isNonEmptyString(item.name)) {
                    basketItem.name = item.name;
                }
            } else {
                basketItem = {
                    name: item.name,
                    quantity: item.quantity,
                    isCustomItem: item.isCustomItem,
                    canReplace: item.canReplace === undefined ? globalFunctions.canReplace(item) : item.canReplace,
                    instructions: item.instructions || '',
                    displayName: item.displayName,
                    type: item.type,
                    subType: item.subType,
                    organic: item.organic,
                    unit: item.unit,
                    selectedModifiers: item.selectedModifiers ? item.selectedModifiers.map(function(modifier) { return modifier.name; }) : [],
                };
            }

            var data = {
                items: [
                    basketItem
                ],
            };
            return hsCart.addItemToCart(data, headers)
                .then(function (response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                })
                .catch(function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to update item.');
                });
        },
        updateItemsInCart(items) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var headers = service.getHeaders();
            var data = {
                items: items.map(function (item) {
                    var params = service.getItemParams(item);
                    params.selectedModifiers = item.selectedModifiers ? item.selectedModifiers.map(function(modifier) { return modifier.name; }) : [];
                    return params;
                }),
            };
            return hsCart.addItemToCart(data, headers)
                .then(function (response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                })
                .catch(function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to update item.');
                });
        },
        removeItemFromCart(item) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var data = {
                itemName: item.name,
                selectedModifiers: item.selectedModifiers,
            };
            var headers = service.getHeaders();

            return hsCart.removeItemFromCart(data, headers)
                .then(function (response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                })
                .catch(function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to remove item.');
                });
        },
        updateCartOptions(promo, value) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var data = {
                promotionsOptOut: {
                    promotionId: promo.id,
                    optOut: value,
                },
            };
            var headers = service.getHeaders();

            return hsCart.updateCartOptions(data, headers)
                .then(function (response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                })
                .catch(function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to update options.');
                });
        },
        getCustomItemParams: function(item) {
            return {
                name: item.name,
                quantity: item.quantity,
                isCustomItem: item.isCustomItem,
                canReplace: item.canReplace || false,
                instructions: item.instructions,
                displayName: item.displayName,
                organic: item.organic,
                unit: item.unit,
                price: item.price,
                upc: item.upc,
                isTaxable: item.isTaxable,
                taxRate: item.taxRate,   
            };
        },
        getItemParams: function (item) {
            if (item.isCustomItem) {
                return service.getCustomItemParams(item);
            }

            return {
                name: item.name,
                quantity: item.quantity,
                isCustomItem: item.isCustomItem,
                canReplace: item.canReplace,
                instructions: item.instructions,
                displayName: item.displayName,
                type: item.type,
                subType: item.subType,
                organic: item.organic,
                unit: item.unit,
                selectedModifiers: item.selectedModifiers
            };
        },
        getUser: function(email) {
            if (!hsUtils.isNonEmptyString(email)) {
                throw 'Invalid user email';
            }

            var url = new URL('/user', ENV.apiEndPoint);
            url.searchParams.append('targetUserEmailId', email);

            return $http.get(url.toString())
                .then(function(response) {
                    if (response.status === 200) {
                        return response.data;
                    } else {
                        if (response.status === 404) {
                            throw 'User not found';
                        } else {
                            throw 'Something went wrong. Please try again or contact suppoprt';
                        }
                    }
                });
        },
        getUsers: function() {
            
            var url = new URL('/users', ENV.apiEndPoint);
            url.searchParams.append('lite', 'true');

            return $http.get(url.toString())
                .then(function(response) {
                    service.users = response.data.users;
                    return response;
                })
                .catch(function(err) {
                    throw err;
                })
        },
        filterUsers: function(searchParam) {
            service.userSearchQueryResult = null;

            if (!hsUtils.isNonEmptyString(searchParam)) {
                throw 'Please provide a valid email or phone number';
            }

            var queriedUsers = null;

            searchParam = searchParam.toLowerCase().trim();
            if (hsUtils.isEmail(searchParam)) {
                queriedUsers = service.users.filter(function(user) {
                    return user.email === searchParam;
                });
            } else if (hsUtils.isPhoneNumber(searchParam)) {
                queriedUsers = service.users.filter(function(user) {
                    return hsUtils.formatPhoneNumber(user.phoneNumber) === hsUtils.formatPhoneNumber(searchParam);
                });
            } else {
                throw 'Please provide a valid email or phone number'
            }

            if (!Array.isArray(queriedUsers) || !queriedUsers.length) {
                throw 'No users found'
            }
            
            service.userSearchQueryResult = queriedUsers;
        },
        signup: function(body) {
			return $http.post(ENV.apiEndPoint + '/user', body, { headers: { targetuseremail: body.newUser.emailId }})
                .then(function(response) {
                    if (response.status === 200) {
                        return response;
                    } else {
                        if (response.status === 409) {
                            throw 'User with same email or phone number already exists';
                        } else {
                            throw 'Something went wrong. Please try again or contact support';
                        }
                    }
                })
                .catch(function(err) {
                    throw err;
                });
		},
        placeOrder: function (params, isQuote) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var url = ENV.apiEndPoint + (!isQuote ? '/user/order' : '/quotes')
            var headers = service.getHeaders();
            params = params || {};
            params.instructions = service.SELECTED_FILTERS.deliveryInstructions || '';
            params.fulfillmentMethod = service.SELECTED_FILTERS.fulfillmentMethod;
            params.date = service.getFulfillmentDateString(service.SELECTED_FILTERS.fulfillmentDate);
            params.time = service.getFulfillmentTimeString(service.SELECTED_FILTERS.fulfillmentTime);

            if (service.SELECTED_FILTERS.fulfillmentMethod === 'delivery') {
                params.address = service.SELECTED_FILTERS.address;
            }
            if (!isQuote && service.getSelectedPriceList().chargeUser) {
                if (service.SELECTED_FILTERS.isHouseChargeOrder === true) {
                    params.houseCharge = service.SELECTED_FILTERS.isHouseChargeOrder;
                } else if (service.SELECTED_FILTERS.paymentMethod && service.SELECTED_FILTERS.paymentMethod.pmid) {
                    params.paymentMethods = {
                        card: {
                            pmid: service.SELECTED_FILTERS.paymentMethod.pmid,
                        },
                    };
                }
            }
            void 0;
            var data = !isQuote ? { delivery: params } : { quote: params };
            return $http.post(url, data, { headers: headers })
                .then(function (response) {
                    if (response.status === 402) {
                        throw service.errorMessages.STRIPE_ERROR_MESSAGE;
                    } else if (response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to place ' + (!isQuote ? 'order' : 'quote') + '.');
                });
        },
        getDeletePopup: function () {
            return ngDialog.openConfirm({
                data: {
                    heading: 'Are You Sure?',
                    subHeading: 'Please confirm that you want to delete this user\'s payment method.',
                    confirmBtnText: 'Confirm',
                    cancelBtnText: 'Cancel'
                },
                template: 'partials/popup/confirm-popup.html',
            });
        },
        getUserAddress: function () {
            if (hsUtils.isObject(service.SELECTED_FILTERS.user) && hsUtils.isObject(service.SELECTED_FILTERS.user.address)) {
                return service.SELECTED_FILTERS.user.address;
            }

            return null;
        },
        clearFilters: function (isQuote) {
            for (var filterName of Object.keys(service.SELECTED_FILTERS)) {
                service.SELECTED_FILTERS[filterName] = null;
            }
            service.availableOptions = null;
            service.userSearchQueryResult = null;
            return service.getTenantAvailability(null, isQuote);
        },
        processUserAddress: function(selected, value) {
            if (hsUtils.isObject(value)) {
                if(hsUtils.isObject(value.address) && selected[service.steps.FULFILLMENT_METHOD] === service.fulfillmentMethods.DELIVERY) {
                    selected[service.steps.ADDRESS] = value.address;
                } else {
                    selected[service.steps.ADDRESS] = null;
                }
            }
        },
        setDefaultUserPaymentMethod: function(selected, value) {
            var paymentMethods = service.getApplicableUserPaymentMethods(value);
            selected[service.steps.PAYMENT_METHOD] = paymentMethods.length ? paymentMethods[0] : null;
        },
        setPaymentMethods: function (value, type) {
            var paymentMethods = service.getApplicableUserPaymentMethods(value);
            service.SELECTED_FILTERS.user.paymentMethods = paymentMethods.reverse();
            
            if(type === 'add' || service.shouldUpdatePayment(value)) {
                service.setDefaultUserPaymentMethod(service.SELECTED_FILTERS, value);
            }
        },
        setHouseCharge: function (value) {
            service.SELECTED_FILTERS.isHouseChargeOrder = value;
        },
        setFilterPaymentMethod: function (value) {
            service.SELECTED_FILTERS[service.steps.PAYMENT_METHOD] = value || null;
        },
        shouldUpdatePayment: function (userData) {
            var paymentMethods = service.getApplicableUserPaymentMethods(userData);
            if(!service.SELECTED_FILTERS.paymentMethod) {
                return true;
            }
            var payentMethod = paymentMethods.find(function (item) {
                return item.pmid === service.SELECTED_FILTERS.paymentMethod.pmid;
            });
    
            return !payentMethod;
        },
        processUserDeliveryInstructions: function(selected, value) {
            if (hsUtils.isObject(value)
                && hsUtils.isNonEmptyString(value.deliveryInstructions)
                && selected[service.steps.FULFILLMENT_METHOD] === service.fulfillmentMethods.DELIVERY
            ) {
                selected[service.steps.DELIVERY_INSTRUCTIONS] = value.deliveryInstructions;
            } else {
                selected[service.steps.DELIVERY_INSTRUCTIONS] = null;
            }
        },
        processFilters: function(option, value, isQuote) {
            var selected = service.SELECTED_FILTERS;
            selected[option] = value;
            if (option === service.steps.USER) {
                service.processUserAddress(selected, value);
                service.setDefaultUserPaymentMethod(selected, value);
                service.processUserDeliveryInstructions(selected, value);
            }
            if (service.shouldResetDateTime(option, isQuote)) {
                selected[service.steps.FULFILLMENT_DATE] = null;
                selected[service.steps.FULFILLMENT_TIME] = null;
            }
            var filtered = service.applyFilters(selected);
            service.setAvailableOptions(service.SELECTED_FILTERS);
            if (!filtered.length) {
                // This condition is added to clear address option in the event that the address is undeliverable
                // When option === 'user', the only way filtered.length === 0 is if address is undeliversable
                if (option === service.steps.USER && hsUtils.isObject(service.SELECTED_FILTERS.address)) {
                    service.SELECTED_FILTERS.address = null;
                    filtered = service.applyFilters(selected);
                    service.setAvailableOptions(service.SELECTED_FILTERS);
                }
                return $q.reject('have nothing left');
            }

            if (value) {
                return $q.resolve( { switchStep: true } );
            } else {
                return $q.resolve( { switchStep: false } );
            }
            
        },
        shouldResetDateTime: function(option, isQuote) {
            return isQuote && [ service.steps.LOCATION, service.steps.PRICELIST, service.steps.FULFILLMENT_METHOD ].includes(option);
        },
        setFilter: function(option, value, isQuote) {
            if (option === service.steps.USER) {
                if (hsUtils.isObject(value)) {
                    if (hsUtils.isObject(value.address)) {
                        return service.getTenantAvailability(value.address, isQuote)
                            .then(function(response) {
                                return service.processFilters(option, value, isQuote);
                            })
                            .catch(function(err) {
                                void 0;
                                throw err;
                            });
                    } else {
                        return service.processFilters(option, value, isQuote);
                    }
                }
                value = null;
            } else {
                // Don't allow to deselect paymentMethod. No reason to do so
                // and it complicates logic.
                if (value === service.SELECTED_FILTERS[option] && option !== service.steps.PAYMENT_METHOD && option !== service.steps.HOUSE_CHARGE) {
                    value = null;
                }
            }
            return service.processFilters(option, value, isQuote);
        },
        applyFilters(selectedFilters) {
            var filtered = service.fulfillments;

            for (var filterName of Object.keys(selectedFilters)) {
                var value = selectedFilters[filterName];
                if (value) {
                    filtered = service.filterFulfillments(filtered, filterName, value, selectedFilters);
                }
            }
            return filtered;
        },
        setAvailableOptions(selectedFilters) {
            var options = {
                priceLists: new Set(),
                fulfillments: new Set(),
                locations: new Set(),
            };

            for (var filterName of Object.keys(selectedFilters)) {
                var allFilters = Object.assign({}, selectedFilters);
                delete allFilters[filterName];

                var filtered = service.applyFilters(allFilters);

                for (var fulfillment of filtered) {
                    if (filterName === service.steps.LOCATION) {
                        options.locations.add(fulfillment.location);
                    }
                    if (filterName === service.steps.PRICELIST) {
                        options.priceLists.add(fulfillment.priceList.title);
                    }
                    if (filterName === service.steps.FULFILLMENT_METHOD) {
                        options.fulfillments.add(fulfillment.name);
                    }
                }

            }
            options.priceLists = Array.from(options.priceLists);
            options.locations = Array.from(options.locations);
            options.fulfillments = Array.from(options.fulfillments);

            service.availableOptions = options;
        },
        filterFulfillments(filtered, filterName, value, selectedFilters) {

            if (filterName === service.steps.PRICELIST) {
                return filtered.filter(function (val) {
                    return val.priceList.title === value;
                })
            }
            if (filterName === service.steps.LOCATION) {
                return filtered.filter(function (val) {
                    return val.location.name === value.name;
                })
            }
            if (filterName === service.steps.FULFILLMENT_METHOD) {
                return filtered.filter(function (val) {
                    return val.name === value;
                })
            }
            if (filterName === service.steps.ADDRESS && hsUtils.isObject(value)
                && selectedFilters.fulfillmentMethod === service.fulfillmentMethods.DELIVERY
            ) {
                return filtered.filter(function (val) {
                    return val.canDeliver === true;
                })
            }
            return filtered;
        },
        addPaymentMethod: function(paymentMethod) {
            var user = service.getSelectedUser();

            var headers = {
                'targetuseremail': user.email,
            };

            if (!hsUtils.isNonEmptyString(service.tenantLevelPaymentProcessor)) {
                headers.location = service.SELECTED_FILTERS.location.uniqueName;
                headers.pricelist = service.SELECTED_FILTERS.location.defaultPriceList.uniqueName;
            }
            var apiUrl = new URL(ENV.apiEndPoint + '/user/payment');

            return $http.post(apiUrl.toString(), { paymentMethod: paymentMethod }, { headers: headers });
        },
        deletePaymentMethod: function(pmid) {
            var user = service.getSelectedUser();

            var headers = {
                'targetuseremail': user.email,
            };

            if (!hsUtils.isNonEmptyString(service.tenantLevelPaymentProcessor)) {
                headers.location = service.SELECTED_FILTERS.location.uniqueName;
                headers.pricelist = service.SELECTED_FILTERS.location.defaultPriceList.uniqueName;
            }
            var apiUrl = new URL(ENV.apiEndPoint + '/user/payment');
            apiUrl.searchParams.append('pmid', pmid);

            return $http.delete(apiUrl.toString(), { headers: headers });
        },
        updateUser: function(userData) {
            var user = service.getSelectedUser();

            var headers = {
                'targetuseremail': user.email,
            };

            if (!hsUtils.isNonEmptyString(service.tenantLevelPaymentProcessor)) {
                headers.location = service.SELECTED_FILTERS.location.uniqueName;
                headers.pricelist = service.SELECTED_FILTERS.location.defaultPriceList.uniqueName;
            }

            return $http.put(ENV.apiEndPoint + '/user', userData, { headers: headers })
                .then(function(response) {
                    return response;
                })
                .catch(function(err) {
                    return $q.resolve(err);
                });
        },
        getPaymentProcessor: function() {
            if (hsUtils.isNonEmptyString(service.tenantLevelPaymentProcessor)) {
                return service.tenantLevelPaymentProcessor;
            }
            
            if (hsUtils.isObject(service.SELECTED_FILTERS.location) && hsUtils.isNonEmptyString(service.SELECTED_FILTERS.location.paymentProcessor)) {
                return service.SELECTED_FILTERS.location.paymentProcessor;
            }
    
            return null;
        },
        getApplicableUserPaymentMethods: function(userData) {
            var defaultValue = [];
            var paymentProcessor = service.getPaymentProcessor();

            if (!paymentProcessor) return defaultValue;
            if (!hsUtils.isObject(userData)) return defaultValue;
            if (!hsUtils.isNonEmptyArray(userData.paymentMethods)) return defaultValue;

            return userData.paymentMethods.filter(function (pm) {
                return pm.paymentProcessor === paymentProcessor;
            }).reverse();
        },
        getFulfillmentDateString: function (fulfillmentDate) {
            if (!hsUtils.isObject(fulfillmentDate)) return '';
            return hsUtils.getDateString(fulfillmentDate);
        },
        getFulfillmentTimeString: function (fulfillmentTime) {
            if (hsUtils.isNonEmptyString(fulfillmentTime)) {
                return fulfillmentTime;
            }
            if (!hsUtils.isObject(fulfillmentTime)) return '';
            return (
                Number(fulfillmentTime.hour)
                    + ':' + fulfillmentTime.minute + fulfillmentTime.meridian
            );
        },
        getDiscountDisplayText: function(quoteDetails) {
            if (quoteDetails.discount.hasOwnProperty("percent")) {
                return quoteDetails.discount.percent.toFixed(2) + '%';
            }
            return '$' + quoteDetails.discount.value.toFixed(2);        
        },
        getProduct(productName) {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            return hsApi.getProduct(productName, false, service.getHeaders())
                .then(function(product) {
                    return product;
                })
                .catch(function(err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to get additional product data.');
                })
        },
        getUsersPastOrders() {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }
            var headers = service.getHeaders();

            return hsAdmin.getUsersPastOrders(headers)
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to get user\'s past orders.');
                });
        },
        sendQuoteEmail(id) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/send-email');
            return $http.post(apiUrl.toString(), { quote: { id: id } })
                .then(function(response) {
                    if (response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to send quote email.');
                });
        },
        getQuoteDetails(quoteId, isForUser) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/' + quoteId);
            apiUrl.searchParams.append('isForUser', isForUser);
            
            return $http.get(apiUrl.toString())
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to get quote details.');
                });
        },
        updateQuoteDetails(params, headers, quoteId) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/' + quoteId);
            return $http.put(apiUrl.toString(), params, { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to update quote details.');
                });
        },
        updateQuoteItem(params, headers, quoteId) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/' + quoteId + '/item');
            return $http.put(apiUrl.toString(), params, { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to update quote item.');
                });
        },
        removeQuoteItem(item, headers, quoteId) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/' + quoteId + '/item');
            apiUrl.searchParams.append('itemName', item.name);

            if (hsUtils.isNonEmptyArray(item.selectedModifiers)) {
                item.selectedModifiers.forEach(function(modifier) {
                    apiUrl.searchParams.append('selectedModifiers', modifier.name);
                });
            }
            return $http.delete(apiUrl.toString(), { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to delete quote item.');
                });
        },
        addQuoteItem(params, headers, quoteId) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/' + quoteId + '/item');

            return $http.post(apiUrl.toString(), { item: params }, { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to add an item to quote.');
                });
        },
        listQuotes(allQuotes) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes');
            apiUrl.searchParams.append('allQuotes', allQuotes);
            
            return $http.get(apiUrl.toString())
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to get quotes.');
                });
        },
        getBaseUrl(isQuote) {
            return !isQuote ? '/admin/create-order' : '/admin/create-quote';
        },
        canGetAvailableTimes() {
            return service.SELECTED_FILTERS.location && service.SELECTED_FILTERS.priceList;
        },
        getAvailableTimes(headers) {
            var apiUrl = new URL(ENV.apiEndPoint + '/available-times');

            // below section is only applicable to select filters flow
            if (!headers) {
                if (!service.canGetAvailableTimes()) {
                    return $q.reject('Missing required filters selection.');
                }
                headers = service.getHeaders(true);
            }

            return $http.get(apiUrl.toString(), { headers: headers })
                .then(function(res) {
                    if(res.status !== 200) {
                        throw res.data;
                    }
                    return res.data;
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to get available times.');
                });
        },
        getNextSteps(isQuote) {
            var nextSteps = {};

            nextSteps[service.steps.PRICELIST] = service.steps.USER;

          
            nextSteps[service.steps.USER] = service.steps.FULFILLMENT_METHOD;
            nextSteps[service.steps.ADDRESS] = service.steps.DELIVERY_INSTRUCTIONS;
            nextSteps[service.steps.DELIVERY_INSTRUCTIONS] = service.steps.LOCATION;
            nextSteps[service.steps.FULFILLMENT_METHOD] = service.steps.LOCATION;
            nextSteps[service.steps.LOCATION] = service.steps.FULFILLMENT_DATE_TIME;
            nextSteps[service.steps.FULFILLMENT_DATE] = service.steps.FULFILLMENT_DATE_TIME;
            nextSteps[service.steps.FULFILLMENT_TIME] = service.steps.FULFILLMENT_DATE_TIME;

            return nextSteps;
        },
        getProductList() {
            if (!service.canMakeApiCall()) {
                return $q.reject('Missing required filters selection.');
            }

            var headers = service.getHeaders();
            return hsAdmin.getProductList(headers)
                .then(function(productList) {
                    return productList;
                })
                .catch(function(err) {
                    throw err;
                });
            
        },
        placeOrderForQuote: function(data, headers) {
            var apiUrl = new URL(ENV.apiEndPoint + '/quotes/create-order');
            return $http.post(apiUrl.toString(), data, { headers: headers })
                .then(function(res) {
                    if(res.status !== 200) {
                        throw res;
                    }
                    return res.data;
                })
                .catch(function(err) {
                    void 0;
                    throw err;
                });
        },
        isDeletedUserAccount(quoteDetails) {
            return quoteDetails.userObj === null;
        },
        indexAvailableTimesByDay(availableTimes) {
            var index = {
                enableCustomFulfillmentTimes: availableTimes.enableCustomFulfillmentTimes,
            };

            delete availableTimes.enableCustomFulfillmentTimes;

            Object.keys(availableTimes).forEach(function (fulfillmentName) {
                var fulfillmentTimes = availableTimes[fulfillmentName];
                index[fulfillmentName] = {};

                fulfillmentTimes.forEach(function (day) {
                    index[fulfillmentName][day.dateString] = day.timeSlots;
                });
            });
            return index;
        },
    };
    return service;
}
/**
 * Created by MrSingh on 1/30/16.
 */

'use strict';

hsApp.constant('allProducts', {
        categories  : {
            Default  : {
                heroImage:'../images/hero-images/home-bg.jpg',
                seoImage:'/images/hero-images/home-bg.jpg'
            },            
            Bakery  : {
                heroImage:'../images/hero-images/bakery.jpg',
                seoImage:'/images/hero-images/bakery.jpg'
            },
            IndianPantry  : {
                heroImage:'../images/hero-images/indian-pantry.jpg',
                seoImage:'/images/hero-images/indian-pantry.jpg'
            },
            DairyEggs  : {
                heroImage:'../images/hero-images/dairy-eggs.jpg',
                seoImage:'/images/hero-images/dairy-eggs.jpg'
            },
            Snacks  : {
                heroImage:'../images/hero-images/snacks.jpg',
                seoImage:'/images/hero-images/snacks.jpg'
            },
            RicePasta  : {
                heroImage:'../images/hero-images/rice-pasta.jpg',
                seoImage:'/images/hero-images/rice-pasta.jpg'
            },
            RiceNoodles  : {
                heroImage:'../images/hero-images/rice-pasta.jpg',
                seoImage:'/images/hero-images/rice-pasta.jpg'
            },
            Fruits  : {
                heroImage:'../images/hero-images/fruits.jpg',
                seoImage:'/images/hero-images/fruits.jpg'
            },
            Beverages  : {
                heroImage:'../images/hero-images/beverages.jpg',
                seoImage:'/images/hero-images/beverages.jpg'
            },
            CannedGoods  : {
                heroImage:'../images/hero-images/canned-goods.jpg',
                seoImage:'/images/hero-images/canned-goods.jpg'
            },
            Vegetables  : {
                heroImage:'../images/hero-images/vegetables.jpg',
                seoImage:'/images/hero-images/vegetables.jpg'
            },
            Babies  : {
                heroImage:'../images/hero-images/babies.jpg',
                seoImage:'/images/hero-images/babies.jpg'
            },
            MeatSeafood  : {
                heroImage:'../images/hero-images/meat-seafood.jpg',
                seoImage:'/images/hero-images/meat-seafood.jpg'
            },
            Pantry  : {
                heroImage:'../images/hero-images/pantry.jpg',
                seoImage:'/images/hero-images/pantry.jpg'
            },
            Breakfast  : {
                heroImage:'../images/hero-images/breakfast.jpg',
                seoImage:'/images/hero-images/breakfast.jpg'
            },
            Deli  : {
                heroImage:'../images/hero-images/deli.jpg',
                seoImage:'/images/hero-images/deli.jpg'
            },
            Frozen  : {
                heroImage:'../images/hero-images/frozen.jpg',
                seoImage:'/images/hero-images/frozen.jpg'
            },
            OrganicVegetables  : {
                heroImage:'../images/hero-images/organic-vegetables.jpg',
                seoImage:'/images/hero-images/organic-vegetables.jpg'
            },
            OrganicFruits  : {
                heroImage:'../images/hero-images/organic-fruits.jpg',
                seoImage:'/images/hero-images/organic-fruits.jpg'
            },
            Pulses  : {
                heroImage:'../images/hero-images/pulses.jpg',
                seoImage:'/images/hero-images/pulses.jpg'
            },
            MealKits  : {
                heroImage:'../images/hero-images/meal-kits.jpg',
                seoImage:'/images/hero-images/meal-kits.jpg'
            },
            Flours  : {
                heroImage:'../images/hero-images/flours.jpg',
                seoImage:'/images/hero-images/flours.jpg'
            },
            HealthBeauty  : {
                heroImage:'../images/hero-images/health-beauty.jpg',
                seoImage:'/images/hero-images/health-beauty.jpg'
            },
            Household  : {
                heroImage:'../images/hero-images/household.jpg',
                seoImage:'/images/hero-images/household.jpg'
            },

            // YellowChilli header images
            Starters  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Shuruaat  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Soups  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Curries  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Breads  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Rice  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            Meetha  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            SaathMein  : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'
            },
            //see products-landing.html, this is a bad hack, but works.
            YellowChilliDefaultBanner : {
                heroImage:'../images/hero-images/yellochilli-header1.jpg',
                seoImage:'/images/hero-images/yellochilli-header1.jpg'

            }
        }
});
angular.module('homesome.factories').factory('hsBulkProductOps', ['$http', 'hsUtils', '$q', 'globalFunctions', bulkProductOperationsService]);

function bulkProductOperationsService($http, hsUtils, $q, globalFunctions) {
    return {
        getParsedFile: function(file) {
            void 0;
            var selectedPriceList = null;
            if (ENV.enablePriceList) {
                selectedPriceList = globalFunctions.getAdminSelectedPriceListFromStorage();
                if (!hsUtils.isObject(selectedPriceList) || !hsUtils.isNonEmptyString(selectedPriceList.uniqueName)) {
                    throw new Error('Pricelist not selected');
                }
            }
            if (!(file instanceof File)) return $q.reject('No file selected');

            var dfd = $q.defer();
            var reader = new FileReader();

            reader.onload = function (e) {
                var data = e.target.result;
                var headers = {
                    'content-type': 'text/csv',
                };

                if (hsUtils.isObject(selectedPriceList) && hsUtils.isNonEmptyString(selectedPriceList.uniqueName)) {
                    headers.pricelist = selectedPriceList.uniqueName;
                }

                $http.post(ENV.apiEndPoint + '/bulk/addProducts/uploadcsv', data, { headers })
                    .then(function (res) {
                        if (res.status !== 200) {
                            return dfd.reject(res.data.message);
                        }
                        void 0;
                        dfd.resolve(res.data);
                    })
                    .catch(function (err) {
                        void 0;
                        dfd.reject(err.message || err);
                    });
            };
            reader.onerror = function (err) {
                void 0;
                dfd.reject(err.message || err);
            };
            reader.readAsBinaryString(file);

            return dfd.promise;
        },
        bulkAddProducts: function(productsToAdd, csvHeaders, target) {
            void 0;

            var selectedPriceList = null;
            if (ENV.enablePriceList) {
                selectedPriceList = globalFunctions.getAdminSelectedPriceListFromStorage();
                if (!hsUtils.isObject(selectedPriceList) || !hsUtils.isNonEmptyString(selectedPriceList.uniqueName)) {
                    throw new Error('Pricelist not selected');
                }
            }

            var data = {
                productsToAdd: Object.values(productsToAdd), 
                csvHeaders,
            }

            var headers = {};

            if (hsUtils.isObject(selectedPriceList) && hsUtils.isNonEmptyString(selectedPriceList.uniqueName)) {
                headers.pricelist = selectedPriceList.uniqueName;
            }

            if (hsUtils.isObject(target)) {
                headers.location = target.locationUniqueName;
                headers.pricelist = target.priceListUniqueName;
            }
            
            return $http.post(ENV.apiEndPoint + '/bulk/addProducts?sendResultsEmail=true', data, { headers })
                .then(function (res) {
                    if (res.status === 200) {
                        return res.data;
                    }
                    var message = res.data && res.data.message || 'Failed to add products.';
                    throw new Error(message);
                })
        },
    }
}
angular.module('homesome.factories').factory('hsConversations', ['$http', 'ENV', '$window', '$q', '$timeout', '$rootScope', 'hsAdmin', '$cacheFactory', 'hsUtils', 'globalFunctions', hsConversations]);

function hsConversations($http, ENV, $window, $q, $timeout, $rootScope, hsAdmin, $cacheFactory, hsUtils, globalFunctions) {

    var constants = {
        twilioSdkScript: 'https://media.twiliocdn.com/sdk/js/conversations/releases/2.0.1/twilio-conversations.min.js',
        MAX_ALLOWED_FOCUS_LOST_TIME: 60000,
        UPDATE_TOKEN_REQ_TIMER: 10000,
        EXPIRY_CUTOFF: 180,
    };
    var service = {
        conversationClientInstance: null,
        isConnected: null,
        sdkLoaded: false,
        reset: false,
        conversationIndex: null,
        eventHandlersAdded: false,
        conversationStates: {
            ACTIVE: 'active',
            INACTIVE: 'inactive',
            CLOSED: 'closed'
        },
        focusState: {
            away: false,
            focusLostAt: null,
        },
        allowedImageContentTypes: ['image/jpeg', 'image/png'],
        getConversationToken: function (overrideToken) {

            if (!service.shouldFetchNewToken(overrideToken)) {
                var cachedToken = service.getCachedToken();
                if (cachedToken) return $q.resolve(cachedToken.token);
            }

            return $http.get(ENV.apiEndPoint + '/conversations/token')
                .then(function (res) {
                    if (res.status === 200) {
                        var hsConversationsCache = $cacheFactory.get('hsConversations');
                        if (!hsConversationsCache) {
                            hsConversationsCache = $cacheFactory('hsConversations');
                        }
                        hsConversationsCache.put('token', res.data);
                        return res.data.token;
                    } else if (res.status === 400) {
                        throw { status: res.status, message: 'Conversations not enabled for tenant.'};
                    }
                    throw new Error('Failed to get conversations access tokens.');
                });
        },
        getCachedToken: function() {
            var hsConversationsCache = $cacheFactory.get('hsConversations');
            var cachedTokenData = hsConversationsCache ? hsConversationsCache.get('token') : null;
            return cachedTokenData;
        },
        shouldFetchNewToken: function(overrideToken) {
            if (overrideToken) return true;
            var tokenData = service.getCachedToken();
            return !tokenData || service.tokenExpiredOrAboutToExpire(tokenData);
        },
        tokenExpiredOrAboutToExpire: function(tokenData) {
            return tokenData.exp - (Date.now()/1000) <= constants.EXPIRY_CUTOFF;
        },
        loadTwilioConversationSDK: function () {
            var dfd = $q.defer();
            $.getScript(constants.twilioSdkScript, function () {
                if (window.Twilio && window.Twilio.Conversations && window.Twilio.Conversations.Client) {
                    service.sdkLoaded = true;
                    return dfd.resolve(service.sdkLoaded);
                }
                else {
                    return dfd.reject("Couldn't load Twilio Conversations SDK");
                }
            });
            return dfd.promise;
        },
        initConversationClient: function () {
            var startTime = Date.now();

            var hsConversationsCache = $cacheFactory.get('hsConversations');
            if (!hsConversationsCache) {
                hsConversationsCache = $cacheFactory('hsConversations');
            }

            var initConversationClientReq = hsConversationsCache.get('initConversationClient');
            if (initConversationClientReq) {
                return initConversationClientReq;
            }

            initConversationClientReq = $q(function(resolve, reject) {
                if (!service.sdkLoaded) {
                    return service.loadTwilioConversationSDK().then(function(res) {
                        if (!res) {
                            throw "Couldn't load Twilio Conversations SDK";
                        }
                        return service.getConversationToken().then(processHandlers);
                    }).then(resolve).catch(reject);
                }
                service.getConversationToken().then(processHandlers).then(resolve).catch(reject);
            }).finally(function () {
                if (hsConversationsCache && hsConversationsCache.get('initConversationClient')) {
                    hsConversationsCache.remove('initConversationClient');
                }
                var duration = Math.round((Date.now() - startTime) / 1000);
                globalFunctions.sendGAEvent(globalFunctions.GAEventType.TWILIO, 'client init', duration + ' seconds');
            });

            hsConversationsCache.put('initConversationClient', initConversationClientReq);
            return initConversationClientReq;

            function handleToken (token) {
                return window.Twilio.Conversations.Client.create(token).then(function(client){
                    service.conversationClientInstance = client;
                    service.addEventHandlers();
                    void 0
                    service.isConnected = client.connectionState === 'connected';
                    return service.conversationClientInstance;
                });
            }

            // Added to ensure that initConversationClient promise always resolves with the created client,
            // regardless of how many promises there are in the chain.
            function processHandlers(token) {
                return handleToken(token).then(function(client) {
                    return service.handleCurrentUser()
                        .then(function() {
                            return client;
                        });
                });
            }
        },
        handleCurrentUser: function () {
            var user = $rootScope.currentUser;
            if (!hsUtils.isObject(user.conversations)) {
                return globalFunctions.updateUserInStorage()
                    .catch(function(err) {
                        throw new Error('Failed to update user in storage.');
                    });
            }
            return $q.resolve();
        },
        initOrderConversation: function (conversationId, loadLatest, reset) {
            void 0;

            if (!service.conversationClientInstance) {
                return service.initConversationClient().then(onClientInit);
            }

            return onClientInit(service.conversationClientInstance);

            function onClientInit(conversationClientInstance) {

                if (!reset) {
                    // Check if we have already loaded exactly the same conversation regardless of the "loadLatest" flag.
                    var loadedConversation = Object.values(service.conversationIndex || {}).find(function (index) {
                        if (hsUtils.isObject(index) && hsUtils.isObject(index.conversation) && index.conversation.sid === conversationId) {
                            return index;
                        }
                    });

                    if (loadedConversation) {
                        return $q.resolve();
                    }
                }

                return conversationClientInstance.getConversationBySid(conversationId).then(function (conversation) {
                    void 0;

                    var orderId = conversation.attributes.orderId;
                    var index = (service.conversationIndex || {})[orderId];

                    // If some closed conversation was already loaded possibly due to lingering index,
                    // but the init was called for an active conversation for the same order,
                    // or loading latest from Order View, then reload.
                    // If an active index has more than one lingering closed conversations
                    // then only the first one will be loaded.
                    if (reset || !index || loadLatest || conversation.state.current !== service.conversationStates.CLOSED) {
                        return service.createIndex(conversation.attributes.orderId, conversation, reset).then(function () {
                            service.digest();
                        });
                    }
                    return $q.resolve();

                });
            }
        },
        fetchSubscribedConversations: function () {
            return conversationClientInstance.getSubscribedConversations().then(function(paginator) {
                return service.fetchItemsFromPage(paginator, []).then(function(conversations) {
                    var dfd = $q.defer();
                    var count = 0;
                    for (var i = 0; i < conversations.length; i++) {
                        service.createIndex(orderId, conversations[i]).then(function () {
                            count++;
                            if (count >= conversations.length) {
                                return dfd.resolve();
                            }
                        }).catch(function (error) {
                            return dfd.reject(error);
                        });
                    }
                    return dfd.promise;
                }).then(function () {
                    service.digest();
                });
            });
        },
        addEventHandlers: function () {
            if (service.eventHandlersAdded) return;
            service.conversationClientInstance.on("connectionStateChanged", function (state) {
                if (state === "connected") {
                    service.isConnected = true;
                } else {
                    service.isConnected = false;
                }
                void 0;
                service.digest();
            });
            service.conversationClientInstance.on("messageAdded", function (message) {
                void 0;
                var orderId = message.conversation.attributes.orderId;
                service.initializeIndex(orderId, message.conversation, false);

                service.conversationIndex[orderId].messages[message.state.index] = message;
                service.conversationIndex[orderId].messages = Object.assign({}, service.conversationIndex[orderId].messages);
                service.updateLastReadMessageIndex(message.conversation.lastReadMessageIndex, orderId);
                service.setUnreadMessagesCount(message.conversation).then(function () {
                    service.digest();
                });
            });
            service.conversationClientInstance.on("conversationAdded", function (conversation) {
                void 0;
                void 0;
                service.createIndex(conversation.attributes.orderId, conversation).then(function () {
                    service.digest();
                }).catch(function (error) {
                    void 0;
                });
            });
            service.conversationClientInstance.on("conversationUpdated", function (data) {
                void 0;
                service.initializeIndex(data.conversation.attributes.orderId, data.conversation);

                if (data.updateReasons.includes("lastReadMessageIndex")) {
                    service.setUnreadMessagesCount(data.conversation).then(function (res) {
                        void 0;
                    })
                    .catch(function (err) {
                        void 0;
                    })
                    .finally(function () {
                        service.digest();
                    });
                }
            });
            service.conversationClientInstance.on("tokenAboutToExpire", function (res) {
                void 0;
                service.getConversationToken(true)
                    .then(function(token) {
                        return service.syncToken(token)
                    })
                    .catch(function(error) {
                        if (!error || error === 'TIMEOUT') {
                            service.resetClient();
                            return;
                        }
                        void 0;
                    });
            });
            service.conversationClientInstance.on("tokenExpired", function () {
                void 0;
                service.resetClient();
            });
            service.eventHandlersAdded = true;
        },
        createIndex: function (orderId, conversation, reset) {
            var shouldReset = service.overrideIndex(orderId, conversation) || !!reset;
            service.initializeIndex(orderId, conversation, shouldReset);
            return service.fetchConversationMessages(orderId, conversation).then(function(){
                return service.getUnreadMessagesCount(conversation);
            });
        },
        initializeIndex: function (orderId, conversation, shouldReset) {
            
            if (!service.conversationIndex) {
                service.conversationIndex = {};
            }
            if (!service.conversationIndex[orderId] || shouldReset) {
                service.conversationIndex[orderId] = {
                    conversation: conversation,
                    messages: {},
                    lastReadMessageIndex: null,
                    unreadMessagesCount: null
                };
            } 
            if (service.isValidLastReadMessageIndex(conversation.lastReadMessageIndex)) {
                service.conversationIndex[orderId].lastReadMessageIndex = conversation.lastReadMessageIndex;
            }
        },
        // When we change the conversation on the order, we want to reconstruct the index
        overrideIndex: function(orderId, conversation) {
            return service.conversationEntryExists(orderId)
                && !service.isSameConversation(orderId, conversation);
        },
        conversationEntryExists: function(orderId) {
            return !!service.conversationIndex
            && !!service.conversationIndex[orderId]
            && !!service.conversationIndex[orderId].conversation;
        },
        isSameConversation: function(orderId, conversation) {
            return service.conversationIndex[orderId].conversation.sid === conversation.sid;
        },
        fetchConversationMessages: function (orderId, conversation) {
            return conversation.getMessages().then(function(paginator) {
                return service.fetchItemsFromPage(paginator, []).then(function(messages) {
                    messages.forEach(function(message) {
                        service.conversationIndex[orderId].messages[message.state.index] = message;
                    });
                    service.conversationIndex[orderId].messages = Object.assign({},service.conversationIndex[orderId].messages);
                });
            });
        },
        fetchItemsFromPage: function (paginator, items) {
            if (paginator.items.length > 0) {
                paginator.items.forEach(function (item) {
                    items.push(item);
                });
            }
            if (paginator.hasPrevPage) {
                return paginator.prevPage().then(function (paginator) {
                    return service.fetchItemsFromPage(paginator, items);
                });
            }
            return $q.resolve(items);
        },
        digest: function () {
            try{
                void 0;
                $rootScope.$digest();
            }
            catch(error){
                void 0;
            }
        },
        createMessageRequests: function(message, conversation, imageList) {
            var messagesToSend = [];
            if (message) {
                messagesToSend.push(conversation.sendMessage(message));
            }
            if (hsUtils.isNonEmptyArray(imageList)) {
                for (var i = 0; i < imageList.length; i++) {

                    var image = imageList[i];
                    if (service.isValidImageContentType(image)) {
                        messagesToSend.push(
                            hsUtils.readAsArrayBuffer(image)
                                .then(function(result) {
                                    var messageBuilder = conversation.prepareMessage();
                                    messageBuilder.addMedia({
                                        contentType: service.getImageContentType(image),
                                        media: result
                                    });
                                    //var media = btoa(String.fromCharCode.apply(null, new Uint8Array(result)));
                                    return messageBuilder.build().send();
                                })
                        );
                    }
                    
                }
            }
            return messagesToSend;
        },
        sendMessage: function (message, orderId, imageList) {

            var conversation = service.conversationIndex[orderId].conversation;
            return service.isParticipant(conversation, $rootScope.currentUser.conversations.user.identity).then(function(isUserParticipant){
                if (!isUserParticipant) {
                    conversation.join().then(function() {
                        return $q.all(service.createMessageRequests(message, conversation, imageList));
                    });
                } else {
                    return $q.all(service.createMessageRequests(message, conversation, imageList));
                }
            });

        },
        updateLastReadMessageIndex: function(lastReadMessageIndex, orderId) {
            var index = service.conversationIndex[orderId];
            if (!service.isValidLastReadMessageIndex(lastReadMessageIndex)) {
                return;
            }
            index.lastReadMessageIndex = lastReadMessageIndex;
        },
        isValidLastReadMessageIndex: function(lastReadMessageIndex) { 
            return typeof lastReadMessageIndex === 'number';
        },
        getUnreadMessagesCount: function (conversation) {
            return conversation.getUnreadMessagesCount().then(function(count) {
                void 0;
                if (count === null) {
                    count = Object.keys(service.conversationIndex[conversation.attributes.orderId].messages).length;
                }
                service.conversationIndex[conversation.attributes.orderId].unreadMessagesCount = count;
            }).catch(function(err) {
                if (err.message !== 'Not Found') {
                    void 0;
                }
            });
        },
        setUnreadMessagesCount: function (conversation) {
            
            var index = service.conversationIndex[conversation.attributes.orderId];
            service.updateLastReadMessageIndex(conversation.lastReadMessageIndex, conversation.attributes.orderId);
            var messages = Object.values(index.messages);

            // this should not happen, but it does
            if (index.lastReadMessageIndex === null) {
                void 0;
                index.unreadMessagesCount = messages.length;
                return $q.resolve();
            }

            if (!messages.length) {
                index.unreadMessagesCount = 0;
                return $q.resolve();
            }

            messages.sort(function (a, b) {
                return a.state.index - b.state.index;
            });

            var lastReadMessageIndex = messages.findIndex(function (message) {
                return message.state.index === index.lastReadMessageIndex;
            });

            if (lastReadMessageIndex === -1) {
                void 0;
                return $q.resolve();
            }

            var unreadCount = messages.length - 1 - lastReadMessageIndex;

            index.unreadMessagesCount = unreadCount < 0 ? 0 : unreadCount;
            return $q.resolve();
        },
        updateUnreadMessagesCount: function (index, orderId) {
            var identity = $rootScope.currentUser.conversations.user.identity;
            var conversation = service.conversationIndex[orderId].conversation;
            var currentIndex = service.conversationIndex[orderId].lastReadMessageIndex;
            var unreadMessagesCount = service.conversationIndex[orderId].unreadMessagesCount;

            if (!service.isConnected || conversation.state.current === service.conversationStates.CLOSED) {
                void 0;
                return $q.resolve();
            }

            if (index === null) {
                return $q.resolve();
            }

            if (currentIndex !== null) {
                // Encountered an issue where Twilio had incorectly set unread messages count, so need to check equality to reset unread count.
                if (index > currentIndex) {
                    // console.log('CLEAN UPDATE', index, '>', currentIndex);
                    return conversation.advanceLastReadMessageIndex(index);
                }

                if (index === currentIndex && unreadMessagesCount) {
                    // console.log('CLEAN UPDATE', index, '=', currentIndex);
                    return conversation.updateLastReadMessageIndex(index);
                }
                return $q.resolve();
            } else {
                return service.isParticipant(conversation, identity).then(function (isParticipant) {
                    if (!isParticipant) {
                        // console.log('NOT isParticipant');
                        return $q.resolve();
                    }
                    // console.log('PARTICIPANT UPDATE', currentIndex, '>', index);
                    return conversation.advanceLastReadMessageIndex(index);
                });
            }
        },
        isParticipant: function (conversation, identity) {
            return conversation.getParticipantByIdentity(identity).then(function(res){
                return true;
            }).catch(function (error) {
                return false;
            });
        },
        isConversationEnabled: function () {
            return hsAdmin.getConversationFlags().then(function(conversationSettings){
                return conversationSettings.enabled;
            }).catch(function(error) {
                void 0;
                return false;
            });
        },
        isAutoSendMessageEnabled: function() {
            return hsAdmin.getConversationFlags().then(function(conversationSettings){
                return conversationSettings.autoSendMessage;
            }).catch(function() {
                return false;
            });
        },
        isPackerRequired: function() {
            return hsAdmin.getConversationFlags().then(function(conversationSettings){
                return conversationSettings.packerRequired;
            }).catch(function() {
                return false;
            });
        },
        initOrdersWithActiveConversations: function() {
            return service.getActiveIndex().then(function(activeConversationIds) {
                void 0;

                for (var i = 0; i < activeConversationIds.length; i++) {
                    (function (sid) {
                        service.initOrderConversation(sid).catch(function (err) {
                            void 0;
                        });
                    })(activeConversationIds[i]);
                }
            });
        },
        getActiveIndex: function () {
            return $http.get(ENV.apiEndPoint + '/conversations/index/active')
                .then(function (res) {
                    if (res.status === 200) {
                        return res.data.activeIndex;
                    }
                    throw new Error('Failed to get active conversations index.');
                }).catch(function (error) {
                    void 0;
                });
        },
        updateToken: function(token) {

            var timeout = $q(function(_, reject) {
                $timeout(function() {
                    reject('TIMEOUT');
                }, constants.UPDATE_TOKEN_REQ_TIMER);
            });

            return $q.race([timeout, service.conversationClientInstance.updateToken(token)]);
        },
        syncToken: function(token) {
            if (!service.conversationClientInstance) return $q.reject();
            return service.updateToken(token)
                .then(function (client) {
                    void 0;
                    service.conversationClientInstance = client;
                })
                .then(service.handleCurrentUser)
                .catch(function (error) {
                    void 0;
                    return $q.reject(error);
                });
        },
        isInitializing: function () {
            var hsConversationsCache = $cacheFactory.get('hsConversations');
            if (!hsConversationsCache) return false;

            var initConversationClientReq = hsConversationsCache.get('initConversationClient');
            return !!initConversationClientReq;
        },
        restartClient: function (msecDelay) {
            if (typeof msecDelay !== 'number') {
                msecDelay = 10000;
            }
            void 0;
            setTimeout(function () {
                void 0;
                if (!service.reset) return;

                service.initConversationClient()
                    .then(function () {
                        Object.values(service.conversationIndex).forEach(function (index) {
                            void 0;
                            service.initOrderConversation(index.conversation.sid, false, true)
                                .catch(console.error);
                        });
                        service.reset = false;
                    })
                    .catch(function (err) {
                        void 0;
                        if (!(err.status && err.status === 400)) {
                            service.restartClient();
                        }
                    });
            }, msecDelay);
        },
        resetClient: function () {
            if (service.reset || service.isInitializing()) {
                void 0;
                return;
            }

            void 0;
            service.shutdownClient()
                .finally(function() {
                    service.restartClient();
                });
        },
        shutdownClient: function() {
            return service.conversationClientInstance.shutdown()
                .catch(function (err) {
                    void 0;
                })
                .finally(function () {
                    service.conversationClientInstance = null;
                    service.reset = true;
                    service.eventHandlersAdded = false;
                    service.isConnected = false;
                    service.digest();
                });
        },
        addWindowEvents: function () {
            void 0;

            $window.addEventListener('visibilitychange', service.visibilityChange);
        },
        addAuthEvents: function() {
            $rootScope.$on("logout", function() {
                if  (service.conversationClientInstance) {
                    service.shutdownClient();
                }
            });
        },
        visibilityChange: function (event) {
            void 0;
            void 0;

            // if ($window.document.visibilityState === 'visible' && service.conversationClientInstance) {
            if ($window.document.visibilityState === 'visible') {
                var wasAway = service.focusState.away;
                var focusLostAt = service.focusState.focusLostAt;
                service.resetFocusLost();

                if (service.conversationClientInstance) {
                    if (wasAway && Date.now() - focusLostAt < constants.MAX_ALLOWED_FOCUS_LOST_TIME && !service.shouldFetchNewToken()) return;

                    service.isConnected = false;
                    var startTime = Date.now();
                    // The idea here is to call a method on the Twilio client to cause an internall websocket error
                    // which allows to either restart a client and update the token, or trigger the tokenExpired event
                    // and reset client. Otherwise, nothing will happen if token expired when device was closed.
                    service.getConversationToken()
                        .then(function(token) {
                            return service.syncToken(token)
                                .then(function () {
                                    void 0;
                                    service.isConnected = true;
                                    var duration = Math.round((Date.now() - startTime) / 1000);
                                    globalFunctions.sendGAEvent(globalFunctions.GAEventType.TWILIO, 'token updated', duration + ' seconds');
                                });
                        })
                        .catch(function (err) {
                            void 0;
                            var duration = Math.round((Date.now() - startTime) / 1000);
                            globalFunctions.sendGAEvent(globalFunctions.GAEventType.TWILIO, 'failed to update token', duration + ' seconds');
                            service.resetClient();
                        });
                }
            } else {
                service.setFocusLost();
            }
        },
        hasImage: function(message) {
            return message.media && message.media.contentType && message.media.contentType.startsWith('image/');
        },
        fetchImageUrl: function(message) {
            return message.media.getContentTemporaryUrl();
        },
        loadImage: function(message) {
            return $q(function(resolve, reject) {

                if (message.imageUrl) {
                    return resolve();
                }

                return service.fetchImageUrl(message)
                    .then(function(url) {
                        message.imageUrl = url;
                        resolve();
                    })
                    .catch(reject);

            }).then(service.digest);
        },
        getImageContentType: function(file) {
            return file.type || 'image/jpeg';
        },
        isValidImageContentType: function(file) {
            return service.allowedImageContentTypes.includes(file.type);
        },
        setFocusLost: function () {
            service.focusState.away = true;
            service.focusState.focusLostAt = Date.now();
            void 0;
        },
        resetFocusLost: function () {
            service.focusState.away = false;
            service.focusState.focusLostAt = null;
            void 0;
        },
    };
    service.addWindowEvents();
    service.addAuthEvents();
    
    return service;
}
angular.module('homesome.factories').factory('hsCoupons', ['$http', 'hsUtils', couponService]);

function couponService($http, hsUtils) {
    function allComparator(val) {
        return true;
    }

    function emptyComparator(sourceVal) {
        return [undefined, null, ''].includes(sourceVal);
    }

    function stringComparator(sourceVal, filterVal) {
        sourceVal = sourceVal || '';
        return sourceVal.includes(filterVal);
    }

    function booleanComparator(sourceVal, filterVal) {
        sourceVal = [undefined, null, ''].includes(sourceVal) ? false : sourceVal;
        return sourceVal === filterVal;
    }

    function phoneComparator(sourceVal, filterVal) {
        sourceVal = sourceVal || '';
        sourceVal = sourceVal.replace(/[^0-9]/g, '');
        filterVal = filterVal.replace(/[^0-9]/g, '');
        return sourceVal.includes(filterVal);
    }

    function booleanToYesNo(val) {
        if (val === true) return VALUES.YES;
        return VALUES.NO;
    }

    function falsyToEmptyString(val) {
        return val || '';
    }

    var couponTypes = {
        PROMOTIONAL: 'Promotional',
        FREE_DELIVERY: 'FreeDelivery',
    };
    var couponDisplayTypes = {};
    couponDisplayTypes[couponTypes.PROMOTIONAL] = 'Promotional';
    couponDisplayTypes[couponTypes.FREE_DELIVERY] = 'Free Delivery';

    var fulfillmentMethods = {
        PICKUP: 'pickup',
        DELIVERY: 'delivery',
    };
    var displayFulfillmentMethods = {};
    displayFulfillmentMethods[fulfillmentMethods.PICKUP] = 'Pickup';
    displayFulfillmentMethods[fulfillmentMethods.DELIVERY] = 'Delivery';

    var discountType = {
        PERCENTAGE: true,
        DOLLAR: false,
    };
    var displayDiscountType = {};
    displayDiscountType[discountType.PERCENTAGE] = 'Percentage';
    displayDiscountType[discountType.DOLLAR] = 'Dollar';

    var VALUES = {
        ALL: 'All',
        ANY: 'Any',
        EMPTY: '',
        YES: 'Yes',
        NO: 'No',
    };

    var service = {
        couponTypes: couponTypes,
        couponDisplayTypes: couponDisplayTypes,
        fulfillmentMethods: fulfillmentMethods,
        displayFulfillmentMethods: displayFulfillmentMethods,
        discountType: discountType,
        displayDiscountType: displayDiscountType,
        VALUES: VALUES,
        getCouponFormOptions: function() {
            return {
                type: [
                    {
                        name: couponDisplayTypes[couponTypes.PROMOTIONAL],
                        value: couponTypes.PROMOTIONAL,
                    },
                    {
                        name: couponDisplayTypes[couponTypes.FREE_DELIVERY],
                        value: couponTypes.FREE_DELIVERY,
                    },
                ],
                fulfillmentMethod: [
                    {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                    },
                    {
                        name: displayFulfillmentMethods[fulfillmentMethods.PICKUP],
                        value: fulfillmentMethods.PICKUP,
                    },
                    {
                        name: displayFulfillmentMethods[fulfillmentMethods.DELIVERY],
                        value: fulfillmentMethods.DELIVERY,
                    },
                ],
                value: {
                    isPercentage: [
                        {
                            name: displayDiscountType[discountType.DOLLAR],
                            value: discountType.DOLLAR,
                        },
                        {
                            name: displayDiscountType[discountType.PERCENTAGE],
                            value: discountType.PERCENTAGE,
                        },
                    ],
                },
                pricelist: [
                    {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                    },
                ],
            };
        },
        getOptionsFilters: function () {
            return {
                type: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    FreeDelivery: {
                        name: couponDisplayTypes[couponTypes.FREE_DELIVERY],
                        value: couponTypes.FREE_DELIVERY,
                        comparator: true,
                    },
                    Promotional: {
                        name: couponDisplayTypes[couponTypes.PROMOTIONAL],
                        value: couponTypes.PROMOTIONAL,
                        comparator: true,
                    },
                },
                fulfillmentMethod: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    '': {
                        name: VALUES.ANY,
                        value: VALUES.EMPTY,
                        comparator: emptyComparator,
                    },
                    delivery: {
                        name: displayFulfillmentMethods[fulfillmentMethods.DELIVERY],
                        value: fulfillmentMethods.DELIVERY,
                        comparator: true,
                    },
                    pickup: {
                        name: displayFulfillmentMethods[fulfillmentMethods.PICKUP],
                        value: fulfillmentMethods.PICKUP,
                        comparator: true,
                    },
                },
                expired: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    Yes: {
                        name: VALUES.YES,
                        value: true,
                        comparator: booleanComparator,
                    },
                    No: {
                        name: VALUES.NO,
                        value: false,
                        comparator: booleanComparator,
                    },
                },
                isHidden: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    Yes: {
                        name: VALUES.YES,
                        value: true,
                        comparator: booleanComparator,
                    },
                    No: {
                        name: VALUES.NO,
                        value: false,
                        comparator: booleanComparator,
                    },
                },
                singleUse: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    Yes: {
                        name: VALUES.YES,
                        value: true,
                        comparator: booleanComparator,
                    },
                    No: {
                        name: VALUES.NO,
                        value: false,
                        comparator: booleanComparator,
                    },
                },
                forUser: {
                    All: {
                        name: VALUES.ALL,
                        value: VALUES.EMPTY,
                        comparator: allComparator,
                        default: true,
                    },
                    Yes: {
                        name: VALUES.YES,
                        value: true,
                        comparator: booleanComparator,
                    },
                    No: {
                        name: VALUES.NO,
                        value: false,
                        comparator: booleanComparator,
                    },
                },
            };
        },
        getOptionFilterValueConverter: function (filterName) {
            var converters = {
                fulfillmentMethod: falsyToEmptyString,
                expired: booleanToYesNo,
                isHidden: booleanToYesNo,
                singleUse: booleanToYesNo,
                forUser: booleanToYesNo,
            };
            if (!(filterName in converters)) return null;
            if (typeof converters[filterName] !== 'function') return null;
            return converters[filterName];
        },
        getInputFilters: function () {
            return {
                code: {
                    comparator: false,
                },
                userPhoneNumber: {
                    comparator: phoneComparator,
                },
                userFullName: {
                    comparator: stringComparator,
                },
                userEmail: {
                    comparator: stringComparator,
                },
            };
        },
        getCouponDisplayValue: function (value) {
            if (!hsUtils.isObject(value)) return '--';

            var numValue = typeof value.numValue === 'number' ? value.numValue : '--';
            return value.isPercentage ? numValue + ' %' : '$' + numValue.toFixed(2);
        },
        getCouponDisplayExpiration: function (expiry) {
            if (!hsUtils.isObject(expiry)) return '--';
            return (+expiry.month + 1).toString().padStart(2, '0') + '/' + expiry.day.toString().padStart(2, '0') + '/' + expiry.year.toString().slice(2);
        },
        getCouponDisplayType: function (type) {
            return service.couponDisplayTypes[type] || '--';
        },
        getDisplayPriceListName: function (priceList, priceLists) {
            if (!priceList) return VALUES.ANY;

            var found = priceLists.find(function (pl) { return pl.uniqueName === priceList });
            if (!found) return '--';

            return found.title;
        },
        getDisplayMaxOrders: function (noofOrderConstraint) {
            return noofOrderConstraint || 'No Limit';
        },
        getDisplayMaxUses: function(timesRedeemable, singleUse) {
            if (singleUse) return '1';

            return timesRedeemable || 'No Limit';
        },
        getCouponObject: function (models) {
            var coupon = {
                code: models.code,
                description: models.description, 
                excludeServiceFee: models.excludeServiceFee,
                expiry: {
                    day: models.expiry.day,
                    month: models.expiry.month,
                    year: models.expiry.year,
                },
                forUser: models.forUser,
                fulfillmentMethod: models.fulfillmentMethod.value,
                image: models.image,
                isHidden: models.isHidden,
                minOrder: models.minOrder,
                noofOrderConstraint: models.noofOrderConstraint,
                singleUse: models.singleUse,
                timesRedeemable: models.timesRedeemable,
                title: models.title,
                type: models.type.value,
                targetUser: models.userEmail,
                value: {
                    numValue: models.value.numValue,
                    isPercentage: models.value.isPercentage.value,
                },
            };
            if (models.pricelist.value) {
                coupon.pricelist = models.pricelist.value;
            }
            if (!coupon.targetUser) {
                delete coupon.targetUser;
            }
            if (!coupon.image) {
                delete coupon.image;
            }
            if (!coupon.timesRedeemable) {
                delete coupon.timesRedeemable;
            }
            if (coupon.type !== couponTypes.FREE_DELIVERY) {
                delete coupon.excludeServiceFee;
            }
            if (!coupon.forUser) {
                delete coupon.targetUser;
            }
            if (coupon.singleUse) {
                delete coupon.timesRedeemable;
            }
            return coupon;
        },
        getCoupons: function () {
            return $http.get(ENV.apiEndPoint + '/user/coupon?couponsForAdmin=true')
                .then(function(res) {
                    if (res.status === 200) {
                        return res.data;
                    }
                    throw new Error('Failed to get coupons.');
                });
        },
        updateCoupon: function (data, target) {
            var headers = service.getHeaders(target);
            return $http.put(ENV.apiEndPoint + '/user/coupon/' + encodeURIComponent(data.code), { coupon: data }, { headers: headers })
                .then(function (res) {
                    if (res.status !== 200) {
                        void 0;
                        if (target) {
                            throw res;
                        }
                        throw res.data.message || 'Failed to update a coupon';
                    }
                    void 0;
                    return res.data;
                });
        },
        createCoupon: function (data, target) {
            var headers = service.getHeaders(target);
            return $http.post(ENV.apiEndPoint + '/user/coupon', { coupon: data }, { headers: headers })
                .then(function (res) {
                    if (res.status !== 200) {
                        void 0;
                        if (target) {
                            throw res;
                        }
                        throw res.data.message || 'Failed to create a coupon';
                    }
                    void 0;
                    return res.data;
                });
        },
        getHeaders: function (target) {
            var headers = {};

            if (hsUtils.isNonEmptyObject(target)) {
                headers.location = target.locationUniqueName;
                headers.pricelist = target.priceListUniqueName;
            }

            return headers;
        },
    };

    return service;
}

angular.module('homesome.factories').factory('hsDelivery', ['$http', 'hsAdmin', 'hsUtils', '$q', deliveryService]);

function deliveryService($http, hsAdmin, hsUtils, $q) {

    var service = {
        deliveryStates: {
            UNSCHEDULED: 'unscheduled',
            QUOTED: 'quoted',
            PENDING: 'pending',
            PICKUP: 'pickup',
            PICKUP_COMPLETE: 'pickup_complete',
            DROPOFF: 'dropoff',
            DELIVERED: 'delivered',
            CANCELED: 'canceled',
            RETURNED: 'returned',
            FAILED: 'failed',
            SCHEDULING: ' scheduling'
        },
        displayDeliveryStates: {
            unscheduled: 'Unscheduled',
            quoted: 'Quoted',
            pending: 'Pending',
            pickup: 'Pickup',
            pickup_complete: 'Pickup Complete',
            dropoff: 'Dropoff',
            delivered: 'Delivered',
            canceled: 'Canceled',
            returned: 'Returned',
            failed: 'Failed',
            scheduling: 'Scheduling'

        },
        deliverableStates: {
            UNKNOWN: 'unknown',
            DELIVERABLE: 'deliverable',
            UNDELIVERABLE: 'undeliverable',
        },
        displayDeliverableStates: {
            unknown: 'Unknown',
            deliverable: 'Deliverable',
            'cannot deliver': 'Undeliverable',
        },
        displayQuotedFee: {
            unknown: 'Unknown',
            undeliverable: 'Undeliverable',
        },
        getPriceListUniqueName: function(isAdmin) {
            if (!isAdmin) return $q.resolve(null);

            return hsAdmin.getSelectedPriceList()
                .then(function(priceList) {
                    if (priceList) return priceList.uniqueName;
                    return null;
                });
        },
        getDeliveries: function (startDate, endDate) {
            var params = service.getDateParams(startDate, endDate);

            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.get(ENV.apiEndPoint + '/hds/deliveries' + params, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                // service.promotions = res.data;
                                return res.data;
                            }
                            throw new Error('Failed to get deliveries.');
                        });

                });
        },
        getDateParams: function (start, end) {
            if (!(start instanceof Date) || !(end instanceof Date)) return '';

            return '?startDate=' + start.getDate() + '&startMonth=' + (start.getMonth() + 1) + '&startYear=' + start.getFullYear()
                + '&endDate=' + end.getDate() + '&endMonth=' + (end.getMonth() + 1) + '&endYear=' + end.getFullYear();
        },
        getDeliveryDate: function (date) {
            if (!hsUtils.isValidDate(date.year, date.month - 1, date.date)) return date.year + '/' + date.month + '/' + date.date;
            
            var dateObj = new Date(date.year, date.month - 1, date.date);
            var parts = dateObj.toDateString().split(' ');
            return parts[2] + ' ' + parts[1] + ' ' + parts[3];
        },
        getDeliveryTime: function (time) {
            var hour = time.hour;
            var period = hour >= 12 ? 'PM' : 'AM';
            hour = hour % 12;
            hour = hour ? hour : 12;
            var minute = time.minute.toString().padStart(2, '0');

            return hour + ':' + minute + period;
        },
        getAddress: function (address) {
            return address.street + ' ' + address.aptUnit + ', ' + address.city + ', ' + address.state + ', ' + address.zip;
        },
        getDisplayDeliveryState: function (state) {
            if (!(state in service.displayDeliveryStates)) return '';

            return service.displayDeliveryStates[state];
        },
        getDisplayDeliverableState: function (state) {
            if (!(state in service.displayDeliverableStates)) return '';

            return service.displayDeliverableStates[state];
        },
        getDisplayQuotedFee : function (state) {
            if (typeof state === 'number') {
                return '$' + state.toFixed(2);
            }
            return '--';
        },
        getParsedFile: function (file) {
            if (!(file instanceof File)) return $q.reject('No file selected');

            var dfd = $q.defer();
            var reader = new FileReader();

            reader.onload = function (e) {
                var data = e.target.result;

                $http.post(ENV.apiEndPoint + '/hds/deliveries/uploadcsv', data, { headers: { 'content-type': 'text/csv' }})
                    .then(function (res) {
                        if (res.status !== 200) {
                            return dfd.reject(res.data.message);
                        }
                        void 0;
                        dfd.resolve(res.data);
                    })
                    .catch(function (err) {
                        void 0;
                        dfd.reject(err.message || err);
                    });
            };
            reader.onerror = function (err) {
                void 0;
                dfd.reject(err.message || err);
            };
            reader.readAsBinaryString(file);

            return dfd.promise;
        },
        importDeliveryObjects: function (list) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.post(ENV.apiEndPoint + '/hds/deliveries', { deliveries: list })
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                throw res.data.message || 'Failed to import deliveries';
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        createDeliveryObject: function (data) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.post(ENV.apiEndPoint + '/hds/delivery', { delivery: data })
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                var message = res.data.message || 'Failed to create delivery';
                                throw message;
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        deleteDeliveryObject: function (delivery) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.delete(ENV.apiEndPoint + '/hds/delivery/' + encodeURIComponent(delivery.key))
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                throw new Error('Failed to delete delivery');
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        updateDeliveryObject: function (deliveryObjId, data) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.put(ENV.apiEndPoint + '/hds/delivery/' + deliveryObjId, { updatedParams: data })
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                var message = res.data.message || 'Failed to update delivery';
                                throw message;
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        cancelDelivery: function (delivery) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    return $http.post(ENV.apiEndPoint + '/hds/delivery/' + encodeURIComponent(delivery.id) + '/cancel')
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                throw new Error('Failed to cancel delivery');
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        getQuote: function (delivery) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.post(ENV.apiEndPoint + '/hds/delivery/' + encodeURIComponent(delivery.id) + '/quote')
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                var message = res.data.message || 'Failed to get a quote';
                                throw message;
                            }
                            void 0;
                            return res.data;
                        });

                });
        },
        scheduleDelivery: function(scheduleAsap, delivery) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    return $http.post(ENV.apiEndPoint + '/hds/delivery/' + encodeURIComponent(delivery.id) + '/schedule', { scheduleAsap: scheduleAsap })
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                var message = res.data.message || 'Failed to schedule delivery';
                                throw message;
                            }
                            void 0;
                            return res.data;
                        });
                })
        },
        isDeliverable: function(delivery) {
            if (!delivery || !delivery.hasOwnProperty('quotedFeeStates')) return false;
            if (typeof delivery.quotedFeeStates === 'number') return true;

            return delivery.quotedFeeStates === service.deliverableStates.DELIVERABLE;
        },
        isUndeliverable: function(delivery) {
            if (!delivery || !delivery.hasOwnProperty('quotedFeeStates')) return false; // unknown will return "false"
            if (typeof delivery.quotedFeeStates === 'number') return false;

            return delivery.quotedFeeStates === service.deliverableStates.UNDELIVERABLE;
        },
        canScheduleDelivery: function(delivery) {
            if (!delivery) return false;

            var terminalStates = [
                service.deliveryStates.UNSCHEDULED,
                service.deliveryStates.DELIVERED,
                service.deliveryStates.CANCELED,
                service.deliveryStates.RETURNED,
                service.deliveryStates.FAILED,
            ];
            return terminalStates.includes(delivery.state);
        },
        canDeleteDelivery: function(delivery) {
            if (!delivery) return false;

            var allowedStates = [
                service.deliveryStates.UNSCHEDULED,
                service.deliveryStates.FAILED,
            ];
            return allowedStates.includes(delivery.state);
        },
        canCancelDelivery: function(delivery) {
            if (!delivery) return false;

            var allowedStates = [
                service.deliveryStates.PENDING,
                service.deliveryStates.PICKUP,
            ];
            return allowedStates.includes(delivery.state);
        },
        canEditDelivery: function(delivery) {
            if (!delivery) return false;

            var allowedStates = [
                service.deliveryStates.UNSCHEDULED,
                service.deliveryStates.FAILED,
                service.deliveryStates.RETURNED,
                service.deliveryStates.CANCELED,
                service.deliveryStates.DELIVERED,
            ];
            return allowedStates.includes(delivery.state);
        },
        bulckScheduleDeliveries: function(deliveryIds) {
            return service.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    return $http.post(ENV.apiEndPoint + '/hds/deliveries/schedule', { deliveryObjIds: deliveryIds})
                        .then(function (res) {
                            if (res.status !== 200) {
                                void 0;
                                var message = res.data.message || 'Failed to schedule deliveries';
                                throw message;
                            }
                            void 0;
                            return res.data;
                        });
                })
        },
        getPickupTimeTitle: function(delivery) {
            var latestDelivery = delivery.deliveries.slice(-1)[0];
            if (latestDelivery.localActualPickupTime) {
                return 'Actual Pickup Time:';
            }

            return 'Estimate Pickup Time:';
        },
        getPickupTimeDisplay: function(delivery) {
            var latestDelivery = delivery.deliveries.slice(-1)[0];
            if (latestDelivery.localActualPickupTime) {
                return latestDelivery.localActualPickupTime;
            }

            return latestDelivery.localEstimatedPickupTime;
        },
        getDeliveryTimeTitle: function(delivery) {
            var latestDelivery = delivery.deliveries.slice(-1)[0];
            if (latestDelivery.localActualDeliveryTime) {
                return 'Actual Delivery Time:';
            }

            return 'Estimate Delivery Time:';
        },
        getDeliveryTimeDisplay: function(delivery) {
            var latestDelivery = delivery.deliveries.slice(-1)[0];
            if (latestDelivery.localActualDeliveryTime) {
                return latestDelivery.localActualDeliveryTime;
            }

            return latestDelivery.localEstimatedDeliveryTime;
        },
        showTrackDeliveryButton: function(delivery) {
            if (!delivery || !delivery.deliveries || !delivery.deliveries.length) return false;

            var allowedStates = [
                service.deliveryStates.PENDING, service.deliveryStates.PICKUP,
                service.deliveryStates.PICKUP_COMPLETE, service.deliveryStates.DROPOFF
            ];

            return allowedStates.includes(delivery.state);
        },
        trackLastDelivery: function(delivery) {
            var latestDelivery = delivery.deliveries.slice(-1)[0];
            return latestDelivery.trackingUrl;
        }
    };

    return service;
}

angular.module('homesome.factories').factory('hsDialog', ['globalFunctions', 'ngDialog', '$rootScope', dialogService]);

function dialogService(globalFunctions, ngDialog, $rootScope) {

    return {
        scrollToContentInDialog: function(elem) {
            var element = $(elem);
            var offset = $(element).offset();
            var scrollAmount = offset.top;
            $(".ngdialog-content").animate({scrollTop: scrollAmount},'slow');
        },
        openSyncProductDialog: function(productData, adminUserLocations, adminUserPriceLists) {

            var allLocations = JSON.parse(JSON.stringify($rootScope.location.allLocations));
            var selectedPricelist = globalFunctions.getAdminSelectedPriceListFromStorage();
            var selectedLocation = globalFunctions.getSelectedLocationFromStorage();

            var availableTargetLocations = allLocations
                .filter(function(location) {
                    if (adminUserLocations.includes(location.uniqueName)) {
                         return location;
                    }
                }).map(function(location) {
                    if (Array.isArray(adminUserPriceLists) && Array.isArray(location.priceLists)) {
                        var priceListUniqueNames = location.priceLists.map(function(priceList) {
                            return priceList.uniqueName;
                        });
                        if (priceListUniqueNames.some(function(priceListUniqueName) {
                            return adminUserPriceLists.includes(priceListUniqueName);
                        })) {
                                location.priceLists = location.priceLists.filter(function(priceList) {
                                    if (adminUserPriceLists.includes(priceList.uniqueName)) {
                                        return priceList;
                                    }
                                });
                        }
                    }
                    
                    //We need to remove selected pricelist from selected location
                    if (location.uniqueName === selectedLocation.uniqueName) {
                        location.priceLists = location.priceLists.filter(function(priceList) {
                            if (selectedPricelist && selectedPricelist.uniqueName !== priceList.uniqueName) {
                                return priceList;
                            }
                        });
                    }

                    return location;
                });

            var defaultPriceList = globalFunctions.getDefaultPriceListFromLocation(globalFunctions.getSelectedLocationFromStorage());
            
            var showUpdatePopup = false;

            for (var location of availableTargetLocations) {
                if (Array.isArray(location.priceLists) && location.priceLists.length) {
                    showUpdatePopup = true;
                    break;
                }
            }

            if (!showUpdatePopup) {
                void 0;
                return;
            }

            var syncProductsData = {
                products: Array.isArray(productData) ? productData : [productData],
                source: {
                    location: globalFunctions.getSelectedLocationFromStorage(),
                    priceList: globalFunctions.getAdminSelectedPriceListFromStorage() || defaultPriceList,
                },
                availableTargets: availableTargetLocations
            };
            ngDialog.open({
                template:
                    '<div><sync-products-popup '
                    + 'products="ngDialogData.products" '
                    + 'source-location="ngDialogData.sourceLocation" '
                    + 'available-target-locations="ngDialogData.availableTargetLocations" '
                    + 'on-close="closeThisDialog(ngDialogData)" '
                    + '></sync-products-popup></div>',
                className: 'ngdialog-theme-default email-capture',
                plain: true,
                data: {
                    products: syncProductsData.products,
                    sourceLocation: syncProductsData.source,
                    availableTargetLocations: syncProductsData.availableTargets,
                    enableShowConfirmation: true
                }
            }).closePromise
        },
        openZoomDialog: function(imageUrl) {
            ngDialog.open({
                template:
                    '<div ng-class="$root.screenWidth.xs ? \'full-height\':\'vh87\'"'
                    + 'class="full-width horizontal-align-middle vertical-align-middle"'
                    + '><image-zoom-component '
                    + 'image="ngDialogData.url" class="full-height"'
                    +'></image-zoom-component></div>',
                className: 'ngdialog-theme-default zoom vertical-align-middle',
                plain: true,
                data: {
                    url: imageUrl
                }
            });
        }
    };
}

angular.module('homesome.factories').factory('ebtService', [ 'hsAdmin', 'hsUtils', '$http', '$cacheFactory', '$rootScope', 'globalFunctions', ebtService ]);

function ebtService(hsAdmin, hsUtils, $http, $cacheFactory, $rootScope, globalFunctions) {
    var constants = {
        sdkScript: 'https://prod-forage-sdk.s3.us-west-2.amazonaws.com/versions/1.0.4/sdk.js',
    };
    var service = {
        forageClientInstance: null,
        isEbtEnabled: function() {
            var selectedLocation = globalFunctions.getSelectedLocationFromStorage();
            return hsUtils.isObject(selectedLocation) && hsUtils.isObject(selectedLocation.ebtConfig) && selectedLocation.ebtConfig.enabled;
        },
        registerEvents: function () {
            $rootScope.$on('logout', function () {
                service.forageClientInstance = null;
            });
        },
        loadSdk: function () {
            if (window.Forage) return Promise.resolve(true);

            var hsForageCache = $cacheFactory.get('hsForage');

            if (!hsForageCache) {
                hsForageCache = $cacheFactory('hsForage');
            }
            var loadSdkReq = hsForageCache.get('loadSdk');

            if (loadSdkReq) return loadSdkReq;

            void 0;
            loadSdkReq = new Promise(function (res, rej) {
                    $.getScript(constants.sdkScript, function () {
                        if (window.Forage) return res(true);

                        rej('Failed to load Forage SDK');
                    });
                })
                .finally(function () {
                    if (hsForageCache && hsForageCache.get('loadSdk')) {
                        hsForageCache.remove('loadSdk');
                    }
                });

            hsForageCache.put('loadSdk', loadSdkReq);
            return loadSdkReq;
        },
        getToken: function () {
            if (!$rootScope.loggedIn || !hsUtils.isObject($rootScope.currentUser)) {
                return Promise.reject('User is not logged in.');
            }
            if (!service.shouldFetchNewToken()) {
                var tokenData = service.getCachedToken();
                if (tokenData) return Promise.resolve(tokenData);
            }
            var hsForageCache = $cacheFactory.get('hsForage');

            if (!hsForageCache) {
                hsForageCache = $cacheFactory('hsForage');
            }
            var getTokenReq = hsForageCache.get('getToken');

            if (getTokenReq) return getTokenReq;

            void 0;

            getTokenReq = $http.get(ENV.apiEndPoint + '/ebt/token')
                .then(function (res) {
                    if (res.status === 200) {
                        service.cacheToken(res.data);

                        var tokenCopy = JSON.parse(JSON.stringify(res.data));

                        tokenCopy.reloadClient = true;
                        return tokenCopy;
                    }
                    return Promise.reject(hsUtils.getMessageFromError(res.data, 'Failed to get token.'));
                })
                .then(function (token) {
                    void 0;
                    return token;
                })
                .finally(function () {
                    if (hsForageCache && hsForageCache.get('getToken')) {
                        hsForageCache.remove('getToken');
                    }
                });

            hsForageCache.put('getToken', getTokenReq);
            return getTokenReq;
        },
        cacheToken: function (token) {
            var hsForageCache = $cacheFactory.get('hsForage');

            if (!hsForageCache) {
                hsForageCache = $cacheFactory('hsForage');
            }
            hsForageCache.put('token', token);
        },
        getCachedToken: function () {
            var hsForageCache = $cacheFactory.get('hsForage');
            return hsForageCache ? hsForageCache.get('token') : null;
        },
        shouldFetchNewToken: function () {
            if (!hsUtils.isObject(service.forageClientInstance)) return true;

            var tokenData = service.getCachedToken();

            if (!hsUtils.isObject(tokenData)) return true;

            return service.isTokenExpired(tokenData);
        },
        isTokenExpired: function (tokenData) {
            var expired = new Date(tokenData.expiresAt) < new Date();
            void 0;
            return expired;
        },
        getClient: function () {
            var hsForageCache = $cacheFactory.get('hsForage');

            if (!hsForageCache) {
                hsForageCache = $cacheFactory('hsForage');
            }
            var getClientReq = hsForageCache.get('getClient');

            if (getClientReq) return getClientReq;

            getClientReq = service.loadSdk()
                .then(function (isLoaded) {
                    if (!isLoaded) return Promise.reject('Failed to load Forage SDK.');

                    return service.getToken();
                })
                .then(function (token) {
                    if (token.reloadClient || !service.forageClientInstance) {
                        return service.initializeClient(token);
                    }
                    return service.forageClientInstance;
                })
                .finally(function () {
                    if (hsForageCache && hsForageCache.get('getClient')) {
                        hsForageCache.remove('getClient');
                    }
                });

            hsForageCache.put('getClient', getClientReq);
            return getClientReq;
        },
        initializeClient: function (token) {
            void 0;

            service.forageClientInstance = Forage({
                fnsNumber: token.fnsNumber,
                sessionToken: token.token,
                customerId: token.userId,
                appearance: {
                    variables: {
                        borderRadius: '8px'
                    },
                },
            });
            return service.forageClientInstance;
        },
        getUserFriendlyError: function (err) {
            void 0
            var genericError = 'Oops! Something went wrong. Please try again. If this problem persists, please contact merchant support.';

            if (!hsUtils.isObject(err) || !hsUtils.isNonEmptyArray(err.errors)) return genericError;

            var codes = {
                ebt_error_02: 'Bad FNS status for merchant.',
                ebt_error_03: 'Invalid merchant.',
                ebt_error_14: 'Invalid card number.',
                ebt_error_54: 'Card expired.',
                ebt_error_59: 'Cannot process. Please call the number on the back of your EBT card for assistance.', // fraud
                // the required errors
                ebt_error_05: genericError,
                ebt_error_14: 'Invalid card number. Please check the card number and try again or call the number on the back of your EBT card for assistance.',
                ebt_error_41: 'Restricted card, cannot be used. Please call the number on the back of your EBT card for assistance.',
                ebt_error_51: 'Insufficient funds.',
                ebt_error_55: 'The PIN you have entered is incorrect. Please try again.',
                ebt_error_61: 'Please contact merchant support to complete the refund with an alternate payment method.',
                ebt_error_75: 'Your card was locked after too many incorrect PIN attempts. Please call the number on the back of your card for assistance.',
                ebt_error_76: genericError,
                ebt_error_90: 'The EBT network is currently offline. Please try again later.',
                ebt_error_92: genericError,
                ebt_error_96: genericError,
                T1: 'Oops! Something went wrong. Please try again. If this problem persists, please contact member services.',
            };
            codes.ebt_error_56 = codes.ebt_error_14;

            codes.ebt_error_43 = codes.ebt_error_41; // lost or stolen
            codes.ebt_error_62 = codes.ebt_error_41;

            codes.ebt_error_91 = codes.ebt_error_90;

            // These have different messages depending on a sequence of events,
            // but I think only apply to credit cards.
            codes.C1 = codes.T1;
            codes.C2 = codes.T1;

            var error = err.errors[0];

            if (error.code === 'ebt_error_51' && hsUtils.isNonEmptyString(error.message)) {
                // Need to show balance by FNS requirements which is returned in the message.
                // ex: Insufficient funds - Insufficient Funds. Remaining balances are SNAP: $100.00, EBT Cash: $100.00
                return error.message.split(' - ')[1] || error.message;
            }
            return codes[error.code] || error.message || genericError;
        },
        submitRefund: function(orderKey, amount, reason) {

            var data = {
                orderKey: orderKey,
                amount: amount,
                fundingType: 'snap',
                reason: reason,
            };

            return hsAdmin.processRefund({ refund: data })
                .then(function(res) {
                    if (res.status === 200) {
                        return res.data;
                    }
                    throw res.data;
                })
                .catch(function(err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to submit refund. Please try again.');
                });
        },
        startSession: function(amount, fulfillmentMethod) {
            var data = {
                amount: amount,
                fundingType: 'snap',
                fulfillmentMethod: fulfillmentMethod,
            };
            return $http.post(ENV.apiEndPoint + '/ebt/session', data)
                .then(function (res) {
                    if (res.status === 200) {
                        return res.data;
                    }
                    return Promise.reject(hsUtils.getMessageFromError(res.data, 'Failed to start EBT session.'));
                });
        },
    };
    return service;
};
angular.module('homesome.factories').factory('aiSearchEvents', [ 'globalFunctions', 'hsAuth', '$location', 'hsUtils', aiSearchEventsService ]);

function aiSearchEventsService(globalFunctions, hsAuth, $location, hsUtils) {
    var service = {
		eventAction: {
			QUERY: 'query',
			ADD_TO_CART: 'addToCart',
			SEARCH_ITEM_RANK: 'searchItemRank',
			UNSUCCESSFUL_SEARCH: 'unsuccessfulSearch',
			PURCHASE: 'purchase',
		},
		getEventCategory(path) {
			if (!path) {
				path = $location.path();
			}

			if (path === '/products') {
				return globalFunctions.GAEventType.PRODUCT_LANDING;
			} else if (path === '/search') {
				return globalFunctions.GAEventType.SEARCH;
			} else if (path === '/my-account') {
				return globalFunctions.GAEventType.MY_ACCOUNT;
			} else if (path.startsWith('/shop/')) {
				return globalFunctions.GAEventType.PRODUCT_CATERGORY;
			} else {
				return globalFunctions.GAEventType.UNKNOWN;
			}
		},
		sendEvent(category, action, label) {
			var user = hsAuth.getUser();
			
			if (!hsUtils.isObject(user)) {
				globalFunctions.sendGAEvent(category, action, 'Unknown User<>' + label);
			} else {
				if (!hsUtils.isNonEmptyString(user.hashedEmail)) {
					hsAuth.getUpdatedUser()
						.then(function(resp) {
							user = resp.data;
							globalFunctions.sendGAEvent(category, action, user.hashedEmail + '<>' + label);
						})
						.catch(function(err) {
							void 0;
						})
				} else {
					globalFunctions.sendGAEvent(category, action, user.hashedEmail + '<>' + label);
				}
			}
		}
	}

    return service;
};
angular.module('homesome.factories').factory('hsImageUpload', [
    imageUploadService
]);

function imageUploadService() {
    var service = {
        checkIfImageExists(url) {
            return new Promise(function(resolve) {
                const img = new Image();
                img.src = url;
              
                if (img.complete) {
                    resolve(true);
                } else {
                    img.onload = function() {
                        resolve(true);
                    };
                  
                    img.onerror = function() {
                        resolve(false);
                    };
                }
            });
        }    
    }
    return service;
}
'use strict';

angular.module('homesome.factories').factory('hsLogin', ['localStorageService', '$location', 'hsAuth', '$rootScope', 'hsCart', 'toastr', '$http', hsLogin]);

function hsLogin(localStorageService, $location, hsAuth, $rootScope, hsCart, toastr, $http) {
    var service = {
        processLogin(response, redirectLink, routeParams) {
            localStorageService.remove('user_email');
            hsAuth.saveUserLocal(response.data);
            $rootScope.currentUser = response.data;
            $rootScope.loggedIn = true;

            var basket = localStorageService.get('basket');

            if (basket && Array.isArray(basket)) {
                hsCart
                    .addItemToCart({
                        items: basket.map(function (item) {
                            return {
                                name: item.name,
                                quantity: item.quantity,
                                isCustomItem: false,
                                canReplace: item.canReplace,
                                instructions: item.instructions || '',
                                displayName: item.displayName,
                                type: item.type,
                                subType: item.subType,
                                organic: item.organic,
                                unit: item.unit,
                                selectedModifiers: item.selectedModifiers
                                    ? item.selectedModifiers.map(function (option) {
                                          return option.name;
                                      })
                                    : [],
                            };
                        }),
                    })
                    .then(function (res) {
                        void 0;
                        if (res.status === 200) {
                            toastr.success('cart updated successfully.');
                            localStorageService.remove('basket');

                            $rootScope.$emit('cartUpdated', true);

                            if (redirectLink) {
                                $location.url(redirectLink);
                            } else if (Object.keys(routeParams).length > 0) {
                                var urlParams = {};
                                for (var prop in routeParams) {
                                    if (prop !== 'multipleParams' && prop !== 'urlPath') {
                                        urlParams[prop] = routeParams[prop];
                                    }
                                }

                                $location.path(routeParams['urlPath']).search(urlParams);
                            } else {
                                $location.url('/products');
                            }
                        } else {
                            $location.url('/products');
                            void 0;
                        }
                    });
            } else {
                localStorageService.remove('user');
                hsAuth.saveUserLocal(response.data);
                $rootScope.$emit('cartUpdated', true);

                if (redirectLink) {
                    $location.url(redirectLink);
                } else if (Object.keys(routeParams).length > 0) {
                    var urlParams = {};
                    for (var prop in routeParams) {
                        if (prop !== 'multipleParams' && prop !== 'urlPath') {
                            urlParams[prop] = routeParams[prop];
                        }
                    }

                    $location.path(routeParams['urlPath']).search(urlParams);
                } else {
                    $location.url('/products');
                }
            }
        },
		getUserForAppLogin: function () {
			return $http.get(ENV.apiEndPoint + '/user')
                .then(function(response){
                    return response;
                })
                .catch(function(error){
                    // caller should handle non-200 response
                    return error;
                });
        },
    };

    return service;
}

angular.module('homesome.factories').factory('hsManagedDelivery', ['$http', 'ENV', hsManagedDelivery]);

function hsManagedDelivery($http, ENV) {

    return {
        UNCANCELLABLE_DELIVERY_STATUSES: [
            'pickup_complete',
 			'delivered',
 			'dropoff',
 			'returned',
 			'canceled'
        ],
        requestCancelDelivery: function (reqBody){
            return $http.post(ENV.apiEndPoint + '/order/delivery', reqBody)
                .catch(function (error) {
                    return error;
                });
        }
    };
}

angular.module('homesome.factories').factory('hsMarketingService', [ 'localStorageService', 'hsUtils', '$routeParams', '$location', '$rootScope', hsMarketingService ]);

function hsMarketingService(localStorageService, hsUtils, $routeParams, $location, $rootScope) {

    var service = {
        setMarketingQueryPriceList: function() {
			var location = localStorageService.get('location');
			var priceList = localStorageService.get('selectedPriceList');
            var pListName =  $location.search().pListName;
            if (!pListName) {
                return;
            }
			if (hsUtils.isObject(location) && hsUtils.isObject(priceList) && hsUtils.isObject($routeParams) && priceList.name !== pListName) {
				var found = false;
				location.selectedLocation.priceLists.forEach(function (pl) {
					if (service.isMatchingPriceList(pListName, pl)) {
						localStorageService.set('selectedPriceList', pl);
						$rootScope.selectedPriceList = pl;
						found = true;
					}
				});
				if (!found) {
					$location.path('/products');
				}
			}
		},
        isMatchingPriceList: function (pListName, priceList) {
            if (!hsUtils.isNonEmptyString(pListName) || !hsUtils.isObject(priceList)) {
                return false;
            }

            pListName = pListName.toLowerCase();
            var priceListName = priceList.name.toLowerCase();
            var priceListPListName = priceList.pListName;

            var namesToCheck = [priceListName, priceListPListName];

            return namesToCheck.includes(pListName);
        },
        isMatchingLocation: function (locName, location) {
            if (!hsUtils.isNonEmptyString(locName) || !hsUtils.isObject(location)) {
                return false;
            }

            locName = locName.toLowerCase();
            var locationLocName = location.locName;
            
            return locationLocName === locName;
        },
        getDirectLinkingQueryParams: function() {
            var queryParams = $location.search();
            var retVal = {};

            if (queryParams.locName) {
                retVal.locName = queryParams.locName;
            }

            if (queryParams.pListName) {
                retVal.pListName = queryParams.pListName;
            }

            return Object.keys(retVal).length > 0 ? retVal : null;
        },
        clearDirectLinkingQueryParams: function() {
            $location.search('locName', null);
            $location.search('pListName', null);
        }
	};
    
    
    return service;
}
angular.module('homesome.factories').factory('hsMasonryGrid', ['globalFunctions', '$q', 'hsUtils', masonryGridService]);

function masonryGridService(globalFunctions, $q, hsUtils) {
	var service = {
		LAYOUTS: {
			FOURTEEN_CELL: {
				ID: 'FOURTEEN_CELL',
				HERO_CARD_IDS: [],
				BUTTON_CARD_IDS: [ 'card2' ],
				DEFAULT: {
					CLASS: 'masonry-grid-14',
				},
				MOBILE: {
					CLASS: 'masonry-grid-14-mobile'
				},
				TABLET: {
					CLASS: 'masonry-grid-14-tablet'
				}
			}
		},
		getTargetPriceList: function() {
			var location = globalFunctions.getSelectedLocationFromStorage();
			var priceList = globalFunctions.getSelectedPriceListFromStorage();
			if (!hsUtils.isObject(priceList)) {
				if (hsUtils.isObject(location) && hsUtils.isArray(location.priceLists)) {
					priceList = location.priceLists.find(function (pl) {
						return pl.default && !pl.isDisabled;
					});
					if (!hsUtils.isObject(priceList)) {
						priceList = location.priceLists.find(function (pl) {
							return !pl.isDisabled;
						});
					}
				}
			}
			return priceList;
		},
		getGridData: function() {
			var mockedData = {
				grid: {
					layout: 'FOURTEEN_CELL',
					roundedCorners: false,
				},
				cards: [
					{
						id: 'card1',
						title: 'Easter',
						textPositionY: 'top',
						textPositionX: 'left',
						linkTitle: 'Shop Now',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-1.jpg',
						linkURL: '/shop/Easter'
					},
					{
						id: 'card2',
						title: 'Breakfast &<br>Brunch',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-2.jpg',
						linkURL: '/shop/BreakfastBrunch'
					},
					{
						id: 'card3',
						title: 'Box Lunch',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-3.jpg',
						linkURL: '/shop/BoxLunch'
					},
					{
						id: 'card4',
						title: 'Appetizers & Party<br>Platters',
						linkTitle: 'Shop Now',
						textPositionY: 'bottom',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-4.jpg',
						linkURL: '/shop/AppetizersPartyPlatters'
					},
					{
						id: 'card5',
						title: 'Sandwiches',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'right',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-5.jpg',
						linkURL: '/shop/Sandwiches'
					},
					{
						id: 'card6',
						title: 'Sushi',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-6.jpg',
						linkURL: '/shop/Sushi'
					},
					{
						id: 'card7',
						title: 'Cheese &<br>Charcuterie',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-7.jpg',
						linkURL: '/shop/CheeseCharcuterie'
					},
					{
						id: 'card8',
						title: 'Soups & Salads',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-8.jpg',
						linkURL: '/shop/SoupsSalads'
					},
					{
						id: 'card9',
						title: 'Bakery',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-9.jpg',
						linkURL: '/shop/Bakery'
					},
					{
						id: 'card10',
						title: 'Beverages',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-10.jpg',
						linkURL: '/shop/Beverages'
					},
					{
						id: 'card11',
						title: 'Beer, Wine &<br>Spirits',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-11.jpg',
						linkURL: '/shop/BeerWineSpirits'
					},
					{
						id: 'card12',
						title: 'Meal For<br>Two',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-12.jpg',
						linkURL: '/shop/MealforTwo'
					},
					{
						id: 'card13',
						title: 'Entrees &<br>Seasonal<br>Sides',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-13.jpg',
						linkURL: '/shop/EntreesSeasonalSides'
					},
					{
						id: 'card14',
						title: 'Floral',
						linkTitle: 'Shop Now',
						textPositionY: 'top',
						textPositionX: 'left',
						imageURL: 'https://s3.us-west-2.amazonaws.com/www.gethomesome.com/productimages/mollie-stones-catering-grid-14-card-14.jpg',
						linkURL: '/shop/Floral'
					},
				],
			};
			
			var mockedDataByPriceList = {
				'42ECA60E-2374-4986-A006-CBCF02E79991': mockedData, // mollie-stones greenbrae catering
				'9A5C47C4-5F0D-4D27-8DC7-A7A120641189': mockedData, // mollie-stones sausalito catering
				'0F1C3DC6-4B13-4920-8199-7805B23D371E': mockedData, // mollie-stones san-francisco-pacific-heights catering
				'CB65C321-51F8-448F-A560-C901A68E936B': mockedData, // mollie-stones san-francisco-twin-peaks catering
				'F1AF9A79-3451-455A-9D12-D3513F99DB50': mockedData, // mollie-stones san-bruno catering
				'7CCD64FB-1379-4E79-8516-1D4003EFDF75': mockedData, // mollie-stones san-mateo catering
				'CB7F0751-DE3B-4C0C-BAEF-6C9DEFBE8D37': mockedData, // mollie-stones burlingame catering
				'73804AAF-8000-49CC-839D-2E4A79554E57': mockedData, // mollie-stones palo-alto catering
				'C976E887-F37F-4E6B-9E7B-8A779FB01F37': mockedData, // test-store herzliya groceries
			};
			
			var deferred = $q.defer();
			try {
				var data = null;
				var targetPriceList = service.getTargetPriceList();
				
				if (!targetPriceList) {
					throw 'No pricelist';
				}
				if (!targetPriceList.useMasonryGridLanding) {
					throw 'Should not show masonry grid';
				}
				if (!mockedDataByPriceList.hasOwnProperty(targetPriceList.uniqueName)) {
					throw `No mocked data for pricelist ${targetPriceList.uniqueName}`;
				}
				data = mockedDataByPriceList[targetPriceList.uniqueName];
				
				deferred.resolve(data);
				
			} catch (err) {
				deferred.reject(err);
			}
			return deferred.promise;
		}
	}
	return service;
}

angular.module('homesome.factories').factory('hsModifiers', ['globalFunctions', 'localStorageService', '$http', 'hsUtils', modifiersService]);

function modifiersService(globalFunctions, localStorageService, $http, hsUtils) {
    var service = {
        TAX_MODIFICATIONS: {
            NONE: '', 
            MODIFIER: 'modifier',
            PRODUCT: 'product'
        },
        TEMPLATES: {
            CREATE_MODIFIER: 'create',
            EDIT_MODIFIER: 'edit',
            LIMITED_EDIT_MODIFIER: 'limitedEdit',
            PRODUCT_SELECTION: 'itemSelection'
        },
        DRAWERS: {
            OPTIONS: 'options',
            LINKED_PRODUCTS: 'linkedProducts'
        },
        PRODUCT_SELECTION_STATES: {
            ALL_ITEMS: 'allItems',
            SELECTED_ITEMS: 'selectedItems'
        },
        MODIFIER_TYPES: {
            MODIFIER: 'modifier',
            PRODUCT: 'product'
        },
        modifierValidator: {
            rules: {
                displayName: {
                    required: true,
                },
                minSelections: {
                    number: true,
                },
                maxSelections: {
                    number: true,
                },
            },
            messages: {
                minSelections: {
                    number: "Please enter a number",
                },
                maxSelections: {
                    number: "Please enter a number",
                },
            },
        },
        optionValidator: {
            rules: {
                optionDisplayName: {
                    required: true,
                },
                optionPrice: {
                    number: true
                }
            },
            messages: {
                price: {
                    number: "Please enter a number",
                }
            }
        },
        NEW_MODIFIER: {
            displayName: '',
            type: 'modifier',
            singleSelection: false,
            selectionRequired: false,
            minSelections: 0,
            maxSelections: 0,
            options: [],
            defaultOption: '',
        },
        NEW_MODIFIER_OPTION: {
            displayName: '',
            price: 0,
            upc: '',
            taxModification: ''
        },
        getSelectedLocation: function() {
            return globalFunctions.getSelectedLocationFromStorage();
        },
        getSelectedPriceList: function() {
            var adminSelectedPriceList = localStorageService.get('adminSelectedPriceList');
            if (adminSelectedPriceList) {
                return adminSelectedPriceList;
            }
            return null;
        },
        getHeaders: function(target) {
            var location = service.getSelectedLocation();
            var priceList = service.getSelectedPriceList();

            var headers = {};

            if (location) {
                headers.location = location.uniqueName;
            }

            if (priceList) {
                headers.pricelist = priceList.uniqueName;
            }

            if (hsUtils.isNonEmptyObject(target)) {
                headers.location = target.locationUniqueName;
                headers.pricelist = target.priceListUniqueName;
            }

            return headers;
        },
        getAllModifiers: function() {
            var headers = service.getHeaders();
            var url = new URL('/product/modifiers', ENV.apiEndPoint);
            return $http.get(url.toString(), { headers: headers })
                .then(function(res) {
                    if (res.status !== 200) {
                        throw 'Failed to load modifiers';
                    }
                    return res.data;
                })
                .catch(function(err){
                    throw 'Failed to load modifiers';
                });
        },
        getModifier: function(modifierName) {
            var headers = service.getHeaders();
            var url = new URL('/product/modifier', ENV.apiEndPoint);
            url.searchParams.set('name', modifierName);
            return $http.get(url.toString(), { headers: headers })
                .then(function(res) {
                    if (res.status !== 200) {
                        throw 'Failed to load modifier';
                    }
                    return res.data;
                })
                .catch(function(err) {
                    throw 'Failed to load modifier';
                });
        },
        createModifier: function(modifierData, createProductList, target) {
            var headers = service.getHeaders(target);
            var url = new URL('/product/modifier', ENV.apiEndPoint);
            return $http.post(url.toString(), { modifier: modifierData },  { headers: headers })
                .then(function(modifierRes) {
                    if (modifierRes.status !== 200) {
                        throw modifierRes;
                    }
                    if (createProductList) {
                        return service.createProductList(target)
                            .then(function(productListRes) {
                                return modifierRes.data;
                            })
                            .catch(function(err) {
                                throw err;
                            });
                    }
                    return modifierRes.data;
                })
                .catch(function(err) {
                    void 0;
                    throw err;
                });
        },
        getModifierProducts: function(modifierName) {
            var headers = service.getHeaders();
            var url = new URL('/product/list', ENV.apiEndPoint);
            url.searchParams.set('includeAllItems', true);
            return $http.get(url.toString(), { headers: headers })
                .then(function(res) {
                    if (res.status !== 200) {
                        throw 'Failed to load products';
                    }
                    var products = res.data.products;
                    var modifierProducts = products.filter(function(product) {
                        if (!product.hasModifiers) {
                            return false;
                        }
                        for (var modifier of product.modifiers) {
                            if (modifier.name === modifierName) {
                                return true;
                            }
                        }
                        return false;
                    });

                    return {
                        allProducts: products,
                        linkedProducts: modifierProducts
                    };
                })
                .catch(function(err) {
                    throw 'Failed to load products';
                });
        },
        updateModifier: function(modifierData) {
            var headers = service.getHeaders();
            var url = new URL('/product/modifier', ENV.apiEndPoint);
            return $http.put(url.toString(), { modifier: modifierData }, { headers: headers })
                .then(function(res) {
                    if (res.status !== 200) {
                        throw 'Failed to update modifier';
                    }
                    return res.data;
                })
                .catch(function(err) {
                    throw 'Failed to update modifier';
                });
        },
        updateProducts: function(updates, target, updateErrors) {
            if (updates.length === 0) {
                if (Array.isArray(updateErrors)) {
                    // For the purpose of propagating changes to other pricelists, if all errors are 404
                    // we will return a 404 so we know that updates are not available. Otherwise we will
                    // return an error message and the handler will know it was not due to products not
                    // being available at the target.
                    var allErrorsAre404 = updateErrors.every(function(err) {
                        return err.status === 404;
                    });
                    if (allErrorsAre404) {
                        throw {
                            status: 404,
                            message: 'Product(s) not found'
                        };
                    } else {
                        throw 'One or more products failed to update';
                    }
                }
                return;
            }

            var isFinalUpdate = updates.length === 1;
            var productData = updates[0];
            productData.createList = isFinalUpdate;

            var headers = service.getHeaders(target);
            var url = new URL('/product', ENV.apiEndPoint);
            return $http.put(url.toString(), { product: productData }, { headers: headers })
                .then(function(updateProductRes) {

                    if (updateProductRes.status !== 200) {
                        // if the final product update fails we should still create the list
                        if (productData.createList) {
                            return service.createProductList(target).then(function(res) {
                                // throwing original error on successful product list creation
                                throw updateProductRes;
                            }); 
                        }
                        throw updateProductRes;
                    }

                    void 0;
                })
                .catch(function(err) {
                    void 0;
                    if (Array.isArray(updateErrors)) {
                        updateErrors.push(err);
                    } else {
                        updateErrors = [err];
                    }
                })
                .finally(function() {
                    updates.splice(0,1);
                    return service.updateProducts(updates, target, updateErrors);
                });
        },
        getProduct: function(productName) {
            var headers = service.getHeaders();
            var url = new URL('/product', ENV.apiEndPoint);
            url.searchParams.set('name', productName);
            return $http.get(url.toString(), { headers: headers })
                .then((function(res) {
                    if (res.status !== 200) {
                        throw 'There was an error fetching product with name = ' + productName;
                    }
                    return res.data;
                }))
                .catch(function(err) {
                    throw 'Failed to get product';
                });
        },
        createProductList: function(target) {
            var headers = service.getHeaders(target);
            var url = new URL('/product/list', ENV.apiEndPoint);
            return $http.post(url.toString(), { headers: headers })
                .then((function(res) {
                    if (res.status !== 200) {
                        throw res;
                    }
                    void 0;
                    return res.data;
                }))
                .catch(function(err) {
                    void 0;
                    throw err;
                });
        },
        createModifierAndUpdateProducts: function(updateData, target) {
            if (!hsUtils.isObject(updateData.modifierData)) {
                throw 'Missing modifier data';
            }

            updateData = JSON.parse(JSON.stringify(updateData));
            
            if (!Array.isArray(updateData.productUpdates)) {
                updateData.productUpdates = [];
            }

            var shouldCreateProductList = !updateData.productUpdates.length;

            return service.createModifier(updateData.modifierData, shouldCreateProductList, target)
                .then(function(modifierRes) {
                    if (!updateData.productUpdates.length) {
                        return {
                            modifierData: modifierRes
                        };
                    }
                    return service.updateProducts(updateData.productUpdates, target)
                        .then(function(productRes) {
                            return {
                                modifierData: modifierRes,
                                productUpdates: productRes 
                            };
                        })
                        .catch(function(err) {
                            void 0;
                            throw err;
                        });
                })
                .catch(function(err) {
                    void 0;
                    throw err;
                });
        },
    };
    return service;
}
angular.module('homesome.factories').factory('hsPickingApp', [ hsPickingAppService ]);

function hsPickingAppService() {
	return {
		REACT_NATIVE_EVENT_TYPES: {
			EXTERNAL_URL_REDIRECT: 'external_url_redirect',
			LOGOUT: 'logout',
            LOCATION_UPDATE: 'location_update',
            INIT_FE_STATE: 'init_fe_state',
		},
        isWrapped: function() {
            return !!(window.ReactNativeWebView && window.ReactNativeWebView.postMessage);
        },
        postMessage: function(message) {
            if (this.isWrapped()) {
                window.ReactNativeWebView.postMessage(JSON.stringify(message));
            }
        }
	};
}
hsApp.factory('promoValidators', function () {
    return {
        promotion: {
            rules: {
                name: {
                    required: true,
                },
                displayName: {
                    // required: true,
                },
                startDate: {
                    required: true,
                    date: true,
                },
                endDate: {
                    required: true,
                    date: true,
                },
                maxUses: {
                    number: true,
                    min: 0,
                },
                linkCode: {
                    required: true,
                },
            },
        },
        itemGroup: {
            rules: {
                name: {
                    required: true,
                },
                displayName: {
                    // required: true,
                },
                type: {
                    required: true,
                },
                sourceType: {
                    required: true,
                },
                rewardsType: {
                    required: true,
                },
                rewardsValue: {
                    required: true,
                    number: true,
                    gt: 0,
                },
                eligibilityQuantity: {
                    required: true,
                    number: true,
                    min: 0,
                },
                // rewardsQuantity: {
                //     required: true,
                //     number: true,
                //     min: 0,
                // },
                maxUsesPerItem: {
                    required: true,
                    number: true,
                    min: 0,
                },
                maxUsesPerOrder: {
                    required: true,
                    number: true,
                    min: 0,
                },
            },
        },
    };
});

angular.module('homesome.factories').factory('hsPromos', [
    '$rootScope', '$http', '$q', 'ENV', 'hsAdmin', 'ngDialog', 'toastr', 'promoValidators', 'globalFunctions', 'hsUtils', hsPromos
]);

function hsPromos($rootScope, $http, $q, ENV, hsAdmin, ngDialog, toastr, promoValidators, globalFunctions, hsUtils) {

    var service = {
        validators: promoValidators,
        sourceTypes: {
            INDIVIDUAL: 'individual',
            GROUP: 'group',
        },
        types: {
            PREORDER: 'preorder',
            FEATURED: 'featuredItem',
            DEAL: 'deal',
            DISCOUNT: 'discount',
            FREE_ITEM: 'freeItem',
        },
        rewardsTypes: {
            DOLLAR: 'dollar',
            PERCENT: 'percent',
        },
        scopes: {
            SAME_ITEM: 'sameItem',
            MIX_AND_MATCH: 'mixAndMatch',
        },
        promotions: null,
        userGroups: null,
        ongoingPromotions: null,
        getPriceListUniqueName: function(isAdmin) {
            if (!isAdmin) return $q.resolve(null);

            return hsAdmin.getSelectedPriceList()
                .then(function(priceList) {
                    if (priceList) return priceList.uniqueName;
                    return null;
                });
        },
        getOngoingPromotions: function(user, onlyApplicable, forOrderKey, headersParams) {
            var url = new URL('/promotions/today', ENV.apiEndPoint);
            var headers = {};

            if (hsUtils.isObject(headersParams)) {
                headers = headersParams;
            }
            if (onlyApplicable) {
                url.searchParams.append('onlyApplicable', true);
            }
            var userGroupsParams = service.getUserGroupsParams(user);

            if (userGroupsParams) {
                url.searchParams.append('userGroups', userGroupsParams);
            }
            if (forOrderKey) {
                url.searchParams.append('forOrderKey', forOrderKey);
            }
            return $http.get(url.toString(), { headers: headers })
                .then(function(res) {
                    if (res.status === 200) {
                        service.ongoingPromotions = res.data;
                        return service.ongoingPromotions;
                    }
                    throw new Error('Failed to get on-going promotions.');
                });

        },
        getPromotions: function() {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.get(ENV.apiEndPoint + '/promotions', { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                service.promotions = res.data;
                                return service.promotions;
                            }
                            throw new Error('Failed to get promotions.');
                        });

                });
        },
        createPromotion: function(promotion) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.post(ENV.apiEndPoint + '/promotion', promotion, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var newPromotion = res.data;
                                service.promotions.unshift(newPromotion);
                                return newPromotion;
                            }
                            var message = res.data && res.data.message || 'Failed to create promotion.';
                            throw new Error(message);
                        });

                });
        },
        updatePromotion: function(promotion) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }


                    return $http.put(ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotion.id), promotion, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var updatedPromotion = res.data;
                                var index = service.promotions.findIndex(function(promotion) {
                                    return promotion.id === updatedPromotion.id;
                                });
                                if (index === -1) throw 'Failed to get promotion index';

                                service.promotions[index] = updatedPromotion;

                                return updatedPromotion;
                            }
                            var message = res.data && res.data.message || 'Failed to update promotion.';
                            throw new Error(message);
                        });

                });
        },
        deletePromotion: function(promotionId) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.delete(ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotionId), { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {

                                var index = service.promotions.findIndex(function(promotion) {
                                    return promotion.id === promotionId;
                                });
                                if (index === -1) throw 'Failed to get promotion index';

                                service.promotions.splice(index, 1);

                                return;
                            }
                            var message = res.data && res.data.message || 'Failed to delete promotion.';
                            throw new Error(message);
                        });

                });
        },
        clonePromotion: function(promotion) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    var url = ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotion.id) + '/clone';

                    return $http.post(url, promotion, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var newPromotion = res.data;
                                service.promotions.unshift(newPromotion);
                                return newPromotion;
                            }
                            var message = res.data && res.data.message || 'Failed to clone promotion.';
                            throw new Error(message);
                        });

                });
        },
        createItemGroup: function(promotion, itemGroup) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    var url = ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotion.id) + '/itemGroup';

                    return $http.post(url, itemGroup, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var newItemGroup = res.data;
                                promotion.itemGroups.unshift(newItemGroup)
                                return res.data;
                            }
                            var message = res.data && res.data.message || 'Failed to create item group.';
                            throw new Error(message);
                        });

                });
        },
        updateItemGroup: function(promotion, itemGroup, originalItemGroupName) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    var url = ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotion.id)
                        + '/itemGroup/' + encodeURIComponent(originalItemGroupName);

                    return $http.put(url, itemGroup, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var itemGroup = res.data;
                                var index = promotion.itemGroups.findIndex(function(itemGroup) {
                                    return itemGroup.name === originalItemGroupName;
                                });
                                if (index === -1) {
                                    promotion.itemGroups.unshift(itemGroup)
                                } else {
                                    promotion.itemGroups[index] = itemGroup;
                                }
                                return res.data;
                            }
                            var message = res.data && res.data.message || 'Failed to update item group.';
                            throw new Error(message);
                        });

                });
        },
        deleteItemGroup: function(promotion, itemGroupName) {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }
                    var url = ENV.apiEndPoint + '/promotion/' + encodeURIComponent(promotion.id)
                        + '/itemGroup/' + encodeURIComponent(itemGroupName);

                    return $http.delete(url, { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                var index = promotion.itemGroups.findIndex(function(itemGroup) {
                                    return itemGroup.name === itemGroupName;
                                });
                                void 0
                                if (index === -1) throw 'Failed to get itemGroup index';

                                promotion.itemGroups.splice(index, 1);

                                return;
                            }
                            var message = res.data && res.data.message || 'Failed to delete item group.';
                            throw new Error(message);
                        });
                });
        },
        getUserGroups: function() {
            return this.getPriceListUniqueName(true)
                .then(function(priceListUniqueName) {
                    var headers = {};
                    if (priceListUniqueName) {
                        headers.pricelist = priceListUniqueName;
                    }

                    return $http.get(ENV.apiEndPoint + '/promotions/userGroups', { headers: headers })
                        .then(function(res) {
                            if (res.status === 200) {
                                service.userGroups = res.data;
                                return res.data;
                            }
                            throw new Error('Failed to get user groups.');
                        });

                });
        },
        isPromotionOnGoing: function(promotion) {
            var now = dayjs();
            var start = now.clone().startOf('day');
            var end = now.clone().endOf('day');

            start = start.set('year', promotion.startDate.year);
            start = start.set('month', promotion.startDate.month - 1);
            start = start.set('date', promotion.startDate.date);

            end = end.set('year', promotion.endDate.year);
            end = end.set('month', promotion.endDate.month - 1);
            end = end.set('date', promotion.endDate.date);

            var timezone = globalFunctions.getLocationTimezone();
            now = now.tz(timezone);
            start = start.tz(timezone, true);
            end = end.tz(timezone, true);

            return start <= now && now <= end;
        },
        getItemPromotions(item) {
            if (!hsUtils.isObject(item)) return [];
            if (!hsUtils.isObject(service.ongoingPromotions)) return [];
            if (!hsUtils.isObject(service.ongoingPromotions.promotions)) return [];
            if (!hsUtils.isObject(service.ongoingPromotions.byItem)) return [];
            if (!(item.name in service.ongoingPromotions.byItem)) return [];
            if (!hsUtils.isObject(service.ongoingPromotions.byItem[item.name])) return [];
            if (!Array.isArray(service.ongoingPromotions.byItem[item.name].byVolume)) return [];
            if (!service.ongoingPromotions.byItem[item.name].byVolume.length) return [];

            var promotions = service.ongoingPromotions.byItem[item.name].byVolume;

            promotions = promotions.filter(function (promoIndex) {
                if (!(promoIndex.promotionId in service.ongoingPromotions.promotions)) return false;
                if (!hsUtils.isObject(service.ongoingPromotions.promotions[promoIndex.promotionId])) return false;
                if (!hsUtils.isObject(service.ongoingPromotions.promotions[promoIndex.promotionId].itemGroups)) return false;
                if (!(promoIndex.itemGroupName in service.ongoingPromotions.promotions[promoIndex.promotionId].itemGroups)) return false;
                if (!service.ongoingPromotions.promotions[promoIndex.promotionId].itemGroups[promoIndex.itemGroupName].isVisible) return false;

                return true;
            });
            service.resolveAnyQuantityPromotions(item, promotions);

            return promotions;
        },
        resolveAnyQuantityPromotions(item, promotionsByVolume) {
            var weightItem = item.unit === 'lb' && !item.sellByQty;
            var anyQuantityPromo = null;
            var eq0Index = -1;
            var eq1Index = -1;

            for (var i = 0; i < promotionsByVolume.length; i++) {
                var promo = promotionsByVolume[i];

                if (promo.eligibilityQuantity > 1) break;

                if (promo.eligibilityQuantity === 0) {
                    eq0Index = i;
                } else if (promo.eligibilityQuantity === 1) {
                    eq1Index = i;
                    break;
                }
            }
            // weight items will keep both EQ === 0 and EQ === 1 if present, because EQ === 1 means that it requires at least 1LB
            if (eq1Index !== -1 && !weightItem) {
                var p1 = promotionsByVolume[eq1Index];

                if (eq0Index !== -1) {
                    var p0 = promotionsByVolume[eq0Index];

                    var p0UpdateDate = new Date(p0.updatedAt);
                    var p1UpdateDate = new Date(p1.updatedAt);

                    if (p0UpdateDate >= p1UpdateDate) {
                        anyQuantityPromo = p0;
                        promotionsByVolume.splice(eq1Index, 1);
                    } else {
                        anyQuantityPromo = p1;
                        promotionsByVolume.splice(eq0Index, 1);
                    }
                } else {
                    anyQuantityPromo = p1;
                }
            } else if (eq0Index !== -1) {
                anyQuantityPromo = promotionsByVolume[eq0Index];
            }
            if (anyQuantityPromo) {
                anyQuantityPromo.eligibilityQuantity = 0;
                anyQuantityPromo.applyInIncrementsOnly = false;
            }
        },
        getVisibleVolumePromotions(item) {
            var promotionsIndex = service.getItemPromotions(item);
            var promotions = [];
            var singleQuantityPromotion = null;
            var singleQuantityPromotionPrice = 0;

            if (!promotionsIndex.length) return promotions;

            // BE returns byVolume sorted
            main:
            for (var i = 0; i < promotionsIndex.length; i++) {
                var promoIndex = promotionsIndex[i];

                var promotion = angular.copy(service.ongoingPromotions.promotions[promoIndex.promotionId].itemGroups[promoIndex.itemGroupName]);
                promotion.eligibilityQuantity = promoIndex.eligibilityQuantity;
                promotion.applyInIncrementsOnly = promoIndex.applyInIncrementsOnly;

                if (![service.types.DEAL, service.types.DISCOUNT, service.types.FREE_ITEM].includes(promoIndex.promotionType)) continue;
                if (!promotion.eligibilityQuantity) {
                    var price = 0;
                    if (promoIndex.promotionType === service.types.DEAL) {
                        if (service.isValidPrice(promoIndex.promotionPrice) && promoIndex.promotionPrice < item.price) {
                            price = promoIndex.promotionPrice;
                        }
                    } else if (promoIndex.promotionType === service.types.DISCOUNT) {
                        price = service.getDiscountPrice(item, promotion);
                    }
                    if (price || promoIndex.promotionType === service.types.FREE_ITEM) {
                        if (!singleQuantityPromotionPrice || price < singleQuantityPromotionPrice) {
                            promotion.promotionPrice = price;
                            singleQuantityPromotionPrice = price;
                            singleQuantityPromotion = promotion;
                        }
                    }
                    continue;
                }

                if (promoIndex.promotionType === service.types.DEAL) {
                    if (!service.isValidPrice(promoIndex.promotionPrice) || promoIndex.promotionPrice >= item.price) continue;
                    promotion.promotionPrice = promoIndex.promotionPrice;
                } else if (promoIndex.promotionType === service.types.DISCOUNT) {
                    promotion.promotionPrice = service.getDiscountPrice(item, promotion);
                } else if (promoIndex.promotionType === service.types.FREE_ITEM) {
                    promotion.promotionPrice = service.getDiscountPrice(item, promotion);
                }
                if (singleQuantityPromotionPrice && promotion.promotionPrice >= singleQuantityPromotionPrice) continue;
                if (promotion.applyInIncrementsOnly === false) {
                    singleQuantityPromotionPrice = promotion.promotionPrice;
                }

                var quantity = promotion.eligibilityQuantity;
                var candidateItemizedPrice = service.getItemizedPrice(item, promotion, quantity);

                for (var j = 0; j < promotions.length; j++) {
                    var itemizedPrice = service.getItemizedPrice(item, promotions[j], quantity);

                    if (candidateItemizedPrice >= itemizedPrice) continue main;
                }
                promotions.push(promotion);
            }
            return promotions;
        },
        getItemizedPrice(item, promotion, quantity) {
            var sellByQtyItem = item.unit === 'lb' && item.sellByQty;
            var itemizedPrice = 0;
            var qtyAtRegularPrice = 0;
            var qtyAtPromotionPrice = 0;

            if (promotion.applyInIncrementsOnly === false) {
                qtyAtPromotionPrice = quantity;
            } else {
                qtyAtPromotionPrice = Math.floor(quantity / promotion.eligibilityQuantity) * promotion.eligibilityQuantity;
                qtyAtRegularPrice = quantity % promotion.eligibilityQuantity;
            }
            if (qtyAtPromotionPrice) {
                itemizedPrice = qtyAtPromotionPrice * promotion.promotionPrice;
            }
            if (qtyAtRegularPrice) {
                itemizedPrice += qtyAtRegularPrice * item.price;
            }
            if (sellByQtyItem) {
                var avgWeight = item.packed ? item.quantityWeight / item.quantity : item.avgWeight;
                qtyAtRegularPrice *= item.avgWeight;
                qtyAtPromotionPrice *= item.avgWeight;
            }
            return itemizedPrice;
        },
        getVisiblePromotion(item) {
            var promotionsIndex = service.getItemPromotions(item);

            if (!promotionsIndex.length) return null;

            for (var i = 0; i < promotionsIndex.length; i++) {
                var promoIndex = promotionsIndex[i];
                var promotion = angular.copy(service.ongoingPromotions.promotions[promoIndex.promotionId].itemGroups[promoIndex.itemGroupName]);
                promotion.eligibilityQuantity = promoIndex.eligibilityQuantity;
                promotion.applyInIncrementsOnly = promoIndex.applyInIncrementsOnly;

                if (![service.types.DEAL, service.types.DISCOUNT, service.types.FREE_ITEM].includes(promoIndex.promotionType)) continue;
                if (promotion.eligibilityQuantity !== 0) continue;

                if (promoIndex.promotionType === service.types.DEAL) {
                    if (!service.isValidPrice(promoIndex.promotionPrice) || promoIndex.promotionPrice >= item.price) continue;
                    promotion.promotionPrice = promoIndex.promotionPrice;
                } else if (promoIndex.promotionType === service.types.DISCOUNT) {
                    promotion.promotionPrice = service.getDiscountPrice(item, promotion);
                } else if (promoIndex.promotionType === service.types.FREE_ITEM) {
                    promotion.promotionPrice = 0;
                }
                return promotion;
            }
            return null;
        },
        getPotentialSavingsPromo(item) {
            if (!item || item.membershipDiscount) return null;

            var promo = service.getVisiblePromotion(item);
            var volumePromos = service.getVisibleVolumePromotions(item);
            var promos = [];

            if (promo) {
                promos.push(promo);
            }
            if (volumePromos.length) {
                promos = promos.concat(volumePromos);
            }
            promos.sort(function (a, b) {
                return a.eligibilityQuantity - b.eligibilityQuantity;
            });
            var found = null;

            for (var i = 0; i < promos.length; i++) {
                var candidate = promos[i];

                if (candidate.eligibilityQuantity > item.quantity) break;

                candidate = JSON.parse(JSON.stringify(candidate));
                candidate.itemizedPrice = service.getVolumePromotionItemizedPrice(item, candidate);

                if (!found || candidate.itemizedPrice < found.itemizedPrice) {
                    found = candidate;
                }
            }
            return found;
        },
        getDiscountPrice(item, promotion) {
            if (!item || typeof item.price !== 'number') return 0;
            if (promotion.type === service.types.FREE_ITEM) return 0;

            var price = item.price;

            if (promotion.rewardsType === service.rewardsTypes.DOLLAR) {
                price = price - promotion.rewardsValue;
            } else if (promotion.rewardsType === service.rewardsTypes.PERCENT) {
                price = price - price * promotion.rewardsValue / 100;
            }
            if (!service.isValidPrice(price)) return item.price;

            return Number(price.toFixed(2));
        },
        isValidPrice(price) {
            return price && !isNaN(price) && price > 0;
        },
        getPromotionString(promotion, item) {
            var promosMap = {};
            promosMap[service.types.DISCOUNT] = service.getDiscountString;
            promosMap[service.types.DEAL] = service.getDealString;
            promosMap[service.types.FREE_ITEM] = service.getFreeItemString;

            if (!promotion || !promotion.type || !Object.keys(promosMap).includes(promotion.type)) return '';

            return promosMap[promotion.type](promotion, item);
        },
        getDiscountString(promotion, item) {
            var rewardsValueTypeMap = {};
            rewardsValueTypeMap[service.rewardsTypes.PERCENT] = service.formatPercent;
            rewardsValueTypeMap[service.rewardsTypes.DOLLAR] = service.formatAmount;

            if (!Object.keys(rewardsValueTypeMap).includes(promotion.rewardsType)) return '';

            var savingsStr = rewardsValueTypeMap[promotion.rewardsType](promotion.rewardsValue)  + ' OFF';

            if (!promotion.eligibilityQuantity) {
                return savingsStr;
            }
            var membersDescription = promotion.membersOnly
                ? (promotion.userGroupDisplayName ? promotion.userGroupDisplayName : 'Members') + ' ' : '';

            var weightDescription = '';

            if (item.unit === 'lb' && !item.sellByQty) {
                weightDescription = 'LB';
            }

            return (membersDescription || '') + 'Buy ' + promotion.eligibilityQuantity + weightDescription + ' and Get ' + savingsStr;
        },
        getDealString(promotion, item) {
            var savings = item.price - promotion.promotionPrice;
            var weightDescription = '';

            if (!promotion.eligibilityQuantity) {
                if (item.unit === 'lb') {
                    weightDescription = ' per LB';
                }
                return 'Save ' + service.formatAmount(savings) + weightDescription;
            }
            savings = (item.price - promotion.promotionPrice) * promotion.eligibilityQuantity;
            var membersDescription = promotion.membersOnly
                ? (promotion.userGroupDisplayName ? promotion.userGroupDisplayName : 'Members') + ' ' : '';

            if (item.unit === 'lb' && !item.sellByQty) {
                weightDescription = 'LB';
            }
            var commonPrefix = (membersDescription || '') + 'Buy ' + promotion.eligibilityQuantity + weightDescription + ' ';

            if (item.unit === 'lb' && item.sellByQty) {
                return commonPrefix + 'and Get ' + service.formatAmount(promotion.promotionPrice) + ' per LB';
            }
            return commonPrefix + 'and Save ' + service.formatAmount(savings);
        },
        getFreeItemString(promotion, item) {
            var savings = item.price;
            var weightDescription = '';

            if (!promotion.eligibilityQuantity) {
                return 'Save ' + service.formatAmount(savings);
            }
            return '';
            // there is no support for this yet

            // var membersDescription = promotion.membersOnly
            //     ? (promotion.userGroupDisplayName ? promotion.userGroupDisplayName : 'Members') + ' ' : '';

            // if (item.unit === 'lb' && !item.sellByQty) {
            //     weightDescription = 'LB';
            // }
            // var commonPrefix = (membersDescription || '') + 'Buy ' + promotion.eligibilityQuantity + weightDescription + ' ';

            // if (item.unit === 'lb' && item.sellByQty) {
            //     return commonPrefix + 'and Get ';
            // }
            // return commonPrefix + 'and Get ';
        },
        formatPercent(val) {
            var str = '%';
            if (typeof val !== 'number') return str;
            return parseInt(val) + str;
        },
        formatAmount(val) {
            var str = '$';
            if (typeof val !== 'number') return str;
            return str + val.toFixed(2);
        },
        addPromotionToItem(item) {
            // TODO: get rid of this code and move this to BE.
            // This is necessary now due to the way adding items work in Tableside Ordering which doesn't make a basket call.
            // Do not use below functions to avoid adding dependencies.

            var promotion = service.getPotentialSavingsPromo(item);

            if (promotion) {
                item.promotion = promotion;
            } else {
                delete item.promotion;
            }
            service.addPriceBreakdownToItem(item);
        },
        addPriceBreakdownToItem(item) {
            // do not use
            if (item.promotion && item.promotion.isApplicable) {
                var promotion = item.promotion;
                var itemIsSellByQty = item.sellByQty && item.unit === 'lb';
                var atRegularPrice = 0;
                var atPromotionPrice = 0;

                if (promotion.applyInIncrementsOnly) {
                    atPromotionPrice = Math.floor(item.quantity / promotion.eligibilityQuantity) * promotion.eligibilityQuantity;
                    atRegularPrice = item.quantity % promotion.eligibilityQuantity;
                } else {
                    atPromotionPrice = item.quantity;
                }
                item.priceBreakdown = [];

                if (atRegularPrice) {
                    item.priceBreakdown.push({
                        quantity: atRegularPrice,
                        price: item.price,
                    });
                }
                if (atPromotionPrice) {
                    item.priceBreakdown.push({
                        quantity: atPromotionPrice,
                        price: promotion.promotionPrice,
                    });
                }

            } else {
                item.priceBreakdown = [{
                    quantity: item.quantity,
                    price: item.price,
                }];
            }

            for (var t = 0; t < item.priceBreakdown.length; t++) {
                var tier = item.priceBreakdown[t];

                // not adding membership discount since this is for anonymous
                // if (item.membershipDiscount) {
                //     tier.price = tier.price - tier.price * item.membershipDiscount / 100;
                // }
                if (itemIsSellByQty) {
                    tier.weight = tier.quantity * item.avgWeight
                    tier.total = tier.weight * tier.price;
                } else {
                    tier.total = tier.quantity * tier.price;
                }
            }

            if (item.selectedModifiers && Array.isArray(item.selectedModifiers) && item.selectedModifiers.length > 0) {
                var modifiersPrice = item.selectedModifiers.reduce(function (acc, m) { return acc + m.price; }, 0);

                for (var t = 0; t < item.priceBreakdown.length; t++) {
                    var tier = item.priceBreakdown[t];
                    tier.modifiersPrice = modifiersPrice;
                    const modifiersTotal = tier.quantity * tier.modifiersPrice;
                    tier.total = tier.total + modifiersTotal;
                }
            }
            item.itemizedPrice = 0;

            for (var t = 0; t < item.priceBreakdown.length; t++) {
                var tier = item.priceBreakdown[t];

                item.itemizedPrice += tier.total;
            }
        },
        getVolumePromotionItemizedPrice(item, promotion) {
            // do not use
            var itemizedPrice = 0;
            var atRegularPrice = 0;
            var atPromotionPrice = 0;

            if (promotion.applyInIncrementsOnly) {
                atPromotionPrice = Math.floor(item.quantity / promotion.eligibilityQuantity) * promotion.eligibilityQuantity;
                atRegularPrice = item.quantity % promotion.eligibilityQuantity;
            } else {
                atPromotionPrice = item.quantity;
            }
            if (atPromotionPrice) {
                itemizedPrice = atPromotionPrice * promotion.promotionPrice;
            }
            if (atRegularPrice) {
                itemizedPrice += atRegularPrice * item.price;
            }
            return itemizedPrice;
        },
        shouldShowMembershipDiscount: function (item, promotion) {
            if (item.membershipDiscount) return true; // legacy
            if (promotion && promotion.membersOnly) return true;

            return false;
        },
        getUserGroupsParams: function (user) {
            var userGroups = {
                userGroups: [],
            };
            if (!hsUtils.isObject(user)) return '';

            if (user.id) {
                userGroups.id = user.id;
            } else {
                userGroups.email = user.email;
            }

            if (Array.isArray(user.userGroups)) {
                userGroups.userGroups = user.userGroups;
            }
            if (user.membership) {
                userGroups.membership = {
                    isActive: !!user.membership.isActive,
                };
                if (Array.isArray(user.membership.userGroups)) {
                    userGroups.membership.userGroups = user.membership.userGroups;
                }
            }
            return JSON.stringify(userGroups);
        },
        getRelevantPromotionForPrice: function (item, promotion) {
            if (!promotion || promotion.optOut) return null;

            return !item.priceBreakdown || item.priceBreakdown.length === 1 ? promotion : null;
        },
        getLimitedUsePromoName: function (promo) {
            if (!promo) return '';
            if (promo.displayName) return promo.displayName;
            if (promo.linkCode) return promo.linkCode;

            return service.getStringFromDate(promo.startDate) + '-' + service.getStringFromDate(promo.endDate);
        },
        getStringFromDate(dateObj) {
            return dateObj.year + '/' + dateObj.month + '/' + dateObj.date;
        },
    };

    return service;
}


angular.module('homesome.factories').factory('hsPromotionsV2', [
    '$rootScope',
    '$http',
    'ENV',
    'hsUtils',
    'hsCart',
    'globalFunctions',
    'localStorageService',
    'aiSearchEvents',
    hsPromotionV2Controller
]);

function hsPromotionV2Controller ($rootScope, $http, ENV, hsUtils, hsCart, globalFunctions, localStorageService, aiSearchEvents) {
    var service = {
        getPromotionProgress: function (promoId) {
            return $http.get(ENV.apiEndPoint + '/v2/promotions/' + promoId + '/progress')
                .then (function (response) {
                    if (response.status !== 200) {
                        throw response.data;
                    }
                    return response.data;
                })
                .catch (function (err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to fetch item.');
                })
        },
        getCurrentStepItems: function (promotionProgress, currentStepIndex) {
            var data = [];
            if (hsUtils.isNonEmptyArray(promotionProgress.steps)) {
                promotionProgress.steps[currentStepIndex].items.map(function (item) {
                    var prod = $rootScope.allProductsHash[item.name];
                    if(prod) {
                        prod.loading = false;
                        prod.quantity = item.quantity.cart;
                        data.push(prod);
                    }
                });
            }
            return data;
        },
        getUnitIncrement: function (item) {
            var unitIncrement = 1;
            if (!item.sellByQty && item.unit === 'lb') {
                unitIncrement = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
            }
            return unitIncrement;
        },
        hasItemReachedMaxQuantity: function (item) {
            return item.hasOwnProperty('maxQuantity') && item.maxQuantity > 0 && item.quantity === item.maxQuantity;
        },
        hasItemReachedMinQuantity: function (item) {
            var unitIncrement = service.getUnitIncrement(item);
            return item.quantity === unitIncrement || item.minQuantity && item.quantity === item.minQuantity;
        },
        getUpdatedQuantity: function (operation, item) {
            var quantity = item.quantity;
            var unitIncrement = service.getUnitIncrement(item);
            quantity = Math.ceil(parseFloat((quantity / unitIncrement).toFixed(2))) * unitIncrement;
            quantity = parseFloat(quantity.toFixed(2));

            if (operation === 'add') {
                if (!service.hasItemReachedMaxQuantity(item)) {
                    quantity = parseFloat((quantity + unitIncrement).toFixed(2));
                }
            } else if (operation === 'subtract') {
                if (!service.hasItemReachedMinQuantity(item)) {
                    quantity = parseFloat((quantity - unitIncrement).toFixed(2));
                }
            }

            return quantity;
        },
        isCurrentStepInProgress: function (productData, currentStepIndex) {
            if(hsUtils.isArray(productData.steps) && hsUtils.isObject(productData.steps[currentStepIndex])) {
                var currentStepProgress = productData.steps[currentStepIndex].progress;
                return currentStepProgress.completed < currentStepProgress.total;
            }

            return false;
        },
        getDataForAddItemToCart: function (item, quantity) {
            var data = {
                items: [{
                    name: item.name,
                    quantity: quantity,
                    canReplace: globalFunctions.canReplace(item),
                    displayName: item.displayName,
                    type: item.type,
                    subType: item.subType,
                    organic: item.organic,
                    unit: item.unit,
                    isCustomItem: item.isCustomItem === true,
                    instructions: item.instructions || '',
                    selectedModifiers: item.selectedModifiers
                        ?  item.selectedModifiers.map(function(modifier) {
                                return modifier.name
                            })
                        : [],
                    }]
            };

            return data;
        },
        addItemToCart: function (item, quantity, promoId) {
            var data = service.getDataForAddItemToCart(item, quantity);

            return hsCart.addItemToCart(data, null, promoId)
                .then(function (response) {
                    if (response.status === 200) {
                        service.sendAddItemGAEvent(item);
                        $rootScope.$emit('cartUpdated',true);
                        return response.data;
                    } else if (response.status === 409) {
                        throw 'Maximum quantity for product reached';
                    } else {
                        throw response.data;
                    }
                })
                .catch(function (err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed update cart.');
                });
        },
        removeItemFromCartForLoggedOutUser: function (item) {
            var basket = service.getLocalBasket();
            var itemIndex = 0;

            basket.forEach(function(product, idx){
                if(product.name === item.name){
                    itemIndex = idx;
                }
            });

            basket.splice(itemIndex, 1);
            service.setLocalBasket(basket);

            $rootScope.$emit('cartUpdated', true);
        },
        removeItemFromCartForLoggedInUser: function (item, promoId) {
            var data = {
                itemName: item.name
            };

            if (item.selectedModifiers) {
                data.selectedModifiers = item.selectedModifiers;
            }

            return hsCart.removeItemFromCart(data, null, promoId)
                .then(function (response) {
                    if (response.status !== 200) {
                        throw response.data;
                    } else {
                        $rootScope.$emit('cartUpdated', true);
                        return response.data;
                    }
                })
                .catch(function (err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to remove item from cart.');
                });
        },
        getProgressPercent: function (promotionProgress) {
            var progressPercent = 0;
            if(hsUtils.isNonEmptyObject(promotionProgress.progress)) {
                progressPercent = hsUtils.roundNumber((promotionProgress.progress.completed/promotionProgress.progress.total) * 100);
            }

            return progressPercent;
        },
        getProductDisplayName: function(item) {
            return hsCart.getProductDisplayName(item);
        },
        calculateProductPrice: function(item) {
            return hsCart.calculateProductPrice(item);
        },
        calculatePricePerQuantity: function(item) {
            return hsCart.calculatePricePerQuantityV2(item);
        },
        calculateAvailableTimeString: function(product) {
            return hsCart.calculateAvailableTimeString(product, 'product')
        },
		sendAddItemGAEvent: function(item) {
			var gaEventCategory = aiSearchEvents.getEventCategory();
			aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.ADD_TO_CART, item.name);
		},
        getLocalBasket: function() {
            return localStorageService.get('basket');
        },
        setLocalBasket: function(basket) {
            localStorageService.set('basket', basket);
        },
        getSortedPromotionItems: function (products) {
            return products.sort(function (a, b) {
                return b.quantity.cart - a.quantity.cart;
            });
        },
        getSortedPromotionProgress: function (promotionsProgress) {
            if (hsUtils.isNonEmptyArray(promotionsProgress.steps)) {
                promotionsProgress.steps.forEach(function (step) {
                    step.items = service.getSortedPromotionItems(step.items);
                });
            }

            return promotionsProgress;
        },
        getUpdatedItems: function (products, updatedProducts) {
            var newProducts = [];

            for (var product of products) {
                for (var updatedProduct of updatedProducts) {
                    if(product.name === updatedProduct.name) {
                        newProducts.push(updatedProduct);
                        break;
                    }
                }
            }

            return newProducts;
        },
        getUpdatedPromotionProgress: function (updatedProgress, promotionProgress) {
            if(hsUtils.isNonEmptyArray(updatedProgress.steps)) {
                promotionProgress.steps.forEach(function (step, index) {
                    updatedProgress.steps[index].items = service.getUpdatedItems(step.items, updatedProgress.steps[index].items);
                });
            }

            return updatedProgress;
        },
        getFilteredItemsBySearchText: function (value, promotionProgress, currentPageIndex) {
            var currentPageItem = service.getCurrentStepItems(promotionProgress, currentPageIndex);
            var newItems = [];
            angular.forEach(currentPageItem, function (val) {
                if (val.displayName.toLowerCase().includes(value.toLowerCase())) {
                    newItems.push(val);
                }
            });

            return newItems;
        },
        getFilterCategories: function (products) {
            let filterCategories = {};
            products.forEach(function (item) {
                if(!filterCategories.hasOwnProperty(item.type)) {
                    filterCategories[item.type] = {
                        name: item.type,
                        selected: false,
                        partial: false,
                        subCategories: {}
                    }
                    filterCategories[item.type].subCategories[item.subType] = {
                        name: item.subType,
                        selected: false,
                        category: item.type
                    }

                } else {
                    filterCategories[item.type].subCategories[item.subType] = {
                        name: item.subType,
                        selected: false,
                        category: item.type
                    }
                }
            });

            return filterCategories;
        },
        setCategorySelection: function (category, categories) {
            var subCategories = Object.values(categories[category].subCategories) || [];
            var selected;
            var notSelected;

            subCategories.forEach(function (subCategory) {
                if(subCategory.selected) {
                    selected = true;
                } else {
                    notSelected = true;
                }
            });

            categories[category].partial = selected && notSelected;
            categories[category].selected = selected && !categories[category].partial;
        },
        getSelectedOptions: function (options) {
            return options.filter(function (option) {
                return option.selected;
            });
        },
        getSelectedOptionsCount: function (options) {
            var selectedOptions = service.getSelectedOptions(options || [])

            return selectedOptions.length;
        },
        getSelectedSubCategories: function (subCategories) {
            var selectedSubCategories = service.getSelectedOptions(Object.values(subCategories || []))
            return selectedSubCategories;
        },
        getSelectedCategoryCount: function (categories) {
            var count = 0;
            for (var category in categories) {
                var selectedSubCategories = service.getSelectedSubCategories(categories[category].subCategories);
                if(!categories[category].selected) {
                    count += selectedSubCategories.length;
                } else {
                    count++;
                }
            }

            return count;
        },
        getPriceString: function (priceObj) {
            return '$' + priceObj.min.toFixed(2) + ' To ' + '$' + priceObj.max.toFixed(2)
        },
        getHealthClaimsForFilter: function (products) {
            var healthClaimObj = {};
            products.forEach(function (product) {
                if (hsUtils.isNonEmptyArray(product.healthClaims)) {
                    product.healthClaims.forEach(function (healthClaim) {
                        healthClaimObj[healthClaim] = {
                            name: healthClaim,
                            selected: false
                        }
                    });
                }
            });

            return Object.values(healthClaimObj);
        },
        getUpdatedHealthClaims: function (healthClaimObj, healthClaims) {
            return healthClaims.map(function (healthClaim) {
                if (healthClaim.name === healthClaimObj.name) {
                    return {
                        name: healthClaimObj.name,
                        selected: !healthClaimObj.selected
                    }
                }
    
                return healthClaim;
            });
        },
        getFilterBrands: function (products) {
            var filterBrands = {};
            products.forEach(function (item) {
                var key = '#';
                if(item.brand) {
                    if(!hsUtils.isStringStartWithNumber(item.brand)) {
                        key = item.brand.charAt(0).toUpperCase();
                    }
                    if(filterBrands.hasOwnProperty(key)) {
                        filterBrands[key].brands[item.brand] = {
                            name: item.brand,
                            selected: false
                        }
                    } else {
                        filterBrands[key] = {
                            atleastOneSelected: false,
                            brands: {}
                        };
                        filterBrands[key].brands[item.brand] = {
                            name: item.brand,
                            selected: false
                        }
                    }
                }
            });
            return filterBrands;
        },
        getFilteredBrands: function (searchText, visibleBrands, firstletter) {
            var newBrands = {};
            newBrands[firstletter] = {};

            for(var key in visibleBrands[firstletter]) {
                if (key.toLowerCase().includes(searchText.toLowerCase())) {
                    newBrands[firstletter][key] = visibleBrands[firstletter][key];
                }
            }
            return newBrands;
        },
        getSelectedItems: function (items) {
            return items.filter(function (item) {
                return item.selected;
            });
        },
        getSelectedItemsCount: function (items) {
            var selectedItems = service.getSelectedItems(items || [])

            return selectedItems.length;
        },
        getSelectedBrands: function (brands) {
            var selectedBrands = [];
            for(var key in brands) {
                var items = service.getSelectedItems(Object.values(brands[key].brands || {}));
                selectedBrands = selectedBrands.concat(items);
            }

            return selectedBrands;
        },
        getSelectedBrandsCount: function (brands) {
            var count = 0;
            for(var key in brands) {
                count += service.getSelectedItemsCount(Object.values(brands[key].brands || {}));
            }
            return count;
        },
        getSelectedSubCategories: function (subCategories) {
            var selectedSubCategories = service.getSelectedItems(Object.values(subCategories || {}))
            return selectedSubCategories;
        },
        getSelectedCategories: function (categories) {
            var selectedCategories = [];
            for (var category in categories) {
                if(categories[category].selected) {
                    selectedCategories.push({
                        name: categories[category].name,
                        isCategory: true
                    });
                } else {
                    var selectedSubCategories = service.getSelectedSubCategories(categories[category].subCategories);
                    if (selectedSubCategories.length > 0) {
                        selectedCategories = selectedCategories.concat(selectedSubCategories);
                    }
                }
            }

            return selectedCategories;
        },
        getSelectedCategoryCount: function (categories) {
            var count = 0;
            for (var category in categories) {
                var subCategoriesCount = service.getSelectedItemsCount(Object.values(categories[category].subCategories));
                if(!categories[category].selected) {
                    count += subCategoriesCount;
                } else {
                    count++;
                }
            }

            return count;
        },
        getPriceMenu: function () {
            return [
                {
                    min: 0.00,
                    max: 1.00,
                    selected: false
                },
                {
                    min: 1.01,
                    max: 2.00,
                    selected: false
                },
                {
                    min: 2.01,
                    max: 5.00,
                    selected: false
                },
                {
                    min: 5.01,
                    max: 10.00,
                    selected: false
                },
            ];
        },
        atleastOneBrandSelected: function (brand) {
            return Object.values(brand).some(function (item) {
                return item.selected;
            });
        },
        isAvailableInSelectedBrands: function (brand, selectedBrands) {
            return selectedBrands.some(function (selectedBrand) {
                return brand === selectedBrand.name;
            });
        },
        filterByBrands: function (selectedBrands, currentPageItems) {
            if(selectedBrands.length === 0) {
                return currentPageItems;
            }

            return currentPageItems.filter(function (item) {
                return service.isAvailableInSelectedBrands(item.brand, selectedBrands);
            });
        },
        isPriceWithInSelectedRange: function (selectedPrices, itemPrice) {
            return selectedPrices.some(function (selectedPrice) {
                return selectedPrice.min <= itemPrice && selectedPrice.max >= itemPrice;
            })
        },
        filterByPrice: function (selectedPrices, currentPageItems) {
            if (selectedPrices.length === 0) {
                return currentPageItems;
            }
            return currentPageItems.filter(function (item) {
                return service.isPriceWithInSelectedRange(selectedPrices, item.price);
            });
        },
        isCategoryAvailable: function (item, selectedCategories) {
            return selectedCategories.some(function (category) {
                if (category.isCategory) {
                    return item.type === category.name
                } 

                return category.category === item.type && category.name === item.subType;
            })
        },
        filterByCategory: function (selectedCategories, currentPageItems) {
            if (selectedCategories.length === 0) {
                return currentPageItems;
            }

            return currentPageItems.filter(function (item) {
                return service.isCategoryAvailable(item, selectedCategories);
            });
        },
        isHealthClaimsAvailable: function (item, selectedHealthClaims) {
            return selectedHealthClaims.every(function (healthClaim) {
                return item.healthClaims.includes(healthClaim.name);
            });
        },
        filterByHealthClaims: function (selectedHealthClaims, currentPageItems) {
            if (selectedHealthClaims.length === 0) {
                return currentPageItems;
            }

            return currentPageItems.filter(function (item) {
                return service.isHealthClaimsAvailable(item, selectedHealthClaims);
            });
        },
        filterProducts: function (categories, brands, healthClaims, prices, promotionProgress, currentPageIndex) {
            var selectedHealthClaims = service.getSelectedItems(healthClaims || []);
            var selectedPrices = service.getSelectedItems(prices || []);
            var selectedBrands = service.getSelectedBrands(brands);
            var selectedCategories = service.getSelectedCategories(categories);

            var currentPageItems = service.getCurrentStepItems(promotionProgress, currentPageIndex);

            var fileredProducts = service.filterByBrands(selectedBrands, currentPageItems);
            fileredProducts = service.filterByPrice(selectedPrices, fileredProducts);
            fileredProducts = service.filterByCategory(selectedCategories, fileredProducts);
            fileredProducts = service.filterByHealthClaims(selectedHealthClaims, fileredProducts);

            return fileredProducts;
        }
    };

    return service;
}
'use strict';
var hsFac = angular.module('homesome.factories');

hsFac.factory('scannerUtils', ["globalFunctions", "hsUtils", function (globalFunctions, hsUtils) {
	var BARCODE_SCANNERS = {
		DYNAMSOFT: 'dynamsoft',
		ZEBRA: 'zebra'
	};

	var DEFAULT_BARCODE_SCANNER = BARCODE_SCANNERS.DYNAMSOFT;

	return {
        getAvailableBarcodeScanners: function() {
            return BARCODE_SCANNERS;
        },
        getDefaultBarcodeScanner: function() {
            return DEFAULT_BARCODE_SCANNER;
        },
		getBarcodeScannerName: function() {
			var selectedLocation = globalFunctions.getSelectedLocationFromStorage();
			
            if (selectedLocation.hasOwnProperty('scannerObj') && hsUtils.isObject(selectedLocation.scannerObj)) {
                return selectedLocation.scannerObj.type;
            }

			return DEFAULT_BARCODE_SCANNER;
		},
	}
}]);
angular.module('homesome.factories').factory('hsScroll', [scrollService]);
function scrollService() {

    var scrollService = {

		// Given a list of elements, return those fully visible on the container's viewport
		getVisibleElements: function(elements, container) {
			var elementsVisible = [];
			for (var element of elements) {
				if (scrollService.isVisible(element, container)) {
					elementsVisible.push(element);
				}
			}
			return elementsVisible;
		},
		isVisible: function(element, container) {
			var elementTop = element.offsetTop - container.offsetTop;
			var elementBottom = elementTop + element.clientHeight;
			var containerTop = container.scrollTop;
			var containerBottom = containerTop + container.clientHeight;
			return elementTop >= containerTop && elementBottom <= containerBottom;
		},
		getPositionInScrollContainer: function(element, container) {
			var elementTop = element.offsetTop;
			var divTop = container.offsetTop;
			return elementTop - divTop;
		}

	};

    return scrollService;
}

'use strict';
var hsFac = angular.module('homesome.factories');

hsFac.factory('hsSearch', ["$rootScope", "$http", "$q", "$location", "ENV", "globalFunctions", "hsUtils", function($rootScope, $http, $q, $location, ENV, globalFunctions, hsUtils) {
    function isSearchV2Enabled() {
        if (!ENV.enablePriceList) {
            var location = globalFunctions.getSelectedLocationFromStorage();
            if (!hsUtils.isObject(location) || !hsUtils.isNonEmptyArray(location.priceLists)) return false;
            for(var pl of location.priceLists) {
                if (hsUtils.isObject(pl) 
                    && pl.default
                    && !pl.isDisabled
                    && hsUtils.isObject(pl.aiIntegrations) 
                    && hsUtils.isObject(pl.aiIntegrations.searchV2) 
                    && pl.aiIntegrations.searchV2.enabled) {
                        return true;
                }
            }
            return false;
        }

        var priceList = globalFunctions.getSelectedPriceListFromStorage();            
        return hsUtils.isObject(priceList)
            && hsUtils.isObject(priceList.aiIntegrations)
            && hsUtils.isObject(priceList.aiIntegrations.searchV2)
            && priceList.aiIntegrations.searchV2.enabled;
    }

    var service = {
        search: function(str, filters, order, matchAllWords, includeAllItems, isAdminDashboard, useV2) {
            var dfd = $q.defer();
            
            var categoryOrder = '';
            if (ENV.categoryOrder) {
                var keys = Object.keys(ENV.categoryOrder);
                if (keys.length) {
                    categoryOrder = keys.join(' ');
                }
            }

            var queryParams = {
                search: str,
                matchAllWords: matchAllWords,
                includeAllItems: includeAllItems,
                categoryorder: categoryOrder,
            };

            var params = (filters && Object.keys(filters).length) ? filters : $location.search();
            if (params && Object.keys(params).length) {
                Object.keys(params).forEach(function (key) {
                    queryParams[key] = params[key];
                });
            }
            
            var queryStr = globalFunctions.createUrlQueryParams(queryParams);
            var searchEndpoint = ENV.apiEndPoint + '/product/search';
            if (useV2 && isSearchV2Enabled()) {
                searchEndpoint = ENV.apiEndPointEast + '/product/searchV2';
            }

            var req = {
                method: 'GET',
                url: searchEndpoint + queryStr,
                headers: {},
            };

            if (order) {
                if (order.location) {
                    req.headers['location'] = order.location;
                }
                if (order.priceList && ENV.enablePriceList) {
                    req.headers['pricelist'] = order.priceList;
                }
            }

            if (isAdminDashboard) {
                var adminSelectedPriceList = $rootScope.adminFilterPriceList;
                if (ENV.enablePriceList && adminSelectedPriceList && adminSelectedPriceList.uniqueName) {
                    req.headers['pricelist'] = adminSelectedPriceList.uniqueName;
                }
            }

            $http(req)
                .then(function(response) {
                    if (response.status !== 200) {
                        dfd.reject(response);
                        return;
                    }
                    dfd.resolve(response.data);
                })
                .catch(function(error) {
                    dfd.reject(error);
                });
            return dfd.promise;
        },
        pendingRequests: [],
        isSearchV2Enabled: function() {
            return isSearchV2Enabled();
        },
        autoCompleteQuery: function(phrase) {
            if (!isSearchV2Enabled()) return;
            var url = new URL('/product/search/autocomplete', ENV.apiEndPoint);
            url.searchParams.append('phrase', phrase);

            var cancel = $q.defer();
            service.pendingRequests.push(cancel);
            
            return $http.get(url.toString(), { timeout: cancel.promise })
                .then(function(res) {
                    if (res.status === -1) {
                        return 'ABORTED_REQUEST';
                    }

                    if (res.status === 200) {

                        var removeAll = false;
                        for (var i = service.pendingRequests.length - 1; i >= 0; i--) {
                            if (service.pendingRequests[i] === cancel) {
                                removeAll = true;
                            }
                            if (removeAll) {
                                service.pendingRequests[i].resolve();
                                service.pendingRequests.splice(i, 1);
                            }
                        }

                        if (hsUtils.isObject(res.data) && hsUtils.isNonEmptyArray(res.data.results)) {
                            return res.data.results;
                        }
                        return [];
                    }
                    throw new Error('Failed to get auto-complete options.');
                });
        },
        resolveSearchURL: function(includeSearchTerm) {
            var queryParams = $location.search();
            var result = {};
            Object.keys(queryParams).forEach(function(key) {
                result[key] = Array.isArray(queryParams[key])
                    ? queryParams[key]
                    : [queryParams[key]];
            });
        
            if (!includeSearchTerm) {
                delete result['item'];
            }
            return result;
        },
        refreshURL: function(queryParamsToKeep) {
            var sanitizedParamsToKeep = queryParamsToKeep.reduce(function(acc, curr) {
                if (acc[curr.filterKey]) {
                    acc[curr.filterKey].push(curr.activeFilter);
                } else {
                    acc[curr.filterKey] = [curr.activeFilter];
                }
                return acc;
            }, {});
            Object.keys(sanitizedParamsToKeep).forEach(function(sanitizedParam) {
                $location.search(sanitizedParam, sanitizedParamsToKeep[sanitizedParam]);              
            });
        },
        getQueryParamAsArray: function(param, params) {
            params = params || $location.search();
            var data = params[param] || [];
            return Array.isArray(data) ? data : [data];
        },
        hasSearchParams: function(searchOptions) {
            if (Array.isArray(searchOptions) || typeof searchOptions !== "object") {
                return false;
            }
            return Object.keys(searchOptions).map(function(key) {
                return searchOptions[key]
            }).filter(function(searchOption) {
                return searchOption.length > 0
            }).length ? true : false;
        },
        convertFilterParamsToTitleCase: function(filters) {
            var queryParams = $location.search();
            Object.keys(queryParams).forEach(function(key) {
                if (Object.keys(filters).includes(key)) {
                    var param = queryParams[key];
                    if (filters[key].displayMap) {
                        if (key === 'healthClaims') {
                            if (Array.isArray(param)) {
                                param = param.map(function(searchOption) {
                                    if ($rootScope.healthClaimsMap && $rootScope.healthClaimsMap[searchOption]) {
                                        return $rootScope.healthClaimsMap[searchOption].displayName;
                                    } else {
                                        return searchOption;
                                    }
                                });
                            } else {
                                if ($rootScope.healthClaimsMap && $rootScope.healthClaimsMap[param]) {
                                    param = $rootScope.healthClaimsMap[param].displayName
                                }
                            }
                        }
                        $location.search(key, param);
                    } else {
                        if (Array.isArray(param)) {
                            param = param.map(function(searchOption) {
                                return globalFunctions.toTitleCase(searchOption);
                            });
                            $location.search(key, param);
                        } else {
                            $location.search(key, globalFunctions.toTitleCase(param));
                        }
                    }
                }
            });
        },
        searchV2Enabled: function() {
            return isSearchV2Enabled();
        },
        autofillOptionTypes: {
            PRODUCT: 'product',
        }
    };

    return service;
}]);

'use strict';

angular.module('homesome.factories').factory('hsSocialLogin', ['ENV', 'localStorageService', '$location', 'globalFunctions', hsSocialLogin]);

function hsSocialLogin(ENV, localStorageService, $location, globalFunctions) {
    var service = {
        getGoogleAuthUrl(redirect, isSignUp) {
            var url = new URL('https://accounts.google.com/o/oauth2/v2/auth');
            var params = url.searchParams;
            params.append('scope', 'profile email openid');
            params.append('client_id', ENV.googleClientId);
            params.append('response_type', 'code');
            params.append('redirect_uri', window.location.origin + '/social-' + (isSignUp ? 'signup' : 'login') + '-callback');
            var now = new Date();
            var googleState = btoa('google' + now.getTime());
            localStorageService.set('google_state', googleState);
            localStorageService.set('socialRedirect', redirect);
            params.append('state', googleState);

            return url;
        },
        getFbAuthUrl(redirect, isSignUp) {
            var url = new URL('https://www.facebook.com/v10.0/dialog/oauth');
            var params = url.searchParams;
            params.append('scope', 'email');
            params.append('client_id', ENV.FB);
            params.append('redirect_uri', window.location.origin + '/social-' + (isSignUp ? 'signup' : 'login') + '-callback');
            var now = new Date();
            var fbState = btoa('facebook' + now.getTime());
            localStorageService.set('fb_state', fbState);
            localStorageService.set('socialRedirect', redirect);
            params.append('state', fbState);

            return url;
        },
        getSocialLoginCallback(localStorageParam, providerType, loginFunction, isSignup) {
            return function (searchParams) {
                var socialLoginState = localStorageService.get(localStorageParam);
                if (socialLoginState === searchParams.state) {
                    localStorageService.remove(localStorageParam);
                    var data = {
                        code: searchParams.code,
                        redirect: $location.absUrl().split('?')[0],
                        providerType: providerType,
                    };
                    loginFunction(data);
                } else {
                    //check failed, fallback quietly to logn/signup page
                    localStorageService.remove(localStorageParam);
                    if (isSignup) {
                        $location.url('/signup');
                    } else {
                        $location.url('/login');
                    }
                }
            };
        },
    };

    return service;
}

'use strict';

angular.module('homesome.factories').factory('hsStripe', ['ENV', '$http', stripeService]);

function stripeService(ENV, $http) {

    var service = {
        createElement(darkStyle) {
            var elements = stripe.elements({
                fonts: [
                    {
                        cssSrc: 'https://fonts.googleapis.com/css2?family=Lato&display=swap',
                    },
                ],
            });
            var style = {
                base: {
                    fontSize: '14px',
                    color: !darkStyle ? '#555555' : '#fff',
                    fontFamily: 'Lato, sans-serif',
                    fontSmoothing: 'antialiased',
                    '::placeholder': {
                        color: !darkStyle ? 'rgba(0,0,0,0.4)' : '#888',
                    },
                },
            };
            var card = elements.create('card', {
                style: style,
                hidePostalCode: true,
            });

            return card;
        },
        createToken(cardElement, address) {
            var address = {
                address_line1: address && address.street || '',
                address_line2: address && address.aptUnit || '',
                address_city: address && address.city || '',
                address_state: address && address.state || '',
                address_zip: address && address.zip || '',
                address_country: address && address.country || 'US',
            };

            return stripe.createToken(cardElement, address);
        },
        fetchStripeAccountSessionSecret() {
            return $http.post(ENV.apiEndPoint + '/stripe/account-session');
        },
    };

    return service;
}

'use strict';

angular.module('homesome.factories').factory('hsTableSideOrders', [
    '$rootScope', '$http', '$q', 'ENV', 'ngDialog', 'toastr', '$location', 'localStorageService', hsTableSideOrders
]);

function hsTableSideOrders($rootScope, $http, $q, ENV, ngDialog, toastr, $location, localStorageService) {

    var service = {
        sessionName: 'tso_session',
        sessionDuration: 2 * 60 * 60 * 1000, // 2 hours
        checkSessionInterval: 5 * 60 * 1000, // 5 minutes
        interval: null,

        getSession() {
            var session = sessionStorage.getItem(service.sessionName);
            if (session) {
                return JSON.parse(session);
            }
            return null;
        },
        saveSession(session) {
            sessionStorage.setItem(service.sessionName, JSON.stringify(session));
        },
        checkSession() {
            void 0;
            var session = service.getSession();

            if (session) {
                var now = new Date().getTime();
                var expiration = new Date(session.expiration).getTime();

                if (now > expiration) {
                    return service.endSession();
                }

                $rootScope.tableSideOrder = true;
                service.checkOpenOrder();

                if (!service.interval) {
                    service.interval = setInterval(function() { service.checkSession(); }, service.checkSessionInterval);
                }
            } else {
                service.endSession();
            }
        },
        initSession(tableNumber, location, pricelist) {
            void 0;
            // Existing session should have party size set
            var session = service.getSession() || {};

            if (!location || !pricelist) {
                service.endSession();
                $location.url('/table-side/error');
                return;
            }

            session.tableNumber = tableNumber;
            session.location = location;
            session.pricelist = pricelist;
            session.expiration = new Date(Date.now() + service.sessionDuration);

            service.saveSession(session);
            $rootScope.tableSideOrder = true;
            $rootScope.openTableSideOrder = null;

            if (!service.interval) {
                service.interval = setInterval(function() { service.checkSession(); }, service.checkSessionInterval);
            }

            service.checkOpenOrder()
                .then(function(openOrder) {
                    if (openOrder) {
                        session.partySize = openOrder.partySize;
                    }
                    if (session.partySize) {
                        service.saveSession(session);
                        return;
                    }
                    return service.showPartySizePopup()
                        .then(function(data) {
                            if (data.value && typeof data.value === 'number') {
                                session.partySize = data.value;
                            } else {
                                // Don't break the process, just initialize to 1. Servers can change it later.
                                session.partySize = 1;
                            }
                            service.saveSession(session);
                        });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Something went wrong. Could not start a session.');
                    service.endSession();
                });
        },
        refreshSession() {
            void 0;
            var session = service.getSession();

            if (session) {
                session.expiration = new Date(Date.now() + service.sessionDuration);
                service.saveSession(session);
            }
        },
        endSession() {
            void 0;
            clearInterval(service.interval);
            service.interval = null;
            $rootScope.tableSideOrder = false;
            $rootScope.openTableSideOrder = null;
            sessionStorage.removeItem(service.sessionName);
        },
        checkOpenOrder() {
            var dfd = $q.defer();
            if (!$rootScope.tableSideOrder || !$rootScope.loggedIn) {
                dfd.resolve(null);
                return dfd.promise;
            }

            return $http.get(ENV.apiEndPoint + '/user/orders?orderCount=2')
                .then(function(res) {
                    if (res.data && Array.isArray(res.data.orders) && res.data.orders.length) {
                        for (var order of res.data.orders) {
                            if (order.fulfillmentMethod === 'Table Side' && !['Cancelled', 'Completed'].includes(order.state)) {
                                service.setOpenOrder(order);
                                return order;
                            }
                            $rootScope.openTableSideOrder = null;
                        }
                    }
                    return null;
                })
                .catch(function(err) {
                    void 0;
                    $rootScope.openTableSideOrder = null;
                    return null;
                });
        },
        setOpenOrder(order) {
            $rootScope.openTableSideOrder = '/my-account?order=' + encodeURIComponent(order.key);
        },
        showPartySizePopup() {
            return ngDialog.open({
                template: '<div><table-side-party-size '
                    + 'on-close="closeThisDialog(partySize)" '
                    + '</table-side-party-size></div>',
                className: 'ngdialog-theme-default',
                plain: true,
                closeByNavigation: false,
                closeByDocument: false,
                closeByEscape: false,
                showClose: false,
            }).closePromise;
        },
        getGratuityMessage() {
            var session = service.getSession();
            if (!session || !session.partySize) {
                return '';
            }

            var locationUniqueName = session.location;
            var location = localStorageService.get('location');
            var allLocations = location && location.allLocations || [];
            var tableSideMandatoryTip;

            for (var location of allLocations) {
                if (location.uniqueName === locationUniqueName) {
                    tableSideMandatoryTip = location.tableSideMandatoryTip;
                    break;
                }
            }

            if (!Array.isArray(tableSideMandatoryTip) || tableSideMandatoryTip.length === 0) {
                return '';
            }

            tableSideMandatoryTip.sort(function(a, b) {
                return b.partSize - a.partSize;
            });

            var minPartySizeForAutoGratuity = tableSideMandatoryTip[0].partySize;
            var gratuityPercent = tableSideMandatoryTip[0].percent;

            for (var tipObj of tableSideMandatoryTip) {
                if (session.partySize >= tipObj.partySize) {
                    minPartySizeForAutoGratuity = tipObj.partySize;
                    gratuityPercent = tipObj.percent;
                    break;
                }
            }

            return 'For tables with ' 
                + minPartySizeForAutoGratuity + ' or more guests there will be a mandatory gratuity of '
                + gratuityPercent + '% applied to the final bill.';
        }
    };

    return service;
}

angular.module('homesome.factories').factory('hsUpc', [upcService]);

function upcService() {

    var service = {
        isRandomWeightUpc(upc) {
            if (typeof upc !== 'string' || upc.length < 12 || upc.length > 13) return false;

            if (upc.length === 13) {
                return /^(20|02)/.test(upc);
            }

            return /^2/.test(upc);
        },
        isRandomWeightProductUpc(upc) {
            if (typeof upc !== 'string') return false;

            return upc.length === 6 && upc[0] === '2';
        },
        getCodeFromRandomWeightUpc(upc) {
            var code = '';

            if(service.isRandomWeightUpc(upc)) {
                code = upc.replace(/^0/, ''); // normalize EAN13 to 12 digits if it starts with 02, so any type will start with 2
                code = upc.slice(1, -6); // EAN13 starting with 20 would result in 6 digits long ex: 012345 instead of 5 for UPCA
            }
            return code;
        },
        getPriceFromRandomWeightUpc(upc) {
            var price = null;

            if (service.isRandomWeightUpc(upc)) {
                var upcPrice = upc.slice(7 - upc.length, -1).replace(/^0*/, '');
                upcPrice = parseInt(upcPrice) / 100;

                if (!isNaN(upcPrice)) {
                    upcPrice = upcPrice.toFixed(2);
                    price = Number(upcPrice);
                }
            }

            return price;
        },
        matchUpc(upc, productUpc) {
            if (!upc || !productUpc) return false;

            productUpc = productUpc.trim();
            upc = upc.trim();

            if(service.isRandomWeightUpc(upc) && service.isRandomWeightProductUpc(productUpc)) {
                var code = service.getCodeFromRandomWeightUpc(upc);
                var productCode = productUpc.slice(-5);

                // We encountered that some customers use scales to encode EAN13 starting with 20, and reuse 0 in 20 type marker
                // which results in a truncated code. This is technically incorrect, but we need to handle it.

                // with the approach below
                // case 1: OK
                //         code: 012345 - 20 EAN13 encoding (leading zero is left over from 20 UPC type identifier)
                //  productCode: 01234  - incorrect, should have been encoded as 001234

                // case 2: OK
                //         code: 012345 - 20 EAN13 encoding
                //  productCode:  12345 - correct product code

                // highly unlikely, but possible
                // case 3: ERROR - wrong match
                //         code: 001234 - 20 EAN13 encoding
                //  productCode: 00123  - correct product code; should match to 000123 instead

                // case 4: ERROR - wrong match
                //         code: 001234 - 20 EAN13 encoding
                //  productCode:  01234 - incorrect product code; should match to 01234x instead

                if (code.includes(productCode)) return true;
            }
            productUpc = productUpc.replace(/^0+/, '');
            upc = upc.replace(/^0+/, '');

            return upc === productUpc;
        },
        isValidUPC(upc) {
            if (typeof upc !== 'string') return false;

            upc = upc.trim();

            if (/[^0-9]/.test(upc) || upc.length < 12 || upc.length > 13) return false;

            var sum;
            if (upc.length === 12) {
                sum = Number(upc[0]) * 3 + Number(upc[1])
                    + Number(upc[2]) * 3 + Number(upc[3])
                    + Number(upc[4]) * 3 + Number(upc[5])
                    + Number(upc[6]) * 3 + Number(upc[7])
                    + Number(upc[8]) * 3 + Number(upc[9])
                    + Number(upc[10]) * 3 + Number(upc[11]);
            }
            if (upc.length === 13) {
                sum = Number(upc[0]) + Number(upc[1]) * 3
                    + Number(upc[2]) + Number(upc[3]) * 3
                    + Number(upc[4]) + Number(upc[5]) * 3
                    + Number(upc[6]) + Number(upc[7]) * 3
                    + Number(upc[8]) + Number(upc[9]) * 3
                    + Number(upc[10]) + Number(upc[11]) * 3
                    + Number(upc[12]);
            }
            return sum % 10 === 0;
        },
    };

    return service;
}

angular.module('homesome.factories').factory('hsUserPayments', [ '$http', 'hsUtils', hsUserPaymentsService ]);

function hsUserPaymentsService($http, hsUtils) {

    var service = {
        sortPaymentMethods(paymentMethods) {
            var sortedPaymentMethods = [];
            if (!hsUtils.isNonEmptyArray(paymentMethods)) return sortedPaymentMethods;

            var ebtPaymentMethods = paymentMethods.filter(function(pm) {
                return pm.paymentProcessor === service.PAYMENT_PROCESSORS.forage;
            });

            var defaultPaymentMethod = paymentMethods.filter(function(pm) {
                return pm.paymentProcessor !== service.PAYMENT_PROCESSORS.forage && pm.default;
            });

            var remainingPaymentMethods = paymentMethods.filter(function(pm) {
                return pm.paymentProcessor !== service.PAYMENT_PROCESSORS.forage && !pm.default;
            });
            
            return sortedPaymentMethods.concat(defaultPaymentMethod, remainingPaymentMethods, ebtPaymentMethods);
        },
        isHouseChargeAvailable(userData) {
            if (!hsUtils.isNonEmptyObject(userData)) return false;
            return userData.enableHouseCharge === true;
        },
        addPaymentMethod(paymentMethod, targetUser, locationKey, priceListKey) {
            var headers = service.getHeaders(targetUser, locationKey, priceListKey);

            var apiUrl = new URL(ENV.apiEndPoint + '/user/payment');

            return $http.post(apiUrl.toString(), { paymentMethod: paymentMethod }, { headers: headers })
        },
        setDefaultPaymentMethod(pmid) {
            var apiUrl = new URL(ENV.apiEndPoint + '/user/payment');
            var data = {
                pmid: pmid,
                default: true,
            };
            return $http.put(apiUrl.toString(), { paymentMethod: data })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data.user;
                })
                .catch(function(err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to update payment.');
                });
        },
        getHeaders(targetUser, locationKey, priceListKey) {
            var headers = {};
            if (hsUtils.isNonEmptyString(targetUser)) {
                headers.targetuseremail = targetUser;
            }

            if (hsUtils.isNonEmptyString(locationKey)) {
                headers.location = locationKey;
            }

            if (hsUtils.isNonEmptyString(priceListKey)) {
                headers.pricelist = priceListKey;
            }
            return headers;
        },
        deletePaymentMethod(pmid, targetUser, locationKey, priceListKey) {
            var headers = service.getHeaders(targetUser, locationKey, priceListKey);
            var apiUrl = new URL(ENV.apiEndPoint + '/user/payment');
            apiUrl.searchParams.append('pmid', pmid);

            return $http.delete(apiUrl.toString(), { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    return response.data.user;
                })
                .catch(function(err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to delete payment.');
                });
        },
        PAYMENT_PROCESSORS: {
            // Only needed forage for now
            // remaining payment processor constants can be added as needed
            forage: 'forage'
        }
    };

    return service;
}

angular.module('homesome.factories').factory('hsUtils', ['$q', '$filter', utilsService]);

function utilsService($q, $filter) {

    var service = {
        isObject(val) {
            return val && typeof val === 'object' && !Array.isArray(val);
        },
        isArray(val) {
            return Array.isArray(val);
        },
        isDeliveryInTerminalState(delivery) {
            if (!delivery || !delivery.status) return false;

            return ['delivered', 'canceled', 'returned'].includes(delivery.status);
        },
        isValidDate(year, month, date) {
            var args = Array.from(arguments).slice(0, 3);
            if (args.includes(undefined) || args.some(isNaN)) return false;

            year = parseInt(year);
            month = parseInt(month);
            date = parseInt(date);
            var dateObj = new Date(year, month, date);

            if (isNaN(dateObj.getTime())) return false;
            if (year !== dateObj.getFullYear()) return false;
            if (month !== dateObj.getMonth()) return false;
            if (date !== dateObj.getDate()) return false;

            return true;
        },
        isEmptyObject(val) {
            return service.isObject(val) && Object.keys(val).length === 0;
        },
        isNonEmptyObject(obj) {
			return service.isObject(obj) && Object.keys(obj).length > 0;
		},
        isEmptyArray(val) {
            return service.isArray(val) && val.length === 0;
        },
        isNonEmptyArray(val) {
            return service.isArray(val) && val.length > 0;
        },
        isNonEmptyString(val) {
            return typeof val === 'string' && val.length > 0;
        },
        isString(val) {
            return typeof val === 'string';
        },
        isUndefinedOrEmptyObj(val) {
            return service.isEmptyObject(val) || service.isEmptyArray(val) || val === undefined;
        },
        convertISOStringToTimestamp(time) {
			return dayjs(time).format('h:mm A');
		},
        convertISOStringToChatDisplayTime(time) {
            return dayjs(time).format('MMM D, h:mm A');
        },
        convertISOStringToDisplayTime(time) {
            return dayjs(time).format('D MMM YYYY h:mm A');
        },
        isToday(time) {
            return dayjs().isSame(time, 'day');
        },
        readAsArrayBuffer(data) {
            return $q(function(resolve) {
                var reader = new FileReader();
                reader.onloadend = function () {
                    resolve(reader.result);
                };
                reader.readAsArrayBuffer(data);
            });
        },
        readAsDataURL(data) {
            return $q(function(resolve) {
                var reader = new FileReader();
                reader.onloadend = function () {
                    resolve(reader.result);
                };
                reader.readAsDataURL(data);
            });
        },
        isHttpURL(data) {
            var url;
            try {
                url = new URL(data);
            } catch (_) {
                return false;  
            }

            return url.protocol === "http:" || url.protocol === "https:";
        },
        resizeImage: function(imgFile, maxWidth, maxHeight) {

            return $q(function(resolve, reject) {
                maxWidth = maxWidth || 1000;
                maxHeight = maxHeight || 2000;
            
                service.readAsDataURL(imgFile).then(function(result) {

                    var img = new Image();
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext("2d");
                    var canvasCopy = document.createElement("canvas");
                    var copyContext = canvasCopy.getContext("2d");

                    img.onload = function() {
                        var ratio = 1;
                        if (img.width > maxWidth) {
                            ratio = maxWidth / img.width;
                        } else if (img.height > maxHeight) {
                            ratio = maxHeight / img.height;
                        }

                        canvasCopy.width = img.width;
                        canvasCopy.height = img.height;
                        copyContext.drawImage(img, 0, 0);

                        canvas.width = img.width * ratio;
                        canvas.height = img.height * ratio;
                        ctx.drawImage(canvasCopy, 0, 0, canvasCopy.width, canvasCopy.height, 0, 0, canvas.width, canvas.height);

                        // Convert canvas to Blob, then Blob to File.
                        canvas.toBlob(function(blob) {
                            var newFile = new File([blob], imgFile.name, { type: imgFile.type });
                            resolve(newFile);
                        }, imgFile.type);
                    }

                    img.src = result;
                });
            });
        },
        getDateString(dateObj) {
            let monthNames = [ 
                "Jan","Feb","Mar","Apr",
                "May","Jun","Jul","Aug",
                "Sep", "Oct","Nov","Dec", 
            ];

            return dateObj.getDate() + ' ' + monthNames[dateObj.getMonth()] + ' ' + dateObj.getFullYear();
        },
        roundNumber: function(number) {
            if (typeof number !== 'number') return number;
            return Number(number.toFixed(2));
        },
        getMessageFromError(err, defaultMessage) {
            var message = defaultMessage || 'Something went wrong.';

            if (service.isObject(err) && service.isNonEmptyString(err.message)) {
                message = err.message;
            } else if (service.isNonEmptyString(err)) {
                message = err;
            }
            return message;
        },
        isEmail: function(str) {
            if (!this.isNonEmptyString(str)) {
                return false;
            }

            // Source of regex: https://stackoverflow.com/questions/46155/how-can-i-validate-an-email-address-in-javascript
            return str
                    .toLowerCase()
                    .match(/^([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
        },
        formatPhoneNumber: function(str) {
            return $filter('bcTelephone')(str, 'clean');
        },
        isPhoneNumber: function(str) {
            str = this.formatPhoneNumber(str);
            return str.length === 10;
        },
        isNumber: function(val) {
            return !isNaN(val) && typeof val === 'number';
        },
        isInteger: function(val) {
            return service.isNumber(val) && Number.isInteger(val);
        },
        isPositiveInteger: function(val) {
            return service.isInteger(val) && val > 0;
        },
        isPositiveNumber: function(val) {
            return service.isNumber(val) && val > 0;
        },
        isBoolean: function(val) {
            return typeof val === 'boolean';
        },
        isDateObject: function(val) {
            return val instanceof Date;
        },
        getAddressLine1: function(address) {
            return address.street + (address.aptUnit ? ', ' + address.aptUnit : '');
        },
        getAddressLine2: function(address) {
            return address.city + ', ' + address.state + ' ' + address.zip;
        },
        getItemType: function(item) {
            var itemType = item.type || '';
            if (service.isObject(item.posData) && service.isNonEmptyString(item.posData.department)) {
                itemType = item.posData.department;
            }
            return itemType;
        },
        getItemSubType: function(item) {
            var itemSubType = item.subType || '';
            if (service.isObject(item.posData) && service.isNonEmptyString(item.posData.subDepartment)) {
                itemSubType = item.posData.subDepartment;
            }
            return itemSubType;
        },
        isStringStartWithNumber: function (str) {
            return service.isString(str) && /[0-9]/.test(str[0]);
        }
    };

    return service;
}

hsApp.factory('VALIDATORS', function () {
    return {
        ADDRESS: {
            rules: {
                street1: {
                    required: true,
                },
                city: {
                    required: true,
                },
                state: {
                    required: true,
                },
                zip: {
                    required: true,
                    number: true,
                    minlength: 5,
                    maxlength: 5,
                },
            },
            messages: {
                street1: {
                    required: 'Please enter your street address',
                },
                city: {
                    required: 'Please enter your city',
                },
                state: {
                    required: 'Please select your state',
                },
                zip: {
                    required: 'Please enter valid zipcode',
                    number: 'Please only enter numbers',
                    minlength: 'zipcode must be 5 digits',
                    maxlength: 'zipcode must be 5 digits',
                },
            },
            US: {
                rules: {
                    street1: {
                        required: true,
                    },
                    city: {
                        required: true,
                    },
                    state: {
                        required: true,
                    },
                    zip: {
                        required: true,
                        number: true,
                        minlength: 5,
                        maxlength: 5,
                    },
                },
                messages: {
                    street1: {
                        required: 'Please enter your street address',
                    },
                    city: {
                        required: 'Please enter your city',
                    },
                    state: {
                        required: 'Please select your state',
                    },
                    zip: {
                        required: 'Please enter valid zipcode',
                        number: 'Please only enter numbers',
                        minlength: 'zipcode must be 5 digits',
                        maxlength: 'zipcode must be 5 digits',
                    },
                },
            },
            CA: {
                rules: {
                    street1: {
                        required: true,
                    },
                    city: {
                        required: true,
                    },
                    state: {
                        required: true,
                    },
                    zip: {
                        required: true,
                        minlength: 7,
                        maxlength: 7,
                    },
                },
                messages: {
                    street1: {
                        required: 'Please enter your street address',
                    },
                    city: {
                        required: 'Please enter your city',
                    },
                    state: {
                        required: 'Please select your province',
                    },
                    zip: {
                        required: 'Please enter valid zipcode',
                        minlength: 'Zipcode must be 6 characters with a space between them',
                        maxlength: 'Zipcode must be 6 characters with a space between them',
                    },
                },
            },
        },
        BILLING_ADDRESS: {
            rules: {
                'billing-street1': {
                    required: true,
                },
                'billing-city': {
                    required: true,
                },
                'billing-state': {
                    required: true,
                },
                'billing-zip': {
                    required: true,
                    number: true,
                    minlength: 5,
                    maxlength: 5,
                },
            },
            messages: {
                'billing-street1': {
                    required: 'Please enter your billing street address',
                },
                'billing-city': {
                    required: 'Please enter your billing city',
                },
                'billing-state': {
                    required: 'Please select your billing state',
                },
                'billing-zip': {
                    required: 'Please enter valid billing zipcode',
                    number: 'Please only enter numbers',
                    minlength: 'zipcode must be 5 digits',
                    maxlength: 'zipcode must be 5 digits',
                },
            },
        },
        TIP: {
            rules: {
                tip: {
                    required: true,
                    number: true,
                    min: 1,
                },
            },
            messages: {
                tip: {
                    required: "Please enter a valid number",
                    number: "Please enter numbers only"
                },
            },
        },
        TABLE_NUMBER: {
            rules: {
                tableNumber: {
                    required: true,
                    digits: true,
                    min: 1,
                },
            },
            messages: {
                tableNumber: {
                    required: "Please enter a valid number",
                    number: "Please enter numbers only"
                },
            },
        },
        SIGN_UP: {
            rules: {
                firstName: {
                    required: true,
                    minlength: 2
                },
                lastName: {
                    required: true,
                    minlength: 2
                },
                email: {
                    required: true
                },
                phoneNumber: {
                    required: true,
                    phoneUS: true
                },
                password: {
                    required: true
                },
                businessName: {
                    required: true
                },
                street: {
                    required: true
                },
                city: {
                    required: true
                },
                state: {
                    required: true
                },
                zip: {
                    required: true,
                    number: true,
                    minlength: 5,
                    maxlength: 5
                },
            },
        },
        SIGN_UP_ADMIN: {
            rules: {
                firstName: {
                    required: true,
                },
                lastName: {
                    required: true,
                },
                userEmail: {
                    email: true,
                    required: true,
                },
                phoneNumber: {
                    required: true,
                    phoneUS: true
                }
            },
            messages: {
                firstName: {
                    required: "Please enter first name"
                },
                lastName: {
                    required: "Please enter last name",
                },
                userEmail: {
                    email: "Enter Valid Email",
                    required: "Please enter email",
                },
                phoneNumber: {
                    required: "Please enter phone number",
                    phoneUS: "Please enter valid phone number"
                }
            },
        },
        PHONE_NUMBER_VERIFICATION: {
            rules: {
                verificationPhoneNumber: {
                    required: true,
                    phoneUS: true
                },
                verificationCode: {
                    required: true,
                },
            },
            messages: {
                verificationPhoneNumber: {
                    required: "Please enter valid phone number required",
                    phoneUS: "Please enter valid phone number"
                },
            },
        },
        UPC: {
            rules: {
                upc: {
                    required: true,
                },
            },
            messages: {
                tip: {
                    required: "Please enter a valid UPC",
                },
            },
        },
        COUPONS: {
            rules: {
                code: {
                    required: true,
                },
                title: {
                    required: true,
                },
                description: {
                    required: true,
                },
                valueNumValue: {
                    required: true,
                    number: true,
                    min: 0,
                },
                minOrder: {
                    required: true,
                    number: true,
                    min: 0,
                },
                noofOrderConstraint: {
                    required: true,
                    number: true,
                    min: 0,
                },
                timesRedeemable: {
                    number: true,
                    min: 1,
                },
            },
            messages: {
                timesRedeemable: {
                    min: "Please enter a number greater than 1, or leave empty",
                },
            },
        },
    };
});

hsApp.component('adminActionForm', {
    templateUrl: '/partials/components/admin-action-form.html',
    bindings: {
        title: '@',
        subTitle: '@',
        btnText: '@',
        errorMessage: '<',
        isLoading: '<',
        formValidation: '<',
        inputVal: '<',
        inputType: '<',
        handleSubmit: '&',
        handleSkipClick: '&',
    },
    controller: ['$attrs', function($attrs) {
        this.$onInit = function() {
            if ($attrs.handleSkipClick === undefined) {
                this.handleSkipClick = null;
            }
            var name = this.formValidation && this.formValidation.name ? this.formValidation.name : '';
            // needed for property binding to work properly in component template's input element when !subTitle
            this.input = {
                value: this.inputVal,
                name: name,
                type: this.inputType || 'text',
            };
        };
    }],
});

hsApp.component('adminDiscountInput', {
    templateUrl: '/partials/components/admin-discount-input.html',
    bindings: {
        typeValue: '<',
        dollarValue: '<',
        percentValue: '<',
        onChange: '&',
    },
    controller: [ 'hsAdmin', 'hsUtils', adminDiscountInputController ],
});

function adminDiscountInputController(hsAdmin, hsUtils) {
    var ctrl = this;
    var logPrefix = '[adminDiscountInput]: ';

    ctrl.adminDiscountFormValidators = {
        rules: {
            'input-percent': {
                required: true,
                min: 0,
                max: 100
            },
            'input-dollar': {
                required: true,
                min: 0,
            },
        },
        messages: {
            'input-percent': {
                required: "Enter discount",
                min: "Enter value between 0 - 100",
                max: "Enter value between 0 - 100"
            },
            'input-dollar': {
                required: "Enter discount",
                min: "Enter discount 0 or greater",
            }
        }
    };
    ctrl.adminDiscountTypes = hsAdmin.adminDiscountTypes;

    ctrl.$onInit = function () {
        ctrl.adminDiscountForm = null;
        ctrl.initModels();
    };

    ctrl.$onChanges = function(changes) {
        if ('typeValue' in changes || 'dollarValue' in changes || 'percentValue' in changes) {
            ctrl.initModels();
        }
    };

    ctrl.initModels = function() {
        ctrl.models = {
            typeValue: ctrl.typeValue || ctrl.adminDiscountTypes.PERCENT,
            dollarValue: ctrl.dollarValue || 0,
            percentValue: ctrl.percentValue || 0,
        };
    };

    ctrl.hasChangedPercent = function() {
        return ctrl.percentValue !== ctrl.models.percentValue;
    };

    ctrl.hasChangedDollar = function() {
        return ctrl.dollarValue !== ctrl.models.dollarValue;
    };

    ctrl.cleanInput = function(input) {
        if (input === ctrl.adminDiscountTypes.PERCENT && !hsUtils.isNumber(ctrl.models.percentValue)) {
            ctrl.models.percentValue = 0;
        }
        if (input === ctrl.adminDiscountTypes.DOLLAR && !hsUtils.isNumber(ctrl.models.dollarValue)) {
            ctrl.models.dollarValue = 0;
        }
    };

    ctrl.onValueChange = function(input) {
        ctrl.cleanInput(input);

        if (ctrl.models.typeValue === ctrl.adminDiscountTypes.PERCENT && ctrl.hasChangedPercent()
            || ctrl.models.typeValue === ctrl.adminDiscountTypes.DOLLAR && ctrl.hasChangedDollar()
        ) {
            ctrl.notifyOnChange();
        }

    };

    ctrl.onTypeChange = function(type) {
        if (type !== ctrl.typeValue) {
            ctrl.notifyOnChange();
        }
    };

    ctrl.notifyOnChange = function() {
        var params = {
            validate: ctrl.adminDiscountForm.validate,
            typeValue: ctrl.models.typeValue,
            percentValue: ctrl.models.percentValue,
            dollarValue: ctrl.models.dollarValue,
        };
        ctrl.onChange({ value: params });
    };

}

hsApp.component('adminDragDrop', {
    templateUrl: '/partials/components/admin-drag-drop.html',
    bindings: {
        options: '<',
        showRemoveButton: '<',
        displayNameMapping: '<',
        showUpDownButton: '<',
        displayLogo: '<',
        showPreferredBadge:'<',
        showText: '<',
        onChange: '&',
        allowDisable: '&',
    },
    controller: ['$rootScope', 'hsUtils', adminDragDropController],
});

function adminDragDropController($rootScope, hsUtils) {

    var ctrl = this;
    var logPrefix = '[admin-drag-drop]: ';
    
    ctrl.$onInit = function () {

        void 0;
        
        /* Component accepts options as an array of objects
         * Eg: [{name: value_1}, {name: value_2}, ... , {name: value_N}] */
        if (!ctrl.options || !Array.isArray(ctrl.options)) {
            void 0;
        }

        for (var option of ctrl.options) {
            if (!hsUtils.isObject(option)) {
                void 0;
                break;
            }
        }

        if(!ctrl.showRemoveButton || typeof ctrl.showRemoveButton !== 'boolean') {
            void 0;
            ctrl.showRemoveButton = true;
        }

        if(!ctrl.showMoveUpButton || typeof ctrl.showMoveUpButton !== 'boolean') {
            void 0;
            ctrl.showUpDownButton = !$rootScope.screenWidth.lg;
        }

        if(!ctrl.displayLogo || typeof ctrl.displayLogo !== 'boolean') {
            void 0;
            ctrl.displayLogo = true;
        }

        if(!ctrl.showPreferredBadge || typeof ctrl.displayLogo !== 'boolean') {
            void 0;
            ctrl.showPreferredBadge = true;
        }

        if(!ctrl.showText || typeof ctrl.showText !== 'boolean') {
            void 0;
            ctrl.showPreferredBadge = true;
        }

        if(!ctrl.onChange || typeof ctrl.onChange !== 'function') {
            void 0;
            ctrl.onChange = function() {};
        }

        if(!ctrl.allowDisable || typeof ctrl.allowDisable !== 'function') {
            void 0;
            ctrl.allowDisable = function() { return true; };
        }
    };

    ctrl.removeOption = function(index) {
        ctrl.options.splice(index, 1);
        ctrl.onChange();
    };

    ctrl.moveUp = function(index) {
        var newIndex = index-1;
        
        if (newIndex >= 0) {
            var option = ctrl.options.splice(index, 1)[0];
            ctrl.options.splice(newIndex, 0, option);
            ctrl.onChange();
        }
    };

    ctrl.moveDown = function(index) {

        var newIndex = index+1;
        
        if (newIndex >= 0) {
            var option = ctrl.options.splice(index, 1)[0];
            ctrl.options.splice(newIndex, 0, option);
            ctrl.onChange();
        }
    };

    ctrl.disableUpDownButton = function(index, buttonType) {

        if (buttonType === 'up') {
            return index <= 0;
        }

        if (buttonType === 'down') {
            return index >= ctrl.options.length - 1;
        }
    };
}
hsApp.component('adminOrderItem', {
    templateUrl: '/partials/components/admin-order-item.html',
    bindings: {
        order: '<',
        product: '<',
        canReplace: '<',
        packingPreview: '<',
        
        onUpdatePrice: '&',
        onChangeQuantity: '&',
        onUpdateQuantity: '&',
        onReplaceItem: '&',
        onRemoveItem: '&',
        onPackQuantity: '&',
        onChangePackQuantity: '&',
    },
    controller: ['$scope', 'hsCart', 'toastr', 'hsPromos', adminOrderItemController],
});

function adminOrderItemController($scope, hsCart, toastr, hsPromos) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.hasOnInitRun = true;
        var nameWithoutSpaces = ctrl.product.name.replace(/\s*/g, '');
        ctrl.priceId = 'price-' + nameWithoutSpaces;
        ctrl.quantityId = 'quantity-' + nameWithoutSpaces;
        ctrl.quantityPackId = 'quantity-pack-' + nameWithoutSpaces;
        ctrl.sellByQtyPackId = nameWithoutSpaces;
        ctrl.isSellByQty = ctrl.product.unit === 'lb' && ctrl.product.sellByQty;

        ctrl.price = '';
        ctrl.quantity = ctrl.product.quantity;
        ctrl.quantityLb = '';
        ctrl.quantityPack = 0;
        ctrl.quantityPackLb = '';

        ctrl.showUpdatePriceBtn = false;
        ctrl.showUpdateQuantityBtn = false;

        void 0;
    };

    ctrl.$onChanges = function (changesObj) {
        if (!ctrl.hasOnInitRun) return;

        if (changesObj.product) {
            ctrl.quantity = changesObj.product.currentValue.quantity;
        }
    };

    ctrl.updatePrice = function() {
        if (isNaN(ctrl.price) || ctrl.price === '') {
            return toastr.error('Please enter valid number.');
        }
        ctrl.onUpdatePrice({priceId: '#' + ctrl.priceId});
        ctrl.showUpdatePriceBtn = false;
        ctrl.price = '';
    };

    ctrl.changeQuantity = function(product, updateType, selector) {
        ctrl.onChangeQuantity({product: product, updateType: updateType, selector: ctrl.quantityId});
    };

    ctrl.updateQuantity = function(lb) {
        var model = ctrl.quantity;
        if (lb) {
            model = ctrl.quantityLb;
        }
        if (isNaN(model) || model === '' || parseFloat(model) === 0) {
            return toastr.error('Please enter valid number.');
        }
        ctrl.onUpdateQuantity({index: ctrl.quantityId.replace('quantity-', '')});
        ctrl.showUpdateQuantityBtn = false;
        ctrl.quantityLb = '';
    };

    ctrl.removeItem = function() {
        ctrl.onRemoveItem().then(function(res) {
            if (res === true) {
                $scope.$parent.closeThisDialog();
            }
        });
    };

    ctrl.replaceItem = function() {
        ctrl.onReplaceItem();
    };

    ctrl.packQuantity = function(lb) {
        ctrl.onPackQuantity({index: '', selector: ctrl.isSellByQty ? ctrl.sellByQtyPackId : ctrl.quantityPackId})
            .then(function(res) {
                if (res.status === 200) {
                    $scope.$parent.closeThisDialog();
                }
            })
            .catch(function(err) {
                void 0;
            });
    };

    ctrl.changePackQuantity = function(product, updateType, selector) {
        ctrl.onChangePackQuantity({product: product, updateType: updateType, selector: ctrl.quantityPackId});
    };

    ctrl.calculateProductPrice = function() {
        return hsCart.calculateProductPrice(ctrl.product);
    };

    ctrl.calculateUnitQuantity = function() {
        return hsCart.calculateUnitQuantity(ctrl.product);
    };

    ctrl.getProductDisplayName = function() {
        return hsCart.getProductDisplayName(ctrl.product);
    };

    ctrl.getProductItemizedTotal = function() {
        return hsCart.getProductItemizedTotal(ctrl.product);
    };

    ctrl.getRelevantPromotionForPrice = function() {
        return hsPromos.getRelevantPromotionForPrice(ctrl.product, ctrl.product.promotion);
    };
}


/************************************************

************************************************/

"use strict";

hsApp.directive("hsAdminProductItem",
    function () {
        return {
            restrict    : "E",
            templateUrl : '../../../partials/components/admin-product-item.html',
            scope       : {
                rebuildProductCategories: '=',
                products: '=',
                productObj      : '=',
	            manageProduct   : '=',
	            replaceItem     : '=',
	            order           : '=',
	            addItemToOrder  : '=',
                hideImage		: '=',
                categoryName	: '=',
                categoryUrl     : '=',
	            tabularView     : '=',
	            tabularManagerView: '='
            },
            controller  : ["$scope", "$rootScope", "$http", "localStorageService", "scrollToElement", "$filter", "ENV", "$location", "allProducts", "hsCart", "hsAuth", "hsAdmin", "toastr", "ngDialog", "hsPromos", "hsDialog", "globalFunctions", function($scope, $rootScope,$http, localStorageService, scrollToElement, $filter, ENV, $location, allProducts, hsCart, hsAuth, hsAdmin, toastr, ngDialog, hsPromos, hsDialog, globalFunctions){
	            $scope.product = {
	            	addingItem: false,
                    config                      : {
                        showLoading     : false,
                        showViewAll     : false,
                        categoryName	: '',
                        renderEmptyTile : false,
	                    quantity        : '',
	                    productObj      : '',
	                    allProducts     : allProducts,
                    },
		            unitTypes                   : ['lb', 'count', 'bunch'],
		            productPrice                : 0,
                    data                        : {},
					originalData				: {},
		            quantity                    : 1,
		            unitType                    : '',
                    getProductDisplayName: function (item) {
                        return hsCart.getProductDisplayName(item);
                    },
		            updateUnit() {
                    	void 0;
                    	this.updateProduct(false, 'unit');
		            },
		            addItemToOrder: function (item) {
			            void 0;
						if (isNaN($scope.product.quantity) || $scope.product.quantity <= 0) {
							toastr.error('Please enter a valid quantity.');
							return;
						}
						var qty = hsCart.getValidQuantityWithUnits(item, $scope.product.quantity);
						if (!qty.isValid) {
							$scope.product.quantity = qty.value;
							toastr.error('Value should be in the increments of ' + qty.unit);
							return ;
						}
			            if (item.isContainer || item.hasModifiers || (item.availableTimes && item.availableTimes.length > 0)) {
				            item.quantity = $scope.product.quantity;
				            this.showProductPopup(item);
			            } else {
				            var data = {
					            order: {
						            key: $scope.order.key,
						            itemName: item.name,
						            itemQuantity: $scope.product.quantity,
						            isCustomItem: item.isCustom || item.isCustomItem || false,
						            isOrganicItem: item.organic
					            }
				            };

				            this.addItemToExistingOrder(data, item);
			            }
		            },
		            addItemToExistingOrder: function (data, item) {
		            	if ($scope.product.addingItem) return;

		            	$scope.product.addingItem = true;

                    	if ($scope.replaceItem) {
                    		data.order.remove = {
                    			itemName: $scope.replaceItem.name,
			                    selectedModifiers: []
		                    };

		                    if ($scope.replaceItem.selectedModifiers) {
			                    data.order.remove.selectedModifiers = $scope.replaceItem.selectedModifiers.map(function (modifier) {
				                    return modifier.name;
			                    });
		                    }
	                    }

                    	void 0;
			            hsAdmin.addItemToOrder(data)
				            .then(function (response) {
					            switch(response.status) {
						            case 200:
							            void 0;
							            toastr.success('Item added to order successfully.');
							            if ($scope.replaceItem) {
								            void 0;
								            if ($scope.replaceItem.bulkPacking) {
									            ngDialog.getOpenDialogs().forEach(function(dialog) {
										            if (dialog !== 'bulkpacking-dialog') {
											            ngDialog.close(dialog, { replaced: true });
										            }
									            });
								            } else {
								                ngDialog.close(null, { type: 'order-updated', data: response.data });
								            }
										} else {
											$rootScope.$emit('itemAddedToOrder', { type: 'order-updated', data: response.data });
										}
							            break;
						            case 402:
							            toastr.error('Customer credit card was declined and hence the change you are attempting to make was not successful.');
                                        break;
                                    case 406:
                                        toastr.error('Item selected is only available for Pick Up.');
                                        break;
						            case 409:
							            toastr.error('Item already exists in the order.');
							            break;
						            default:
							            void 0;
							            toastr.error('Error adding item to order.');
							            break;
					            }

					            if (item) {
						            item.isUpdating = false;
						            item.loading = false;
					            }
				            })
				            .finally(function () {
				            	$scope.product.addingItem = false;
				            });
		            },
                    init                        : function () {
	                    if ($scope.tabularView || $scope.tabularManagerView) {
		                    this.config.tabularView = $scope.tabularView;
		                    this.config.quantity = $scope.productObj.quantity;
		                    $scope.product.data = $scope.productObj;
		                    $scope.product.unitType = $scope.productObj.unit;
		                    $scope.product.productPrice = $scope.productObj.price;
	                    } else {
		                    if(!$scope.productObj) {
			                    this.config.showViewAll = true;
			                    this.config.categoryName = $scope.categoryName;
		                    } else {
			                    if($scope.productObj.renderEmptyTile){
				                    $scope.product.renderEmptyTile = $scope.productObj.renderEmptyTile;
			                    }else{
				                    $scope.product.data = $scope.productObj;
				                    $scope.product.unitType = $scope.productObj.unit;
				                    $scope.product.productPrice = $scope.productObj.price;
			                    }
		                    }
	                    }
						$scope.product.originalData = Object.assign({}, $scope.product.data);
                        $scope.$watch('productObj', function (newValue) {
                            if (newValue) {
                                if (newValue.renderEmptyTile) {
                                    $scope.product.renderEmptyTile = newValue.renderEmptyTile;
                                } else {
                                    $scope.product.data = newValue;
                                    $scope.product.unitType = newValue.unit;
                                    $scope.product.productPrice = newValue.price;
                                }
                            }
                        }, true);

						$(function () {
                            $('[data-toggle="tooltip"]').tooltip()
                        });
                    },
		            viewAllProducts             : function () {
                    	$location.url('/shop/'+ $scope.categoryUrl);
		            },
		            updateItemQuantity          : function (type, item) {
                    	if (type === "add") {
                    		item.quantity++;
		                    item.showRemoveBtn = false;
		                    this.addItem(item, item.quantity, (item.quantity !== 1));
	                    } else if (type === "subtract") {
                    		if (item.quantity === 1) {
                    		    this.removeItem(item);
		                    } else {
			                    item.quantity--;
                    		    item.showRemoveBtn = false;
			                    this.addItem(item, item.quantity, (item.quantity !== 1));
		                    }
	                    }
		            },
		            updateAddItemQuantity       : function (item, updateType) {
                    	$scope.product.quantity = hsCart.getUpdatedQuantity(item, updateType, $scope.product.quantity);
		            },
		            updateOrderFormItemQuantity : function (type, item) {
			            if (type === "add") {
				            $scope.product.config.quantity++;
				            item.loading = true;
				            $scope.product.processOrderItem();

			            } else if (type === "subtract" && $scope.product.config.quantity > 0) {
				            if ($scope.product.config.quantity > 0 && $scope.product.config.quantity < 1) {
					            $scope.product.config.quantity = 0;
				            } else {
					            $scope.product.config.quantity--;
				            }

				            item.loading = true;
				            $scope.product.processOrderItem();
			            }
		            },
					copyProductUrlToClipboard: function(product) {
						globalFunctions.copyProductUrlToClipboard(product, true);
					},
		            showProductPopup            : function (product) {
                    	void 0;
			            if ($scope.manageProduct && !$scope.addItemToOrder) {
			            	if ($rootScope.currentUser.isAdminRestricted && ENV.disabledRestrictedAdminProductChange) {
			            		return;
				            }
			            	$scope.product.showProductDetails(product);
			            } else {
				            var modalClass = '';


				            if(product.hasImage){
					            modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
				            }else{
					            modalClass = 'ngdialog-theme-default email-capture';
				            }

				            if ($scope.addItemToOrder) {
				            	product.order = $scope.order;
				            	product.addItemToOrder = true;
				            }

				            if ($scope.replaceItem) {
					            $scope.replaceItem.order = null;
					            delete $scope.replaceItem.order;
					            void 0;
				            }

				            product.replaceItem = $scope.replaceItem || false;

				            void 0;
				            ngDialog.open({
					            template    : 'partials/popup/admin-product-item/admin-product-item-popup.html',
					            controller  :'ModalController',
					            className   : modalClass,
					            data        : product
				            });
			            }

		            },
		            showProductDetails: function(product) {
		            	ngDialog.open({
				            template: '/partials/admin/product/product-details.html',
				            controller:'adminCtrl',
				            className: 'ngdialog-theme-default ngdialog-full-width ngdialog-admin-product-item-popup',
				            closeByEscape: false,
				            data: {
				                product: product,
				                allProducts: $scope.products,
								showGridView: true,
				            }
			            }).closePromise.then(function(data) {
                            if (data.value && data.value.product && typeof $scope.rebuildProductCategories === 'function') {
                                $scope.rebuildProductCategories(data.value.product);
                            }
							if (data.value && data.value.product && data.value.callback && typeof data.value.callback === "function") {
								data.value.callback(data.value.product);
							}
                        });
		            },
		            updateItemPrice             : function (value) {
                    	if (value && !isNaN(value)) {
		                    this.updateProduct({
			                    price       : parseFloat(value)
		                    });
	                    } else {
                    		$scope.product.productPrice = $scope.productObj.price;
	                    }
		            },
		            updateItemInStock           : function (value) {
                    	if ($scope.product.config.showLoading) {
                    		void 0;
                    		return;
	                    }
                    		void 0;
                    	$scope.product.data.isInStock = value;
                    	this.updateProduct(value, 'isInStock');
		            },
		            updateProduct               : function (updateInStock, updateType) {
			            this.config.showLoading = true;
			            if (!$scope.product.productPrice || isNaN($scope.product.productPrice)) {
				            $scope.product.config.showLoading = false;
				            return toastr.error('Please enter a valid value.');
			            }

			            var productData         = {
				            product: {
					            name        : $scope.product.data.name,
					            isInStock   : $scope.product.data.isInStock,
					            unit        : $scope.product.unitType,
					            price       : parseFloat($scope.product.productPrice)
				            }
			            };

						if ($scope.product.data.hasOwnProperty('isAutoAdded') && $scope.product.data.isAutoAdded && !$scope.product.data.wasReviewed) {
							productData.product.wasReviewed = true;
						}
			            
						var userEmail = $rootScope.currentUser.email;

						if (updateType === 'isInStock') {
							productData.product.dataSources = {
								isInStock: {
									source: userEmail,
								},
							};
						}

			            void 0;

			            if ($rootScope.currentUser.isAdminRestricted && ENV.disabledRestrictedAdminProductChange) {
			            	delete productData.product.price;
			            }

			            hsAdmin.updateProduct(productData)
				            .then(function(response){
					            void 0;
					            if (response.status === 200) {
						            if (updateInStock) {
						                $scope.product.data.isInStock = productData.product.isInStock;
						            } else {
						                $scope.product.data.price = productData.product.price;
						            }

						            $scope.productObj.unit = productData.product.unit;
						            toastr.success('The system has successfully recorded your change, it may take a couple of mins for the change to become visiblethroughout the system. No need to update again.');
									var condensedProduct = $scope.product.condenseProductData(productData.product, updateType);
									$scope.product.originalData = Object.assign({}, $scope.product.data);
									var adminUserLocations = globalFunctions.getUserAdminLocations() || globalFunctions.getUserAdminLocationsFromStorage();
									var adminUserPriceLists = globalFunctions.getUserAdminPriceLists() || globalFunctions.getUserAdminPriceListsFromStorage();
									if (ENV.enableLocations && $rootScope.location && $rootScope.location.allLocations && $rootScope.location.selectedLocation
										&& adminUserLocations.length >= 1
										&& globalFunctions.getTruthyProductKeys(condensedProduct).length > 1 && condensedProduct.name)
									{
										hsDialog.openSyncProductDialog(updateType ? condensedProduct : productData.product, adminUserLocations, adminUserPriceLists);
									}
					            } else {	
					            	if (response.status === 417) {
						                toastr.error('Check Product Price and try again');
						            } else {
						                toastr.error('Error updating product.');
						            }

						            $scope.product.unitType = $scope.productObj.unit;
					            }

					            $scope.product.config.showLoading = false;
				            });
		            },
					condenseProductData			: function(productObj, updateType) {
						var condensedProduct = { name: productObj.name };
						switch (updateType) {
							case 'isInStock':
								if (productObj.isInStock !== $scope.product.originalData.isInStock) {
									condensedProduct.isInStock = productObj.isInStock;
								}
								break;
							case 'price':
								if (productObj.price !== $scope.product.originalData.price) {
									condensedProduct.price = productObj.price;
								}
								break;
							case 'unit':
								if (productObj.unit !== $scope.product.originalData.unit) {
									condensedProduct.unit = productObj.unit;
								}
								break;
						}
						return condensedProduct;
					},
		            addItem                     : function (item, quantity, isUpdating) {
                    	if(item.isContainer) {
							this.showProductPopup(item);
						} else {
                            var basket = localStorageService.get('adminOrder');
                            item.quantity = quantity;

                            if(basket){
                                var sameItem = false;
                                basket.forEach(function (basketItem) {
                                    if(basketItem.name === item.name){
                                        basketItem.quantity = item.quantity;
                                        sameItem = true;
                                    }
                                });

                                if(!sameItem){
                                    basket.push(item);
                                }

                                localStorageService.set('adminOrder', basket);
                            }else{
                                var basketArray = [];
                                basketArray.push(item);
                                localStorageService.set('adminOrder', basketArray);
                            }

                            item.quantity = quantity++;
                            $rootScope.$emit('adminOrderUpdated',true);
						}
		            },
		            removeItem                  : function (item) {
	                    var basket = localStorageService.get('adminOrder');
						var itemIndex = 0;

	                    basket.forEach(function(product, idx){
		                    if(product.name === item.name){
			                    itemIndex = idx;
		                    }
	                    });

	                    basket.splice(itemIndex, 1);

	                    localStorageService.set('adminOrder', basket);

	                    item.quantity       = 0;
	                    item.showRemoveBtn  = false;
	                    $rootScope.$emit('adminOrderUpdated',true);
		            },
		            processOrderItemOnBlur      : function () {
			            if (typeof this.config.quantity === 'undefined') {
				            this.config.quantity = 0;
				            if($scope.product.data.quantity > 0) {
					            $scope.product.removeOrderFormItem($scope.product.data);
				            }
			            } else if($scope.product.data.quantity > 0 && this.config.quantity === 0) {
				            $scope.product.removeOrderFormItem($scope.product.data);
			            }
		            },
		            processOrderItem            : function () {
			            if (this.config.quantity > 0) {
				            var item = $scope.product.data;
				            var quantity = this.config.quantity;
				            var basket = localStorageService.get('adminOrder');
				            item.quantity = quantity;

				            if (basket) {
					            var sameItem = false;
					            basket.forEach(function (basketItem) {
						            if(basketItem.name === item.name){
							            basketItem.quantity = item.quantity;
							            sameItem = true;
						            }
					            });

					            if (!sameItem) {
						            basket.push(item);
					            }

					            localStorageService.set('adminOrder', basket);
				            } else {
					            var basketArray = [];
					            basketArray.push(item);
					            localStorageService.set('adminOrder', basketArray);
				            }

				            $rootScope.$emit('adminOrderUpdated',true);
			            } else if (this.config.quantity === 0) {
				            $scope.product.removeOrderFormItem($scope.product.data);
			            }
		            },
		            removeOrderFormItem         : function (item) {
			            var basket = localStorageService.get('adminOrder');
			            var itemIndex = 0;

			            basket.forEach(function(product, idx){
				            if(product.name === item.name){
					            itemIndex = idx;
				            }
			            });

			            basket.splice(itemIndex, 1);

			            localStorageService.set('adminOrder', basket);

			            this.config.quantity = 0;
			            item.quantity       = 0;
			            item.showRemoveBtn  = false;
			            $rootScope.$emit('adminOrderUpdated', true);
		            },
	                calculateProductPrice       : function (priceObj) {
		                return hsCart.calculateProductPrice(priceObj);
	                },
	                calculatePricePerQuantity   : function (priceObj, perWord) {
		                return hsCart.calculatePricePerQuantity(priceObj, perWord);
	                },
                    shouldShowMembershipDiscount: function (item, promotion) {
                        return hsPromos.shouldShowMembershipDiscount(item, promotion);
                    },
                    getRelevantPromotionForPrice: function () {
                        return hsPromos.getRelevantPromotionForPrice($scope.product, $scope.product.promotion);
                    },
                };

                if ($scope.addItemToOrder) {
                    $scope.hsPromos = hsPromos;
                    $scope.$watch('hsPromos.ongoingPromotions', function() {
                        $scope.product.promotion = hsPromos.getVisiblePromotion($scope.productObj);
                        $scope.product.volumePromotions = hsPromos.getVisibleVolumePromotions($scope.productObj);
                    });
                }
            }]
        };
    }
);

hsApp.directive('autocomplete', function() {
	return {
		restrict: 'E',
		scope: {
			model: '=',
			choices: '=',
			inputClass: '@',
			inputName: '@',
			inputDisabled: '=',
			inputChange: '=',
		},
		templateUrl: "/partials/components/autocomplete.html",
		controller: ["$scope", "$timeout", function($scope, $timeout) {
			$scope.showList = false;
			$scope.suggestions = [];

			$scope.autofillInput = function(item) {
				$scope.model = item;
				$scope.showList = false;
				$scope.externalFunction();
			};

			$scope.suggest = function(str, event) {
				if (event.keyCode === 27) {
					$scope.suggestions = [];
					$scope.showList = false;
					return;
				}
				$scope.suggestions = $scope.choices.filter(function(choice) {
					return choice.toLowerCase().startsWith(str.toLowerCase());
				});
				if ($scope.suggestions.length && !($scope.suggestions.length === 1 && $scope.suggestions[0] === str)) {
					$scope.showList = true;
				} else {
					$scope.showList = false;
				}
			};

			$scope.externalFunction = function() {
				if (typeof $scope.inputChange === 'function') {
					$scope.inputChange();
				}
			}

			$scope.prepareToHideList = function() {
				$timeout(function() {
					$scope.showList = false;
				}, 200);
			};
		}],
	};
});

hsApp.component('availableTimes', {
    templateUrl: '/partials/components/available-times.html',
    bindings: {
        product: '<',
    },
    controller: ['globalFunctions', availableTimesController],
});

function availableTimesController(globalFunctions) {
    var ctrl = this;
    
    ctrl.$onInit = function () {
        if (!ctrl.product || typeof ctrl.product !== 'object' || Array.isArray(ctrl.product)) {
            void 0;
        }
        void 0;
    };

    ctrl.getTimeString = function(time) {
        if (time) {
            return globalFunctions.getFormattedTime(time);
        }
        return '';
    };
}
hsApp.component('badge', {
    templateUrl: '/partials/components/badge.html',
    bindings: {
        text: '@',
        badgeColor: '@',
        icon: '@',
        toolTipText: '@'
    },
    controller: [badgeController]
});

function badgeController() {
    var ctrl = this;

    ctrl.$onInit = function() {
        if(!ctrl.text) {
            ctrl.text = null;    
        }
        
        if(!ctrl.badgeColor) {
            ctrl.badgeColor = 'text-secondary';
        }

        if (!ctrl.icon) {
            ctrl.icon = null;
        }

        if (!ctrl.toolTipText) {
            ctrl.toolTipText = '';
        }

        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        });
    
    }
}
hsApp.component('bottomSheet', {
    transclude: true,
    bindings: {
        open: '<',
        onOpen: '&',
        onClose: '&'
    },
    templateUrl: '/partials/components/bottom-sheet.html',
    controller: [bottomSheetController]
});

function bottomSheetController() {

    var ctrl = this;
    
    ctrl.$onChanges = function(changes) {
        if (changes && changes.open && changes.open.currentValue !== changes.open.previousValue) {
            if (changes.open.currentValue) {
                ctrl.onOpen();
            } else {
                ctrl.onClose();
            }
        }
    }
}
hsApp.directive('categoriesToolbar', function() {
    return {
        restrict: 'E',
        scope: {
            categories: '=',
            selected: '=',
            select: '<',
        },
        templateUrl: "/partials/components/categories-toolbar.html",
        controller: ["$scope", "$window", "$timeout", "$location", "$routeParams", "hsUtils", "hsMarketingService", "globalFunctions", function($scope, $window, $timeout, $location, $routeParams, hsUtils, hsMarketingService, globalFunctions) {

            $scope.leftScrollDisabled = true;
            $scope.rightScrollDisabled = true;
            $scope.showButtons = false;

            $scope.ID = Date.now() + Math.floor(Math.random() * 1000);
            
            if (hsUtils.isObject($routeParams) && $routeParams.pListName) {
                if (!$scope.categories) {
                    $location.path('/products');
                }
                hsMarketingService.setMarketingQueryPriceList();
                return;
            }
            
            $scope.categoryNames = Object.keys($scope.categories).map(function(cat) { return $scope.categories[cat].name; });

            $scope.$watch('categories', function (newValue) {
                if (newValue) {
                    $scope.categoryNames = Object.keys(newValue).map(function(cat) { return $scope.categories[cat].name; });
                }
            });

            $scope.selectedVal = null;
            $scope.checkIfManualSelectionComplete = function(category) {
                var scrollTop     = $(window).scrollTop();
                var element = document.getElementById(category);
                if (!element || !element.offsetTop) return;
                var elementOffset = element.offsetTop;
                var distanceFromTop = (elementOffset - scrollTop);

                if (
                    !isNaN(Number(distanceFromTop))
                    && distanceFromTop >= 0 
                    && distanceFromTop <= window.innerHeight
                ) {
                    $scope.manualSelection = false;
                }
            }

            $scope.$watch('selected', function (newValue) {
                if (newValue) {
                    if ($scope.manualSelection) {
                        $scope.checkIfManualSelectionComplete($scope.selectedVal);
                    } else {
                        $scope.selectedVal = newValue;
                        $scope.scrollRightToTarget(newValue);
                        $scope.scrollLeftToTarget(newValue);
                    }
                }
            });

            $timeout(function() {
                $scope.$container = $("#container-" + $scope.ID);
                $scope.container = $scope.$container[0];
                $scope.container.addEventListener('scroll', updateScroll);
                $window.addEventListener('resize', setButtonsVisibility);
                $window.addEventListener('scroll', setButtonsVisibility);
                $scope.scrollRightToTarget($scope.selectedVal);
                $scope.scrollLeftToTarget($scope.selectedVal);
                setButtonsVisibility();
                $timeout(updateScroll, 250);
            }, 0);

            $scope.$on('$destroy', function() {
                $scope.container.removeEventListener('scroll', updateScroll);
                $window.removeEventListener('resize', setButtonsVisibility);
                $window.removeEventListener('scroll', setButtonsVisibility);
            });


            $scope.selectItem = function(item) {
                $scope.manualSelection = true;
                $scope.selectedVal = item;
                $scope.select(item);
            };

            $scope.scrollRight = function() {
                var list = $("#list-" + $scope.ID);
                var children = list.children();
                var found = -1;
                for (var i = 0; i < children.length; i++) {
                    var elem = children[i];
                    if (elem.offsetLeft + elem.offsetWidth
                        > $scope.container.offsetLeft + $scope.container.offsetWidth + $scope.container.scrollLeft
                    ) {
                        found = i;
                        break;
                    }
                }
                if (~found) {
                    var pos = children[found].offsetLeft - $scope.container.offsetLeft;
                    $scope.$container.animate({scrollLeft: pos}, 1000);
                }
            };

            $scope.scrollRightToTarget = function(target) {
                if (!$scope.$container) return;
                var list = $("#list-" + $scope.ID);
                var children = list.children();

                for (var i = 0; i < children.length; i++) {
                    var elem = children[i];
                    if (elem.id === 'list-cell-' + target) {
                        if (elem.offsetLeft + elem.offsetWidth
                            > $scope.container.offsetLeft + $scope.container.offsetWidth + $scope.container.scrollLeft
                        ) { 
                            var pos = elem.offsetLeft - $scope.container.offsetLeft;
                            $scope.$container.animate({scrollLeft: pos}, 1);
                            break;
                        }
                    }
                }
            };


            $scope.scrollLeft = function() {
                var list = $("#list-" + $scope.ID);
                var children = list.children();
                var found = -1;
                for (var i = children.length - 1; i >= 0; i--) {
                    var elem = children[i];
                    if (elem.offsetLeft < $scope.container.offsetLeft + $scope.container.scrollLeft) {
                        found = i;
                        break;
                    }
                }
                if (~found) {
                    var pos = children[found].offsetLeft + children[found].offsetWidth
                        - $scope.container.offsetLeft - $scope.container.offsetWidth;
                    $scope.$container.animate({scrollLeft: pos}, 1000);
                }
            };

            $scope.scrollLeftToTarget = function(target) {
                if (!$scope.$container) return;
                var list = $("#list-" + $scope.ID);
                var children = list.children();

                for (var i = children.length - 1; i >= 0; i--) {
                    var elem = children[i];
                    if (elem.id === 'list-cell-' + target) {
                        if (elem.offsetLeft < $scope.container.offsetLeft + $scope.container.scrollLeft) {
                            var pos = elem.offsetLeft + elem.offsetWidth
                                - $scope.container.offsetLeft - $scope.container.offsetWidth;
                            $scope.$container.animate({scrollLeft: pos}, 1);
                            break;
                        }
                    }
                }
            };

            $scope.isDarkMode = function(component) {
                return globalFunctions.isDarkMode(component);
            }

            function canScrollRight() {
                var $list = $("#list-" + $scope.ID);
                var list = $list[0];
                if (!list) return;

                return list.scrollWidth > $scope.container.offsetWidth + $scope.container.scrollLeft + 2;
            };

            function canScrollLeft() {
                return $scope.container.scrollLeft !== 0;
            };

            function updateScroll() {
                $scope.$apply(function() {
                    $scope.rightScrollDisabled = !canScrollRight();
                    $scope.leftScrollDisabled = !canScrollLeft();
                });
            }

            function setButtonsVisibility() {
                $scope.$apply(function() {
                    var $list = $("#list-" + $scope.ID);
                    var list = $list[0];
                    if (!list || !$scope.container) {
                        $scope.showButtons = false;
                        return;
                    }

                    $scope.showButtons = list.scrollWidth > $scope.container.offsetWidth + 2;
                    if ($scope.showButtons) {
                        $scope.rightScrollDisabled = !canScrollRight();
                        $scope.leftScrollDisabled = !canScrollLeft();
                    }
                });
            }
        }],
    };
});

hsApp.component('checkoutAvailableTimes', {
    templateUrl: '/partials/components/checkout-available-times.html',
    bindings: {
        cart: '=',
        onClose: '&',
    },
    controller: ['$timeout', checkoutAvailableTimesController],
});

function checkoutAvailableTimesController($timeout) {
    var ctrl = this;
    
    ctrl.$onInit = function () {
        if (!ctrl.cart || typeof ctrl.cart !== 'object') {
            void 0;
        }
    };

    ctrl.checkAvailableItems = function () {
        if(ctrl.cart.hasAvailableTimesItems()) {
            return true;
        } else {
            $timeout(function() {
                ctrl.onClose();
            })
            return false;
            
        }
    };

}
hsApp.component('creditCardForm', {
    templateUrl: '/partials/components/credit-card-form.html',
    bindings: {
        isForUser: '<',
        deliveryAddress: '<',
        isBillingAddressUpdate: '<',
        cardObj: '<',
        canCancel: '<',
        expandedView: '<',
        paymentProcessor: '<',
        btnClass: '@',
        submitButtonText: '<',
        onPreSubmit: '&',
        onSuccess: '&',
        onFailure: '&',
        onCancelClick: '&',
        savePaymentOnUser: '<',
        country: '<',
    },
    controller: [
        '$scope',
        '$attrs',
        'hsCart',
        'hsAuth',
        'hsStripe',
        'address',
        'VALIDATORS',
        'toastr',
        'ENV',
        '$timeout',
        'hsAdminOrder',
        'hsUtils',
        'hsUserPayments',
        creditCardFormController,
    ],
});


function creditCardFormController(
    $scope, $attrs, hsCart, hsAuth, hsStripe, addressFac, VALIDATORS, toastr, ENV, $timeout, hsAdminOrder, hsUtils, hsUserPayments
) {
    var ctrl = this;
    ctrl.hasOnInitRun = false;
    var logPrefix = '[credit-card-form]: ';

    function setDefaultsFromAttrs() {
        var DEFAULT_PROP_VALUES = {
            deliveryAddress: {},
            cardObj: {},
            isBillingAddressUpdate: false,
            canCancel: true,
            expandedView: false,
            btnClass: '',
            submitButtonText: 'Save',
            savePaymentOnUser: true,
            onPreSubmit: function () {},
            onSuccess: function () {},
            onFailure: function () {},
            onCancelClick: function () {},
        };
        Object.keys(DEFAULT_PROP_VALUES).forEach(function (key) {
            if ($attrs[key] === undefined) {
                ctrl[key] = DEFAULT_PROP_VALUES[key];
            }
        });
    }

    function initStripe() {
        var card = hsStripe.createElement();
        // mount the stripe iframe in the DOM
        card.mount('#card-element');

        card.on('change', function (event) {
            if (event.error) {
                ctrl.stripeInputErrorMessage = event.error.message;
            } else {
                ctrl.stripeInputErrorMessage = '';
            }
            $scope.$apply();
        });

        ctrl.cardElement = card;
    }

    function initVgs() {
        if (ctrl.savePaymentOnUser !== true) {
            void 0;
            throw "Failed to load form";
        }
        var form = VGSCollect.create(ENV.vgsConfig.vaultId, ENV.vgsConfig.env, function (state) {
            var cardNumber = state['paymentMethod.vgsCardNumber'];
            var cardCvc = state['paymentMethod.vgsCvc'];
            var cardExpirationDate = state['paymentMethod.vgsExpirationDate'];
            if (cardNumber) {
                ctrl.vgs = {
                    cardLast4: cardNumber.last4 || '',
                    cardBrand: cardNumber.cardType || '',
                };
            }

            ctrl.vgsInputErrors.cardNumber = cardNumber && !cardNumber.isValid 
                ? "Your card number is invalid."
                : '';
            ctrl.vgsInputErrors.cardCvc = cardCvc && !cardCvc.isValid 
                ? "Your card's security code is invalid."
                : '';
            ctrl.vgsInputErrors.cardExpirationDate = cardExpirationDate && !cardExpirationDate.isValid 
                ? "Your card's expiration year is invalid."
                : '';
        });

        var styles = {
            fontSize: '14px',
            color: '#555555',
            '@font-face': {
                'font-family': 'Lato',
                'font-style': 'normal',
                'font-weight': '400',
                'font-display': 'swap',
                'src': 'local("lato"), local("Lato"), url(https://fonts.gstatic.com/s/lato/v14/S6uyw4BMUTPHjx4wXiWtFCc.woff2) format("woff2")',
            },
            'font-family': '"Lato", sans-serif',
            '::placeholder': {
                color: 'rgba(0,0,0,0.4)',
            },
        };

        // name attribute gets merged with the data obj on form submission.
        var cardNumber = form.field('#cc-number', {
            type: 'card-number',
            name: 'paymentMethod.vgsCardNumber',
            placeholder: 'Card number',
            autoComplete: 'cc-number',
            showCardIcon: true,
            validations: ['required', 'validCardNumber'],
            css: styles,
        });

        var cardCvc = form.field('#cc-cvc', {
            type: 'card-security-code',
            name: 'paymentMethod.vgsCvc',
            placeholder: 'CVC',
            autoComplete: 'cc-csc',
            validations: ['required', 'validCardSecurityCode'],
            css: styles,
        });
        
        form.field('#cc-expiration-date', {
            type: 'card-expiration-date',
            name: 'paymentMethod.vgsExpirationDate',
            yearLength: '2',
            placeholder: 'MM / YY',
            validations: ['required', 'validCardExpirationDate'],
            css: styles,
        });
        // validates CVC value according to the card brand
        cardNumber.setCVCDependency(cardCvc);

        ctrl.vgsForm = form;
    }

    function initFiserv() {
        var divElem = document.getElementById(ctrl.fiservCCInputId);

        ctrl.fiservUrl = ctrl.createFiservUrl();
        var fiservUrl = ctrl.createFiservUrl();
        divElem.innerHTML = '<iframe id="tokenFrame" name="tokenFrame" src="' + fiservUrl + '" height="225" width="100%" frameborder="0" scrolling="no"></iframe>';

        window.addEventListener('message', function(event) {
            var tokenizedData = JSON.parse(event.data);   

            if (tokenizedData.validationError) {
                ctrl.fiservInputErrorMessage = "Credit card number, expiry date and CVV are required";
            } else {
                ctrl.fiservInputErrorMessage = '';
                var token = tokenizedData.message;
                if(hsUtils.isNonEmptyString(token)) {
                    var lastFourDigits = token.slice(token.length - 4);
                    ctrl.fiservInputData.token = token;
                    ctrl.fiservInputData.expiry = tokenizedData.expiry;
                    ctrl.fiservInputData.cardLast4 = lastFourDigits.toString();
                }
            }
            $scope.$apply();
        }, false);
    }

    ctrl.handleSubmit = function (ccForm) {
        void 0;
        $scope.$broadcast('validateAddress' + '-' + ctrl.addressFormId, function(isValid) {
            void 0;
            if (!isValid) {
                return;
            }
            ctrl.addNewPaymentMethodError = '';
            ctrl.isLoading = true;
            ctrl.onPreSubmit();
            if (ctrl.isBillingAddressUpdate && !ctrl.addNewPaymentMethod) {
                return ctrl.updateUserPaymentMethod({ billingAddress: ctrl.billingAddress });
            } else if (ctrl.paymentProcessor === 'stripe') {
                return ctrl.createStripeToken();
            } else if (ctrl.paymentProcessor === 'worldpay') {
                return ctrl.createVgsToken();
            } else if (ctrl.paymentProcessor === 'fiserv') {
                return ctrl.createFiservToken();
            }
        });
    };

    ctrl.createVgsToken = function() {
        ctrl.vgsInputErrors.show = false;
        var userAuth = hsAuth.getUserAuthObj();
        var headers = { 
            emailid: userAuth.emailId,
            authtoken: userAuth.authToken,
            apikey: ENV.APIKey,
        };
        if (ctrl.isForUser) {
            var forUser = hsAdminOrder.getSelectedUser();
            headers.targetuseremail = forUser.email;
        }
        void 0;
        ctrl.vgsForm.submit('/user/payment', {
            headers: headers,
            method: 'POST',
            data: { 
                paymentMethod: {
                    cardBrand: ctrl.vgs.cardBrand,
                    cardLast4: ctrl.vgs.cardLast4,
                    billingAddress: ctrl.billingAddress,
                },
            },
            mapDotToObject: 'merge',
        }, function(status, data) {
            if (status === 200) {
                void 0;
                ctrl.onSuccess({ userData: data.user });
            } else {    
                void 0;
                ctrl.handleResponse({ status: status });
            }
            ctrl.isLoading = false;
            $scope.$apply();
        }, function(error) {
            void 0;
            ctrl.onFailure();
            ctrl.isLoading = false;
            ctrl.vgsInputErrors.show = true;
        });
    }

    ctrl.createStripeToken = function () {
        return hsStripe.createToken(ctrl.cardElement, ctrl.billingAddress).then(function (resp) {
            void 0;
            if (resp.error) {
                void 0;
                ctrl.isLoading = false;
                ctrl.addNewPaymentMethodError = 'There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.';
                ctrl.onFailure(resp.error);
                $scope.$apply();
            } else {
                var token = resp.token;
                var paymentMethod = {
                    token: token.id,
                    last4: token.card.last4,
                    cardBrand: token.card.brand,
                    billingAddress: ctrl.billingAddress,
                };
                if (ctrl.savePaymentOnUser) {
                    return ctrl.updateUserPaymentMethod(paymentMethod, ctrl.isBillingAddressUpdate);
                } else {
                    ctrl.onSuccess({ paymentMethod: paymentMethod });
                    return;
                }
            }
        });
    };

    ctrl.createFiservToken = function() {
        
        if (!ctrl.fiservInputData.token || !ctrl.fiservInputData.expiry || !ctrl.fiservInputData.cardLast4) {
            ctrl.addNewPaymentMethodError = 'There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.';
            ctrl.isLoading = false;
            ctrl.onFailure();
            return;
        }

        var paymentMethod = {
            token: ctrl.fiservInputData.token,
            expiry: ctrl.fiservInputData.expiry,
            cardLast4: ctrl.fiservInputData.cardLast4.toString(),
            billingAddress: ctrl.billingAddress,
        };

        if (ctrl.savePaymentOnUser) {
            return ctrl.updateUserPaymentMethod(paymentMethod, ctrl.isBillingAddressUpdate);
        } else {
            ctrl.onSuccess({ paymentMethod: paymentMethod });
            return;
        }
    };

    ctrl.createFiservUrl = function(){
        var baseUrl = 'https://' + ENV.fiservConfig.site + '.cardconnect.com/itoke/ajax-tokenizer.html'
        
        var urlFlags = 'cardinputmaxlength=19' + // accept 19 chars for credit-card number
                    '&cardnumbernumericonly=true' + // accept only numbers for credit-card number
                    '&useexpiry=true' + // expiry date required
                    '&useexpiryfield=true' + // use expiry field as text field (as opposed to drop-down)
                    '&usecvv=true' + // CVC required
                    '&formatinput=true' + // auto format credit card number
                    '&enhancedresponse=true' + // errorCode + errorMessage added to tokenizedData response
                    '&invalidcreditcardevent=true' + // event for invalid credit card
                    '&invalidcvvevent=true' + // event for invalid cvv
                    '&invalidexpiryevent=true' + // event for invalid expiry date
                    '&tokenizewheninactive=true' + // tokenize when user stops typing (as opposed to tokenizing onBlur)
                    '&placeholder=Card Number' + // placeholder for credit card number
                    '&placeholdermonth=MM' + // placeholder for expiry month
                    '&placeholderyear=YYYY' + // placeholder for expiry date
                    '&placeholdercvv=CVV'; // placeholder for CVV

        var cssTags = "label{font-weight:500;font-family:latoregular,sans-serif;line-height:1.7em;font-size:14px;color:rgb(22, 11, 8);}" + 
                "input:first-of-type{width:95%;}" + 
                "input::placeholder{color:rgb(113,113,113,0.7);font-weight:500;}" + 
                "input{width:40px;margin-bottom:15px;padding: 10px 12px 10px 12px;border-radius: 4px;border-width:1px;border-style:solid;border-color:rgb(204, 204, 204);box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);}" + 
                "body{margin-bottom: 0px;}"

        return baseUrl + "?" + urlFlags + "&css=" + encodeURI(cssTags);
    }

    ctrl.handleResponse = function(resp, userData, update) {
        var toastrMsg;
        void 0;
        ctrl.isLoading = false;
        switch (resp.status) {
            case 200:
                toastrMsg = update
                    ? 'Payment Method Updated Successfully'
                    : 'Payment Method Added Successfully';

                var returnValue = ctrl.onSuccess({ userData: resp.data.user });

                if (returnValue && typeof returnValue.then === 'function') {
                    ctrl.isLoading = true;
                    returnValue
                        .then(function() {
                            ctrl.isLoading = false;
                            toastr.success(toastrMsg);
                            ctrl.cardElement && typeof ctrl.cardElement.clear === 'function' && ctrl.cardElement.clear();
                        })
                        .catch(function(err) {
                            void 0;
                            ctrl.isLoading = false;
                            ctrl.addNewPaymentMethodError = err.message;
                            toastr.error(err.message);
                        });
                } else {
                    toastr.success(toastrMsg);
                    ctrl.cardElement && typeof ctrl.cardElement.clear === 'function' && ctrl.cardElement.clear();
                }
                break;
            case 400:
            case 402:
                toastrMsg = update ? 'Error Updating Payment Method' : 'Error Adding Payment Method';
                toastr.error(toastrMsg);
                ctrl.addNewPaymentMethodError = 'There was an error validating the payment information, please make sure your credit card details and billing address are correct and try again.';
                ctrl.onFailure();
                break;
            case 409:
                toastrMsg = 'Maximum cards reached';
                toastr.error(toastrMsg);
                ctrl.addNewPaymentMethodError = 'You have reached the maximum allowed cards on file.';
                ctrl.onFailure();
                break;
            default:
                ctrl.addNewPaymentMethodError = 'Something went wrong. Please try again.';
                toastr.error('Something went wrong. Please try again.');
                ctrl.onFailure();
                break;
        }
    }

    ctrl.updateUserPaymentMethod = function (paymentMethod, update) {
        if (update) {
            ctrl.addNewPaymentMethodError = 'Address update is not supported.';
            toastr.error(ctrl.addNewPaymentMethodError);
            ctrl.onFailure();
            return;
        }
        return (ctrl.isForUser
            ? hsAdminOrder.addPaymentMethod(paymentMethod)
            : hsUserPayments.addPaymentMethod(paymentMethod)
        )
            .then(function (resp) {
                ctrl.handleResponse(resp);
            })
            .catch(function (resp) {
                ctrl.handleResponse(resp);
            });
    };

    ctrl.toggleBillingDeliveryAddress = function (value) {
        ctrl.useDeliveryAsBilling = value;
        if (ctrl.useDeliveryAsBilling) {
            ctrl.billingAddress = Object.assign({}, ctrl.deliveryAddress);
        } else {
            ctrl.billingAddress = Object.assign({}, ctrl.emptyBillingAddress);
        }
    };

    ctrl.toggleShowStripeElement = function () {
        ctrl.addNewPaymentMethod = !ctrl.addNewPaymentMethod;
        ctrl.addNewPaymentMethodError = '';
    };

    ctrl.isValidAddress = function (address) {
        return addressFac.isValidAddress(address);
    };

    function initState() {
        setDefaultsFromAttrs();
        ctrl.isLoading = false;
        ctrl.stripeInputErrorMessage = '';
        ctrl.addNewPaymentMethod = !ctrl.isBillingAddressUpdate;
        ctrl.hasAddress = ctrl.isValidAddress(ctrl.deliveryAddress);
        ctrl.useDeliveryAsBilling = ctrl.hasAddress;
        ctrl.vgsInputErrors = {
            show: false,
            cardNumber: '',
            cardCvc: '',
            cardExpirationDate: '',
        };
        ctrl.emptyBillingAddress = {
            street: '',
            aptUnit: '',
            city: '',
            state: '',
            zip: '',
        };
        ctrl.billingAddress = Object.assign(
            {},
            ctrl.hasAddress ? ctrl.deliveryAddress : ctrl.emptyBillingAddress
        );
        ctrl.isStripeFormMounted = false;
        ctrl.isVgsFormMounted = false;
        ctrl.isFiservFormMounted = false;
        ctrl.fiservInputData = {
            token: '',
            expiry: '',
            cardLast4: '',
        };
        ctrl.fiservUrl = '';
        ctrl.fiservInputErrorMessage = '';
        ctrl.addressFormId = 'credit-card-form';
        ctrl.fiservCCInputId = 'fiserv-cc-input';
    }

    ctrl.initCcForm = function() {
        if (ctrl.paymentProcessor === 'stripe' && !ctrl.isStripeFormMounted) {
            initStripe();
            ctrl.isStripeFormMounted = true;
        } else if (ctrl.paymentProcessor === 'worldpay' && !ctrl.isVgsFormMounted) {
            initVgs();
            ctrl.isVgsFormMounted = true;
        } else if (ctrl.paymentProcessor === 'fiserv' && !ctrl.isFiservFormMounted) {
            $timeout(function() {
                initFiserv();
                ctrl.isFiservFormMounted = true;
            }, 0);
        }
    }

    ctrl.$onInit = function () {
        initState();
        ctrl.initCcForm();
        ctrl.hasOnInitRun = true;
    };

    ctrl.$onChanges = function (changesObj) {
        if (!ctrl.hasOnInitRun) {
            return;
        }

        if (changesObj.deliveryAddress) {
            ctrl.hasAddress = ctrl.isValidAddress(ctrl.deliveryAddress);
            ctrl.useDeliveryAsBilling = ctrl.hasAddress;
            ctrl.billingAddress = Object.assign(
                { country: 'US' },
                ctrl.hasAddress ? ctrl.deliveryAddress : ctrl.emptyBillingAddress
            );
        }

        if (changesObj.isBillingAddressUpdate) {
            ctrl.addNewPaymentMethod = !ctrl.isBillingAddressUpdate;
        }

        if (changesObj.paymentProcessor) {
            ctrl.initCcForm();
        }
    };
}

hsApp.directive('drawer', function () {
    return {
        restrict: 'E',
        transclude: true,
        templateUrl: '/partials/components/drawer.html',
        scope: {
            open: '<',
            title: '@',
            description: '@',
            icon: '@',
            handleClick: '&',
            canClick: '<',
            isError: '<',
        },
        link: {
            pre: function ($scope, _, $attrs) {
                var DEFAULT_PROP_VALUES = {
                    open: false,
                    title: '',
                    description: '',
                    icon: '',
                    canClick: true,
                    isError: false,
                };

                Object.keys(DEFAULT_PROP_VALUES).forEach(function (key) {
                    if ($attrs[key] === undefined) {
                        $scope[key] = DEFAULT_PROP_VALUES[key];
                    }
                });
            },
        },
        controller: ["$scope", "$attrs", function ($scope, $attrs) {
            if ($attrs.handleClick === undefined) {
                $scope.drawerClick = function () {
                    $scope.open = !$scope.open;
                };
            } else {
                $scope.drawerClick = $scope.handleClick;
            }

            $scope.headerIcon = $attrs.icon ? 'fa fa-' + $attrs.icon : '';
        }],
    };
});

hsApp.component('ecrsSignup', {
    templateUrl: '/partials/components/ecrs-signup.html',
    controller: [
        '$rootScope',
        'globalFunctions',
        'localStorageService',
        '$location',
        '$scope',
        'hsCart',
        'hsAuth',
        'toastr',
        'ENV',
        '$filter',
        '$http',
        'VALIDATORS',
        ecrsSignupController,
    ],
});

function ecrsSignupController(
    $rootScope,
    globalFunctions,
    localStorageService,
    $location,
    $scope,
    hsCart,
    hsAuth,
    toastr,
    ENV,
    $filter,
    $http,
    VALIDATORS
) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if (!$rootScope.verifiedPhoneNumber || !$rootScope.loyaltyAccount) {
            $location.url('/signup');
            return;
        }
        var skipAddress = true; // turn off address for now

        globalFunctions.setSEOdata('Sign up | ' + ENV.SEO.title);
        ctrl.error = '';
        ctrl.signupValidationRules = VALIDATORS.SIGN_UP;

        void 0;

        if ('firstName' in $rootScope.loyaltyAccount) {
            ctrl.firstName = $rootScope.loyaltyAccount.firstName;
        }
        if ('lastName' in $rootScope.loyaltyAccount) {
            ctrl.lastName = $rootScope.loyaltyAccount.lastName;
        }
        if ('phoneNumber' in $rootScope.loyaltyAccount) {
            ctrl.phoneNumber = $rootScope.loyaltyAccount.phoneNumber;
        }
        if ('email' in $rootScope.loyaltyAccount) {
            ctrl.email = $rootScope.loyaltyAccount.email;
        }
        if ($rootScope.loyaltyAccount.address && !skipAddress) {
            ctrl.hasAddress = true;
            if ('street' in $rootScope.loyaltyAccount.address) {
                ctrl.street = $rootScope.loyaltyAccount.address.street;
            }
            if ('aptUnit' in $rootScope.loyaltyAccount.address) {
                ctrl.aptUnit = $rootScope.loyaltyAccount.address.aptUnit;
            }
            if ('city' in $rootScope.loyaltyAccount.address) {
                ctrl.city = $rootScope.loyaltyAccount.address.city;
            }
            if ('state' in $rootScope.loyaltyAccount.address) {
                ctrl.state = $rootScope.loyaltyAccount.address.state.toUpperCase();
            }
            if ('zip' in $rootScope.loyaltyAccount.address) {
                ctrl.zip = $rootScope.loyaltyAccount.address.zip;
            }
        }

        if (ENV.hideSignupBtn) {
            $location.url('/login');
            return;
        }
    };

    ctrl.signup = function() {
        ctrl.error = '';
        var form = ctrl.signupForm;

        if (form.validate()) {
            ctrl.buttonLoading = true;

            var data = {
                user: {
                    emailId: ctrl.email.trim().toString().toLowerCase(),
                    firstName: ctrl.firstName.trim().toString(),
                    lastName: ctrl.lastName.trim().toString(),
                    phoneNumber: $filter('bcTelephone')(ctrl.phoneNumber.toString(), 'clean'),
                    loyaltySignup: true,
                },
            };

            if (ctrl.hasAddress) {
                data.user.address = {
                    street: ctrl.street,
                    aptUnit: ctrl.aptUnit || '',
                    city: ctrl.city,
                    state: ctrl.state,
                    zip: ctrl.zip,
                };
            }

            void 0;

            var apiUrl = ENV.apiEndPoint + '/user';

            $http.post(apiUrl, data)
                .then(function(res) {
                    if (res.status === 200) {
                        void 0;
                        ctrl.processSignup(res.data);
                    } else if (res.status === 409) {
                        ctrl.error = 'User with this email already exists.';
                    } else {
                        void 0;
                        ctrl.error = res.data.message;
                    }
                })
                .finally(function() {
                    ctrl.buttonLoading = false;
                });
        }
    };

    ctrl.processSignup = function(user) {
        hsAuth.saveUserLocal(user);
        $rootScope.currentUser = user;
        $rootScope.loggedIn = true;

        var basket = localStorageService.get('basket');
        if(basket){
            hsCart.addItemToCart({
                items: basket.map(function(item) {
                    return {
                        name: item.name,
                        quantity: item.quantity,
                        isCustomItem: false,
                        canReplace: item.canReplace,
                        instructions: item.instructions || '',
                        displayName: item.displayName,
                        type: item.type,
                        subType: item.subType,
                        organic: item.organic,
                        unit: item.unit,
                        selectedModifiers: item.selectedModifiers
                            ? item.selectedModifiers.map(function(option) { return option.name }) : [],
                    };
                })
            })
                .then(function(res) {
                    void 0;
                    if (res.status === 200) {
                        toastr.success('Cart updated successfully.');
                        localStorageService.remove('basket');
                        $rootScope.$emit('cartUpdated', true);

                        if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                            window.location.href = ENV.noOrderingConfig.signupRedirect;
                            return;
                        }
                    } else {
                        void 0;
                    }
                    $location.url('/products');
                })
                .catch(function(err) {
                    void 0;
                });
        } else {
            $rootScope.$emit('cartUpdated', true);

            if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                window.location.href = ENV.noOrderingConfig.signupRedirect;
                return;
            }
            $location.url('/products');
        }
    };
}

hsApp.component('erewhonMembershipPopup', {
    templateUrl: '/partials/components/erewhon-membership-popup.html',
    bindings: {
        renew: '<',
        onClose: '&',
    },
    controller: [
        '$rootScope',
        'globalFunctions',
        '$location',
        '$scope',
        'hsAuth',
        'hsStripe',
        'hsUtils',
        'ENV',
        '$http',
        'VALIDATORS',
        'address',
        erewhonMembershipPopupController,
    ],
});

function erewhonMembershipPopupController(
    $rootScope,
    globalFunctions,
    $location,
    $scope,
    hsAuth,
    hsStripe,
    hsUtils,
    ENV,
    $http,
    VALIDATORS,
    address
) {
    var ctrl = this;
    var logPrefix = '[erewhon-membership]: ';

    ctrl.$onInit = function() {
        if (!$rootScope.loggedIn || !$rootScope.currentUser) {
            $location.url('/login');
            return;
        }
        globalFunctions.setSEOdata('Erewhon Membership | ' + ENV.SEO.title);
        ctrl.form = null;
        ctrl.validationRules = VALIDATORS.SIGN_UP;
        ctrl.error = '';
        ctrl.stripeInputErrorMessage = '';
        ctrl.firstName = null;
        ctrl.lastName = null;
        ctrl.email = null;
        ctrl.phoneNumber = $rootScope.verifiedPhoneNumber;
        ctrl.addressNonEditable = false;
        ctrl.address = {
            street: null,
            aptUnit: null,
            city: null,
            state: null,
            zip: null,
            country: null,
        };
        ctrl.pms = [];

        if ($rootScope.loggedIn) {
            ctrl.initUser($rootScope.currentUser);
        } else {
            ctrl.initUser(null);
        }
        ctrl.showSelectCreditCard = false;
        ctrl.showCreditCardForm = !ctrl.paymentMethodStr;

        ctrl.initStripe();
        ctrl.isLoading = false;
    };

    ctrl.initUser = function (user) {
        ctrl.pms = [];

        if (hsUtils.isObject(user)) {
            ctrl.firstName = user.firstName;
            ctrl.lastName = user.lastName;
            ctrl.phoneNumber = user.phoneNumber;
            ctrl.email = user.email;

            if (hsUtils.isNonEmptyArray(user.paymentMethods)) {
                ctrl.pms = user.paymentMethods.slice().reverse().filter(function(pm) {
                    return pm.paymentProcessor === $rootScope.paymentProcessor;
                });
            }
        } else {
            ctrl.firstName = null;
            ctrl.lastName = null;
            ctrl.phoneNumber = $rootScope.verifiedPhoneNumber;;
            ctrl.email = null;
            ctrl.addressNonEditable = false;
            ctrl.address = {
                street: null,
                aptUnit: null,
                city: null,
                state: null,
                zip: null,
                country: null,
            };
        }
        ctrl.setPaymentMethod(ctrl.pms.length ? ctrl.pms[0] : null);
    };

    ctrl.closeAll = function() {
        ctrl.showSelectCreditCard = false;
        ctrl.showCreditCardForm = false;
    };

    ctrl.toggleSelectCreditCard = function() {
        ctrl.showSelectCreditCard = !ctrl.showSelectCreditCard;
    };

    ctrl.toggleCreditCardForm = function() {
        ctrl.showCreditCardForm = !ctrl.showCreditCardForm;
    };

    ctrl.setPaymentMethod = function(paymentMethod) {
        if (hsUtils.isObject(paymentMethod)) {
            ctrl.paymentMethod = paymentMethod;
            ctrl.paymentMethodStr = ctrl.paymentMethod.cardBrand + ' - ' + ctrl.paymentMethod.cardLast4;
        } else {
            ctrl.paymentMethod = null;
            ctrl.paymentMethodStr = '';
        }
    };

    ctrl.selectPaymentMethod = function(paymentMethod) {
        ctrl.setPaymentMethod(paymentMethod);
        ctrl.closeAll();
    };

    ctrl.initStripe = function() {
        var card = hsStripe.createElement(true);
        card.mount('#card-element-popup');

        card.on('change', function(event) {
            ctrl.stripeInputErrorMessage = event.error ? event.error.message : '';
            $scope.$apply();
        });

        ctrl.cardElement = card;
    };

    ctrl.handleSubmit = function() {
        if (ctrl.isLoading || !ctrl.form.validate()) return;

        ctrl.error = '';
        ctrl.addNewPaymentMethodError = '';
        ctrl.isLoading = true;

        if (ctrl.showCreditCardForm) {
            ctrl.createStripeToken()
                .then(function(token) {
                    if (token) {
                        void 0;
                        ctrl.createOrRenewMembershipAccount(token);
                    } else {
                        void 0;
                        ctrl.isLoading = false;
                        $scope.$apply();
                    }
                })
                .catch(function(err) {
                    void 0;
                    ctrl.error = 'Something went wrong. Please try again.';
                    ctrl.isLoading = false;
                    $scope.$apply();
                });
        } else {
            ctrl.createOrRenewMembershipAccount();
        }
    };

    ctrl.createOrRenewMembershipAccount = function(token) {
        var user = {
            renew: ctrl.renew,
        };

        if (ctrl.showCreditCardForm) {
            user.paymentMethod = token;
            user.address = {
                street: ctrl.address.street,
                aptUnit: ctrl.address.aptUnit,
                city: ctrl.address.city,
                state: ctrl.address.state,
                zip: ctrl.address.zip,
            };
        } else {
            user.pmid = ctrl.paymentMethod.pmid;
        }

        void 0;

        $http.post(ENV.apiEndPoint + '/erewhon/membership', user)
            .then(function(res) {
                if (res.status === 200) {
                    void 0;
                    if (!res.data || !res.data.user) {
                        ctrl.error = 'Something went wrong.';
                        return;
                    }
                    hsAuth.saveUserLocal(res.data.user);
                    ctrl.onClose({ value: 'success' });
                } else if (res.status === 402) {
                    ctrl.error = 'We were unable to process your card. Please try again or use another card.';
                } else if (res.status === 409) {
                    ctrl.error = 'Membership with this phone number already exists.';
                } else {
                    void 0;
                    ctrl.error = 'Something went wrong.';
                }
                return ctrl.refreshUser();
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.createStripeToken = function() {
        return hsStripe.createToken(ctrl.cardElement, ctrl.address).then(function(res) {
            void 0;
            if (res.error) {
                void 0;
                ctrl.addNewPaymentMethodError = 'There was an error validating the payment information,'
                    + ' please make sure your credit card details and billing address are correct and try again.';
                return null;
            }
            return {
                token: res.token.id,
                last4: res.token.card.last4,
                cardBrand: res.token.card.brand,
            };
        });
    };

    ctrl.refreshUser = function() {
        return hsAuth.getUpdatedUser()
            .then(function (res) {
                if (res.status === 200 && hsUtils.isObject(res.data)) {
                    hsAuth.saveUserLocal(res.data);
                    ctrl.initUser(res.data);
                }
            })
            .catch(function (err) {
                void 0;
            });
    };

    ctrl.addressAutoComplete = function(shippingAddr) {
        // If the value of street1 is not a string, it means that it is the object
        // reference as a result of the ngAutocomplete functionality, which means we
        // have to fill out the rest of the entity fields.
        if (typeof(ctrl.address.street) !== 'string') {
            var autoComppleteAddress = address.getAutoCompleteAddress(ctrl.address.street);
            ctrl.address.street = autoComppleteAddress.street1;
            ctrl.address.aptUnit = autoComppleteAddress.street2;
            ctrl.address.city = autoComppleteAddress.city;
            ctrl.address.state = autoComppleteAddress.state;
            ctrl.address.zip = autoComppleteAddress.zip;
            ctrl.address.country = autoComppleteAddress.country;

            // Once autocomplete is done populating fields, focus on the Address 2 field as it cannot be autocompleted.
            setTimeout(function() {
                // validate and addressNonEditable need to be applied in the next digest cycle,
                // otherwise the errors are not cleared on the front end.
                // If addressNonEditable is set first, errors will not be cleared on disabled fields.
                ctrl.form.validate();
                ctrl.addressNonEditable = true;
                $scope.$apply();
                angular.element('#aptUnit').focus();
            }, 0);
        }
    };

    ctrl.isDarkMode = function() {
        return globalFunctions.isDarkMode('signup');
    }

    ctrl.getNewExpiration = function() {
        if (!$rootScope.currentUser || !$rootScope.currentUser.membership) return null;

        var now = new Date();
        var expiration = new Date($rootScope.currentUser.membership.expiration);

        if ($rootScope.currentUser.membership.expiration && !isNaN(expiration.getTime())) {
            if (expiration > now) {
                now = expiration;
            }
        }
        now = new Date(now.setFullYear(now.getFullYear() + 1));
        var parts = now.toDateString().split(' ');
        return parts[2] + ' ' + parts[1] + ' ' + parts[3];
    };

}

hsApp.component('erewhonMembership', {
    templateUrl: '/partials/components/erewhon-membership.html',
    controller: [
        '$rootScope',
        'globalFunctions',
        'localStorageService',
        '$location',
        '$scope',
        'hsCart',
        'hsAuth',
        'hsStripe',
        'toastr',
        'ENV',
        '$filter',
        '$http',
        'VALIDATORS',
        'address',
        erewhonMembershipController,
    ],
});

function erewhonMembershipController(
    $rootScope,
    globalFunctions,
    localStorageService,
    $location,
    $scope,
    hsCart,
    hsAuth,
    hsStripe,
    toastr,
    ENV,
    $filter,
    $http,
    VALIDATORS,
    address
) {
    var ctrl = this;
    var logPrefix = '[erewhon-membership]: ';

    ctrl.$onInit = function() {
        if ($rootScope.loggedIn || !$rootScope.verifiedPhoneNumber) {
            $location.url('/login');
            return;
        }
        globalFunctions.setSEOdata('Erewhon Membership | ' + ENV.SEO.title);
        ctrl.form = null;
        ctrl.validationRules = VALIDATORS.SIGN_UP;
        ctrl.error = '';
        ctrl.stripeInputErrorMessage = '';
        ctrl.firstName = null;
        ctrl.lastName = null;
        ctrl.email = null;
        ctrl.phoneNumber = $rootScope.verifiedPhoneNumber;
        ctrl.addressNonEditable = false;
        ctrl.address = {
            street: null,
            aptUnit: null,
            city: null,
            state: null,
            zip: null,
            country: null,
        };

        ctrl.initStripe();
        ctrl.isLoading = false;
    };

    ctrl.initStripe = function() {
        var card = hsStripe.createElement(true);
        // mount the stripe iframe in the DOM
        card.mount('#card-element');

        card.on('change', function(event) {
            ctrl.stripeInputErrorMessage = event.error ? event.error.message : '';
            $scope.$apply();
        });

        ctrl.cardElement = card;
    };

    ctrl.handleSubmit = function() {
        if (!ctrl.form.validate()) return;

        ctrl.error = '';
        ctrl.addNewPaymentMethodError = '';
        ctrl.isLoading = true;

        ctrl.createStripeToken()
            .then(function(token) {
                if (token) {
                    void 0;
                    ctrl.createMembershipAccount(token);
                } else {
                    void 0;
                    ctrl.isLoading = false;
                    $scope.$apply();
                }
            })
            .catch(function(err) {
                void 0;
                ctrl.error = 'Something went wrong. Please try again.';
                ctrl.isLoading = false;
                $scope.$apply();
            });
    };

    ctrl.createMembershipAccount = function(token) {
        var user = {
            email: ctrl.email.trim().toString().toLowerCase(),
            firstName: ctrl.firstName.trim().toString(),
            lastName: ctrl.lastName.trim().toString(),
            phoneNumber: $filter('bcTelephone')(ctrl.phoneNumber.toString(), 'clean'),
            paymentMethod: token,
            address: {
                street: ctrl.address.street,
                aptUnit: ctrl.address.aptUnit,
                city: ctrl.address.city,
                state: ctrl.address.state,
                zip: ctrl.address.zip,
            },
        };

        void 0;

        $http.post(ENV.apiEndPoint + '/erewhon/membership', user)
            .then(function(res) {
                if (res.status === 200) {
                    void 0;
                    if (!res.data || !res.data.user) {
                        ctrl.error = 'Something went wrong. Failed to log in user.';
                        return;
                    }
                    ctrl.processLogin(res.data.user);
                } else if (res.status === 401) {
                    ctrl.error = 'Please verify your phone number again.';
                } else if (res.status === 402) {
                    ctrl.error = 'We could not process your card. Please try again with another card.';
                } else if (res.status === 409) {
                    if (res.data.message.toLowerCase().includes('email')) {
                        ctrl.error = 'User with this email already exists.';
                    } else if (res.data.message.toLowerCase().includes('phone number')) {
                        ctrl.error = 'User with this phone number already exists.';
                    } else if (res.data.message.toLowerCase().includes('membership')) {
                        ctrl.error = 'Membership account already exists.';
                    } else {
                        ctrl.error = 'User already exists.';
                    }
                } else {
                    void 0;
                    ctrl.error = 'Something went wrong. Please make sure that all information is correct and try again.';
                }
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.createStripeToken = function() {
        return hsStripe.createToken(ctrl.cardElement, ctrl.address).then(function(res) {
            void 0;
            if (res.error) {
                void 0;
                ctrl.addNewPaymentMethodError = 'There was an error validating the payment information,'
                    + ' please make sure your credit card details and billing address are correct and try again.';
                return null;
            }
            return {
                token: res.token.id,
                last4: res.token.card.last4,
                cardBrand: res.token.card.brand,
            };
        });
    };

    ctrl.processLogin = function(user) {
        hsAuth.saveUserLocal(user);
        $rootScope.currentUser = user;
        $rootScope.loggedIn = true;
        localStorageService.set('erewhonMembershipSuccess', true);

        var basket = localStorageService.get('basket');
        if(basket){
            hsCart.addItemToCart({
                items: basket.map(function(item) {
                    return {
                        name: item.name,
                        quantity: item.quantity,
                        isCustomItem: false,
                        canReplace: item.canReplace,
                        instructions: item.instructions || '',
                        displayName: item.displayName,
                        type: item.type,
                        subType: item.subType,
                        organic: item.organic,
                        unit: item.unit,
                        selectedModifiers: item.selectedModifiers
                            ? item.selectedModifiers.map(function(option) { return option.name }) : [],
                    };
                })
            })
                .then(function(res) {
                    void 0;
                    if (res.status === 200) {
                        toastr.success('Cart updated successfully.');
                        localStorageService.remove('basket');
                        $rootScope.$emit('cartUpdated', true);

                        if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                            window.location.href = ENV.noOrderingConfig.signupRedirect;
                            return;
                        }
                    } else {
                        void 0;
                    }
                    $location.url('/signup/erewhon/success');
                })
                .catch(function(err) {
                    void 0;
                });
        } else {
            $rootScope.$emit('cartUpdated', true);

            if (ENV.noOrderingConfig && ENV.noOrderingConfig.signupRedirect) {
                window.location.href = ENV.noOrderingConfig.signupRedirect;
                return;
            }
            $location.url('/signup/erewhon/success');
        }
    };

    ctrl.addressAutoComplete = function(shippingAddr) {
        // If the value of street1 is not a string, it means that it is the object
        // reference as a result of the ngAutocomplete functionality, which means we
        // have to fill out the rest of the entity fields.
        if (typeof(ctrl.address.street) !== 'string') {
            var autoComppleteAddress = address.getAutoCompleteAddress(ctrl.address.street);
            ctrl.address.street = autoComppleteAddress.street1;
            ctrl.address.aptUnit = autoComppleteAddress.street2;
            ctrl.address.city = autoComppleteAddress.city;
            ctrl.address.state = autoComppleteAddress.state;
            ctrl.address.zip = autoComppleteAddress.zip;
            ctrl.address.country = autoComppleteAddress.country;

            // Once autocomplete is done populating fields, focus on the Address 2 field as it cannot be autocompleted.
            setTimeout(function() {
                // validate and addressNonEditable need to be applied in the next digest cycle,
                // otherwise the errors are not cleared on the front end.
                // If addressNonEditable is set first, errors will not be cleared on disabled fields.
                ctrl.form.validate();
                ctrl.addressNonEditable = true;
                $scope.$apply();
                angular.element('#aptUnit').focus();
            }, 0);
        }
    };

    ctrl.isDarkMode = function() {
        return globalFunctions.isDarkMode('signup');
    }

}

hsApp.component('erewhonSuccess', {
    templateUrl: '/partials/components/erewhon-success.html',
    controller: ['localStorageService', '$location', erewhonSuccessController],
});

function erewhonSuccessController(localStorageService, $location) {
    var ctrl = this;

    ctrl.$onInit = function() {
        var success = localStorageService.get('erewhonMembershipSuccess');
        if (!success) {
            $location.url('/login');
            return;
        }
        localStorageService.remove('erewhonMembershipSuccess');

        ctrl.isLoading = false;
    };

}

"use strict";
hsApp.directive("ngJsonExportExcel",
  function() {
    return {
      restrict: 'AE',
      scope: {
        data: '=',
        filename: '=?',
        reportFields: '=',
        nestedReportFields: '=',
        nestedDataProperty: "@"
      },
      link: function(scope, element) {
        scope.filename = !!scope.filename ? scope.filename : "export-excel";

        function generateFieldsAndHeaders(fieldsObject, fields, header) {
          angular.forEach(fieldsObject, function(field, key) {
            if (!field || !key) {
              throw new Error("error json report fields");
            }
            fields.push(key);
            header.push(field);
          });
          return {
            fields: fields,
            header: header
          };
        }
        // var fieldsAndHeader = generateFieldsAndHeaders(scope.reportFields, [], []);
        // var fields = fieldsAndHeader.fields,
        //   header = fieldsAndHeader.header;
        // var nestedFieldsAndHeader = generateFieldsAndHeaders(scope.nestedReportFields, [], [""]);
        // var nestedFields = nestedFieldsAndHeader.fields,
        //   nestedHeader = nestedFieldsAndHeader.header;

        function _convertToExcel(body, header) {
          return header + "\n" + body;
        }

        function _objectToString(object) {
          var output = "";
          angular.forEach(object, function(value, key) {
            output += key + ":" + value + " ";
          });

          return "'" + output + "'";
        }

        function generateFieldValues(list, rowItems, dataItem) {
          angular.forEach(list, function(field) {
            var data = "",
              fieldValue = "",
              curItem = null;
            if (field.indexOf(".")) {
              field = field.split(".");
              curItem = dataItem;
              // deep access to obect property
              angular.forEach(field, function(prop) {
                if (curItem !== null && curItem !== undefined) {
                  curItem = curItem[prop];
                }
              });
              data = curItem;
            } else {
              data = dataItem[field];
            }
            fieldValue = data !== null ? data : " ";
            if (fieldValue !== undefined && angular.isObject(fieldValue)) {
              fieldValue = _objectToString(fieldValue);
            }
            rowItems.push(fieldValue);
          });
          return rowItems;
        }

        function _bodyData() {
          var body = "";

          angular.forEach(scope.data, function(dataItem) {
            var rowItems = [];
            var nestedBody = "";
            rowItems = generateFieldValues(fields, rowItems, dataItem);
            //Nested Json body generation start 
            if (scope.nestedDataProperty && dataItem[scope.nestedDataProperty].length) {
              angular.forEach(dataItem[scope.nestedDataProperty], function(nestedDataItem) {
                var nestedRowItems = [""];
                nestedRowItems = generateFieldValues(nestedFields, nestedRowItems, nestedDataItem);
                nestedBody += nestedRowItems.toString() + "\n";
              });
              var strData = _convertToExcel(nestedBody, nestedHeader);
              body += rowItems.toString() + "\n" + strData;
              ////Nested Json body generation end 
            } else {
              body += rowItems.toString() + "\n";
            }
          });
          return body;
        }

       // $timeout(function() {
          element.bind("click", function() {
            var bodyData = _bodyData();
            var strData = _convertToExcel(bodyData, header);
            var blob = new Blob([strData], {
              type: "text/plain;charset=utf-8"
            });

            return saveAs(blob, [scope.filename + ".csv"]);
          });
       // }, 1000);

      }
    };


  }
);

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.1.20151003
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent)
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if (target_view && is_safari && typeof FileReader !== "undefined") {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var base64Data = reader.result;
							target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/));
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && is_safari) {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				setTimeout(function() {
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name, no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name || "download");
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}

hsApp.component('filterBar', {
    templateUrl: '/partials/components/filter-bar.html',
    bindings: {
        filters: '<',
        onSelect: '&',
        onRevert: '&',
        phrase: '<',
        showClearAll: '<',
        getFilterDisplayName: '&'
    },
    controller: ['$scope', 'globalFunctions', filterBarController],
});

function filterBarController($scope, globalFunctions) {

    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.filterState = {};
        ctrl.filterSections = Object.keys(globalFunctions.getEnabledFilters(ctrl.filters));
        ctrl.filterSections.forEach(function(filter) {
            ctrl.filterState[filter] = {
                currentPath: {},
                activePath: {}
            };
        });
    };

    $scope.$on('applyFilterOption', function(_, data) {
        ctrl.apply(data);
    });

    $scope.$on('revert', function(_, data) {
        ctrl.revert(data);
    });

    ctrl.apply = function(data) {
        var options = ctrl.processFilterOptions();
        ctrl.onSelect({ options: options, mobile: false }).then(function() {
            $scope.$broadcast("refreshFilterStates", {
                state: ctrl.filters,
                source: data.filterName,
                data: ctrl.filters[data.filterName]['data'],
                level: data.level
            });
            $scope.$broadcast("update", {
                source: data.filterName,
                data: ctrl.filters[data.filterName]['data'],
                level: data.level,
                title: data.title,
                active: data.state,
                multiSelect: data.multiSelect
            });
        }).catch(function(err) {
            void 0;
        });
    }

    ctrl.revert = function() {
        ctrl.onRevert().then(function() {
            $scope.$broadcast("revertAllFilters", {
                state: ctrl.filters
            });
        }).catch(function(err) {
            void 0;
        });
    }

    ctrl.processFilterOptions = function() {
        var options = {};
        Object.keys(ctrl.filterState).forEach(function(filterKey) {
            var keys = Object.keys(ctrl.filterState[filterKey].currentPath);
            if (!ctrl.filters[filterKey].multiSelect) {
                keys.forEach(function(key) {
                    if (Object.keys(ctrl.filterState[filterKey].currentPath[key]).length) {
                        var secondLevel = ctrl.filters[filterKey].titles[1];
                        if (!options[secondLevel]) {
                            options[secondLevel] = [];
                        }
                        options[secondLevel] = Object.keys(ctrl.filterState[filterKey].currentPath[key]);
                    }
                });
            }
            options[filterKey] = keys;
        });
        return options;
    }

    ctrl.applySearchTermChange = function() {
        $scope.$broadcast("revertAllFilters", {
            state: ctrl.filters
        });
        ctrl.resetFilterState();
    }

    ctrl.applySearchTermChangeAndRefresh = function() {
        $scope.$broadcast("refreshFilterStates", {
            state: ctrl.filters,
            source: 'searchTerm',
        });
    }

    ctrl.resetFilterState = function() {
        Object.keys(ctrl.filterState).forEach(function(filterName) {
            ctrl.clearKeys(ctrl.filterState[filterName].currentPath);
            ctrl.clearKeys(ctrl.filterState[filterName].activePath);
        });
    }

    ctrl.clearKeys = function(obj) {
        globalFunctions.clearKeys(obj);
    }

    ctrl.getData = function(section) {
        return ctrl.filters[section].data;
    }
}


hsApp.component('filterOption', {
    templateUrl: '/partials/components/filter-option.html',
    bindings: {
        name: '<',
        level: '<',
        active: '<',
        filter: '<',
        multiSelect: '<',
        tracePath: '<',
        showArrow: '<',
        activate: '<',
        icon: '<',
        iconPath: '<'
    },
    controller: ['$scope', 'globalFunctions', filterOptionController],
});

function filterOptionController($scope, globalFunctions) {

    var ctrl = this;

    ctrl.$onChanges = function(changes) {
        if (changes && changes.activate && changes.activate.currentValue
            && !globalFunctions.areEqualObjects(changes.activate.currentValue, changes.activate.previousValue)) {
                var activate = changes.activate.currentValue; 
                if (activate.activeList
                    && activate.activeList.includes(ctrl.name)
                    && activate.filterName === ctrl.filter
                    && activate.level && activate.level === ctrl.level)
                {
                    ctrl.active = true;
                } else if (activate.activeList
                            && !activate.activeList.includes(ctrl.name)
                            && activate.filterName === ctrl.filter
                            && activate.level && activate.level === ctrl.level)
                {
                    ctrl.active = false;
                }
        }
    }

    ctrl.onClick = function() {
        if (!ctrl.tracePath) {
            ctrl.active = !ctrl.active;
        }
        $scope.$emit("chooseFilterOption", { 
            title: ctrl.name,
            level: ctrl.level,
            active: ctrl.tracePath || ctrl.active,
            tracePath: ctrl.tracePath
        });
    }

    ctrl.getIconPath = function() {
        var path = '..' + ctrl.iconPath + ctrl.icon.toLowerCase() + '.svg';
        return path;
    }
    $scope.$on('deactivateCurrentFilterOptions', function(_, data) {
        if (data && data.filterName === ctrl.filter && !ctrl.tracePath) {
            ctrl.active = false;
        }
    });

    $scope.$on('deactivateAllFilterOptions', function() {
        ctrl.active = false;
    });

    $scope.$on('deactivateFilterOption', function(_, data) {
        if (!Array.isArray(data.title)) {
            if (ctrl.name !== data.title
                && ctrl.level === data.level
                && ctrl.filter === data.filterName)
            {
                ctrl.active = false;
            }
        } else {
            if (!data.title.includes(ctrl.name)
                && ctrl.level === data.level
                && ctrl.filter === data.filterName)
            {
                ctrl.active = false;
            }
        }
    });
}


hsApp.component('filter', {
    templateUrl: '/partials/components/filter.html',
    bindings: {
        hierarchy: '<',
        data: '<',
        multiSelect: '<',
        filterState: '=',
        filters: '<',
        showClearAll: '<',
        getFilterDisplayName: '&'
    },
    controller: ['$scope', '$timeout', '$location', 'globalFunctions', 'hsSearch', filterController],
});

function filterController($scope, $timeout, $location, globalFunctions, hsSearch) {

    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.sections = [];
        ctrl.path = [];
        ctrl.currentPath = {};
        ctrl.activePath = {};
        ctrl.levels = ctrl.hierarchy.length;
        ctrl.filterName = ctrl.hierarchy[0];
        ctrl.filterState[ctrl.filterName].currentPath = ctrl.currentPath;
        ctrl.filterState[ctrl.filterName].activePath = ctrl.activePath;
        ctrl.nextLevel = ctrl.getNextLevel(ctrl.currentPath);
        ctrl.parseData();
        ctrl.activate = {};
    }

    ctrl.$postLink = function() {
        $timeout(function() {
            var currentUrl = hsSearch.resolveSearchURL(false);
            if (Object.keys(currentUrl).length) {
                ctrl.resolveURL(currentUrl);
            }
        });
    }

    ctrl.$onChanges = function(changes) {
        if (changes.data && changes.data.currentValue && changes.data.previousValue && changes.data.previousValue !== 'UNINITIALIZED_VALUE') {
            ctrl.parseData();
        }
    }

    // Reset the filter state if level = 0 is passed. Else, update the filter state.
    $scope.$on('chooseFilterOption', function(_, data) {
        ctrl.activate = {};
        if (data) {
            if (!data.level) {
                ctrl.resetFilter(ctrl.filterName);
            } else {
                ctrl.filter(data.title, data.level, data.active, data.tracePath);
            }
        }
    });

    // will refresh the options for all the non-target filters.
    $scope.$on('refreshFilterStates', function(_, data) {
        if (data && data.state && data.source && data.source !== ctrl.filterName) {
            if (!Array.isArray(data.state[ctrl.filterName]['data'])
                && typeof data.state[ctrl.filterName]['data'] === 'object')
            {
                if (ctrl.path && ctrl.path.length) {
                    var pathToUpdate = ctrl.getFilterAtLevelSingleSelect(data.state[ctrl.filterName]['data'], ctrl.path.length+1);
                    ctrl.sections = Object.keys(pathToUpdate);
                } else {
                    ctrl.sections = Object.keys(data.state[ctrl.filterName]['data']);
                }
            } else {
                ctrl.sections = data.state[ctrl.filterName]['data'];
            }
            if (ctrl.multiSelect) {
                var selectionsToKeep = [];
                (Object.keys(ctrl.activePath)).forEach(function(activeKey) {
                    if (!data.state[ctrl.filterName]['data'].includes(activeKey)) {
                        delete ctrl.currentPath[activeKey];
                        delete ctrl.activePath[activeKey];
                    } else {
                        selectionsToKeep.push(activeKey);
                    }
                });
                $location.search(ctrl.filterName, null);
                $location.search(ctrl.filterName, Object.keys(ctrl.activePath));
                $scope.$broadcast("deactivateFilterOption", {
                    title: selectionsToKeep,
                    level: 1,
                    filterName: ctrl.filterName
                });
            }
        }
    });

    // will clear all filters.
    $scope.$on('revertAllFilters', function(_, data) {
        ctrl.activate = {};
        if (!Array.isArray(data.state[ctrl.filterName]['data'])) {
            ctrl.sections = Object.keys(data.state[ctrl.filterName]['data']);
        } else {
            ctrl.sections = data.state[ctrl.filterName]['data'];
        }
        ctrl.clearKeys(ctrl.currentPath);
        ctrl.clearKeys(ctrl.activePath);
        ctrl.path = [];
        $scope.$broadcast('deactivateAllFilterOptions', {});
        ctrl.nextLevel = ctrl.getNextLevel(ctrl.currentPath);
    });

    // refresh the data in target filter.
    $scope.$on('update', function(_, data) {
        if (data) {
            if (data.source === ctrl.filterName) {
                var activePathToUpdate = ctrl.getFilterAtLevelSingleSelect(ctrl.activePath, data.level);
                if (!data.title) {
                    ctrl.clearKeys(activePathToUpdate);
                    ctrl.path = [];
                    ctrl.sections = Array.isArray(data.data)
                                        ? data.data
                                        : Object.keys(data.data);
                    ctrl.nextLevel = ctrl.getNextLevel(ctrl.currentPath);   
                    $scope.$broadcast('deactivateCurrentFilterOptions', {
                        filterName: ctrl.filterName
                    });
                } else if (!data.multiSelect) {
                    if (data.active) {
                        ctrl.clearKeys(activePathToUpdate);
                        activePathToUpdate[data.title] = {};
                    } else {
                        delete activePathToUpdate[data.title];
                    }
                    if (data.level < ctrl.levels) {
                        var path = ctrl.getPath(ctrl.activePath);
                        ctrl.path = path;
                        if (data.active) {
                            ctrl.sections = Object.keys(data.data[data.title]);
                        } else if (data.level === 1) {
                            ctrl.sections = Object.keys(ctrl.getFilterAtLevelSingleSelect(data.data, data.level));
                        } else {
                            ctrl.sections = Object.keys(ctrl.getFilterAtLevelSingleSelect(data.data, data.level)[data.title]);
                        }
                        ctrl.nextLevel = ctrl.getNextLevel(ctrl.currentPath);
                        $scope.$broadcast('deactivateCurrentFilterOptions', {
                            filterName: ctrl.filterName,
                            level: data.level
                        });
                    }
                } else {
                    if (data.active) {
                        ctrl.activePath[data.title] = {};
                        if (ctrl.filters[ctrl.filterName].intersectionSearch) {
                            ctrl.sections = (Array.isArray(data.data)) ? data.data : Object.keys(data.data);
                        }
                        void 0;
                    } else {
                        delete ctrl.activePath[data.title];
                        if (!Object.keys(ctrl.activePath).length) {
                            ctrl.sections = (Array.isArray(data.data)) ? data.data : Object.keys(data.data);
                        }
                    }
                }
            }
        }
    });

    ctrl.filter = function(section, level, isActive, tracePath) {

        if (tracePath && !ctrl.hasSelectedSubsections(section, level)) {
            return;
        }

        if (!ctrl.multiSelect) {
            $scope.$broadcast("deactivateFilterOption", {
                title: section,
                level: level,
                filterName: ctrl.filterName
            });
            var pathToUpdate = ctrl.getFilterAtLevelSingleSelect(ctrl.currentPath, level);
            if (isActive) {
                ctrl.clearKeys(pathToUpdate);
                pathToUpdate[section] = {};
            } else {
                delete pathToUpdate[section];
            }
        } else {
            if (isActive) {
                ctrl.currentPath[section] = {};
            } else {
                delete ctrl.currentPath[section];
            }
        }
        $scope.$emit("applyFilterOption", {
            filterName: ctrl.filterName,
            title: section,
            level: level,
            state: isActive,
            multiSelect: ctrl.multiSelect,
        });
    }

    ctrl.resolveURL = function(currentUrl) {
        Object.keys(currentUrl).forEach(function(key) {
            if (!currentUrl[key] || !Array.isArray(currentUrl[key]) || (Array.isArray(currentUrl[key]) && !currentUrl[key].length)) {
                delete currentUrl[key];
            }
        });
        var activeList = [];
        Object.keys(currentUrl).forEach(function(key) {
            if (key === ctrl.filterName) {
                currentUrl[key].forEach(function(section) {
                    ctrl.activePath[section] = {};
                    ctrl.currentPath[section] = {};
                    if (ctrl.multiSelect) {
                        activeList.push(section);
                    }
                });
                if (!ctrl.multiSelect) {
                    var path = ctrl.getPath(ctrl.activePath);
                    ctrl.path = path;
                }
            }
        });

        if (!ctrl.multiSelect) {
            if (currentUrl[ctrl.hierarchy[1]] && currentUrl[ctrl.hierarchy[0]]) {
                var activeSelection = Object.keys(ctrl.filterState[ctrl.hierarchy[0]].activePath)[0] || currentUrl[ctrl.hierarchy[0]][0];
                currentUrl[ctrl.hierarchy[1]].forEach(function(subSelection) {
                    ctrl.activePath[activeSelection][subSelection] = {};
                    ctrl.currentPath[activeSelection][subSelection] = {};
                    activeList.push(subSelection);
                });
                ctrl.sections = activeList;
            } else if (currentUrl[ctrl.hierarchy[0]]) {
                ctrl.sections = Object.keys(ctrl.data[currentUrl[ctrl.hierarchy[0]]]);
            } else if (currentUrl[ctrl.hierarchy[1]]) {
                return;
            }
            ctrl.nextLevel = (currentUrl[ctrl.hierarchy[0]] || currentUrl[ctrl.hierarchy[1]]) ? 2 : 1;
        } 
        
        ctrl.activate = {
            filterName: ctrl.filterName,
            level: (!ctrl.multiSelect && currentUrl[ctrl.hierarchy[1]])
                        ? 2
                        : ctrl.multiSelect
                            ? 1
                            : null, 
            activeList: activeList
        }
    }

    ctrl.resetFilter = function(filterName) {
        
        ctrl.clearKeys(ctrl.currentPath);
        $scope.$emit("applyFilterOption", {
            filterName: filterName,
            title: null,
            level: 1,
            active: false,
            multiSelect: ctrl.multiSelect
        });
    }

    ctrl.hasSelection = function() {
        return Object.keys(ctrl.activePath).length;
    }

    ctrl.parseData = function() {
        ctrl.sections = (typeof ctrl.data === 'object' && !Array.isArray(ctrl.data))
            ? Object.keys(ctrl.data)
            : ctrl.data;
    }

    ctrl.getCurrentSection = function() {
        return ctrl.currentPath[Object.keys(ctrl.currentPath)[0]];
    }

    ctrl.getPath = function(obj) {
        return (!Object.keys(obj) || !Object.keys(obj).length)
                    ? []
                    : Object.keys(obj).concat(ctrl.getPath(obj[Object.keys(obj)[0]]));
    }

    ctrl.getFilterAtLevelSingleSelect = function(obj, level) {
        return (level === 1) ? obj : ctrl.getFilterAtLevelSingleSelect(obj[Object.keys(obj)[0]], --level);
    }

    ctrl.getNextLevel = function(obj) {
        if (!obj || !Object.keys(obj) || !Object.keys(obj).length) {
            return 1;
        }
        return 1 + ctrl.getNextLevel(obj[Object.keys(obj)[0]]);
    }

    ctrl.hasSubsections = function(section, level) {
        if (ctrl.data[section] && typeof ctrl.data[section] === 'object'
            && Object.keys(ctrl.data[section]).length && level < ctrl.levels)
        {
            return true;
        }
        return false;
    }

    ctrl.hasSelectedSubsections = function(section, level) {
        var relevantObj = ctrl.getFilterAtLevelSingleSelect(ctrl.currentPath, level);
        if (relevantObj[section] && Object.keys(relevantObj[section]).length) {
            return true;
        }
        return false;
    }

    ctrl.clearKeys = function(obj) {
        globalFunctions.clearKeys(obj);
    }

    ctrl.areEqualObjects = function(obj1, obj2) {
        return globalFunctions.areEqualObjects(obj1, obj2);
    }

}


hsApp.component('jumpToTopButton', {
	templateUrl: '/partials/components/jump-to-top-button.html',
	controller: ['$rootScope', '$scope', '$document', jumpToTopButtonController]
});

function jumpToTopButtonController($rootScope, $scope, $document) {
	var ctrl = this;

	ctrl.$onInit = function () {
		ctrl.isRendered = $rootScope.ENV.enableJumpToTop;
		ctrl.isVisible = false;
		ctrl.visibilityDistance = 20;
		ctrl.size = Object.keys($rootScope.screenWidth).filter(function (key) {
			return $rootScope.screenWidth[key];
		})[0];
	};

	ctrl.$onDestroy = function () {
		$document.unbind('scroll');
	};

	$document.bind('scroll', function () {
		var newIsVisibleValue = window.scrollY >= ctrl.visibilityDistance;
		if (newIsVisibleValue === ctrl.isVisible) {
			return;
		}

		ctrl.isVisible = newIsVisibleValue;
		try {
			$scope.$digest(); // force re-render
		} catch (error) {
			void 0;
		}
	});

	ctrl.onClick = function () {
		$('html, body').animate({ scrollTop: 0 }, 'slow');
	};
}

hsApp.component('loginSso', {
    templateUrl: '/partials/components/login-sso.html',
    controller: [
        'hsAuth',
        'hsLogin',
        '$location',
        '$rootScope',
        'localStorageService',
        'hsUtils',
        loginSsoController
    ],
});

function loginSsoController(
    hsAuth,
    hsLogin,
    $location,
    $rootScope,
    localStorageService,
    hsUtils
) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.isLoading = true;
        var jwt = $location.search().jwt;
        if (!jwt) {
            void 0;
            $location.url('/products');
            ctrl.isLoading = false;
            return;
        }
        
        var marketingQueries = {};
        if ($location.search().locName) {
            marketingQueries.locName = $location.search().locName;
        }

        if ($location.search().pListName) {
            marketingQueries.pListName = $location.search().pListName;
        }

        var redirect = $location.search().redirect || 'products';
        var errorRedirect = $location.search().errorRedirect || 'products';
        
        var bearerToken = 'Bearer ' + jwt;
        var headers = {
            'Authorization': bearerToken
        };
        var location = null;
        var priceList = null;
        var prevUser = null;
        if ($rootScope.loggedIn) {
            location = localStorageService.get('location');
            
            if (ENV.enablePriceList) {
                priceList = localStorageService.get('selectedPriceList');
            }
            prevUser = localStorageService.get('user');
            hsAuth.logoutUser(null, true);
        }
        hsAuth.loginSSO(headers).then(function(response){
            if (response.status === 200) {
                if (prevUser && response.data && prevUser.email === response.data.email && location) {
                    localStorageService.set('location', location);
                    if (ENV.enablePriceList && hsUtils.isObject(priceList)) {
                        localStorageService.set('selectedPriceList', priceList);
                        $rootScope.selectedPriceList = priceList;
                    }
                }
                hsLogin.processLogin(response, ctrl.buildRedirectUrl(redirect, marketingQueries), {});
            } else {
                throw "Error in getting user account";
            }
        })
        .catch(function(error) {
            void 0;
            $location.url(ctrl.buildRedirectUrl(errorRedirect, marketingQueries));
        })
        .finally(function() {
            ctrl.isLoading = false;
        });
    };

    ctrl.buildRedirectUrl = function(redirect, marketingQueries){
        var newUrl = new URL(window.location.origin + '/' + redirect);
        var loc = $location.search().loc || '';
        var plist = $location.search().plist || '';

        if (marketingQueries.pListName || marketingQueries.locName) {
            if (marketingQueries.pListName) {
                newUrl.searchParams.append('pListName', marketingQueries.pListName);
            }

            if (marketingQueries.locName) {
                newUrl.searchParams.append('locName', marketingQueries.locName);
            }
        } else if (redirect === 'products') {
            if (loc && loc.length) {
                newUrl.searchParams.append('loc', loc);
            }
            if (plist && plist.length) {
                newUrl.searchParams.append('plist', plist);
            }
        }
        return newUrl.pathname + newUrl.search;
    };
}

hsApp.component('membershipDiscountBadge', {
    templateUrl: '/partials/components/membership-discount-badge.html',
    bindings: {
        price: '<',
        discount: '<',
        promotion: '<',
        size: '@',
        regularClass: '@',
        membersClass: '@',
        showOnePrice: '<',
        discountApplied: '<',
    },
    controller: ['hsPromos', membershipDiscountBadgeController],
});


function membershipDiscountBadgeController(hsPromos) {
    var ctrl = this;
    ctrl.class = '';
    ctrl.membersDescription = 'Members';
    ctrl.isLargeMemberDescription = false;

    ctrl.$onInit = function () {
        ctrl.discountPrice = 0;

        if (ctrl.discount) { // legacy
            ctrl.discountPrice = ctrl.price - ctrl.price * ctrl.discount / 100;
        } else if (ctrl.promotion) {
            ctrl.discountPrice = ctrl.promotion.promotionPrice || 0;

            if (ctrl.promotion.userGroupDisplayName) {
                ctrl.membersDescription = ctrl.promotion.userGroupDisplayName;
            }

            if (ctrl.membersDescription && ctrl.membersDescription.length >= 10) {
                ctrl.isLargeMemberDescription = true;
            }
        }
        if (!ctrl.discountPrice) {
            if (ctrl.promotion && ctrl.promotion.type === hsPromos.types.FREE_ITEM) {
                ctrl.discountPrice = 'FREE';
            } else {
                ctrl.discountPrice = ctrl.getPriceString(ctrl.price);
            }
        } else {
            ctrl.discountPrice = ctrl.getPriceString(ctrl.discountPrice);
        }
        ctrl.regularColor = 'color-' + (ctrl.regularClass ? ctrl.regularClass : 'primary');
        ctrl.membersColor = 'color-' + (ctrl.membersClass ? ctrl.membersClass : 'primary');

        if (ctrl.showOnePrice) {
            ctrl.appliedPrice = ctrl.discountApplied ? ctrl.discountPrice : ctrl.getPriceString(ctrl.price);
        }
    };

    ctrl.getPriceString = function (price) {
        return '$' + price.toFixed(2);
    };

}

hsApp.component('membershipSavingsBadge', {
    templateUrl: '/partials/components/membership-savings-badge.html',
    bindings: {
        item: '<',
        forUser: '<',
    },
    controller: ['$rootScope', '$scope', 'ngDialog', '$route', membershipSavingsBadgeController],
});


function membershipSavingsBadgeController($rootScope, $scope, ngDialog, $route) {
    var ctrl = this;
    ctrl.savings = 0;

    ctrl.$onInit = function() {
        ctrl.isErewhon = $rootScope.ENV.name.companyName === 'Erewhon';

        if (ctrl.item
            && (
                ctrl.item.membershipDiscount
                || ctrl.item.promotion && ctrl.item.promotion.membersOnly
                || ctrl.item.potentialSavingsPromo && ctrl.item.potentialSavingsPromo.membersOnly
            )
        ) {
            var promotion = ctrl.item.promotion && ctrl.item.promotion.membersOnly
                ? ctrl.item.promotion
                : ctrl.item.potentialSavingsPromo;
            var quantity = ctrl.item.quantity;

            if (ctrl.item.sellByQty && ctrl.item.unit === 'lb') {
                quantity = ctrl.item.packed ? ctrl.item.quantityWeight : ctrl.item.quantity * ctrl.item.avgWeight;
            }
            var basePrice = quantity * ctrl.item.price;
            var membershipPrice = 0;

            if (ctrl.item.membershipDiscountApplied) {
                var modifiersTotal = Array.isArray(ctrl.item.selectedModifiers)
                    ? ctrl.item.selectedModifiers.reduce(function (acc, m) {
                            if (m.price) {
                                acc += m.price;
                            }
                            return acc;
                        }, 0)
                    : 0;
                membershipPrice = ctrl.item.itemizedPrice - modifiersTotal;
            } else if (ctrl.item.membershipDiscount) {
                // Legacy potential savings
                membershipPrice = basePrice - basePrice * ctrl.item.membershipDiscount / 100;
            } else {
                // Need to calculate potential savings
                var eligibilityQuantity = promotion.eligibilityQuantity || 1;
                var usesPerItem = Math.floor(ctrl.item.quantity / eligibilityQuantity);
                var qtyAtRegularPrice = 0;
                var qtyAtPromotionPrice = 0;
                var avgWeight = 0;

                if (ctrl.item.sellByQty && ctrl.item.unit === 'lb') {
                    avgWeight = ctrl.item.packed ? ctrl.item.quantityWeight / ctrl.item.quantity : ctrl.item.avgWeight;
                }

                if (promotion.applyInIncrementsOnly === false) {
                    qtyAtPromotionPrice = ctrl.item.quantity;
                    usesPerItem += Math.ceil(ctrl.item.quantity % eligibilityQuantity);
                } else {
                    qtyAtPromotionPrice = usesPerItem * eligibilityQuantity;
                    qtyAtRegularPrice = ctrl.item.quantity % eligibilityQuantity;
                }
                if (promotion.maxUsesPerItem && usesPerItem > promotion.maxUsesPerItem) {
                    usesPerItem = promotion.maxUsesPerItem;

                    qtyAtPromotionPrice = usesPerItem * eligibilityQuantity;
                    qtyAtRegularPrice = ctrl.item.quantity - qtyAtPromotionPrice;
                }
                if (qtyAtRegularPrice) {
                    if (avgWeight) {
                        qtyAtRegularPrice *= avgWeight;
                    }
                    membershipPrice += qtyAtRegularPrice * ctrl.item.price;
                }
                if (qtyAtPromotionPrice) {
                    if (avgWeight) {
                        qtyAtPromotionPrice *= avgWeight;
                    }
                    membershipPrice += qtyAtPromotionPrice * promotion.promotionPrice;
                }

                if (promotion.userGroup) {
                    ctrl.userGroup = promotion.userGroup;
                }
            }
            ctrl.savings = basePrice - membershipPrice;
        }
    };

    ctrl.getUser = function () {
        return ctrl.forUser || $rootScope.currentUser;
    };

    ctrl.isMember = function() {
        var user = ctrl.getUser();
        return user && user.membership;
    };

    ctrl.isActiveMember = function() {
        var user = ctrl.getUser();
        return ctrl.isMember() && user.membership.isActive;
    };

    ctrl.showMembershipForm = function(renew) {
        // Turning off link until all forms can handle For User Order Membership
        if (ctrl.forUser) return;

        var $newScope = $scope.$new(true);
        $newScope.renew = renew;

        ngDialog.open({
            template: '<div><erewhon-membership-popup '
                + 'on-close="closeThisDialog()" '
                + 'renew="renew" '
                + '></erewhon-membership-popup></div>',
            className: 'ngdialog-theme-default ngdialog-theme-erewhon',
            plain: true,
            scope: $newScope,
        }).closePromise
            .then(function(data) {
                if (data.value && data.value === 'success') {
                    $route.reload();
                }
            })
            .catch(function(err) {
                void 0;
            });
    };

}

hsApp.component('mobileFilter', {
    bindings: {
        openFilterData: '<',
        openFilter: '<',
        filterState: '=',
        onSelect: '&',
        onRevert: '&',
        toggle: '&',
        toggleSlideUp: '<',
        processFilter: '&',
        getFilterDisplayName: '&',
        onClose: '&',
    },
    templateUrl: '/partials/components/mobile-filter.html',
    controller: ['globalFunctions', mobileFilterController]
});

function mobileFilterController(globalFunctions) {

    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.logPrefix = '[mobile-filter]: ';
        ctrl.sections = null;
        ctrl.subsections = null;
    }

    ctrl.$onChanges = function(changes) {
        if (changes) {
            if (changes.openFilterData && changes.openFilterData.currentValue && changes.openFilterData.currentValue.data) {
                ctrl.sections = (typeof ctrl.openFilterData.data === 'object' && Array.isArray(ctrl.openFilterData.data))
                    ? ctrl.openFilterData.data
                    : Object.keys(ctrl.openFilterData.data);
                ctrl.subsections = ctrl.resolveSubsections();
            }
        }
    }

    ctrl.trackFilterPath = function(group, level) {
        var relevantFilters = ctrl.filterState[ctrl.openFilter];
        var parentCategory = Object.keys(relevantFilters.currentFilters).length
            ? Object.keys(relevantFilters.currentFilters)[0]
            : null;
        if (level === 0) {
            if (!relevantFilters.currentFilters[group]) {
                if (!ctrl.openFilterData.multiSelect) {
                    relevantFilters.currentFilters = {};
                }
                relevantFilters.currentFilters[group] = {};
                if (ctrl.openFilterData.titles.length > 1) {
                    ctrl.subsections = Object.keys(ctrl.openFilterData.data[group]);
                }
            } else {
                delete relevantFilters.currentFilters[group];
                if (ctrl.openFilterData.titles.length > 1) {
                    if (!ctrl.openFilterData.multiSelect) {
                        ctrl.subsections = null;
                    } else {
                        ctrl.subsections = Object.keys(relevantFilters.currentFilters).reduce(function(acc, current) {
                            var subsectionsToAdd = Object.keys(relevantFilters.currentFilters[current]);
                            return acc.concat(subsectionsToAdd);
                        }, []);
                    }
                }
                if (!Object.keys(relevantFilters.currentFilters).length
                    && ctrl.openFilterData.multiSelect) {
                        ctrl.apply();
                }
            }
        } else {
            if (!relevantFilters.currentFilters[parentCategory][group]) {
                if (!ctrl.openFilterData.multiSelect) {
                    relevantFilters.currentFilters[parentCategory] = {};
                }
                relevantFilters.currentFilters[parentCategory][group] = {};
            } else {
                delete relevantFilters.currentFilters[parentCategory][group];
                if (!Object.keys(relevantFilters.currentFilters[parentCategory]).length
                    && ctrl.openFilterData.multiSelect) {
                        ctrl.apply();
                }
            }
        }
        if (!ctrl.openFilterData.multiSelect || ctrl.openFilterData.intersectionSearch) {
            ctrl.apply();
        }
    }

    ctrl.apply = function() {
        var options = ctrl.processFilter();
        ctrl.onSelect({ options: options }).then(function() {
            ctrl.toggle({ filter: ctrl.openFilter });
        }).catch(function(err) {
            void 0;
        });
    }

    ctrl.reset = function() {
        ctrl.onRevert().then(function() {
            ctrl.toggle({ filter: ctrl.openFilter });
            for (var filterName of Object.keys(ctrl.filterState)) {
                ctrl.filterState[filterName].currentFilters = {};
                ctrl.filterState[filterName].activeFilters = {};
            }
    
            if (ctrl.sections) {
                ctrl.sections = null;
            }
            if (ctrl.subsections) {
                ctrl.subsections = null;
            }
        });
    }

    ctrl.hasActiveFilters = function() {
        for (var filterName of Object.keys(ctrl.filterState)) {
            if (Object.keys(ctrl.filterState[filterName].activeFilters).length) {
                return true;
            }
        }
        return false;
    }

    ctrl.resolveSubsections = function() {
        if (Array.isArray(ctrl.sections)
            && ctrl.sections.length
            && ctrl.openFilterData.titles.length > 1)
        {
            var selectedSection = Object.keys(ctrl.filterState[ctrl.openFilter].currentFilters)[0] || null;
            var availableSubsections = (selectedSection && Object.keys(ctrl.openFilterData.data[selectedSection])) || null;
            return availableSubsections;
        }
        return null;
    }

    ctrl.getButtonState = function(section, level) {
        if (ctrl.openFilter) {
            return (level === 0)
            ? ctrl.filterState[ctrl.openFilter].currentFilters[section]
            : ctrl.getKeys(ctrl.filterState[ctrl.openFilter].currentFilters).length
                ? ctrl.filterState[ctrl.openFilter]
                    .currentFilters[ctrl.getKeys(
                        ctrl.filterState[ctrl.openFilter].currentFilters
                    )[0]][section]
                : null;            
        }
        return null;
        
    }

    ctrl.keyLength = function (obj) {
        return Object.keys(obj).length;
    }

    ctrl.getKeys = function(obj) {
        return Object.keys(obj);
    }

    ctrl.processFilterName = function(str) {
        return (str && globalFunctions.reverseCamelCase(str)) || '';
    }

    ctrl.getIconPath = function(section) {
        var path = '..' + ctrl.openFilterData.iconPath + ctrl.openFilterData.displayMap[section].toLowerCase() + '.svg';
        return path;
    }
}
hsApp.component('notification', {
    templateUrl: '/partials/components/notification.html',
    bindings: {
        message: '<'
    },
    controller: [notificationController],
});

function notificationController() {

    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
    };
}
hsApp.component('nutritionFacts', {
    templateUrl: '/partials/components/nutrition-facts.html',
    controllerAs: 'ctrl',
    bindings: {
        nutritionInfo: '<',
    },
    controller: NutritionFactsController,
});

function NutritionFactsController() {
    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
    };

    ctrl.getNutritionField = function (field, obj) {
        obj = obj || ctrl.nutritionInfo;
        return _.get(obj, field);
    };

    ctrl.getNutrientField = function (field, obj) {
        obj = obj || (ctrl.nutritionInfo && ctrl.nutritionInfo.nutrients);
        return _.get(obj, field);
    };

    ctrl.getVitaminMineralField = function (field, obj) {
        obj = obj || (ctrl.nutritionInfo && ctrl.nutritionInfo.vitaminsMinerals);
        return _.get(obj, field);
    };

    ctrl.checkNutritionFieldExists = function (field) {
        return ctrl.getNutritionField(field) !== undefined;
    };

    ctrl.checkNutrientFieldExists = function (field) {
        return ctrl.getNutrientField(field) !== undefined;
    };

    ctrl.checkVitaminMineralFieldExists = function (field) {
        return ctrl.getVitaminMineralField(field) !== undefined;
    };

    ctrl.getPercent = function (name) {
        if (ctrl.checkNutrientFieldExists(name)) {
            var dailyValueIntakePercent = ctrl.nutritionInfo.nutrients[name].dailyValueIntakePercent;
            return dailyValueIntakePercent !== undefined ? dailyValueIntakePercent + '%' : '';
        }
        if (ctrl.checkVitaminMineralFieldExists(name)) {
            var dailyValueIntakePercent = ctrl.nutritionInfo.vitaminsMinerals[name].dailyValueIntakePercent;
            return dailyValueIntakePercent !== undefined ? dailyValueIntakePercent + '%' : '';
        }

        return '';
    };

    ctrl.getDisplayName = function (name) {
        if (ctrl.checkNutritionFieldExists(name)) {
            return ctrl.nutritionInfo[name].displayName;
        }
        if (ctrl.checkNutrientFieldExists(name)) {
            return ctrl.nutritionInfo.nutrients[name].displayName;
        }
        if (ctrl.checkVitaminMineralFieldExists(name)) {
            return ctrl.nutritionInfo.vitaminsMinerals[name].displayName;
        }

        return '';
    };

    ctrl.getDisplayValue = function (name) {
        if (ctrl.checkNutritionFieldExists(name)) {
            return ctrl.nutritionInfo[name].displayValue;
        }
        if (ctrl.checkNutrientFieldExists(name)) {
            return ctrl.nutritionInfo.nutrients[name].displayValue;
        }
        if (ctrl.checkVitaminMineralFieldExists(name)) {
            return ctrl.nutritionInfo.vitaminsMinerals[name].displayValue;
        }

        return '';
    };

    ctrl.getValue = function (name) {
        if (ctrl.checkNutritionFieldExists(name)) {
            return ctrl.nutritionInfo[name].value;
        }
        if (ctrl.checkNutrientFieldExists(name)) {
            return ctrl.nutritionInfo.nutrients[name].value;
        }
        if (ctrl.checkVitaminMineralFieldExists(name)) {
            return ctrl.nutritionInfo.vitaminsMinerals[name].value;
        }

        return '';
    };
}

hsApp.component('pageWrapper', {
    restrict: 'E',
    transclude: {
        back: '?pageWrapperBack',
        body: 'pageWrapperBody',
    },
    templateUrl: '/partials/components/page-wrapper.html',
    bindings: {
        backLink: '@',
        sectionStyles: '<',
        marginStyles: '<',
    },

    controller: pageWrapperController,
});

function pageWrapperController() {
    var ctrl = this;

    ctrl.$onInit = function () {
        if (!ctrl.sectionStyles) {
            ctrl.sectionStyles = '';
        }

        if (!ctrl.marginStyles) {
            ctrl.marginStyles = 'mtopbot50';
        }
    };
}

hsApp.component('codeVerification', {
    templateUrl: '/partials/components/phone-number-code-verification.html',
    bindings: {
        phoneNumber: '<',
        onClose: '&',
        purpose: '@',
    },
    controller: ['$rootScope', '$http', codeVerificationController],
});


function codeVerificationController($rootScope, $http) {
    var ctrl = this;
    var genericError = 'Something went wrong. Please try again.';
    var sendCodeError = 'Failed to send a code. Please try again.';

    ctrl.$onInit = function() {
        void 0
        ctrl.verificationCode = null;
        ctrl.error = '';
        ctrl.buttonLoading = false;
        ctrl.isLoading = false;
        ctrl.shouldCallToReceiveCode = false;

        if (!ctrl.phoneNumber) {
            return ctrl.returnError('Phone number is required.');
        }
        ctrl.sendCode();
    };

    ctrl.returnError = function(err) {
        return ctrl.onClose && ctrl.onClose({
            value: {
                error: err,
            },
        });
    };

    ctrl.sendCode = function(shouldCall) {
        ctrl.shouldCallToReceiveCode = shouldCall;
        ctrl.error = '';
        ctrl.isLoading = true;
        ctrl.verificationCode = null;

        var apiUrl = ENV.apiEndPoint + '/phonenumber/code';
        $http.post(apiUrl, { phoneNumber: ctrl.phoneNumber, shouldCall: ctrl.shouldCallToReceiveCode })
            .then(function(res) {
                if (res.status !== 200) {
                    void 0;
                    return ctrl.returnError(sendCodeError);
                }
            })
            .catch(function(err) {
                void 0;
                return ctrl.returnError(sendCodeError);
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.verify = function() {
        if (ctrl.buttonLoading) return;

        ctrl.buttonLoading = true;

        var apiUrl = ENV.apiEndPoint + '/phonenumber/verify';
        var data = {
            phoneNumber: ctrl.phoneNumber,
            code: ctrl.verificationCode,
        };
        if (ctrl.purpose) {
            data.for = ctrl.purpose;
        }

        $http.post(apiUrl, data)
            .then(function(res) {
                if (res.status === 404) {
                    return ctrl.returnError(
                        'The verification code you entered does not match.'
                        +' Please make sure you have entered the correct phone number and code.'
                    );
                }
                if (res.status === 400 && res.data && res.data.message && res.data.message.includes('Incorrect code')) {
                    ctrl.error = 'The verification code you entered does not match.'
                        + ' Please make sure you have entered the correct code and try again.';
                    return;
                }
                if (res.status === 400 && res.data && res.data.message && res.data.message.includes('expired')) {
                    return ctrl.returnError('Code expired. Please try again.');
                }
                if (res.status === 409) {
                    return ctrl.returnError('Phone number is already associated with another account.');
                }
                if (res.status !== 200) {
                    void 0;
                    return ctrl.returnError(genericError);
                }
                ctrl.onClose({ value: (ctrl.purpose ? res.data : 'success') });
            })
            .catch(function(err) {
                void 0;
                return ctrl.returnError(genericError);
            })
            .finally(function() {
                ctrl.buttonLoading = false;
            });
    }

}

hsApp.directive('plusMinusInput', function() {
	return {
		restrict: 'E',
		transclude: true,
		scope: {
			inputId: '@',
			max: '<',
			min: '<',
			model: '=',
			name: '@',
			onChange: '<',
			product: '<',
			size: '@',
			editable: '@',
			additionalParams: '@',
			increment: '<',
			additionalStyle: '@',
		},
		templateUrl: "/partials/components/plus-minus-input.html",
		controller: ["$scope", function($scope) {

			if (!isNaN($scope.model) && !Number.isInteger(Number($scope.model))) {
				$scope.model = Number($scope.model.toFixed(2));
			}

			$scope.disabled = true;
			if ($scope.editable !== undefined) {
				$scope.disabled = false;
			}
			if ($scope.inputId === undefined) {
				$scope.inputId = 'id_' + Date.now();
			}
			if ($scope.size === undefined) {
				$scope.size = 'sm';
			}
			if ($scope.min === undefined) {
				$scope.min = 0;
			}
			if ($scope.max === undefined) {
				$scope.max = 0;
			}
			if ($scope.increment === undefined) {
				$scope.increment = 1;
			} else if (typeof $scope.increment !== 'number') {
				let value = parseFloat($scope.increment);
				if (isNaN(value)) {
					value = 1;
				}
				$scope.increment = value;
			}
			$scope.updateValue = function(operation) {
				if (typeof $scope.onChange !== 'function') {
					let value = Math.floor($scope.model / $scope.increment) * $scope.increment;
					if (isNaN(value)) {
						value = 0;
					}
					if (operation === 'add') {
						$scope.model = (value + $scope.increment) > $scope.max ? $scope.max : (value + $scope.increment);
					}
					if (operation === 'subtract') {
						$scope.model = (value - $scope.increment) < $scope.min ? $scope.min : (value - $scope.increment);
					}
				} else {
					var params = [$scope.product, operation];
					if ($scope.additionalParams === 'id') {
						params.push($scope.inputId);
					}
					if ($scope.additionalParams === 'admin') {
						params.push(true);
					}
					$scope.onChange.apply(null, params);
				}
			};
			$scope.change = function() {
				if (typeof $scope.onChange === 'function' && $scope.product) {
					$scope.onChange($scope.product, null, $scope.inputId);
				} else {
					let value = Math.floor($scope.model / $scope.increment) * $scope.increment;
					if (isNaN(value)) {
						value = '';
					} else if (value > $scope.max) {
						value = $scope.max;
					} else if (value < $scope.min) {
						value = $scope.min;
					}
					$scope.model = value;
				}
			};
		}],
	};
});

hsApp.component('price', {
    templateUrl: '/partials/components/price.html',
    bindings: {
        productData: '<'
    },
    controller: [
        'hsCart',
        priceController
    ]
});

function priceController (hsCart) {
    var ctrl = this;

    ctrl.getRegularPrice = function () {
        return '$' + ctrl.productData.price.toFixed(2) + hsCart.calculatePricePerQuantityV2(ctrl.productData);
    }
}

hsApp.component('printTags', {
    templateUrl: '/partials/components/print-tags.html',
    bindings: {
        printers: '<',
        onClose: '&',
        onPrint: '&',
    },
    controller: ['hsUtils', printTagsController],
});


function printTagsController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.printDisabled = true;
    };

    ctrl.$onChanges = function(changes) {
        if ('printers' in changes) {
            if (!Array.isArray(changes.printers.currentValue)) {
                ctrl.printers = [];
            }
            ctrl.createShouldPrintMap();
        }
    };

    ctrl.createShouldPrintMap = function() {
        ctrl.printDisabled = true;
        var shouldPrint = {};

        for (var i = 0; i < ctrl.printers.length; i++) {
            var printer = ctrl.printers[i];

            if (hsUtils.isObject(ctrl.shouldPrint) && printer.ip in ctrl.shouldPrint) {
                shouldPrint[printer.ip] = ctrl.shouldPrint[printer.ip];
            } else {
                shouldPrint[printer.ip] = false;
            }
            if (shouldPrint[printer.ip]) {
                ctrl.printDisabled = false;
            }
        }
        ctrl.shouldPrint = shouldPrint;
    };

    ctrl.toggleSelectedPrinter = function() {
        var vals = Object.values(ctrl.shouldPrint);

        for (var i = 0; i < vals.length; i++) {
            if (vals[i]) {
                ctrl.printDisabled = false;
                return;
            }
        }
        ctrl.printDisabled = true;
    };

    ctrl.print = function() {
        if (ctrl.printDisabled) return;

        var selectedPrinters = [];

        for (var i = 0; i < ctrl.printers.length; i++) {
            var printer = ctrl.printers[i];

            if (printer && ctrl.shouldPrint[printer.ip]) {
                selectedPrinters.push({
                    printerIP: printer.ip,
                    printerName: printer.name,
                    print: true,
                    quantity: 1,
                });
            }
        }
        ctrl.onPrint({ selectedPrinters: selectedPrinters});
        ctrl.onClose();
    };

    ctrl.cancel = function() {
        ctrl.onClose();
    };
}

hsApp.component('productHealthClaims', {
    templateUrl: '/partials/components/product-health-claims.html',
    controllerAs: 'ctrl',
    bindings: {
        healthClaims: '<',
        healthClaimsMap: '<',
        maxIconsMobile: '<',
    },
    controller: ['$rootScope', productHealthClaimsController],
});

var DEFAULT_PROP_VALUES = {
    maxIconsMobile: 4,
};

function productHealthClaimsController ($rootScope) {
    var ctrl = this;
    var logPrefix = '[product-health-claims]: ';

    ctrl.onShowMoreLessHealthClaimsClick = function () {
        if (!ctrl.isMobile) {
            return;
        }
        if (!ctrl.isShowingAllHealthClaims) {
            ctrl.healthClaimsToDisplay = ctrl.healthClaims;
        } else {
            ctrl.healthClaimsToDisplay = ctrl.healthClaims.slice(0, ctrl.maxIconsMobile);
        }
        ctrl.isShowingAllHealthClaims = !ctrl.isShowingAllHealthClaims;
    }

    ctrl.$onInit = function () {
        void 0;

        if (!Array.isArray(ctrl.healthClaims)) {
            void 0;
        }

        _.defaults(ctrl, DEFAULT_PROP_VALUES);
        
        ctrl.isMobile = $rootScope.screenWidth.xs;
        ctrl.isShowingAllHealthClaims = true;

        if (ctrl.isMobile) {
            ctrl.healthClaimsToDisplay = ctrl.healthClaims.slice(0, ctrl.maxIconsMobile);
        } else {
            ctrl.healthClaimsToDisplay = ctrl.healthClaims.slice(0);
        }
        ctrl.enableShowMoreLessHealthClaims = ctrl.isMobile && ctrl.healthClaims.length > ctrl.healthClaimsToDisplay.length;
        ctrl.isShowingAllHealthClaims = !ctrl.enableShowMoreLessHealthClaims;
    }

    ctrl.getIconPath = function(healthClaim) {
        var path = '../images/shared-assets/health-claims/' + healthClaim.toLowerCase() + '.svg';
        return path;
    }
}
hsApp.component('productItemReplace', {
    templateUrl: '/partials/components/product-item-replace.html',
    bindings: {
        product: '<',
        onRemoveItem: '&',
    },
    controller: ['$scope', 'hsCart', 'hsPromos', productItemReplaceController],
});

function productItemReplaceController($scope, hsCart, hsPromos) {
    var ctrl = this;
    var logPrefix = '[product-item-replace]: ';

    ctrl.$onInit = function () {
        if (!ctrl.product || typeof ctrl.product !== 'object' || Array.isArray(ctrl.product)) {
            void 0;
        }
        ctrl.price = hsCart.calculateProductPrice(ctrl.product);
        ctrl.quantity = hsCart.calculateUnitQuantity(ctrl.product);
        ctrl.displayName = hsCart.getProductDisplayName(ctrl.product);
        ctrl.instructions = ctrl.product.instructions;
        ctrl.promotion = hsPromos.getVisiblePromotion(ctrl.product);

        $scope.hsPromos = hsPromos;
        $scope.$watch('hsPromos.ongoingPromotions', function() {
            ctrl.promotion = hsPromos.getVisiblePromotion(ctrl.product);
        });
    };

}

/************************************************

************************************************/

"use strict";

hsApp.directive("hsProductItem",
    function () {
        return {
            restrict    : "E",
            templateUrl : '../../../partials/components/product-item.html',
            scope       : {
                useTableSideBasket: '<',
                productObj      : '=',
                menuItem        : '=',
                tileProduct     : '=',
                hideImage		: '=',
	            order           : '=',
                categoryName	: '=',
                categoryUrl     : '=',
                tabularView     : '=',
				searchIndex		: '=',
				handleAddProduct: '&',
				showV2: '<'
            },
            controller: ['$scope', '$rootScope', '$http', 'localStorageService', 'scrollToElement', '$filter', 'ENV', '$location', 'allProducts',
            	'hsCart', 'hsAuth', 'hsAdmin', 'hsApi', 'toastr', 'ngDialog', 'globalFunctions', 'hsTableSideOrders', 'hsPromos', 'aiSearchEvents',
				'hsUtils', '$timeout', 'hsPromotionsV2',
            function($scope, $rootScope,$http, localStorageService, scrollToElement, $filter, ENV, $location, allProducts,
            	hsCart, hsAuth, hsAdmin, hsApi, toastr, ngDialog, globalFunctions, hsTableSideOrders, hsPromos, aiSearchEvents,
				hsUtils, $timeout, hsPromotionsV2) {
	            $scope.product = {
                    imageBaseUrl: globalFunctions.imageBaseUrl,
                    config                      : {
                        showLoading     : false,
                        showViewAll     : false,
                        tabularView     : false,
                        menuItem        : false,
                        categoryName	: '',
                        renderEmptyTile : false,
	                    quantity        : '',
	                    productObj      : 0,
	                    allProducts     : allProducts,
                    },
					showV2: false,
                    data                        : {},
		            tileProduct                 : false,
		            menuItem                    : false,
		            order                       : false,
		            confirmHeader: 'Attention',
		            confirmMessage: 'Removing items or reducing the quantity may cause the change in fees, if any, associated with the order.',
		            promotion: null,
                    getProductDisplayName: function (product) {
                        return hsCart.getProductDisplayName(product);
                    },
                    isPromotionV2Enabled: function () {
                        var location = globalFunctions.getSelectedLocationFromStorage();
                        return location.promotionsV2Config && location.promotionsV2Config.enabled;
                    },
					showPromotionPopup: function (promoId) {
                        var modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';

                        var $newScope = $scope.$new(true);
                        $newScope.promoId = promoId;
                        ngDialog.open({
                            template    : '<div><promotion-progress-popup promo-id="promoId"></promotion-progress-popup></div>',
                            scope: $newScope,
                            className: modalClass,
                            plain: true
                        });
                    },
                    getPromotionTag: function (productName) {
                        if(hsUtils.isNonEmptyObject(hsPromotionsV2.promotions) && 
                        hsUtils.isNonEmptyObject(hsPromotionsV2.promotions.items) &&
                        hsUtils.isNonEmptyObject(hsPromotionsV2.promotions.items[productName]) &&
                        hsUtils.isNonEmptyArray(hsPromotionsV2.promotions.items[productName].primary)) {
                            return hsPromotionsV2.promotions.items[productName].primary[0].tag;
                        } 

                        return null;
                    },
                    getPromotionId: function (productName) {
                        if(hsUtils.isNonEmptyObject(hsPromotionsV2.promotions) && 
                        hsUtils.isNonEmptyObject(hsPromotionsV2.promotions.items) &&
                        hsUtils.isNonEmptyObject(hsPromotionsV2.promotions.items[productName]) &&
                        hsUtils.isNonEmptyArray(hsPromotionsV2.promotions.items[productName].primary)) {
                            return hsPromotionsV2.promotions.items[productName].primary[0].id;
                        } 

                        return null;
                    },
		            removeItemFromOrder(order, item) {
			            void 0;
			            var data = {
				            order: {
					            key: encodeURIComponent($scope.order.key),
					            itemName: encodeURIComponent(item.name),
					            selectedModifiers : item.selectedModifiers || []
				            }
			            };

			            void 0;

			            void 0;
			            hsAdmin.removeItemFromOrder(data)
				            .then(function (response) {
					            if (response.status === 200) {
						            void 0;
						            void 0;
						            toastr.success('Item removed successfully.');
						            item.quantity = 0;
					            } else if (response.status === 406) {
						            toastr.error(globalFunctions.errorMsg.minOrder);
					            } else {
						            void 0;
						            void 0;
						            toastr.error('Error removing item from order');
					            }
				            });
		            },
		            updateItemInOrder(item, quantity, originalQuantity) {
			            void 0;

			            void 0;
			            var data = {
				            order: {
					            key: $scope.order.key,
					            itemName: item.name,
					            itemQuantity: parseFloat(quantity)
				            }
			            };

			            if (item.selectedModifiers) {
				            data.order.selectedModifiers = item.selectedModifiers.map(function (modifier) {
					            return modifier.name;
				            });
			            }

			            void 0;

			            hsAdmin.updateOrder(data)
				            .then(function (response) {
					            switch (response.status) {
						            case 200:
							            void 0;
							            void 0;
							            toastr.success('Updated quantity successfully.');
							            break;
						            case 402:
							            toastr.error('Your credit card was declined, please make sure there are enough funds on your card or ask your bank to authorize the transaction and retry.');
							            break;
						            case 403:
							            globalFunctions.showConfirmationDialog(globalFunctions.userOrderChanges.heading, globalFunctions.userOrderChanges.subHeading,
								            'Confirm', '', function (err, success) {
									            void 0;
									            ngDialog.close();
								            });
							            toastr.error('Can not make changes anymore.');
							            break;
									case 409:
										toastr.error('Maximum quantity for product reached.');
										item.quantity  = originalQuantity;
							            break;
						            case 406:
							            toastr.error(globalFunctions.errorMsg.minOrder);
							            break;
						            default:
							            toastr.error('Error updating quantity.');

							            break;
					            }

					            item.isUpdating = false;
					            item.loading = false;

				            });
		            },
                    init                        : function () {
						$scope.product.showV2 = $scope.showV2;
                    	this.order = $scope.order || false;
                    	this.menuItem = $scope.menuItem || false;
                    	this.tileProduct = $scope.tileProduct || false;

                    	if ($scope.tabularView) {
                    		this.config.tabularView = true;
		                    $scope.product.data = $scope.productObj;
                    		this.config.quantity = $scope.productObj.quantity;
	                    } else {
		                    if(!$scope.productObj) {
			                    this.config.showViewAll = true;
			                    this.config.categoryName = $scope.categoryName;
		                    } else {
			                    if($scope.productObj.renderEmptyTile){
				                    $scope.product.renderEmptyTile = $scope.productObj.renderEmptyTile;
			                    }else{
				                    $scope.product.data = $scope.productObj;
			                    }
		                    }
	                    }

                        // setup bootstrap tooltips - must be done when DOM is rendered
                        $(function () {
                            $('[data-toggle="tooltip"]').tooltip()
                        });

						$rootScope.$on( "$routeChangeStart", function(event, next, current) {
							$('#tooltip-' + $scope.product.data.name).tooltip('hide');
							delete $scope.product.tooltipTimeouts[$scope.product.data.name];
						});
                    },
		            viewAllProducts             : function () {
                    	$location.url('/shop/'+ $scope.categoryUrl);
		            },
                    isItemInTableSideBasket: function(item) {
                        var basket = localStorageService.get('orderBasket');
                        if (!basket || !Array.isArray(basket.items)) return false;

                        return !!basket.items.find(function(i) {
                            return i.name === item.name;
                        });
                    },
		            updateItemQuantity          : function (type, item) {
		            	var quantity = item.quantity;
		            	var quantityUnit = 1;
		            	if (!item.sellByQty && item.unit.toLowerCase() === 'lb') {
		            		quantityUnit = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
		            		quantity = Math.ceil(parseFloat((quantity / quantityUnit).toFixed(2))) * quantityUnit;
            				quantity = parseFloat(quantity.toFixed(2));
		            	}
                    	if(type === "add") {
                    		if (item.hasOwnProperty('maxQuantity')
			                    && item.maxQuantity > 0
			                    && item.quantity === item.maxQuantity
			                ) {
                    			if (item.hasOwnProperty('maxQuantityMessage')) {
                    			    toastr.error(item.maxQuantityMessage);
			                    } else {
                    			    toastr.error(globalFunctions.product.maxQuantityError(item.maxQuantity));
			                    }
		                    } else {
		                        item.quantity = parseFloat((quantity + quantityUnit).toFixed(2));

			                    item.showRemoveBtn = false;
                                updateQuantity(item, quantity);
		                    }
	                    } else if(type === 'subtract') {

                    		if (item.quantity === quantityUnit || item.minQuantity && item.quantity === item.minQuantity) {
                                if ($scope.useTableSideBasket) {
                                    $scope.product.removeTableSideOrderItem(item);
                                } else if ($scope.order) {
				                    $scope.product.removeItemFromOrder($scope.order, item);
			                    } else {
				                    $scope.product.removeItem(item);
			                    }
		                    } else {
			                    item.quantity = parseFloat((quantity - quantityUnit).toFixed(2));

                    		    item.showRemoveBtn = false;
                                updateQuantity(item, quantity);
		                    }
	                    }
                        function updateQuantity(item, originalQuantity) {
                            if ($scope.useTableSideBasket) {
                                $scope.product.addTableSideOrderItem(item, item.quantity);
                            } else if ($scope.order) {
                                $scope.product.updateItemInOrder(item, item.quantity, originalQuantity);
                            } else {
                                $scope.product.addItem(item, item.quantity, item.quantity !== 1, originalQuantity);
                            }
                        }
		            },
					showDeleteButton: function(item) {
						var quantityUnit = 1;
						if (!item.sellByQty && item.unit.toLowerCase() === 'lb') {
		            		quantityUnit = item.unitIncrement && typeof item.unitIncrement === 'number' ? item.unitIncrement : 0.5;
		            	}

						if (item.quantity <= quantityUnit || item.minQuantity && item.quantity === item.minQuantity) {
							return true;
						}
						return false;
					},
					tooltipTimeouts: {},
					handleProductWithModifiersUpdate: function(operation) {
						if (operation === "add") {
							$scope.product.addItem($scope.product.data, ($scope.product.data.unit === 'lb' ? .5 : 1));
						} else {
							if ($scope.product.showDeleteButton($scope.product.data)) {
								$scope.product.updateItemQuantity(operation, $scope.product.data);		
							} else {
								clearTimeout($scope.product.tooltipTimeouts[$scope.product.data.name]);
								$('#tooltip-' + $scope.product.data.name).tooltip('show');
								$scope.product.tooltipTimeouts[$scope.product.data.name] = setTimeout(function() {
									$('#tooltip-' + $scope.product.data.name).tooltip('hide');
									delete $scope.product.tooltipTimeouts[$scope.product.data.name];
								}, 5000);
							}
						}
					},
					updateQuantityV2: function(operation) {
						if (["add", "subtract"].includes(operation)) {
							if ($scope.product.data.hasModifiers || $scope.product.data.isContainer) {
								$scope.product.handleProductWithModifiersUpdate(operation);
							} else if ($scope.product.data.quantity === 0 && operation === "add") {
								$scope.product.addItem($scope.product.data, (!$scope.product.data.sellByQty && $scope.product.data.unit === 'lb' ? 0.5 : 1));
							} else {
								$scope.product.updateItemQuantity(operation, $scope.product.data);
							}
						} else {
							void 0;
						}
					},
		            updateOrderFormItemQuantity : function (type, item) {
                    	void 0;
                    	if (type === "add") {
		                    if (item.hasOwnProperty('maxQuantity')
			                    && item.maxQuantity > 0
			                    && $scope.product.config.quantity === item.maxQuantity) {
			                    if (item.hasOwnProperty('maxQuantityMessage')) {
				                    toastr.error(item.maxQuantityMessage);
			                    } else {
				                    toastr.error(globalFunctions.product.maxQuantityError(item.maxQuantity));
			                    }
		                    } else {
			                    $scope.product.config.quantity++;
			                    item.loading = true;
			                    $scope.product.processOrderItem();
		                    }
	                    } else if (type === "subtract" && $scope.product.config.quantity > 0) {
                    		if ($scope.product.config.quantity > 0 && $scope.product.config.quantity < 1) {
		                        $scope.product.config.quantity = 0;
		                    } else {
		                        $scope.product.config.quantity--;
		                    }
		                    item.loading = true;
		                    $scope.product.processOrderItem();
	                    }
		            },
		            showProductPopup            : function (product, originalQuantity) {
                    	void 0;
			            var modalClass = '';
			
			            if (product.hasImage) {
				            modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
			            } else {
				            modalClass = 'ngdialog-theme-default email-capture';
			            }

			            if ($rootScope.tableSideOrder) {
			            	hsTableSideOrders.refreshSession();
			            }

			            product.order = $scope.order || false;

						var gaEventCategory = aiSearchEvents.getEventCategory();

						if (gaEventCategory === globalFunctions.GAEventType.SEARCH) {
							product.searchIndex = $scope.searchIndex;
						}

                        hsApi.getProduct(product.name)
                            .then(function (productResp) {
                                var keysToAdd = ['nutritionInfo', 'ingredients', 'marketingCopy'];
                                keysToAdd.forEach(function (key) {
                                    if (key in productResp) {
                                        product[key] = productResp[key];
                                    }
                                });
                            })
                            .catch(function (error) {
                                void 0;
                            })
                            .finally(function () {
                                ngDialog.open({
                                    template    : 'partials/popup/product-item/product-item-popup.html',
                                    controller  :'ModalController',
                                    className   : modalClass,
                                    data        : product,
                                })
								.closePromise
									.then(function(data) {
										if (hsUtils.isObject(data) && hsUtils.isObject(data.value)) {
											var item = data.value;
											$scope.handleAddProduct({ item: item });
										} else if (hsUtils.isNumber(originalQuantity) && !$scope.product.data.hasModifiers) {
											$scope.product.data.quantity = originalQuantity;
										}
									})
									.catch(function() {
										void 0;
									});
                            });
		            },
		            addItem                     : function (item, quantity, isUpdating, originalQuantity) {
                    	if(item.isContainer || item.hasModifiers 
                            || (item.availableTimes && Array.isArray(item.availableTimes) && item.availableTimes.length > 0)){
								if (!hsUtils.isNumber(originalQuantity)) {
									originalQuantity = 0;
								}
							this.showProductPopup(item, originalQuantity);
						} else {
							if (item.minQuantity && !item.quantity) {
								quantity = quantity < item.minQuantity ? item.minQuantity : quantity;
							}
                            if ($scope.useTableSideBasket) {
                                return $scope.product.addTableSideOrderItem(item, quantity);
                            }
                            if (!$rootScope.loggedIn) {
                                var basket = localStorageService.get('basket');
                                item.quantity = quantity;

                                if(basket){
                                    var sameItem = false;
                                    basket.forEach(function (basketItem) {
                                        if(basketItem.name === item.name){
                                            basketItem.quantity = item.quantity;
                                            sameItem = true;
                                        }
                                    });

                                    if(!sameItem){
                                        basket.push(item);
                                    }

                                    localStorageService.set('basket', basket);
                                }else{
                                    var basketArray = [];
                                    basketArray.push(item);
                                    localStorageService.set('basket', basketArray);
                                }

                                item.quantity = quantity++;
                                $rootScope.$emit('cartUpdated',true);

	                            globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'Visitor added || ' + item.displayName + ' || to cart.');
								$scope.product.sendAddProductGAEvent(item);
								$scope.handleAddProduct({ item: item });
                            } else {
                            	if ($scope.order) {
		                            $scope.product.addItemToExistingOrder(item);
	                            } else {
                                    $scope.product.addToCart(item, quantity, isUpdating, originalQuantity);
	                            }
                            }
						}
		            },
					sendAddProductGAEvent: function(item) {
						var gaEventCategory = aiSearchEvents.getEventCategory();
						aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.ADD_TO_CART, item.name);

						if (gaEventCategory === globalFunctions.GAEventType.SEARCH) {
							aiSearchEvents.sendEvent(gaEventCategory, aiSearchEvents.eventAction.SEARCH_ITEM_RANK, $scope.searchIndex + 1);
						}
					},
                    addTableSideOrderItem: function(item, quantity) {
                    	hsTableSideOrders.refreshSession();

                        var orderItem = $scope.order && $scope.order.items.find(function(i) { return i.name === item.name; });
                        item.quantity = quantity;
                        var basket = localStorageService.get('orderBasket') || {};
                        if (!Array.isArray(basket.items)) {
                        	basket.items = [];
                        }

                        if (basket.items.length) {
                            var basketItem = basket.items.find(function(i) { return i.name === item.name; });
                            if (basketItem) {
                                basketItem.quantity = item.quantity;
                            } else {
                                addItemToBasket(item);
                            }
                        } else {
                            addItemToBasket(item);
                        }
                        localStorageService.set('orderBasket', basket);

                        function addItemToBasket(item) {
                            if (orderItem && item.quantity > orderItem.quantity) {
                                item.quantity -= orderItem.quantity;
                            }
                            delete item.order;
                            basket.items.push(item);
                        }
                    },
                    removeTableSideOrderItem: function(item) {
                        var basket = localStorageService.get('orderBasket');
                        var index = basket.items.findIndex(function(i) { return i.name === item.name; });
                        basket.items.splice(index, 1);
                        localStorageService.set('orderBasket', basket);
                        item.quantity = 0;

                        var orderItem = $scope.order && $scope.order.items.find(function(i) { return i.name === item.name; });
                        if (orderItem) {
                            item.quantity = orderItem.quantity;
                        }
                    },
		            removeItem                  : function (item) {
                    	if(!$rootScope.loggedIn){
		                    var basket = localStorageService.get('basket');
							var itemIndex = 0;
		                    
		                    basket.forEach(function(product, idx){
			                    if(product.name === item.name){
				                    itemIndex = idx;
			                    }
		                    });
		                    
		                    basket.splice(itemIndex, 1);
		
		                    localStorageService.set('basket', basket);
		
		                    item.quantity       = 0;
		                    item.showRemoveBtn  = false;
		                    $rootScope.$emit('cartUpdated',true);
	                    }else{
		                    void 0;
		                    void 0;
		                    item.loading = true;
		
		                    var data = {
			                    itemName    : item.name
		                    };
	
							if (item.selectedModifiers) {
								data.selectedModifiers = item.selectedModifiers;
							}

		                    hsCart.removeItemFromCart(data)
		                    .then(function(response){
			                    if(response.status === 200){
				                    void 0;
				
				                    item.quantity       = 0;
				                    item.showRemoveBtn  = false;
				                    toastr.success('Item removed successfully.');
				
				                    $rootScope.$emit('cartUpdated',true);
			                    }else{
				                    void 0;
				                    void 0;
				                    toastr.error('Error removing item from cart.');
			                    }
			
			                    item.loading = false;
		                    });
	                    }
		            },
		            addToCart                   : function (item, quantity, isUpdating, originalQuantity) {
		            	if ($rootScope.tableSideOrder) {
		            		hsTableSideOrders.refreshSession();
		            	}
                    	item.loading = true;
                        void 0;
                        
                        var data = {
	                        items : [{
		                        name            : item.name,
		                        quantity        : quantity,
		                        isCustomItem    : false,
		                        canReplace      : globalFunctions.canReplace(item),
		                        instructions    : "",
		                        displayName     : item.displayName,
		                        type            : item.type,
		                        subType         : item.subType,
		                        organic         : item.organic,
		                        unit            : item.price.unit
	                        }]
                        };
                        
                    	hsCart.addItemToCart(data)
	                    .then(function(response){
	                    	void 0;
	                    	if(response.status === 200){
                                void 0;
			                    if(isUpdating){
				                    toastr.success('Quantity updated successfully.');
			                    }else{
				                    toastr.success('Product added to cart successfully.');
                                }
                                if (hsCart.getIsPickupOnly(item) && !$rootScope.cartGlobal.isPickupOnly) {
                                    toastr.warning('Item added is Pick Up only.');
                                }
			                    item.quantity = quantity++;
			                    $rootScope.cartGlobal.itemsTotal++;
	                    		$rootScope.$emit('cartUpdated',true);
			                    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'User added || ' + item.displayName + ' || to cart.');
								$scope.product.sendAddProductGAEvent(item);
								$scope.handleAddProduct({ item: item });
		                    }else{
								if (response.status === 409) {
									toastr.error('Maximum quantity for product reached');
									item.quantity = originalQuantity;
								} else {
									toastr.error('Error adding product.');
								}
			                    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Error', 'Error adding || ' + item.displayName + ' || to cart.');
		                    }
		                    item.loading = false;
	                    });
		            },
		            addItemToExistingOrder(item) {
			            item.loading = true;

			            var interval = item.unit === 'lb' && !item.sellByQty ? 0.5 : 1;

			            var data = {
				            order: {
					            key: $scope.order.key,
					            itemName: item.name,
					            itemQuantity: interval,
					            isCustomItem: item.isCustom || item.isCustomItem || false,
					            isOrganicItem: item.organic
				            }
			            };

			            void 0;

			            hsAdmin.addItemToOrder(data)
				            .then(function (response) {
				            	void 0;
					            switch (response.status) {
						            case 200:
							            void 0;
							            item.quantity = interval;
                                        toastr.success('Item added to order successfully.');
							            break;
						            case 402:
							            toastr.error('Your credit card was declined, please make sure there are enough funds on your card or ask your bank to authorize the transaction and retry.');
                                        break;
                                    case 406:
                                        toastr.error('Item selected is only available for Pick Up.');
                                        break;
						            case 409:
							            toastr.error('Item already exists in the order.');
							            break;
						            case 403:
						            	globalFunctions.showConfirmationDialog(globalFunctions.userOrderChanges.heading, globalFunctions.userOrderChanges.subHeading,
							            'Confirm', '', function (err, success) {
								            void 0;
								            ngDialog.close();
							            });
							            toastr.error('Can not make changes anymore.');
							            break;
						            default:
							            toastr.error('Error adding item to order.');
							            break;
					            }

					            item.loading = false;
				            });
		            },
		            processOrderItemOnBlur      : function () {
			            if (this.config.quantity !== 0 && !this.config.quantity) {
				            this.config.quantity = 0;
				            $scope.product.removeOrderFormItem($scope.product.data);
			            }
		            },
		            processOrderItem            : function () {
						var item = $scope.product.data;
						var quantityOfItemInBasket = $scope.product.getQuantityOfItemInBasket(item);
						if (this.config.quantity === quantityOfItemInBasket) {
							return;
						}
						if (this.config.quantity > 0) {
							var quantity = this.config.quantity;
							if (!$rootScope.loggedIn) {
								var basket = localStorageService.get('basket');
								item.quantity = quantity;

								if (basket) {
									var sameItem = false;
									basket.forEach(function (basketItem) {
										if(basketItem.name === item.name){
											basketItem.quantity = item.quantity;
											sameItem = true;
										}
									});

									if(!sameItem){
										basket.push(item);
									}

									localStorageService.set('basket', basket);
								} else {
									var basketArray = [];
									basketArray.push(item);
									localStorageService.set('basket', basketArray);
								}

								item.loading = false;
								$rootScope.$emit('cartUpdated',true);
							} else {
								$scope.product.placeOrderFormItem($scope.product.data, $scope.product.config.quantity, true);
							}
						} else if (this.config.quantity === 0) {
							$scope.product.removeOrderFormItem($scope.product.data);
						} else if (!this.config.quantity) {
				            this.config.quantity = 0;
							if (quantityOfItemInBasket > 0) {
								$scope.product.removeOrderFormItem($scope.product.data);
							}
			            }
		            },
					getQuantityOfItemInBasket: function(targetItem) {
						var basket = localStorageService.get('basket');
						var itemsInBasket = basket;
						if ($rootScope.loggedIn) {
							itemsInBasket = basket.items;
						}
						var targetItemQuantity = 0;
						if (itemsInBasket) {
							for (var item of itemsInBasket) {
								if (item.name === targetItem.name) {
									targetItemQuantity += item.quantity;
								}
							}
						}
						return targetItemQuantity;
					},
					processOrderItemOnKeyDown: function(event) {
						if (event.keyCode === 13) {
							$scope.product.processOrderItem();
						}
					},
		            removeOrderFormItem         : function (item) {
			            if(!$rootScope.loggedIn){
				            var basket = localStorageService.get('basket');
				            var itemIndex = 0;

				            basket.forEach(function(product, idx){
					            if(product.name === item.name){
						            itemIndex = idx;
					            }
				            });

				            basket.splice(itemIndex, 1);

				            localStorageService.set('basket', basket);

				            item.quantity       = 0;
				            item.showRemoveBtn  = false;
				            $rootScope.$emit('cartUpdated',true);
			            } else {
				            void 0;
				            void 0;
				            item.loading = true;

				            var data = {
					            itemName    : item.name
				            };

				            hsCart.removeItemFromCart(data)
					            .then(function(response){
						            if(response.status === 200){
							            void 0;
							            item.quantity       = 0;
							            item.showRemoveBtn  = false;
							            toastr.success('Item removed successfully.');

							            $rootScope.$emit('cartUpdated',true);
						            }else{
							            void 0;
							            void 0;
							            toastr.error('Error removing item from cart.');
						            }
						            item.loading = false;
					            });
			            }
		            },
		            placeOrderFormItem          : function (item, quantity, isUpdating) {
                    	void 0;
                    	item.loading = true;
                        void 0;

                        var data = {
	                        items : [{
		                        name            : item.name,
		                        quantity        : quantity,
		                        isCustomItem    : false,
		                        instructions    : "",
		                        canReplace      : globalFunctions.canReplace(item),
		                        displayName     : item.displayName,
		                        type            : item.type,
		                        subType         : item.subType,
		                        organic         : item.organic,
		                        unit            : item.price.unit
	                        }]
                        };

                    	hsCart.addItemToCart(data)
	                    .then(function(response){
	                    	void 0;
	                    	if(response.status === 200){
	                    		void 0;
			                    if(isUpdating){
				                    toastr.success('Quantity updated successfully.');
			                    }else{
				                    toastr.success('Product added to cart successfully.');
			                    }
	                    		$rootScope.$emit('cartUpdated',true);

		                    }else{
			                    toastr.error('Error adding product.');
		                    }

		                    item.loading = false;
	                    });
		            },
	                calculateProductPrice       : function (priceObj) {
		                return hsCart.calculateProductPrice(priceObj);
	                },
	                calculatePricePerQuantity   : function (priceObj) {
		                return hsCart.calculatePricePerQuantity(priceObj);
	                },
					getUnit		: function(product){
						if (product.data.unit === 'lb' && !product.data.sellByQty) {
							return 'lb'
						}
						return 'count'
					},
                    shouldShowMembershipDiscount: function () {
                        return hsPromos.shouldShowMembershipDiscount($scope.product.data, $scope.product.promotion);
                    },
                    getRelevantPromotionForPrice: function (item) {
                        return hsPromos.getRelevantPromotionForPrice($scope.product.data, $scope.product.promotion);
                    },
                    shouldShowUnit: function () {
                        if ($scope.product.shouldShowMembershipDiscount() || ENV.hideItemUnit) return false;
                        if ($scope.product.promotion && $scope.product.promotion.type === hsPromos.types.FREE_ITEM) return false;

                        return true;
                    },
					getProductDescriptionLink: function(name) {
						var path = $location.path();
						localStorageService.set('previousPath', path);

						if (path === '/search') {
							localStorageService.set('productSearchIndex', $scope.searchIndex + 1);
						}
						return '/product/' + name;
					},
					openProductDescription: function(name) {
						var path = $location.path();
						localStorageService.set('previousPath', path);

						if (path === '/search') {
							localStorageService.set('productSearchIndex', $scope.searchIndex + 1);
						}
						$location.url('/product/' + name);
					}
                };

                $scope.hsPromos = hsPromos;
                $scope.$watch('hsPromos.ongoingPromotions', function(newVal, oldVal) {
                    $scope.product.promotion = hsPromos.getVisiblePromotion($scope.productObj);
                    $scope.product.volumePromotions = hsPromos.getVisibleVolumePromotions($scope.productObj);
                });
            }
        ]};
    }
);

hsApp.component('qrCode', {
    templateUrl: '/partials/components/qr-code.html',
    bindings: {
        title: '<',
        encodingData: '<',
    },
    controller: ['hsUtils', qrCodeController],
});

function qrCodeController(hsUtils) {

    var ctrl = this;
    var logPrefix = '[qr-code]: ';
    
    ctrl.$onInit = function () {
        void 0;

        ctrl.error = '';
        if (!hsUtils.isNonEmptyString(ctrl.encodingData)) {
            void 0;
            ctrl.error = 'Failed to generate QR Code';
            return;
        }
        ctrl.elementId = 'canvas';
        ctrl.generateQRCode();
    };

    ctrl.generateQRCode = function() {
        var canvas = document.getElementById(ctrl.elementId);

        // Large QR Code 400 x 400 generated
        var qrOptions = {
            width: 400
        };
        
        QRCode.toCanvas(canvas, ctrl.encodingData, qrOptions, function (error) {
            if (error) {
                ctrl.error = 'Failed to generate QR Code';
                void 0;
                return;
            }
            
            // Override style to fix 70% area
            canvas.style.width = '70%';
            canvas.style.height = '70%';
        });
    };
}

hsApp.component('removeItem', {
    templateUrl: '/partials/components/remove-item.html',
    bindings: {
        isTableSideOrder: '<',
        onConfirm: '&',
        onClose: '&',
    },
    controller: ['$attrs', 'ENV', removeItemController],
});


function removeItemController($attrs, ENV) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.reasons = [
            'Waitstaff Error',
            'Kitchen Error',
            'Promo Comp',
            'Dislike Comp',
            'Goodwill Comp',
            'Customer Ordered Wrong',
            'Out of Stock',
        ];
        ctrl.selectedReason = null;
        ctrl.isLoading = false;
        ctrl.errorMessage = '';
        ctrl.showSelectReason = $attrs.isTableSideOrder && ENV.isRestaurant ? true : false;
    };

    ctrl.cancelRemoveItem = function() {
        void 0;
        ctrl.onClose();
    };

    ctrl.removeItem = function() {
        ctrl.isLoading = true;
        ctrl.errorMessage = '';
        var args = {};

        if (ctrl.showSelectReason) {
            if (!ctrl.selectedReason) {
                ctrl.errorMessage = 'Please select a reason.';
                ctrl.isLoading = false;
                return;
            }
            args.reason = ctrl.selectedReason;
        }

        ctrl.onConfirm(args)
            .then(function(res) {
                void 0;
                if (res === 'success') {
                    ctrl.onClose({ value: 'success' });
                    return;
                }
                ctrl.errorMessage = res;
            })
            .catch(function(err) {
                void 0;
                ctrl.errorMessage = 'Something went wrong.';
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };
}

hsApp.component('sidebar', {
    templateUrl: '/partials/components/sidebar.html',
    transclude: true,
    bindings: {
    },
    controller: [sidebarController],
});

function sidebarController() {
    var ctrl = this;
}


/**
 * @filters All the filter data. Comes from parent.
 *      ex. {'categories': {'titles': ['categories','subcategories'], 'multiSelect':false, 'data':{}}}
 *          if (multiSelect), typeof data = array, else object.
 * @currentFilters represents the current filter clickpath.
 * @activeFilters represents the currently active filters - what is currently filtered for.
 * @filterState Stores all current and active filters for every filter obj.
 *      ex. "brands": {"currentFilters":{}, "activeFilters":{}}, etc.
 * @openFilter The current filter that is open in the slide up sheet.
 * @openFilterData The data (options) of the currently open filter.
 */

hsApp.component('slideupMenubar', {
    bindings: {
        toggleSlideUp: '<',
        filters: '<',
        onOpen: '&',
        onClose: '&',
        onSelect: '&',
        onRevert: '&',
        phrase: '<',
        getFilterDisplayName: '&'
    },
    templateUrl: '/partials/components/slideup-menubar.html',
    controller: ['$rootScope', 'hsSearch', 'globalFunctions', slideUpMenuBarController]
});

function slideUpMenuBarController($rootScope, hsSearch, globalFunctions) {

    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.logPrefix = '[slideup-menubar]: ';
        ctrl.filterState = {};
        ctrl.initializeState();
    };

    ctrl.$onChanges = function(changes) {
        if (changes && changes.phrase && !changes.phrase.isFirstChange() && changes.phrase.previousValue) {
            if (ctrl.openFilter) {
                ctrl.toggleFilter(ctrl.openFilter);
            }
            ctrl.filterState = {};
            ctrl.initializeState();
        }

        if (changes && changes.filters && !changes.filters.isFirstChange() && $rootScope.screenWidth.xs) {
            var filterKeys = Object.keys(changes.filters.currentValue);
            var queryParamsToKeep = [];
            for (var filterKey of filterKeys) {
                var data = ctrl.filters[filterKey]['data'];
                var activeFilters = Object.keys(ctrl.filterState[filterKey].activeFilters);
                for (var activeFilter of activeFilters) {
                    if (Array.isArray(data) && !data.includes(activeFilter)) {
                        delete ctrl.filterState[filterKey].activeFilters[activeFilter];
                        delete ctrl.filterState[filterKey].currentFilters[activeFilter];
                    } else if (!Array.isArray(data) && typeof data === 'object' && !(activeFilter in data)) {
                        delete ctrl.filterState[filterKey].activeFilters[activeFilter];
                        delete ctrl.filterState[filterKey].currentFilters[activeFilter];
                    } else {
                        queryParamsToKeep.push({
                            filterKey: filterKey,
                            activeFilter: activeFilter
                        });
                    }
                }
            }
            if (queryParamsToKeep.length) {
                hsSearch.refreshURL(queryParamsToKeep);
            }
        }
    }

    ctrl.initializeState = function() {
        ctrl.openFilter = null;
        ctrl.openFilterData = null;
        ctrl.showSlideUp = false;
        if (ctrl.filters) {
            ctrl.filterNames = Object.keys(globalFunctions.getEnabledFilters(ctrl.filters));
            ctrl.filterNames.forEach(function(filterName) {
                if (ctrl.filterState) {
                    ctrl.filterState[filterName] = {
                        activeFilters: {},
                        currentFilters: {},
                        titles: ctrl.filters[filterName].titles
                    };
                }
            });
            ctrl.resolveState();
        } else {
            void 0;
        }
    }

    ctrl.processFilterName = function(str) {
        return globalFunctions.reverseCamelCase(str);
    }

    ctrl.closeFilters = function() {
        ctrl.openFilter = null;
        ctrl.openFilterData = null;
        ctrl.showSlideUp = false;
    }

    ctrl.toggleFilter = function(filter) {
        if (ctrl.openFilter === filter) {
            ctrl.openFilter = null;
            ctrl.openFilterData = null;
            ctrl.showSlideUp = false;
        } else {
            if (ctrl.openFilter) {
                if (!ctrl.selectedFiltersEqualsAppliedFilters()) {
                    ctrl.search(filter);
                }
            }
            ctrl.openFilter = filter;
            ctrl.openFilterData = ctrl.sanitizeFilterData(ctrl.filters[filter]);
            ctrl.showSlideUp = true;
        }
    }

    ctrl.resolveState = function() {
        var searchUrl = hsSearch.resolveSearchURL();
        Object.keys(searchUrl).forEach(function(key) {
            if (ctrl.filterState[key]) {
                searchUrl[key].forEach(function(section) {
                    ctrl.filterState[key].activeFilters[section] = {};
                    ctrl.filterState[key].currentFilters[section] = {};
                });
            }
        });
        if (searchUrl['categories'] && searchUrl['subcategories']) {
            var activeCategory = Object.keys(ctrl.filterState['categories'].activeFilters)[0] || searchUrl.categories[0];
            searchUrl['subcategories'].forEach(function(subsection) {
                ctrl.filterState['categories'].activeFilters[activeCategory][subsection] = {};
                ctrl.filterState['categories'].currentFilters[activeCategory][subsection] = {};
            });
        }
    }

    ctrl.processFilter = function() {
        var options = {};
        for (var filterName of ctrl.filterNames) {
            var filterData = ctrl.filterState[filterName];
            var currentFilters = Object.keys(filterData.currentFilters);
            if (currentFilters.length) {
                options[filterName] = currentFilters;
                if (filterData.titles.length > 1) { // for subcats
                    currentFilters.forEach(function(filter) {
                        if (filterData.currentFilters[filter]
                            && Object.keys(filterData.currentFilters[filter]).length)
                        {
                            var key = filterData.titles[1];
                            if (!options[key]) {
                                options[key] = [];
                            }
                            options[key] = options[key].concat(Object.keys(filterData.currentFilters[filter]))
                        }
                    });
                }
            }
            filterData.activeFilters = JSON.parse(
                JSON.stringify(
                    filterData.currentFilters
                )
            );
        }
        return options;
    }

    ctrl.search = function(filter) {
        var options = ctrl.processFilter();
        ctrl.onSelect({ options: options }).then(function() {
            ctrl.openFilter = filter;
            ctrl.openFilterData = ctrl.sanitizeFilterData(ctrl.filters[filter]);
        }).catch(function(err) {
            void 0;
        });
    }

    ctrl.isFilterButtonOn = function(filterName) {
        return ctrl.openFilter === filterName || ctrl.keyLength(ctrl.filterState[filterName].activeFilters);
    }

    ctrl.selectedFiltersEqualsAppliedFilters = function() {
        for (var filterName of Object.keys(ctrl.filterState)) {
            if (!ctrl.areEqualObjects(ctrl.filterState[filterName].activeFilters, ctrl.filterState[filterName].currentFilters)) {
                return false;
            }
        }
        return true;
    }

    ctrl.sanitizeFilterData = function(filterObj) {
        return {
            data: filterObj.data,
            titles: filterObj.titles,
            multiSelect: filterObj.multiSelect,
            iconPath: filterObj.iconPath,
            displayMap: filterObj.displayMap,
            intersectionSearch: filterObj.intersectionSearch,
            onLanding: filterObj.onLanding
        };
    }

    ctrl.keyLength = function (obj) {
        return Object.keys(obj).length + Object.keys(obj).reduce(function(acc, key) {
            acc += Object.keys(obj[key]).length;
            return acc;
        }, 0);
    }

    ctrl.hasSections = function(filterName) {
        var data = ctrl.filters[filterName].data;
        return (Array.isArray(data)) ? data.length : Object.keys(data).length;
    }

    ctrl.getActiveFilterCount = function(filterName) {
        return ctrl.keyLength(ctrl.filterState[filterName].activeFilters);
    }

    ctrl.areEqualObjects = function(obj1, obj2) {
        return globalFunctions.areEqualObjects(obj1, obj2);
    }

}
hsApp.component('successfulPackNotification', {
    templateUrl: '/partials/components/successful-pack-notification.html',
    bindings: {
        isVisible: '<',
        message: '<',
    },
    controller: [successfulPackNotificationController],
});


function successfulPackNotificationController() {}

hsApp.component('syncPricelistsPopup', {
    bindings: {
        elementId: '@',
        locationLevelOnly    : '<',
        updateHandler: '&',
        isThrowableResponse: '&',
        isUnavailableError: '&'
    },
    templateUrl: '/partials/components/sync-pricelists-popup.html',
    controller: [ 'hsAdmin', 'hsUtils', 'globalFunctions', '$timeout', '$attrs', 'ENV', syncPricelistsPopupController ],
});

function syncPricelistsPopupController(hsAdmin, hsUtils, globalFunctions, $timeout, $attrs, ENV) {
    var ctrl = this;
    var logPrefix = '[syncPricelistsPopup]: ';

    ctrl.UPDATE_STATUS = {
        NONE: null,
        IN_PROGRESS: 'inProgress',
        SUCCESS: 'success',
        ERROR: 'error',
        NOT_AVAILABLE: 'notAvailable',
    };

    ctrl.UPDATE_STATUS_ICONS = {
        targets: {},
        groups: {}
    };

    ctrl.UPDATE_STATUS_ICONS.targets[ctrl.UPDATE_STATUS.NONE] = null;
    ctrl.UPDATE_STATUS_ICONS.targets[ctrl.UPDATE_STATUS.IN_PROGRESS] = null;
    ctrl.UPDATE_STATUS_ICONS.targets[ctrl.UPDATE_STATUS.SUCCESS] = './images/ui-v2/icon-svg/mono-check.svg';
    ctrl.UPDATE_STATUS_ICONS.targets[ctrl.UPDATE_STATUS.ERROR] = './images/ui-v2/icon-svg/mono-error.svg';
    ctrl.UPDATE_STATUS_ICONS.targets[ctrl.UPDATE_STATUS.NOT_AVAILABLE] = './images/ui-v2/icon-svg/mono-warning.svg';

    ctrl.UPDATE_STATUS_ICONS.groups[ctrl.UPDATE_STATUS.NONE] = null;
    ctrl.UPDATE_STATUS_ICONS.groups[ctrl.UPDATE_STATUS.IN_PROGRESS] = null;
    ctrl.UPDATE_STATUS_ICONS.groups[ctrl.UPDATE_STATUS.SUCCESS] = './images/ui-v2/icon-svg/filled-check.svg';
    ctrl.UPDATE_STATUS_ICONS.groups[ctrl.UPDATE_STATUS.ERROR] = './images/icons/error.svg';
    ctrl.UPDATE_STATUS_ICONS.groups[ctrl.UPDATE_STATUS.NOT_AVAILABLE] = './images/ui-v2/icon-svg/filled-warning.svg';

    ctrl.GROUP_BY = {
        LOCATION: 'location',
        PRICELIST: 'priceList',
    };

    ctrl.GROUP_LABEL_STYLES = {};

    ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.NONE] = 'group-label-default';
    ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.IN_PROGRESS] = 'group-label-default';
    ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.SUCCESS] = 'group-label-success';
    ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.ERROR] = 'group-label-error';
    ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.NOT_AVAILABLE] = 'group-label-warning';

    ctrl.$onInit = function() {
        void 0;

        if (!hsUtils.isBoolean(ctrl.locationLevelOnly)) {
            ctrl.locationLevelOnly = !ENV.enablePriceList;
        }

        ctrl.initData();

        // $timeout is needed to ensure jquery hook is set after bindings are passed and 
        // rendering is complete
        $timeout(function() {
            // re-initialize data when closing the modal for reuse
            $('#' + ctrl.elementId).on('hidden.bs.modal', function() {
                ctrl.initData();
            });
        }, 0);

    };

    ctrl.initData = function() {
        // If local storage data is not set, parent controller will not show it.
        // We still want to avoid errors, otherwise parent controller logic may be affected,
        // so setting default values here.
        ctrl.allLocations = globalFunctions.getAllLocationsFromStorage() || [];
        ctrl.selectedLocation = globalFunctions.getSelectedLocationFromStorage() || {};
        ctrl.selectedPriceList = globalFunctions.getAdminSelectedPriceListFromStorage() || {};

        ctrl.updating = false;
        ctrl.updatesComplete = false;
        ctrl.retrying = false;

        ctrl.initTargets();
        ctrl.initGroups();

        ctrl.targetUpdateStatusCounts = ctrl.getTargetUpdateStatusCounts();

        ctrl.selectGroupBy(ctrl.GROUP_BY.LOCATION);
    };

    ctrl.getLocation = function(locationUniqueName) {
        return ctrl.allLocations.find(function(location) {
            return location.uniqueName === locationUniqueName;
        });
    };

    ctrl.getPriceList = function(location, priceListUniqueName) {
        return location.priceLists.find(function(pl) {
            return pl.uniqueName === priceListUniqueName;
        });
    };

    ctrl.userHasTargetPermissions = function(locationUniqueName, priceListUniqueName) {
        if (hsUtils.isNonEmptyString(priceListUniqueName)) {
            return hsAdmin.currentUserHasPriceListAdminPermissions(locationUniqueName, priceListUniqueName);
        }

        return hsAdmin.currentUserHasLocationAdminPermissions(locationUniqueName);
    };

    ctrl.initTargets = function() {
        ctrl.targets = {};
        for (var location of ctrl.allLocations) {
            if (ctrl.locationLevelOnly) {
                if (ctrl.userHasTargetPermissions(location.uniqueName)) {
                    var defaultPriceList = globalFunctions.getDefaultPriceListFromLocation(location);
                    var targetKey = ctrl.getTargetKey(location, defaultPriceList);
                    ctrl.targets[targetKey] = ctrl.createTarget(targetKey, location, defaultPriceList);
                }
            } else {
                for (var priceList of location.priceLists) {
                    if (ctrl.userHasTargetPermissions(location.uniqueName, priceList.uniqueName)) {
                        var targetKey = ctrl.getTargetKey(location, priceList);
                        ctrl.targets[targetKey] = ctrl.createTarget(targetKey, location, priceList);
                    }
                }
            }
        }
    };

    ctrl.getTargetKey = function(location, priceList) {
        return location.uniqueName + '_' + priceList.uniqueName;
    };

    ctrl.createTarget = function(key, location, priceList) {
        var target = {
            key: key,
            displayName: {},
            locationUniqueName: location.uniqueName,
            priceListUniqueName: priceList.uniqueName,
            selected: false,
            updateStatus: ctrl.UPDATE_STATUS.NONE
        };

        target.displayName[ctrl.GROUP_BY.PRICELIST] = location.name;
        target.displayName[ctrl.GROUP_BY.LOCATION] = priceList.title;

        if (
            (ctrl.locationLevelOnly && ctrl.selectedLocation.uniqueName === location.uniqueName)
            || (!ctrl.locationLevelOnly && ctrl.selectedPriceList.uniqueName === priceList.uniqueName)
        ) {
            target.selected = true;
            target.updateStatus = ctrl.UPDATE_STATUS.SUCCESS;
        };

        return target;
    };

    ctrl.initGroups = function() {
        ctrl.groups = {};

        for (var targetKey of Object.keys(ctrl.targets)) {

            var target = ctrl.targets[targetKey];
            var location = ctrl.getLocation(target.locationUniqueName);
            var priceList = ctrl.getPriceList(location, target.priceListUniqueName);

            ctrl.addTargetToGroup(
                target,
                ctrl.GROUP_BY.LOCATION,
                location.uniqueName,
                location.name
            );
            if (!ctrl.locationLevelOnly) {
                ctrl.addTargetToGroup(
                    target,
                    ctrl.GROUP_BY.PRICELIST,
                    priceList.title.toLowerCase(),
                    priceList.title
                );
            }
        }

    };

    ctrl.addTargetToGroup = function(target, groupBy, key, displayName) {
        if (!Object.values(ctrl.GROUP_BY).includes(groupBy)) return;

        if (!ctrl.groups.hasOwnProperty(key)) {
            ctrl.groups[key] = ctrl.createGroup(
                key,
                displayName,
                groupBy
            );
        }

        ctrl.groups[key].targets.push(target.key);
    };

    ctrl.createGroup = function(key, displayName, type) {
        return {
            key: key,
            displayName: displayName,
            targets: [],
            updateStatus: ctrl.UPDATE_STATUS.NONE,
            elementId: ctrl.elementId + key + '-group',
            dropDownOpen: true,
            selectable: true,
            selected: false,
            type: type,
            label: '',
        };
    };

    ctrl.shouldHideTarget = function(targetKey) {
        return (ctrl.updating || ctrl.updatesComplete) && ctrl.targets[targetKey].updateStatus === ctrl.UPDATE_STATUS.NONE;
    };

    ctrl.shouldHideGroup = function(groupKey) {
        var group = ctrl.groups[groupKey];
        return (
            group.type !== ctrl.groupBy
            || (ctrl.updating && group.updateStatus === ctrl.UPDATE_STATUS.NONE)
            || (ctrl.updatesComplete && group.updateStatus === ctrl.UPDATE_STATUS.NONE)
        );
    };

    ctrl.selectGroupBy = function(option) {
        if (Object.values(ctrl.GROUP_BY).includes(option)) {
            $('#' + ctrl.getElementId('modal-body-groups')).scrollTop(0);
            ctrl.groupBy = option;
            ctrl.syncControllerState();
        }
    };

    ctrl.toggleGroupDropdown = function(groupKey) {
        ctrl.groups[groupKey].dropDownOpen = !ctrl.groups[groupKey].dropDownOpen;
    };

    ctrl.getGroupSelectedTargetCount = function(groupKey) {
        return ctrl.getGroupSelectableCount(groupKey, true);
    };
    
    ctrl.getGroupSelectableCount = function(groupKey, filterSelected) {
        var count = 0;
        for (var targetKey of ctrl.groups[groupKey].targets) {
            if (ctrl.isTargetSelectable(targetKey) && (!filterSelected || ctrl.targets[targetKey].selected)) {
                count = count + 1;
            }
        }
        return count;
    };

    ctrl.getAllSelectedTargetCount = function() {
        return ctrl.getTargetSelectableCount(true);
    };

    ctrl.getTargetSelectableCount = function(filterSelected) {
        var count = 0;
        for (var target of Object.values(ctrl.targets)) {
            if (ctrl.isTargetSelectable(target.key) && (!filterSelected || target.selected)) {
                count = count + 1;
            }
        }
        return count;
    };

    ctrl.syncControllerState = function() {
        ctrl.targetUpdateStatusCounts = ctrl.getTargetUpdateStatusCounts();

        var everyGroupInCompleteState = true;
        for (var groupKey of Object.keys(ctrl.groups)) {
            ctrl.syncGroupState(groupKey);
            if (ctrl.groups[groupKey].updateStatus === ctrl.UPDATE_STATUS.IN_PROGRESS) {
                everyGroupInCompleteState = false;
            }
        }

        if (ctrl.updating && everyGroupInCompleteState) {
            ctrl.updatesComplete = true;
            ctrl.updating = false;
        }
    };

    ctrl.syncGroupState = function(groupKey) {
        var group = ctrl.groups[groupKey];

        var selectedCount = ctrl.getGroupSelectedTargetCount(groupKey);
        var selectableCount = ctrl.getGroupSelectableCount(groupKey, false);

        var input = document.getElementById(group.elementId);
        if (input) {
            input.indeterminate = selectedCount !== 0 && selectedCount !== selectableCount;
        }

        group.selected = selectedCount === selectableCount;

        group.updateStatusCounts = ctrl.getGroupUpdateStatusCounts(groupKey);
        group.updateStatus = ctrl.getGroupUpdateStatus(groupKey);
        group.label = ctrl.getGroupLabel(groupKey);
    };

    ctrl.getGroupUpdateStatus = function(groupKey) {
        var targets = ctrl.groups[groupKey].targets;

        if (ctrl.updating || ctrl.updatesComplete) {
            targets = targets.filter(function(targetKey) {
                return ctrl.targets[targetKey].updateStatus !== ctrl.UPDATE_STATUS.NONE;
            });
        }

        if (hsUtils.isEmptyArray(targets)) return ctrl.UPDATE_STATUS.NONE;

        if (ctrl.groups[groupKey].updateStatusCounts[ctrl.UPDATE_STATUS.IN_PROGRESS] > 0) {
            return ctrl.UPDATE_STATUS.IN_PROGRESS;
        }

        if (ctrl.groups[groupKey].updateStatusCounts[ctrl.UPDATE_STATUS.ERROR] > 0) {
            return ctrl.UPDATE_STATUS.ERROR;
        }

        if (ctrl.groups[groupKey].updateStatusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] > 0) {
            return ctrl.UPDATE_STATUS.NOT_AVAILABLE;
        }

        if (ctrl.groups[groupKey].updateStatusCounts[ctrl.UPDATE_STATUS.SUCCESS] === targets.length) {
            return ctrl.UPDATE_STATUS.SUCCESS;
        }

        return ctrl.UPDATE_STATUS.NONE;
    };

    ctrl.getGroupUpdateStatusCounts = function(groupKey) {
        var statuses = {};

        statuses[ctrl.UPDATE_STATUS.NONE] = 0;
        statuses[ctrl.UPDATE_STATUS.IN_PROGRESS] = 0;
        statuses[ctrl.UPDATE_STATUS.SUCCESS] = 0;
        statuses[ctrl.UPDATE_STATUS.ERROR] = 0;
        statuses[ctrl.UPDATE_STATUS.NOT_AVAILABLE] = 0;
        
        
        var group = ctrl.groups[groupKey];
        for (var targetKey of group.targets) {
            var target = ctrl.targets[targetKey];
            statuses[target.updateStatus] = statuses[target.updateStatus] + 1;
        }

        return statuses;
    };

    ctrl.getGroupLabel = function(groupKey) {
        var group = ctrl.groups[groupKey];

        if (ctrl.updating) return '';
        
        if (!ctrl.isGroupSelectable(groupKey)) {
            var statusCounts = ctrl.getGroupUpdateStatusCounts(groupKey);

            var label = '';
            if (statusCounts[ctrl.UPDATE_STATUS.SUCCESS] > 0) {
                label = label + statusCounts[ctrl.UPDATE_STATUS.SUCCESS] + ' Updated';
            }
            if (statusCounts[ctrl.UPDATE_STATUS.ERROR] > 0) {
                if (label !== '') {
                    label = label + ', ';
                }
                label = label + statusCounts[ctrl.UPDATE_STATUS.ERROR] + ' Failed';
            }
            if (statusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] > 0) {
                if (label !== '') {
                    label = label + ', ';
                }
                label = label + statusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] + ' Unavailable';
            }
            return label;
        } 
        
        var selectedTargetCount = ctrl.getGroupSelectedTargetCount(groupKey);
        var label = selectedTargetCount + ' Selected';

        if (group.updateStatusCounts[ctrl.UPDATE_STATUS.SUCCESS] > 0) {
            label = label + ', ' + group.updateStatusCounts[ctrl.UPDATE_STATUS.SUCCESS] + ' Updated';
        }
        return label;
    };

    ctrl.getGroupLabelStyle = function(groupKey) {
        var groupHasSuccessfulUpdates = false;
        for (var targetKey of ctrl.groups[groupKey].targets) {
            if (ctrl.targets[targetKey].updateStatus === ctrl.UPDATE_STATUS.SUCCESS) {
                groupHasSuccessfulUpdates = true;
            }
        }

        var isPartiallyUpdatedGroup = groupHasSuccessfulUpdates && ctrl.groups[groupKey].updateStatus !== ctrl.UPDATE_STATUS.SUCCESS;

        if (!ctrl.updating && !ctrl.updatesComplete && isPartiallyUpdatedGroup) {
            // we want to show light green for any group that has had updates 
            // but user can still select targets for
            return ctrl.GROUP_LABEL_STYLES[ctrl.UPDATE_STATUS.NOT_AVAILABLE];
        }
        
        return ctrl.GROUP_LABEL_STYLES[ctrl.groups[groupKey].updateStatus];
    };

    ctrl.handleGroupSelection = function(groupKey) {
        var group = ctrl.groups[groupKey];

        for (var targetKey of group.targets) {
            if (ctrl.isTargetSelectable(targetKey)){
                ctrl.targets[targetKey].selected = group.selected;
            }
        }

        ctrl.syncControllerState();
    };

    ctrl.handleGroupSelectionByLabel = function(groupKey) {
        var group = ctrl.groups[groupKey];

        if (!ctrl.isGroupSelectable(groupKey)) return;

        group.selected = !group.selected;
        ctrl.handleGroupSelection(groupKey);
    };

    ctrl.handleTargetSelection = function() {
        ctrl.syncControllerState();
    };

    ctrl.handleTargetSelectionByLabel = function(targetKey) {
        if (!ctrl.isTargetSelectable(targetKey)) return;

        ctrl.targets[targetKey].selected = !ctrl.targets[targetKey].selected;
        ctrl.handleTargetSelection();
    };

    ctrl.isGroupSelectable = function(groupKey) {
        return !ctrl.updating && !ctrl.updatesComplete && ctrl.groups[groupKey].updateStatus === ctrl.UPDATE_STATUS.NONE;
    }

    ctrl.isTargetSelectable = function(targetKey) {
        return ctrl.targets[targetKey].updateStatus === ctrl.UPDATE_STATUS.NONE;
    };

    ctrl.clearAllSelections = function() {
        ctrl.setAllTargetsSelectedState(false);
    };
    
    ctrl.selectAll = function() {
        ctrl.setAllTargetsSelectedState(true);
    };
    
    ctrl.setAllTargetsSelectedState = function(selected) {
        for (var target of Object.values(ctrl.targets)) {
            if (ctrl.isTargetSelectable(target.key)) {
                target.selected = selected;
            }
        }
        ctrl.syncControllerState();
    };

    ctrl.closeDialog = function() {
        $('#' + ctrl.elementId).modal('hide');
    };

    ctrl.getTargetDisplayName = function(targetKey) {
        return ctrl.targets[targetKey].displayName[ctrl.groupBy];
    };

    ctrl.getTargetUpdateStatusIconUrl = function(targetKey) {
        var target = ctrl.targets[targetKey];
        return ctrl.UPDATE_STATUS_ICONS.targets[target.updateStatus];
    };

    ctrl.getGroupUpdateStatusIconUrl = function(groupKey) {
        var group = ctrl.groups[groupKey];
        return ctrl.UPDATE_STATUS_ICONS.groups[group.updateStatus];
    };

    ctrl.shouldShowTargetInputBox = function() {
        return !ctrl.updating && !ctrl.updatesComplete;
    };

    ctrl.shouldShowTargetUpdateStatusIcon = function(targetKey) {
        return (
            (ctrl.updating || ctrl.updatesComplete)
            && ctrl.targets[targetKey].updateStatus !== ctrl.UPDATE_STATUS.NONE
            && ctrl.targets[targetKey].updateStatus !== ctrl.UPDATE_STATUS.IN_PROGRESS
        );
    };

    ctrl.shouldShowGroupUpdateStatusIcon = function(groupKey) {
        var group = ctrl.groups[groupKey];
        return group.updateStatus !== ctrl.UPDATE_STATUS.NONE && group.updateStatus !== ctrl.UPDATE_STATUS.IN_PROGRESS;
    };

    ctrl.applyUpdates = function() {

        for (var target of Object.values(ctrl.targets)) {
            if (!ctrl.updatesComplete) {
                // applying updates for the first time
                if (ctrl.isTargetSelectable(target.key)) {
                    target.updateStatus = target.selected ? ctrl.UPDATE_STATUS.IN_PROGRESS : ctrl.UPDATE_STATUS.NONE;
                }
            } else {
                // retrying
                if (target.updateStatus === ctrl.UPDATE_STATUS.ERROR) {
                    target.updateStatus = ctrl.UPDATE_STATUS.IN_PROGRESS;
                }
            }
        }

        ctrl.syncControllerState();

        ctrl.updating = true;
        if (ctrl.updatesComplete) {
            ctrl.retrying = true;
        }
        ctrl.updatesComplete = false;

        for (var targetKey of Object.keys(ctrl.targets)) {
            if (ctrl.targets[targetKey].updateStatus !== ctrl.UPDATE_STATUS.IN_PROGRESS) continue;
            ctrl.updateTarget(targetKey);
        }

    };

    ctrl.updateTarget = function(targetKey) {
        var targetCopy = JSON.parse(JSON.stringify(ctrl.targets[targetKey]));
        ctrl.updateHandler({ target: targetCopy })
            .then(function(res) {
                if (ctrl.shouldThrowSuccessfulResponse(res)) {
                    throw res;
                }
                ctrl.targets[targetKey].updateStatus = ctrl.UPDATE_STATUS.SUCCESS;
            })
            .catch(function(err) {
                if (ctrl.shouldSetUnavailableStatus(err)) {
                    ctrl.targets[targetKey].updateStatus = ctrl.UPDATE_STATUS.NOT_AVAILABLE;
                } else {
                    ctrl.targets[targetKey].updateStatus = ctrl.UPDATE_STATUS.ERROR;
                }
            })
            .finally(function() {
                ctrl.syncControllerState();
            });
    };

    ctrl.shouldThrowSuccessfulResponse = function(res) {
        if ('isThrowableResponse' in $attrs && typeof ctrl.isThrowableResponse === 'function') {
            return ctrl.isThrowableResponse({ res: res });
        }

        return false;
    }

    ctrl.shouldSetUnavailableStatus = function(err) {
        if ('isUnavailableError' in $attrs && typeof ctrl.isUnavailableError === 'function') {
            return ctrl.isUnavailableError({ err: err });
        }

        return err ? err.status === 404 : false;
    };

    ctrl.getTargetUpdateStatusCounts = function() {
        var statusCounts = {};

        statusCounts[ctrl.UPDATE_STATUS.NONE] = 0;
        statusCounts[ctrl.UPDATE_STATUS.IN_PROGRESS] = 0;
        statusCounts[ctrl.UPDATE_STATUS.SUCCESS] = 0;
        statusCounts[ctrl.UPDATE_STATUS.ERROR] = 0;
        statusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] = 0;
        
        for (var target of Object.values(ctrl.targets)) {
            statusCounts[target.updateStatus] = statusCounts[target.updateStatus] + 1;
        }

        return statusCounts;
    };

    ctrl.updateStatuBarDescription = function() {
        var description = ctrl.getSuccessfulUpdatesMessage();
        
        if (ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.ERROR] > 0) {
            description = description + ', ' + ctrl.getErrorUpdatesMessage();
        }

        if (ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] > 0) {
            description = description + ', ' + ctrl.getUnavailableUpdatesMessage();
        }

        var percentageComplete = ctrl.getUpdatesPercentComplete();

        description = description + ' | ' + percentageComplete + '%';

        var indicator = document.getElementById(ctrl.getElementId('progress-bar-indicator'));
        if (indicator) {
            indicator.style.width = percentageComplete + '%';
        }

        return description;
    };

    ctrl.getTotalUpdatesCount = function() {
        return ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.IN_PROGRESS]
            + ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.SUCCESS]
            + ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.ERROR]
            + ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE];
    };

    ctrl.getCompletedUpdatesCount = function() {
        return ctrl.getTotalUpdatesCount() - ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.IN_PROGRESS];
    };

    ctrl.getSuccessfulUpdatesMessage = function() {
        return ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.SUCCESS] + '/' + ctrl.getTotalUpdatesCount() + ' Succeeded';
    };

    ctrl.getErrorUpdatesMessage = function() {
        return ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.ERROR] + ' Failed';
    };

    ctrl.getUnavailableUpdatesMessage = function() {
        return ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.NOT_AVAILABLE] + ' Unavailable';
    };

    ctrl.getUpdatesPercentComplete = function() {
        return Math.round(( ctrl.getCompletedUpdatesCount() / ctrl.getTotalUpdatesCount() ) * 100);
    };

    ctrl.canApplyOrRetryUpdates = function() {
        return !ctrl.updatesComplete || ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.ERROR] > 0;
    };

    ctrl.disableClearAllButton = function() {
        return ctrl.getAllSelectedTargetCount() === 0;
    };

    ctrl.disableSelectAllButton = function() {
        return ctrl.getAllSelectedTargetCount() === ctrl.getTargetSelectableCount();
    };

    ctrl.disableApplyUpdatesButton = function() {
        return ctrl.updating || !ctrl.updatesComplete && ctrl.getAllSelectedTargetCount() === 0;
    };

    ctrl.getApplyUpdatesButtonText = function() {
        return ctrl.updatesComplete || ctrl.retrying
            ? 'Retry ' + ctrl.targetUpdateStatusCounts[ctrl.UPDATE_STATUS.ERROR] + ' Failed'
            : 'Apply';
    };

    ctrl.getElementId = function(id) {
        return ctrl.elementId + '-' + id;
    };

}
hsApp.component('syncProductsPopup', {
    templateUrl: '/partials/components/popup/sync-products-popup.html',
    bindings: {
        products: '<',
        sourceLocation: '<',
        availableTargetLocations: '<',
        onClose: '&'
    },
    controller: ['ENV', 'hsAdmin', 'toastr', 'globalFunctions', syncProductsPopupController]
});

function syncProductsPopupController(ENV, hsAdmin, toastr, globalFunctions) {

    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.logPrefix = '[sync-products-popup]: ';
        ctrl.AVAILABLE_ACTIONS = { 
            ALL_LOCATIONS_ALL_PRICELISTS: 0,
            SPECIFIC_LOCATIONS_ALL_PRICELISTS: 1,
            ALL_LOCATIONS_SPECIFIC_PRICELISTS: 2,
            SPECIFIC_LOCATIONS_SPECIFIC_PRICELISTS: 3
        };
        ctrl.availablePriceLists = null;
        ctrl.actions = ctrl.getActions();
        ctrl.displayOptions = ctrl.getDisplayOptions();
        ctrl.selectedAction = 0;
        ctrl.selectedOptions = {
            addProductIfDoesNotExist: false
        };
        ctrl.selectAll = false;
        ctrl.showConfirmation = false;
        ctrl.showSelectOptions = false;
        ctrl.selectAllAvailableLocationsAndPriceLists(false);
    };

    ctrl.createServiceData = function() {
        var destinationLocations = (
            ctrl.selectedAction == ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_SPECIFIC_PRICELISTS
            || ctrl.selectedAction == ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_SPECIFIC_PRICELISTS
        )
            ? ctrl.getSelectedLocations()
            : ctrl.availableTargetLocations;
        var targetLocations = destinationLocations
            .filter(function(location) {
                return location.selectedToSyncProducts
            }).map(function(selectedLocation) {
                var selectedPriceListUniqueNames = selectedLocation.priceLists
                    .filter(function(priceList) {
                        return priceList.selectedToSyncProducts;
                    }).map(function(priceList) {
                        return priceList.uniqueName;
                    });
                return {
                    locationName: selectedLocation.uniqueName,
                    targetPriceListNames: selectedPriceListUniqueNames
                };
            })
        var data = {
            products: ctrl.products,
            sourceLocation: {
                locationName: ctrl.sourceLocation.location.uniqueName,
                priceListName: ctrl.sourceLocation.priceList ? ctrl.sourceLocation.priceList.uniqueName : ''
            },
            targetLocations: targetLocations
        };
        return data;
    }

    ctrl.syncProducts = function() {
        var data = ctrl.createServiceData();
        hsAdmin.syncProducts(data).then(function(response) {
            if (response.status === 200) {
                toastr.success("The system has successfully recorded your request to change this product at other stores. It may take a few minutes for the changes to apply.");
            } else {
                toastr.error("Some requests have been rejected by the system.\n" + response.data.message);
            }
            ctrl.onClose();
        });
    }

    // A specific action will be taken based on which choice is selected.
    ctrl.onNext = function() {
        
        switch (ctrl.selectedAction) {
            case ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_ALL_PRICELISTS:
                ctrl.selectAllAvailableLocationsAndPriceLists(true);
                ctrl.showConfirmation = true;
                break;
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_ALL_PRICELISTS:
                ctrl.selectAllAvailablePriceLists(true);
                ctrl.showSelectOptions = true;
                break;
            case ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_SPECIFIC_PRICELISTS:
                ctrl.selectAllAvailableLocations(true);
                ctrl.availablePriceLists = ctrl.getPriceListsFromAllAvailableLocations();
                ctrl.showSelectOptions = true;
                break;
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_SPECIFIC_PRICELISTS:
                ctrl.showSelectOptions = true;
                break;
        }    

    }

    // controls whether the next button is disabled or not
    ctrl.isNextDisabled = function() {
        switch (ctrl.selectedAction) {
            case ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_ALL_PRICELISTS:
                return false;
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_ALL_PRICELISTS:
                return !ctrl.areAnyLocationsSelected();
            case ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_SPECIFIC_PRICELISTS:
                return !ctrl.areAnyPriceListsSelected();
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_SPECIFIC_PRICELISTS:
                return !ctrl.areAnyOptionsSelected();
            default:
                return true;
        }  
    }

    // controls state of selectAll, and plist select btns
    ctrl.selectAction = function(location) {
        switch (ctrl.selectedAction) {
            // case 1: can only select locations
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_ALL_PRICELISTS:
                ctrl.selectAll = ctrl.areAllLocationsSelected();
                break;
            // case 3: can select both locations and price lists
            case ctrl.AVAILABLE_ACTIONS.SPECIFIC_LOCATIONS_SPECIFIC_PRICELISTS:
                ctrl.selectAll = ctrl.areAllLocationsSelected() && ctrl.areAllPriceListsSelectedOnLocations();
                ctrl.selectPriceLists(location);
                break;
        }
    }

    ctrl.toConfirm = function() {
        ctrl.showSelectOptions = false;
        ctrl.showConfirmation = true;
    }

    ctrl.onBack = function(toStart) {
        if (toStart) {
            ctrl.selectAllAvailableLocationsAndPriceLists(false);
            ctrl.selectAll = false;
        }
        ctrl.showConfirmation = false;
        ctrl.showSelectOptions = !toStart;
    }

    // selected locations should have at least one selected price list (cases 2, 3)
    ctrl.getSelectedLocations = function() {
        var selectedLocations = ctrl.availableTargetLocations.filter(function(location) {
            if (location.selectedToSyncProducts) {
                return location;
            }
        });
        if (ctrl.selectedAction == ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_SPECIFIC_PRICELISTS
            || ctrl.selectedAction == ctrl.AVAILABLE_ACTIONS.ALL_LOCATIONS_ALL_PRICELISTS)
        {
            selectedLocations = selectedLocations.filter(function(location) {
                if (ctrl.getSelectedPriceLists(location).length) {
                    return location;
                }
            });
        }
        return selectedLocations;
    }

    ctrl.getSelectedPriceLists = function(location) {
        return location.priceLists.filter(function(priceList) {
            if (priceList.selectedToSyncProducts) {
                return priceList;
            }
        });
    }

    ctrl.selectAllAvailableLocationsAndPriceLists = function(state) {
        ctrl.selectAllAvailableLocations(state);
        ctrl.selectAllAvailablePriceLists(state);
    }

    ctrl.selectAllAvailablePriceLists = function(state) {
        ctrl.availableTargetLocations.forEach(function(location) {
            if (Array.isArray(location.priceLists)) {
                location.priceLists.forEach(function(priceList) {
                    priceList.selectedToSyncProducts = state;
                });
            }
        });
    }

    ctrl.selectAllAvailableLocations = function(state) {
        ctrl.availableTargetLocations.forEach(function(location) {
            location.selectedToSyncProducts = state;
        });
    }

    // key = unique title of all price lists across all locations, value = list of price lists with this title
    // allows us to update the state of multiple price lists on different locations easily, based on the title
    // specifically used for case 2 
    ctrl.getPriceListsFromAllAvailableLocations = function() {
        return ctrl.availableTargetLocations.reduce(function(acc, location) {
            if (Array.isArray(location.priceLists)) {
                location.priceLists.forEach(function(priceList) {
                    if (!acc[priceList.title]) {
                        acc[priceList.title] = [];
                    }
                    acc[priceList.title].push(priceList);
                });
            }
            return acc;
        }, {});
    }

    ctrl.areAllLocationsSelected = function() {
        for (var location of ctrl.availableTargetLocations) {
            if (!location.selectedToSyncProducts) {
                return false;
            }
        }
        return true;
    }

    // Checks all price lists in availableTargetLocations
    ctrl.areAllPriceListsSelectedOnLocations = function() {
        for (var location of ctrl.availableTargetLocations) {
            if (Array.isArray(location.priceLists)) {
                for (var priceList of location.priceLists) {
                    if (!priceList.selectedToSyncProducts) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    // Checks the availablePriceLists map
    ctrl.areAllPriceListsSelected = function() {
        for (var priceListTitle of Object.keys(ctrl.availablePriceLists)) {
            var priceListsWithSameTitle = ctrl.availablePriceLists[priceListTitle];
            if (Array.isArray(priceListsWithSameTitle) && priceListsWithSameTitle.length) {
                if (!priceListsWithSameTitle[0].selectedToSyncProducts) {
                    return false;
                }
            }
        }
        return true;
    }

    ctrl.areAnyLocationsSelected = function() {
        for (var location of ctrl.availableTargetLocations) {
            if (location.selectedToSyncProducts) {
                return true;
            }
        }
        return false;
    }

    ctrl.areAnyPriceListsSelected = function() {
        for (var priceListTitle of Object.keys(ctrl.availablePriceLists)) {
            var priceListsWithSameTitle = ctrl.availablePriceLists[priceListTitle];
            if (Array.isArray(priceListsWithSameTitle) && priceListsWithSameTitle.length) {
                if (priceListsWithSameTitle[0].selectedToSyncProducts) {
                    return true;
                }
            }
        }
        return false;
    }

    // Checks if any locations are selected, or if any price lists on any locations are selected.
    ctrl.areAnyOptionsSelected = function() {
        if (ctrl.areAnyLocationsSelected()) return true;
        else {
            for (var location of ctrl.availableTargetLocations) {
                if (Array.isArray(location.priceLists)) {
                    for (var priceList of location.priceLists) {
                        if (priceList.selectedToSyncProducts) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    }

    // Checks for any selected price lists on a specific location
    ctrl.areAnyPriceListsSelectedForLocation = function(location) {
        if (Array.isArray(location.priceLists)) {
            for (var priceList of location.priceLists) {
                if (priceList.selectedToSyncProducts) {
                    return true;
                }
            }
        }   
        return false;
    }

    // Case 3: If location is selected, the first plist will be selected as a default and the others will be de-selected.
    ctrl.selectPriceLists = function(location) {
        if (Array.isArray(location.priceLists) && location.priceLists.length) {
            location.priceLists.forEach(function(priceList, index) {
                priceList.selectedToSyncProducts = location.selectedToSyncProducts && !index;
            });
        }
    }

    // Case 2: price list input is bound to first price list in list.
    // This replicates the changes on all other price lists in the list.
    ctrl.propagateToAllSimilarPriceLists = function(priceListTitle) {
        if (ctrl.availablePriceLists[priceListTitle]) {
            ctrl.availablePriceLists[priceListTitle].forEach(function(priceList, index) {
                if (index) {
                    priceList.selectedToSyncProducts = ctrl.availablePriceLists[priceListTitle][0].selectedToSyncProducts;
                }
            });
        }
    }

    // The order in which the options are displayed.
    // Does not correspond to the actions/case numbering.
    ctrl.getDisplayOptions = function() {
        var options = [
            ['All Locations', 'All Menus'],
            ['Specific Locations', 'All Menus']
        ];
        if (ENV.enablePriceList) {
            options.splice(1, 0, ['All Locations', 'Specific Menus']);
            options.push(['Specific Locations', 'Specific Menus']);
        }
        return options;
    }

    // action indexes
    // Cases [2,3] apply when price lists are enabled.
    ctrl.getActions = function() {
        return [
            ['All Locations', 'All Menus'],
            ['Specific Locations', 'All Menus'],
            ['All Locations', 'Specific Menus'],
            ['Specific Locations', 'Specific Menus']
        ];
    }

    ctrl.getActionFromMessage = function(message) {
        var actions = ctrl.actions;
        var actionsLength = actions.length;
        for (var i = 0; i < actionsLength; i++) {
            if (globalFunctions.areEqualObjects(message, actions[i])) {
                return i;
            }
        }
        return -1;
    }

    // Allows us to manipulate the order of the options without changing the switch/action flow in several functions.
    // Ex. Message 'All Loc, All PL' may route to Action 2 if we change the order here
    ctrl.assignActionToMessage = function(message) {
        var actions = ctrl.actions;
        actions.forEach(function(action, index) {
            if (globalFunctions.areEqualObjects(action, message)) {
                ctrl.selectedAction = index;
            }
        });
    }
}
hsApp.component('tabItem', {
    restrict: 'E',
    transclude: true,
    templateUrl: '/partials/components/tab-item.html',
    require: {
        tabListCtrl: '^tabList',
    },
    controllerAs: 'ctrl',
    bindings: {
        heading: '@',
        active: '<',
        disabled: '<',
    },

    controller: TabItemController,
});

function TabItemController() {
    var ctrl = this;
    var tabListCtrl;

    ctrl.$onInit = function () {
        tabListCtrl = ctrl.tabListCtrl;
        ctrl.active = Boolean(ctrl.active);
        ctrl.disabled = Boolean(ctrl.disabled);
        tabListCtrl.addTab(ctrl);
    };
}

hsApp.component('tabList', {
    restrict: 'E',
    transclude: true,
    templateUrl: '/partials/components/tab-list.html',
    bindToController: true,
    controllerAs: 'ctrl',
    bindings: {
        scrollOnClick: '&'
    },
    controller: TabListController,
});

function TabListController() {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.tabs = [];
    };

    ctrl.addTab = function addTab(tab) {
        ctrl.tabs.push(tab);
    };

    ctrl.selectTab = function (selectedTab) {
        if (selectedTab.disabled) {
            return;
        }

        if (!selectedTab.active) {
            ctrl.scrollOnClick({ container: '.TabList', section: selectedTab.heading });
        }

        for (var i = 0; i < ctrl.tabs.length; ++i) {
            var tab = ctrl.tabs[i];
            tab.active = tab === selectedTab;
        }
    };
}

hsApp.component('tableSideError', {
    templateUrl: '/partials/components/table-side-error.html',
    controller: [tableSideErrorController],
});

function tableSideErrorController() {}

hsApp.component('tableSidePartySize', {
    templateUrl: '/partials/components/table-side-party-size.html',
    bindings: {
        admin: '<',
        order: '<',
        onClose: '&',
    },
    controller: ['hsAdmin', 'VALIDATORS', 'toastr', 'ENV', partySizeController],
});


function partySizeController(hsAdmin, VALIDATORS, toastr, ENV) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.validationRules = VALIDATORS.TIP;
        ctrl.partySize = ctrl.order && ctrl.order.partySize ? ctrl.order.partySize : 1;
        ctrl.error = '';
    };

    ctrl.update = function() {
        ctrl.error = '';

        if (ctrl.partySizeForm.validate()) {
            if (ctrl.order) {
                var data = {
                    key: ctrl.order.key,
                    partySize: parseInt(ctrl.partySize),
                };

                hsAdmin.updateOrderDetails({ order: data })
                    .then(function(res) {
                        if (res.status === 200) {
                            toastr.success('Updated party size.');
                            ctrl.onClose({ updatedOrder: res.data });
                            return;
                        }
                        void 0;
                        ctrl.error = 'Failed to update party size.';
                        toastr.error(ctrl.error);
                    })
                    .catch(function(err) {
                        void 0;
                        ctrl.error = 'Something whent wrong.';
                        toastr.error(ctrl.error);
                    });
            } else {
                ctrl.onClose({ partySize: ctrl.partySize });
            }
        }
    };
}

hsApp.component('hsTip', {
    templateUrl: '/partials/components/tip.html',
    bindings: {
        order: '<',
        onClose: '&',
        onOrderUpdate: '&',
    },
    controller: ['$scope', 'toastr', 'hsAdmin', '$http', 'ENV', tipController],
});


function tipController($scope, toastr, hsAdmin, $http, ENV) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.tipLockedMessage = '';
        ctrl.tipSelection = [];
        ctrl.currentOrderTip = ctrl.order.tip ? ctrl.order.tip : 0;
        ctrl.newOrderTotal = ctrl.order.total;
        ctrl.customTip = {
            displayValue: 'Other',
            value: typeof ctrl.currentOrderTip === 'number' ? ctrl.currentOrderTip : parseFloat((ctrl.order.subTotal * 15 / 100).toFixed(2)),
        };

        for (var tip of [15, 18, 21]) {
            ctrl.tipSelection.push({
                displayValue: tip + '%',
                value: parseFloat((ctrl.order.subTotal * tip / 100).toFixed(2)),
            });
        }
        ctrl.tipSelection.push(ctrl.customTip);
        ctrl.selectedTip = ctrl.customTip.value ? ctrl.customTip : ctrl.tipSelection[0];
        ctrl.adjustTipValue(ctrl.selectedTip);

        if (ctrl.order.userTipUpdateLocked) {
            ctrl.getTipLockedMessage();
        }
    };

    ctrl.selectTip = function(tip) {
        ctrl.selectedTip = tip;
        ctrl.adjustTipValue(tip);
    };

    ctrl.adjustTipValue = function(tip) {
        var value = !isNaN(tip.value) ? tip.value : 0;
        ctrl.newOrderTotal = ctrl.order.total - ctrl.currentOrderTip + value;
    };

    ctrl.addTip = function() {
        var data = {
            order: {
                key: ctrl.order.key,
                tip: parseFloat(!isNaN(ctrl.selectedTip.value) ? ctrl.selectedTip.value.toFixed(2) : 0),
            }
        };

        hsAdmin.updateOrderDetails(data)
            .then(function(res) {

                if (res.status === 200) {
                    ctrl.onOrderUpdate({ order: res.data });
                    toastr.success('Updated Tips Successfully.');
                    return ctrl.onClose();
                }

                toastr.error('Error Updating Tips.');
                ctrl.error = 'Error Updating Tips.';
            });
    };

    ctrl.skip = function() {
        ctrl.onClose();
    };

    ctrl.getTipLockedMessage = function() {
        var defaultMessage = 'If you would like to change the tip, please ask your server to do so before you pay for the order.';

        $http.get(ENV.apiEndPoint + '/location')
            .then(function(res) {
                if (res.status === 200 && res.data && res.data.tableSideMandatoryTip && Array.isArray(res.data.tableSideMandatoryTip)) {
                    var mandatoryTips = res.data.tableSideMandatoryTip;
                    mandatoryTips.sort(function(a, b) { return b.partySize - a.partySize; });
                    var tip = mandatoryTips.find(function(tip) { return tip.partySize <= ctrl.order.partySize; });

                    if (tip) {
                        ctrl.tipLockedMessage = 'For a group of ' + tip.partySize + ' or more, a '
                            + tip.percent + '% mandatory gratuity is automatically added.';
                    }
                }
                if (!ctrl.tipLockedMessage) {
                    ctrl.tipLockedMessage = defaultMessage;
                }
            })
            .catch(function(err) {
                void 0;
                ctrl.tipLockedMessage = defaultMessage;
            });
    };

}

hsApp.component('upcScanner', {
    templateUrl: '/partials/components/upc-scanner.html',
    bindings: {
        targetUpc: '<',
        item: '<',
        onClose: '&',
        scannerType: '<',
    },
    controller: ['$scope', 'hsCart', 'hsUpc', 'ENV', 'scannerUtils', upcScannerController],
});

function upcScannerController($scope, hsCart, hsUpc, ENV, scannerUtils) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.found = false;
        ctrl.itemsScanned = 0;
        ctrl.totalPrice = 0;
        ctrl.mismatch = false;
        ctrl.showManualInput = false;
        ctrl.manualInputUPC = '';
        ctrl.targetQty = 0;
        ctrl.isRandomWeightItem = false;
        ctrl.scannerTypes = scannerUtils.getAvailableBarcodeScanners();
        ctrl.zebraBarcode = '';

        if (!ctrl.scannerType) {
            ctrl.scannerType = scannerUtils.getDefaultBarcodeScanner();
        }

        if (ctrl.item && ctrl.item.unit) {
            ctrl.isRandomWeightItem = hsUpc.isRandomWeightProductUpc(ctrl.item.upc);

            if (ctrl.isRandomWeightItem && (ctrl.item.sellByQty || ctrl.item.unit !== 'lb')) {
                ctrl.targetQty = ctrl.item.quantity;
            }
        }
        ctrl.start();
    };

    ctrl.initDynamsoftScanner = function () {
        // initializes and uses the library
        Dynamsoft.DBR.BarcodeScanner.createInstance().then(function (scanner) {
            scanner.updateVideoSettings({ video: {width: {ideal: 700}, height: {ideal: 700}, facingMode: {ideal: 'environment'}} });
            scanner.getRuntimeSettings()
                .then(function(settings) {
                    settings.region = {
                        regionLeft: 5,
                        regionTop: 25,
                        regionRight: 95,
                        regionBottom: 75,
                        regionMeasuredByPercentage: 1
                    };
                    scanner.updateRuntimeSettings(settings);
                });
            scanner.setUIElement(document.getElementById('scanner-container-wrapper'))
                .then(function() {
                    scanner.bPlaySoundOnSuccessfulRead = "unduplicated";
                    scanner.bVibrateOnSuccessfulRead = "unduplicated";
                    scanner.onUnduplicatedRead = function (txt, result) {
                        $scope.$apply(function() {
                            var barcodeText = result.barcodeText;

                            if (result.barcodeFormatString === 'CODE_128' && ctrl.isRandomWeightItem) {
                                barcodeText = ctrl.convertCODE128ToEAN13ScaleItem(result.barcodeText);
                                void 0;
                            }
                            ctrl.processResult(barcodeText);
                            ctrl._scannerIsRunning = false;
                        });
                        scanner.pauseScan();
                    };
                    return scanner.show();
                })
                .then(function() {
                    $scope.$apply(function() { ctrl._scannerIsRunning = true; });
                })
                .catch(function(err) {
                    void 0;
                    ctrl.close({
                        result: 'unsupported',
                    });
                });
            
            ctrl.scanner = scanner;
        });
    };

    ctrl.convertCODE128ToEAN13ScaleItem = function(barcodeText) {
        // sample: "0100000000063549392212068"
        //
        //  01000000000 63549 3922 12068
        //   ^ don't      ^    ^     ^
        //     know      upc   ?    price

        var price = barcodeText.slice(-5);
        var upc = '02' + barcodeText.slice(-14, -9);
        //         ^
        // EAN13 is the easiest to way
        // to read a price over $99.99.

        return upc + price + '0';
        //                    ^
        //            Need to add a placeholder
        //            for a check digit.
    };

    ctrl.keypressHandler = function(e) {
        if(ctrl._scannerIsRunning) {
            if (e.key === '#') {
                ctrl.processResult(ctrl.zebraBarcode);
                ctrl.zebraBarcode = '';
                ctrl._scannerIsRunning = false;
                $scope.$apply();
            } else {
                ctrl.zebraBarcode += e.key;
            }
        }
    };

    ctrl.initZebraScanner = function() {
        ctrl._scannerIsRunning = true;
        document.addEventListener('keypress', ctrl.keypressHandler);
    };

    ctrl.start = function() {
        if (ctrl.scannerType === ctrl.scannerTypes.ZEBRA) {
            ctrl.initZebraScanner();
        } else {
            ctrl.initDynamsoftScanner();
        }
    };

    ctrl.stopDynamesoftScanner = function() {
        ctrl.scanner.destroy();
        ctrl._scannerIsRunning = false;
    };

    ctrl.stopZebraScanner = function() {
        document.removeEventListener('keypress', ctrl.keypressHandler);
        ctrl._scannerIsRunning = false;
    };

    ctrl.stop = function() {
        void 0;
        if (ctrl.scannerType === ctrl.scannerTypes.ZEBRA) {
            ctrl.stopZebraScanner();
        } else {
            ctrl.stopDynamesoftScanner();
        }
    };

    ctrl.resetScanner = function() {
        ctrl.stop();
        ctrl.start();
    };

    ctrl.skip = function() {
        if (ctrl.isRandomWeightItem) {
            if (!ctrl.targetQty && ctrl.itemsScanned || ctrl.targetQty && ctrl.targetQty <= ctrl.itemsScanned) {
                return ctrl.close({
                    result: 'done',
                    quantity: ctrl.itemsScanned,
                    total: ctrl.totalPrice,
                });
            }
            return ctrl.close({
                result: 'cancel',
            });
        }
        if (ctrl.mismatch) {
            return ctrl.close({
                result: 'mismatch',
            });
        }
        ctrl.close({
            result: 'skip',
        });
    };

    ctrl.rescan = function() {
        ctrl.result = {};
        ctrl.processedResult = null;
        ctrl.found = false;
        ctrl.mismatch = false;
        ctrl.showManualInput = false;
        ctrl.error = '';

        if (!ctrl._scannerIsRunning) {
            if (ctrl.scannerType === ctrl.scannerTypes.DYNAMSOFT) {
                ctrl.scanner.resumeScan();
            }
            setTimeout(function() {
                $scope.$apply(function() {
                    ctrl._scannerIsRunning = true;
                });
            }, 0);
        }
    };

    ctrl.processResult = function(result, manual) {
        void 0;
        ctrl.processedResult = result;

        if (ctrl.targetUpc) {
            if (ctrl.isUpcMatch(result)) {
                ctrl.found = true;
                ctrl.mismatch = false;
                ctrl.error = '';

                if (ctrl.isRandomWeightItem) {
                    var price = hsUpc.getPriceFromRandomWeightUpc(result);
                    void 0;
                    if (!price) {
                        ctrl.error = 'Invalid price in the UPC.';
                        return;
                    }
                    ctrl.itemsScanned++;
                    ctrl.totalPrice += price;
                    ctrl.showManualInput = false;

                    if (ctrl.targetQty && ctrl.targetQty <= ctrl.itemsScanned) {
                        ctrl.close({
                            result: 'done',
                            quantity: ctrl.itemsScanned,
                            total: ctrl.totalPrice,
                        });
                        return;
                    }
                } else {
                    ctrl.close({
                        result: 'match',
                    });
                }
            } else {
                ctrl.mismatch = true;
                if (manual) {
                    ctrl.error = 'Entered UPC is not a match.';
                }
            }
        } else {
            ctrl.close({
                result: ctrl.processedResult,
            });
        }
    };

    ctrl.isUpcMatch = function(upc) {
        return hsUpc.matchUpc(upc, ctrl.targetUpc);
    };

    ctrl.$onDestroy = function() {
        ctrl.stop();
    };

    ctrl.getProductDisplayName = function() {
        return hsCart.getProductDisplayName(ctrl.item);
    }

    ctrl.getRescanButtonText = function() {
        if (ctrl.isRandomWeightItem && !ctrl.mismatch) {
            return ctrl.targetQty ? 'Scan Next' : 'Scan Another?';
        }
        return 'Rescan';
    };

    ctrl.getSkipScanButtonText = function() {
        if (ctrl.isRandomWeightItem) {
            if (!ctrl.targetQty && ctrl.itemsScanned || ctrl.targetQty && ctrl.targetQty <= ctrl.itemsScanned) {
                return 'Done';
            }
            return 'Cancel';
        }
        if (!ctrl.targetUpc) {
            return 'Skip Scan';
        }
        return ENV.packerRequiredToInputUpc ? 'Manual Entry' : 'Skip Scan';
    };

    ctrl.processManualInputUPC = function() {
        if (!hsUpc.isValidUPC(ctrl.manualInputUPC)) {
            void 0
            ctrl.error = 'Entered invalid UPC.';
            return;
        }
        ctrl.processResult(ctrl.manualInputUPC, true);
    };

    ctrl.close = function(value) {
        ctrl.onClose({ value: value });
    };

}

hsApp.component('updateDateTime', {
    templateUrl: '/partials/components/update-date-time.html',
    bindings: {
        order: '<',
        admin: '<',
        enableCustomFulfillmentTimes: '<',
        onClose: '&',
    },
    controller: ['$scope', 'toastr', 'hsAdmin', 'hsCart', 'hsUtils', updateDateTimeController],
});

function updateDateTimeController($scope, toastr, hsAdmin, hsCart, hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.dates = [];
        ctrl.times = [];
        ctrl.selectedDate = '';
        ctrl.selectedTime = '';
        ctrl.activeIdx = 0;
        ctrl.customDateTime = {
            fulfillmentDate: '',
            fulfillmentTime: '',
            setDate: function(date) {
                void 0;
                ctrl.customDateTime.fulfillmentDate = date;
            },
            setTime: function(time) {
                void 0;
                ctrl.customDateTime.fulfillmentTime = time;
            },
            canUpdateDateTime: function() {
                var fulfillmentTimeSelected = hsUtils.isNonEmptyString(ctrl.customDateTime.fulfillmentTime.hour)
                    && hsUtils.isNonEmptyString(ctrl.customDateTime.fulfillmentTime.minute)
                    && hsUtils.isNonEmptyString(ctrl.customDateTime.fulfillmentTime.meridian);

                return ctrl.customDateTime.fulfillmentDate && fulfillmentTimeSelected;
            },
            updateDateTime: function() {
                ctrl.selectedDate = hsUtils.getDateString(ctrl.customDateTime.fulfillmentDate);
                ctrl.selectedTime = Number(ctrl.customDateTime.fulfillmentTime.hour)
                    + ':' + ctrl.customDateTime.fulfillmentTime.minute + ctrl.customDateTime.fulfillmentTime.meridian

                ctrl.sendUpdateDateTime();
            }
        };
        ctrl.fulfillmentDate = {
			model: '',
			format: 'MM-dd-yyyy',
			opened: false,
			dateOptions: {
				showWeeks: false,
				formatYear: 'yy',
				maxDate: new Date(),
				minDate: new Date(),
				startingDay: 1,
				showClear: false,
				dateDisabled: function(data) {
					
					var date = data.date;
					var dateObj = {
						date: date.getDate(),
						month: date.getMonth(),
						year: date.getFullYear()
					};

					var dateAvailable = ctrl.dates.filter(function(preference) {
						if (dateObj.date === preference.date && dateObj.month === (preference.monthNum - 1) && dateObj.year == preference.year) {
							return preference;
						}
					})
					
					return !dateAvailable.length;
				  },
			},
		};

        if (!hsUtils.isBoolean(ctrl.enableCustomFulfillmentTimes)) {
            ctrl.enableCustomFulfillmentTimes = false;
        }

        hsAdmin.getOrderSlots(ctrl.order.key).then(function (res) {
            if (res.status === 200) {
                ctrl.selectedDate = ctrl.order.deliveryDate;
                ctrl.selectedTime = ctrl.order.deliveryTime;
                var availableTimes = [];
                if (res.data) {
                    if (ctrl.order.fulfillmentMethod === 'delivery') {
                        availableTimes = res.data.delivery.availableTimes;
                    } else {
                        availableTimes = res.data.pickup.availableTimes;
                    }
                }

                availableTimes.forEach(function (date) {
                    if (Array.isArray(date.timeSlots) && date.timeSlots.length > 0){
                        if (!ctrl.admin) {
                            date.timeSlots = hsCart.filterTimeSlots(date.timeSlots, ctrl.getProductsWithAvailableTimes(ctrl.order.items));
                        }

                        if (date.timeSlots.length > 0) {
                            ctrl.dates.push(date);
                        }
                    }
                });

                if (ctrl.order.isAdvancedOrder) {
                    ctrl.initDatePicker()
                }
                ctrl.updateTimes();
            }
        });
    };

    ctrl.initDatePicker = function() {
        var currentDate = new Date(ctrl.selectedDate);
        ctrl.fulfillmentDate.model = currentDate;

        if (Array.isArray(ctrl.dates) && ctrl.dates.length) {
            var firstDate = ctrl.dates[0];
            var lastDate = ctrl.dates[ctrl.dates.length - 1];
            var firstDateObj = new Date(firstDate.year, firstDate.monthNum - 1, firstDate.date);
            var lastDateObj = new Date(lastDate.year, lastDate.monthNum - 1, lastDate.date);
            
            
            ctrl.fulfillmentDate.dateOptions.minDate = firstDateObj;
            ctrl.fulfillmentDate.dateOptions.maxDate = lastDateObj;
        }
    };

    ctrl.showDatePicker = function() {
        return ctrl.order.isAdvancedOrder;
    };

    ctrl.openFulfillmentDatePicker = function() {
        ctrl.fulfillmentDate.opened = !ctrl.fulfillmentDate.opened;
    };

    ctrl.selectDeliveryDate = function (dateString) {
        if (ctrl.order.isAdvancedOrder) {
            var date = ctrl.fulfillmentDate.model
			dateString = hsUtils.getDateString(date);
        }

        ctrl.selectedDate = dateString;
        ctrl.updateTimes();
        ctrl.selectedTime = '';
    };

    ctrl.selectDeliveryTime = function (time) {
        ctrl.selectedTime = time;
    };

    ctrl.updateTimes = function () {
        
        var found = false;
        ctrl.dates.forEach(function (date, index) {
            if (ctrl.selectedDate === date.dateString) {
                ctrl.times = date.timeSlots;
                found = true;
                date.checked = true;
                ctrl.activeIdx = index;

                if (!ctrl.order.isAdvancedOrder) {
                    setTimeout(function() {
                        ctrl.scrollToElement();
                    }, 0);
                }
                
            } else {
                date.checked = false;
            }
        });

        if (!found) {
            ctrl.selectedDate = ctrl.dates[0].dateString;
            ctrl.times = ctrl.dates[0].timeSlots;
            ctrl.selectedTime = ctrl.dates[0].timeSlots[0];
            ctrl.dates[0].checked = true;
        }
    };

    ctrl.sendUpdateDateTime = function () {
        if (ctrl.selectedTime === '') {
            toastr.error('Please select a time slot');
        } else {
            var data = {
                key: ctrl.order.key,
                deliveryDate: ctrl.selectedDate,
                deliveryTime: ctrl.selectedTime,
            };
            hsAdmin
                .updateOrderDetails({ order: data })
                .then(function (res) {
                    if (res.status === 200) {
                        toastr.success('Update Date and Time Successfully');
                        ctrl.onClose();
                        return;
                    }
                    toastr.error('Something went wrong. Please try again.');
                })
                .catch(function (err) {
                    void 0;
                    toastr.error('Something went wrong.');
                });
        }
    };

    ctrl.getProductsWithAvailableTimes  = function (products) {
        var validProducts = [];
        products.forEach (function (product) {
            if (Array.isArray(product.availableTimes) && product.availableTimes.length > 0) {
                validProducts.push(product);
            }
        });
        return validProducts;
    }

    ctrl.scrollToElement = function () {
        document.getElementById(ctrl.activeIdx).scrollIntoView();
    }
}

hsApp.component('hsUser', {
    templateUrl: '/partials/components/user-permissions.html',
    bindings: {
        user: '<',
        onClose: '&',
    },
    controller: ['toastr', 'hsAdmin', 'hsUtils', '$scope', '$timeout', hsUserController],
});

function hsUserController(toastr, hsAdmin, hsUtils, $scope, $timeout) {
    var ctrl = this;
    ctrl.$onInit = function () {
        void 0;
        ctrl.sections = {
            USER_DETAILS: 'user-details',
            ADMIN_PERMISSIONS: 'admin-permissions',
        };
        ctrl.userDetailsSections = {
            NAME: 'name',
            PHONE_NUMBER: 'phone-number',
            DELIVERY_ADDRESS: 'delivery-address',
            PERMISSIONS: 'permissions',
            LOCATION_PERMISSIONS: 'location-permissions'
        };
        ctrl.validationRules = {
            name: {
                rules: {
                    firstName: {
                        required: true
                    },
                    lastName: {
                        required: true
                    }
                },
                messages: {
                    firstName: {
                        required: 'Please enter first name'
                    },
                    lastName: {
                        required: 'Please enter last name'
                    }
                }
            },
            phoneNumber: {
                rules: {
                    phoneNumber: {
                        required: true,
                        phoneUS: true
                    },
                },
                messages: {
                    phoneNumber: {
                        required: 'Please enter a phone number',
                        phoneUS: 'Please enter a valid phone number'
                    },
                }
            },
            deliveryAddress: {
                rules: {},
                messages: {},
            },
        };
        ctrl.editing = null;
        ctrl.currentSection = ctrl.sections.USER_DETAILS;
        ctrl.emptyAddress = {
            street: '',
            aptUnit: '',
            city: '',
            state: '',
            zip: '',
        };
        ctrl.user.address = ctrl.emptyAddress;
        ctrl.userStats = ctrl.user.stats || {};
        ctrl.enableHouseCharge = false;
        ctrl.blockedUser = false;
        ctrl.enabledPermissions = [];
        ctrl.permissions = [];        
        ctrl.allowedLocations = {};
        ctrl.allLocationPriceListsSelected = false;
        ctrl.initUpdateParams();
        ctrl.initUserPermissions();
    };

    ctrl.initUpdateParams = function () {
        ctrl.updateParams = {};
    };

    ctrl.initEnabledPermissions = function() {
        ctrl.enabledPermissions = [];
        for (var permission of ctrl.permissions) {
            if (permission.value) {
                ctrl.enabledPermissions.push(permission.displayName)
            }
        }
    };

    ctrl.initAllowedLocations = function() {
        ctrl.uiPermissions.locations.forEach(function(location) {
            ctrl.allowedLocations[location.uniqueName] = {
                name: location.name,
                selected: location.selected,
                priceLists: {},
                open: false,
                disabled: location.disabled
            };

            location.priceLists.forEach(function(priceList) {
                ctrl.allowedLocations[location.uniqueName].priceLists[priceList.uniqueName] = {
                    name: priceList.name,
                    selected: priceList.selected,
                    disabled: priceList.disabled
                };
            });
        });
    };

    ctrl.initUserPermissions = function() {
        if (!ctrl.user) return;
        ctrl.isLoading = true;

        return hsAdmin.getUserDetails(ctrl.user.email, 'forUiPermissions=true')
            .then(function (res) {
                if (res.status === 200 && res.data) {
                    ctrl.uiPermissions = res.data.uiPermissions || {};
                    ctrl.permissions = ctrl.uiPermissions.permissions || [];
                    ctrl.user = res.data || {};
                    ctrl.enableHouseCharge = !!ctrl.user.enableHouseCharge;
                    ctrl.blockedUser = !ctrl.user.canPlaceOrder;
                    ctrl.initEnabledPermissions();
                    ctrl.initAllowedLocations();
                } else {
                    throw res;
                }
            })
            .catch(function (err) {
                toastr.error('Failed to get user details');
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.setNameUpdateParams = function () {
        ctrl.updateParams = {
            firstName: ctrl.user.firstName,
            lastName: ctrl.user.lastName,
        };
    };

    ctrl.setPhoneNumberUpdateParams = function () {
        ctrl.updateParams = {
            phoneNumber: ctrl.user.phoneNumber,
            phoneNumberVerified: true,
        };
    };

    ctrl.setAddressUpdateParams = function () {
        ctrl.updateParams = JSON.parse(JSON.stringify({
            address: ctrl.user.address || ctrl.emptyAddress,
        }));
    };

    ctrl.setPermissionsUpdateParams = function () {
        ctrl.updateParams = JSON.parse(JSON.stringify({
            permissions: ctrl.permissions
        }));
    };

    ctrl.setIndeterminate = function(locationUniqueName, priceLists) {
        var e = document.getElementById('location-' + locationUniqueName);
        if (!e) return;

        var selected;
        var notSelected;

        for(var priceListUniqueName of Object.keys(priceLists)) {
            var pl = priceLists[priceListUniqueName];
            if (pl.selected) {
                selected = true;
            } else {
                notSelected = true;
            }
        }
     
        if (selected && notSelected) { // Some selected
            e.indeterminate = true;
        } else if (selected && !notSelected) { // All selected
            e.indeterminate = false;
            ctrl.updateParams.allowedLocations[locationUniqueName].selected = true;
        } else { // None selected
            e.indeterminate = false;
            ctrl.updateParams.allowedLocations[locationUniqueName].selected = false;
        }
        ctrl.setAllLocationPriceListsSelected();
    };

    ctrl.setAllLocationPriceListsSelected = function () {
        var notSelectedFound = false;
        for (var locationUniqueName of Object.keys(ctrl.updateParams.allowedLocations)) {
            var location = ctrl.updateParams.allowedLocations[locationUniqueName];
            if (location.disabled) continue;
            Object.keys(location.priceLists).forEach(function(priceListUniqueName) {
                var priceList = location.priceLists[priceListUniqueName];
                if (!priceList.disabled && !priceList.selected) {
                    notSelectedFound = true;
                }
            });
        }
        ctrl.allLocationPriceListsSelected = !notSelectedFound;
    };

    ctrl.setAllowedLocationsUpdateParams = function () {
        ctrl.updateParams = JSON.parse(JSON.stringify({
            allowedLocations: ctrl.allowedLocations
        }));
        ctrl.setAllLocationPriceListsSelected();
        $timeout(function() {
            for (var locationUniqueName of Object.keys(ctrl.updateParams.allowedLocations)) {
                var priceLists = ctrl.updateParams.allowedLocations[locationUniqueName].priceLists;
                ctrl.setIndeterminate(locationUniqueName, priceLists);
            }
        }, 0);

    };

    ctrl.setUpdateParams = function(section) {
        ctrl.initUpdateParams();
        if (section === ctrl.userDetailsSections.NAME) {
            ctrl.setNameUpdateParams();
        } else if (section === ctrl.userDetailsSections.PHONE_NUMBER) {
            ctrl.setPhoneNumberUpdateParams();
        } else if (section === ctrl.userDetailsSections.DELIVERY_ADDRESS) {
            ctrl.setAddressUpdateParams();
        } else if (section === ctrl.userDetailsSections.PERMISSIONS) {
            ctrl.setPermissionsUpdateParams();
        } else if (section === ctrl.userDetailsSections.LOCATION_PERMISSIONS) {
            ctrl.setAllowedLocationsUpdateParams();
        }
    };

    ctrl.setEditing = function(section) {
        ctrl.editing = section;
        ctrl.setUpdateParams(section);
    };

    ctrl.switchTab = function(section) {
        ctrl.setEditing(null);
        ctrl.currentSection = section;
    };

    ctrl.cancel = function() {
        ctrl.setEditing(null);
    };

    ctrl.hasAllowedLocationsChanged = function() {
        var updateParams = ctrl.getLocationsPermissionsUpdateParams(ctrl.updateParams.allowedLocations);
        var existingParams = ctrl.getLocationsPermissionsUpdateParams(ctrl.allowedLocations);
        return !_.isEqual(updateParams, existingParams);
    }

    ctrl.hasUserPermissionsChanged = function() {
        return !_.isEqual(ctrl.updateParams.permissions, ctrl.permissions);
    }

    ctrl.hasChanged = function () {
        var existingParams = {};

        for (var param in ctrl.updateParams) {
            existingParams[param] = ctrl.user[param];
        }

        return !_.isEqual(ctrl.updateParams, existingParams);
    };

    ctrl.updateAddress = function() {
        $scope.$broadcast('validateAddress-admin-my-account-delivery', function(isValid) {
            if (!isValid) return;
            ctrl.updateUserDetails(null, true);
        });
    };

    ctrl.updateUserDetails = function(form, skipValidation) {
        if (skipValidation || form.validate()) {
            var params = {
                emailId: ctrl.user.email,
                userParams: {}
            };
    
            for (var key of Object.keys(ctrl.updateParams)) {
                params.userParams[key] = ctrl.updateParams[key];
            }

            ctrl.updateUser(params, 'User information updated')
                .finally(function() {
                    ctrl.isLoading = false;
                });
        }
    };

    ctrl.handleBlockUserUpdate = function(value) {
        var params = {
            emailId: ctrl.user.email,  
            canPlaceOrder: !value,
        };

        var successMessage = 'User ' + (params.canPlaceOrder ? 'unblocked' : 'blocked');

        ctrl.updateUser(params, successMessage)
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.handleEnableHouseChargeUpdate = function(value) {
        var params = {
            emailId: ctrl.user.email,  
            userParams: {
                enableHouseCharge: value
            }
        };

        var successMessage = 'House charges ' + (params.userParams.enableHouseCharge ? 'enabled' : 'disabled') + ' for user';

        ctrl.updateUser(params, successMessage)
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.getPermissionsUpdateParams = function() {
        var permissionUpdateParams = {};
        for (var permission of ctrl.updateParams.permissions) {
            permissionUpdateParams[permission.permission] = permission.value;
        }
        return permissionUpdateParams;
    };

    ctrl.updateUserPermissions = function() {
        var params = {
            emailId: ctrl.user.email
        };

        params.permissions = ctrl.getPermissionsUpdateParams();
        ctrl.updateUser(params, 'User permissions updated')
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.handleSelectAllLocationPriceLists = function(value) {
        for (var locationUniqueName of Object.keys(ctrl.updateParams.allowedLocations)) {
            var location = ctrl.updateParams.allowedLocations[locationUniqueName];
            if (location.disabled) continue;
            location.selected = value;
            Object.keys(location.priceLists).forEach(function(priceListUniqueName) {
                var priceList = location.priceLists[priceListUniqueName];
                if (!priceList.disabled) {
                    priceList.selected = value;
                }
            });

            ctrl.setIndeterminate(locationUniqueName, location.priceLists);
        }
        
        ctrl.allLocationPriceListsSelected = value;
    };

    ctrl.handlePriceListSelectionsByLabel = function(locationUniqueName, priceListUniqueName) {
        ctrl.updateParams.allowedLocations[locationUniqueName].priceLists[priceListUniqueName].selected = !ctrl.updateParams.allowedLocations[locationUniqueName].priceLists[priceListUniqueName].selected;
        $timeout(function() {
            var priceLists = ctrl.updateParams.allowedLocations[locationUniqueName].priceLists;
            ctrl.setIndeterminate(locationUniqueName, priceLists);
        }, 0);
    };

    ctrl.handleLocationSelectionsByLabel = function(locationUniqueName) {
        ctrl.updateParams.allowedLocations[locationUniqueName].selected = !ctrl.updateParams.allowedLocations[locationUniqueName].selected;
        ctrl.handlePriceListSelections(locationUniqueName);
        ctrl.updateParams.allowedLocations[locationUniqueName].open = ctrl.updateParams.allowedLocations[locationUniqueName].selected;
        $timeout(function() {
            var priceLists = ctrl.updateParams.allowedLocations[locationUniqueName].priceLists;
            ctrl.setIndeterminate(locationUniqueName, priceLists);
        }, 0);
    };

    ctrl.handlePriceListSelections = function(locationUniqueName) {
        var priceLists = ctrl.updateParams.allowedLocations[locationUniqueName].priceLists;
        ctrl.updateParams.allowedLocations[locationUniqueName].open = true;
        for(var priceListUniqueName of Object.keys(priceLists)) {
            var pl = priceLists[priceListUniqueName];
            if (pl.disabled) continue;
            pl.selected = ctrl.updateParams.allowedLocations[locationUniqueName].selected;
        }
        
        ctrl.setAllLocationPriceListsSelected();
    };

    ctrl.getLocationsPermissionsUpdateParams = function(allowedLocations) {
        var selectedLocations = {};

        for (var locationUniqueName of Object.keys(allowedLocations)) {
            var location = allowedLocations[locationUniqueName];
            var selectedPriceLists = [];
            for (var priceListUniqueName of Object.keys(location.priceLists)) {
                var priceList = location.priceLists[priceListUniqueName];
                if (priceList.selected) {
                    selectedPriceLists.push(priceListUniqueName);
                }
            }

            if (selectedPriceLists.length) {
                selectedLocations[locationUniqueName] = selectedPriceLists;
            }
        }
        return selectedLocations;
    }

    ctrl.updateAllowedLocations = function() {
        var params = {
            emailId: ctrl.user.email
        };
        
        params.locationsPermissions = ctrl.getLocationsPermissionsUpdateParams(ctrl.updateParams.allowedLocations);

        ctrl.updateUser(params, 'Location permissions updated')
            .finally(function() {
                ctrl.isLoading = false;
                if(ctrl.editing === ctrl.userDetailsSections.LOCATION_PERMISSIONS) {
                    $timeout(function() {
                        for (var locationUniqueName of Object.keys(ctrl.updateParams.allowedLocations)) {
                            var priceLists = ctrl.updateParams.allowedLocations[locationUniqueName].priceLists;
                            ctrl.setIndeterminate(locationUniqueName, priceLists);
                        }
                    }, 0);
                }
            });
    };

    ctrl.updateUser = function(updateParams, successMessage) {
        ctrl.isLoading = true;
        var errorMessage = 'Something went wrong. Please try again.';
        return hsAdmin.updateUser(updateParams)
            .then(function (res) {
                if (res.status === 200) {
                    return ctrl.initUserPermissions()
                        .then(function() {
                            if (successMessage) {
                                toastr.success(successMessage);
                            } else {
                                toastr.success('User information updated');
                            }
                            ctrl.setEditing(null);
                            return;
                        });
                } else if (res.status === 403) {
                    if (hsUtils.isObject(res.data) && hsUtils.isNonEmptyString(res.data.message)) {
                        errorMessage = res.data.message;    
                    } else {
                        errorMessage = 'Unauthorized access';
                    }
                    toastr.error(errorMessage);
                } else {
                    toastr.error(errorMessage);
                }
            })
            .catch(function (err) {
                toastr.error(errorMessage);
            });
    };

    ctrl.toggleAdminPermission = function($index) {
        ctrl.updateParams.permissions[$index].value = !ctrl.updateParams.permissions[$index].value;
    }

    ctrl.hasPermissionDescription = function($index) {
        return hsUtils.isNonEmptyString(ctrl.updateParams.permissions[$index].description);
    };

    ctrl.hasLocationPermissions = function() {
        for (var locationUniqueName of Object.keys(ctrl.allowedLocations)) {
            var location = ctrl.allowedLocations[locationUniqueName];
            if (location.selected) {
                return true;
            }
        }
        return false;
    };

    ctrl.toggleLocationDropdown = function(uniqueName) {
        ctrl.updateParams.allowedLocations[uniqueName].open = !ctrl.updateParams.allowedLocations[uniqueName].open;
    };

    ctrl.getUserFullName = function() {
        return ctrl.user.firstName + ' ' + ctrl.user.lastName;
    };

    ctrl.getDeliveryAddressDisplayStringLine1 = function() {
        if (!hsUtils.isObject(ctrl.user) || !hsUtils.isObject(ctrl.user.address)) {
            return '';
        }

        var address = ctrl.user.address;
        return address.street + (address.aptUnit ? ', ' + address.aptUnit : '');
    };

    ctrl.getDeliveryAddressDisplayStringLine2 = function() {
        if (!hsUtils.isObject(ctrl.user) || !hsUtils.isObject(ctrl.user.address)) {
            return '';
        }

        var address = ctrl.user.address;
        return address.city + ', ' + address.state + ' ' + address.zip;
    };

    ctrl.getDisplayDate = function(date) {
        if (hsUtils.isNonEmptyString(date)) {
            return hsUtils.getDateString(new Date(date));
        }
        return '-';
    };

    ctrl.getPriceListCountString = function(priceLists) {
        var count = 0;
        for (var pl of Object.keys(priceLists)) {
            if (priceLists[pl].selected) {
                count++;
            }
        }  
        return count + ' Selected';
    };
}

hsApp.component('verifyUpc', {
    templateUrl: '/partials/components/verify-upc.html',
    bindings: {
        targetUpc: '<',
        onClose: '&',
    },
    controller: ['hsUpc', 'VALIDATORS', verifyUpcController],
});


function verifyUpcController(hsUpc, VALIDATORS) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.error = '';
        ctrl.upcInput = null;
        ctrl.validationRules = VALIDATORS.UPC;

        if (!ctrl.targetUpc) {
            ctrl.onClose();
        }
    };

    ctrl.verify = function() {
        ctrl.error = '';
        if (ctrl.upcForm.validate()) {
            var match = ctrl.matchUpc();
            if (match) {
                return ctrl.onClose({ value: 'match' });
            } else {
                ctrl.error = 'UPC/PLU doesn\'t match. Please make sure you are packing the correct item.';
            }
        }
    };

    ctrl.matchUpc = function() {
        return hsUpc.matchUpc(ctrl.upcInput, ctrl.targetUpc);
    };
}

hsApp.directive('yesNoButton', function() {
	return {
		restrict: 'E',
		scope: {
			model: '=',
			name: '@',
            size: '@',
            btnType: '@',
            handleClick: '&',
            disabled: '<',
            onChange: '&',
		},
        templateUrl: "/partials/components/yes-no-button.html",
        controller: ["$scope", function($scope) {
            $scope.btnType = $scope.btnType || 'primary';
        }]
	};
});

hsApp.controller('headerFooterCtrl',['$scope','$rootScope','$sce','$location','toastr','hsAuth', 'ngDialog','localStorageService','ENV','$http', 'hsPickingApp', '$route', 'globalFunctions', 'hsUtils', '$window', '$timeout',
    function($scope, $rootScope, $sce, $location, toastr, hsAuth, ngDialog, localStorageService, ENV, $http, hsPickingApp, $route, globalFunctions, hsUtils, $window, $timeout){
    
    $scope.header = {
        config                      : {
            location : $location.path()
        },
		searchQuery: '',
		showAccountSettingsSlider: false,
		showMegaMenuSlider: false,
		categoryGrid: [],
		megaMenuSlider: {
			activeMenus: {},
			hideMegaMenuSliderButton: function() {
				return ENV.showAllProducts && !(ENV.showOrderPage && !ENV.showProductsPage) && $scope.header.config.location.indexOf('/products') === -1;
			},
			toggleMegaMenuSlider: function() {
				$scope.header.showMegaMenuSlider = !$scope.header.showMegaMenuSlider;
				var megaMenuSlider = $('#mega-menu-slider');
				var width;
				if ($rootScope.screenWidth.xs) {
					width = '80vw'
				} else {
					width = '50vw'	
				}
				$timeout(function() {
					if ($scope.header.showMegaMenuSlider) {
						megaMenuSlider.css({
							"width": width
						});
						document.getElementById('mobile-mega-menu-scroll-container').scrollTop = 0;
						$('#homesome-body-container').addClass('overflow-hidden');
					} else {
						megaMenuSlider.css({
							"width": '0'
						})
						$('#homesome-body-container').removeClass('overflow-hidden');
					}
				}, 0);
				$scope.header.megaMenuSlider.clearActiveMenus();
			},
			handleCategorySelection: function(cat) {
				if (ENV.showAllProducts && !(ENV.showOrderPage && !ENV.showProductsPage)) {
					$scope.header.scrollTo(cat);
					$scope.header.megaMenuSlider.toggleMegaMenuSlider();
				} else if (ENV.showOrderPage && !ENV.showProductsPage) {
					$scope.header.redirectUserToPath('/products?category=' + cat);
				} else {
					$scope.header.megaMenuSlider.toggleActiveMenu(cat);
				}
			},
			toggleActiveMenu: function(cat) {
				if (!$scope.header.megaMenuSlider.activeMenus.hasOwnProperty(cat)) {
					$scope.header.megaMenuSlider.activeMenus[cat] = true;
				} else {
					$scope.header.megaMenuSlider.activeMenus[cat] = !$scope.header.megaMenuSlider.activeMenus[cat];
				}
			},
			clearActiveMenus: function() {
				$scope.header.megaMenuSlider.activeMenus = {};
			},
			shouldAddBorder: function(idx) {
				if (!hsUtils.isObject($rootScope.allProducts)) return false;
				return idx < Object.keys($rootScope.allProducts).length - 1;
			}
		},
	    getTransparentHeader() {
        	return ($rootScope.ENV.enableTransparentHeader && $location.path() === '/');
	    },
		setSearchQuery() {
			var searchTerm = $location.search().item;
			if(searchTerm){
				$scope.header.searchQuery = searchTerm;
			}
		},
		initHeaderAnimation() {
			/*
				The header contains 3 divs
				1) Containing the logo, user, location and cart 
				2) Containing search bar
				3) [screenWidth.xs only] Containing location

				These are refered to as upper, middle and lower sections in description below
			*/
			
			var lastScrollTop = 0; // Denotes how far the user has scrolled
			var maxHeight = -64; // Max pixels outside of the screen the header should move
			var currTop = 0; // Top pixel of upper section of the header (1)
			var currLocTop = 125; // Top pixel of lower section of header (3)

			// On scroll, set didScroll to true
			$(window).scroll(function(event){
				hasScrolled();
			});

			function hasScrolled() {
				var st = $(window).scrollTop(); // Current pixel on top of page
				var pixelsScrolled = Math.abs(lastScrollTop - st);

				/* This section is applicable to mobile devices only
				* When a user scrolls up quickly, the webpage bounces (goes a few pixels below the top and then goes back up) when it reaches the end
				* This causes the header to roll up even though the user has not scrolled. Value of st is <0 when this happens
				*/

				if (st < 0 ) {
					currTop = 0;
					currLocTop = 125;
					return;
				}

				if (st > lastScrollTop) { // Scroll down
					currTop -= (pixelsScrolled/2);
					if (currTop <= maxHeight) {
						currTop = maxHeight;
					}

					currLocTop -= pixelsScrolled;
					if (currLocTop < 16) {
						currLocTop = 16;
					}

				} else { // scrollup
					currTop += (pixelsScrolled/2);
					currLocTop += pixelsScrolled;
					if (currTop > 0) {
						currTop = 0;
					}

					if (currLocTop > 125) {
						currLocTop = 125;
					}
				}

				$('nav').css({
					top: currTop + 'px'		
				});

				$('#location-container').css({
					top: (currLocTop) + 'px'		
				});

				lastScrollTop = st;
			}
		},
		categoryCount: 0,
		subCategoryCount: 0,
		setCategoryCount: function() {
			$scope.header.categoryCount = 0;
			$scope.header.subCategoryCount = 0;
			
			if (!$rootScope.allProducts) {
				return;
			}

			for (var categoryKey of Object.keys($rootScope.allProducts)) {
				var category = $rootScope.allProducts[categoryKey];
				$scope.header.categoryCount += 1;
				if (hsUtils.isObject(category.categories)){
					if(category.categories.hasOwnProperty('All')) {
						$scope.header.subCategoryCount += (Object.keys(category.categories).length - 1);
					} else {
						$scope.header.subCategoryCount += Object.keys(category.categories).length;
					}
				}
			}
		},
		selectedVal: null,		
		initCategoryWatcher: function() {
			$scope.$watch('$root.allProducts', function () {
				if (!$rootScope.fullListLoaded) return;
				if (!$rootScope.allProducts) return;

				if (ENV.showOrderPage && !ENV.showProductsPage) {
					$scope.header.selectedVal = $location.search().category || '';
				} else {
					$scope.header.selectedVal = Object.keys($rootScope.allProducts)[0];
				}
				
				$scope.header.setCategoryCount();
				$scope.header.setMegaMenuStyle();
				$scope.header.setCategorySeperators();
			});
		},
		megaMenuOptionsContainerId: 'mega-menu-options-container-id',
		megaMenuContainerId: 'mega-menu-container-id',
		megaMenuScrollContainerId: 'mega-menu-scroll-container-id',
		setCategorySeperators: function() {
			if (!$rootScope.allProducts) {
				return;
			}
			var containerDiv = $('#' + $scope.header.megaMenuOptionsContainerId);
			if (!hsUtils.isObject(containerDiv)) return;
			for (var category of Object.keys($rootScope.allProducts)) {
				var categoryElem = document.getElementById('hr-' + category);
				if (!hsUtils.isObject(categoryElem)) continue;
				if (hsUtils.isNumber(categoryElem.offsetTop) && categoryElem.offsetTop > containerDiv.offset().top) {
					categoryElem.classList.add('option-border-top');
				} else {
					categoryElem.classList.remove('option-border-top');
				}
			}
		},
		setMegaMenuStyle: function() {
			var columnCountToBgStyles = {
				1: {
					"background": "none"
				},
				2: {
					"background": "linear-gradient( to right, #fff 50%, #F9F9F9 50%)"
				},
				3: {
					"background": "linear-gradient( to right, #fff 33.33%, #F9F9F9 33.33% 66.67%, #fff 66.67%)"
				},
				4: {
					"background": "linear-gradient( to right, #fff 25%, #F9F9F9 25% 50%, #fff 50% 75%, #F9F9F9 75%)"
				},
				5: {
					"background": "linear-gradient( to right, #fff 20%, #F9F9F9 20% 40%, #fff 40% 60%, #F9F9F9 60% 80%, #fff 80%)"
				},
			};

			var columnCountToWidth= {
				1: {
					"max-width": "25vw"
				},
				2: {
					"max-width": "50vw"
				},
				3: {
					"max-width": "80vw"
				},
				4: {
					"max-width": "80vw"
				},
				5: {
					"max-width": "80vw"
				},
			};

			if ($scope.header.categoryCount + $scope.header.subCategoryCount > 70 ) {
				$('#' + $scope.header.megaMenuOptionsContainerId).css({
					'column-count': Math.min($scope.header.categoryCount, 5),
				});

				$('#' + $scope.header.megaMenuScrollContainerId).css(columnCountToBgStyles[Math.min($scope.header.categoryCount, 5)]);
				$('#' + $scope.header.megaMenuContainerId).css(columnCountToWidth[Math.min($scope.header.categoryCount, 5)]);
			} else if ($scope.header.categoryCount + $scope.header.subCategoryCount > 50) {
				$('#' + $scope.header.megaMenuOptionsContainerId).css({
					'column-count': Math.min($scope.header.categoryCount, 4),
				});
				$('#' + $scope.header.megaMenuScrollContainerId).css(columnCountToBgStyles[Math.min($scope.header.categoryCount, 4)]);
				$('#' + $scope.header.megaMenuContainerId).css(columnCountToWidth[Math.min($scope.header.categoryCount, 4)]);
			} else if ($scope.header.categoryCount + $scope.header.subCategoryCount > 30) {
				$('#' + $scope.header.megaMenuOptionsContainerId).css({
					'column-count': Math.min($scope.header.categoryCount, 3),
				});
				$('#' + $scope.header.megaMenuScrollContainerId).css(columnCountToBgStyles[Math.min($scope.header.categoryCount, 3)]);
				$('#' + $scope.header.megaMenuContainerId).css(columnCountToWidth[Math.min($scope.header.categoryCount, 3)]);
			} else if ($scope.header.categoryCount + $scope.header.subCategoryCount > 10) {
				$('#' + $scope.header.megaMenuOptionsContainerId).css({
					'column-count': Math.min($scope.header.categoryCount, 2),
				});
				$('#' + $scope.header.megaMenuScrollContainerId).css(columnCountToBgStyles[Math.min($scope.header.categoryCount, 2)]);
				$('#' + $scope.header.megaMenuContainerId).css(columnCountToWidth[Math.min($scope.header.categoryCount, 2)]);
			} else {
				$('#' + $scope.header.megaMenuOptionsContainerId).css({
					'column-count': 1,
				});
				$('#' + $scope.header.megaMenuScrollContainerId).css(columnCountToBgStyles[1]);
				$('#' + $scope.header.megaMenuContainerId).css(columnCountToWidth[1]);
			}
		},
		showMegaMenu: function() {
			return ($scope.header.categoryCount + $scope.header.subCategoryCount) > 2
				&& $rootScope.screenWidth.lg
				&& (!ENV.showAllProducts && !(ENV.showOrderPage && !ENV.showProductsPage))
				&& $rootScope.fullListLoaded;
		},
		scrollTo: function(section){
			globalFunctions.scrollToElement('#' + section, 170);
		},
		initMegaMenu: function() {
			if (!$rootScope.fullListLoaded) return;
			$scope.header.setCategoryCount();
			$scope.header.setMegaMenuStyle();
			$('document').ready(function() {
				$scope.header.setCategorySeperators();
				document.getElementById($scope.header.megaMenuScrollContainerId).scrollTop = 0;
			});
		
		},
		selectClosestCategory: function() {
			if (!$rootScope.allProducts) return;
			for(var category of Object.keys($rootScope.allProducts)) {
				setSelected(category);
			}

			function setSelected(category) {
				var scrollTop     = $(window).scrollTop();

				if (!category) return;
				var element = document.getElementById(category);
				if (!element || !element.offsetTop) return;
				var elementOffset = element.offsetTop;
				var distanceFromTop = (elementOffset - scrollTop);

				$rootScope.allProducts[category].distanceFromTop = distanceFromTop;

				var minVal = Infinity; // stores distance of element closest to top of screen and inside viewport
				var maxVal = -Infinity // stores distance of element closest to top of screen and outside (above) viewport
				var minCategory = null; // stores category name closest to top of screen and inside viewport
				var maxCategory = null; // stores category name closest to top of screen and outside (above) viewport

				Object.keys($rootScope.allProducts).forEach(function(cat) {
					var data = $rootScope.allProducts[cat];
					if (
						!isNaN(Number(data.distanceFromTop))
						&& data.distanceFromTop >= 0 
						&& data.distanceFromTop < minVal 
						&& data.distanceFromTop <= window.innerHeight
					) {
						minVal = data.distanceFromTop;
						minCategory = cat;
					} else if (
						!isNaN(Number(data.distanceFromTop))
						&& data.distanceFromTop < 0 
						&& data.distanceFromTop > maxVal 
					) {
						maxVal = data.distanceFromTop;
						maxCategory = cat;
					}
				});
				
				if (hsUtils.isNonEmptyString(minCategory)) {
					$scope.header.selectedVal = minCategory;
				} else if (hsUtils.isNonEmptyString(maxCategory)){
					$scope.header.selectedVal = maxCategory;
				}
			}
		},
		initScrollBarAnimation: function() {
			$(window).scroll(function(event){
				$scope.header.selectClosestCategory();
			});
		},
        init                        : function () {
            if (ENV.enableLocations) {
                var location = localStorageService.get('location');
                if(location){
                	if(!location.allLocations){
                		$scope.header.updateLocation();
	                }
                    $rootScope.$broadcast('locationUpdated');
                }
            }

	        $rootScope.$on('locationUpdate', function (event, data) {
	        	void 0;
	        	if (data) {
	        		if (data.location) {
	        			$rootScope.location = data.location;
			        }
	        		if (data.priceList) {
	        			$rootScope.selectedPriceList = data.priceList;
			        }
		        }
	        });

			$scope.header.setSearchQuery();

			if (!$rootScope.screenWidth.lg) {
				$scope.header.initHeaderAnimation();
			} 

			$scope.header.initScrollBarAnimation();
			$scope.header.initCategoryWatcher();

			$('#mega-menu-dropdown').on('show.bs.dropdown', function () {
				$('#homesome-body-container').addClass('overflow-hidden');
			})

			$('#mega-menu-dropdown').on('hide.bs.dropdown', function () {
				$('#homesome-body-container').removeClass('overflow-hidden');
			})
        },
	    updateLocation              : function () {
        	if($location.url().indexOf('admin') === -1 && !$rootScope.tableSideOrder) {
		        $scope.runUpdate = false;
		        ngDialog.open({
			        template    : 'partials/popup/select-location.html',
			        controller  : 'ModalController',
			        className   : 'ngdialog-theme-default email-capture',
			        showClose   : true,
			        closeByDocument: false,
			        closeByEscape: true,
			        closeByNavigation: true,
			        scope       : $scope
		        }).closePromise.then(function () {
                    $rootScope.globalFunctions.disablePriceListSelector();
                });
	        }
        },
	    updatePriceList              : function () {
        	if($location.url().indexOf('admin') === -1){
		        $scope.runUpdate = false;
		        ngDialog.open({
			        template    : 'partials/popup/select-price-list.html',
			        controller  : 'ModalController',
			        className   : 'ngdialog-theme-default email-capture',
			        showClose   : true,
			        closeByDocument: false,
			        closeByEscape: true,
			        scope       : $scope
		        });
	        }
        },
        logout                      : function () {
            hsAuth.logoutUser(null, false, true);
			$scope.header.showAccountSettingsSlider = false;
        },
        showNotificationCarousel    : function () {
            ngDialog.open({
                template    : 'partials/popup/announcement-popup.html',
                controller  : 'ModalController',
                closeByDocument : false,
                className   : 'ngdialog-theme-default email-capture'
            });
        },
        closeNotificationBar        : function () {
        	sessionStorage.setItem('hideNotification', true);
            $rootScope.globalNotification.show = false;
        },
        showHeader: function() {
            if (!$rootScope.currentLocation) {
                return true;
            }

            return !hsPickingApp.isWrapped() || $rootScope.currentLocation.indexOf('/admin/order') !== 0;
        },
		handleScrollbarSelection: function(section) {
			if (ENV.showAllProducts && !(ENV.showOrderPage && !ENV.showProductsPage)) {
				$scope.header.scrollTo(section);
			} else if (ENV.showOrderPage && !ENV.showProductsPage) {
				$scope.header.redirectUserToPath('/products?category=' + section);
			}
		},
		showCategoryScrollBar: function() {
			return $rootScope.screenWidth.lg 
				&& (ENV.showAllProducts || (ENV.showOrderPage && !ENV.showProductsPage))
				&& ($scope.header.config.location.indexOf('/search') !== -1
				|| $scope.header.config.location.indexOf('/products') !== -1
				|| $scope.header.config.location.indexOf('/order') !== -1)
				&& !$scope.header.megaMenuSlider.hideMegaMenuSliderButton();
		},
		redirectUserToPath: function(path) {
			if ($rootScope.onAdminPage && path.indexOf('/admin') === -1) return;
			$location.url(path);
		},
		setSearchQuery: function(searchTerm) {
			$scope.header.searchQuery = searchTerm;
		},
		search: function(value) {
			var searchTerm = value;
			var url = new URL('/search', window.location.origin);
			url.searchParams.append('item', searchTerm);
			if (ENV.showOrderPage && !ENV.showProductsPage) {
				url.searchParams.append('orderView', true);
			}
			$scope.header.redirectUserToPath(url.pathname + url.search);
			$route.reload();
		},
		toggleAccountSettingsSlider: function() {
			$scope.header.showAccountSettingsSlider = !$scope.header.showAccountSettingsSlider;
		}
    };

    $rootScope.$on("$routeChangeSuccess", function(event, next, current) {
        $scope.header.config.location = $location.path();
		$scope.header.showAccountSettingsSlider = false;
		if ($scope.header.showMegaMenuSlider) {
			$scope.header.megaMenuSlider.toggleMegaMenuSlider();
		}
    });
}]);

angular.module('homesome.factories').factory('hsLocationSettings', [
    '$http',
    'ENV',
    'hsUtils',
    '$location',
    '$rootScope',
    'localStorageService',
    'hsAdmin',
    'ngDialog',
    'toastr',
    locationSettingsService
]);

function locationSettingsService($http, ENV, hsUtils, $location, $rootScope, localStorageService, hsAdmin, ngDialog, toastr) {
    var service = {
        locationData: null,
        priceListsData: null,
        descriptions: {},
        DEFAULT_DRAWER: 'settings',
        availableViews: {
            ABOUT: 'about',
            ADDRESS: 'address',
            CONTACT: 'contact',
            FEES: 'fees',
            FEATURES: 'features',
            PICKING: 'picking',
            ABOUT_PRICELIST: 'about-pricelist',
            CHECKOUT_PRICELIST: 'checkout-pricelist',
            PICKUP: 'pickup',
            DELIVERY: 'delivery',
            PROCESSING: 'processing',
            FEATURES_PRICELIST: 'features-pricelist'
        },
        errorMessages: {
            LOAD_ERROR: 'Failed to load location settings.',
            GENERIC_ERROR: 'Failed to update location. Please try again or contact support.',
            INVALID_SETTING_DETECTED: 'Invalid settings detected. Please contact support.',
            OVERLAPPING_SLOTS: 'Overlapping slots found.',
        },
        priceListTypes: {
            PREORDER: 'preorder',
            CATERING: 'catering',
        },
        fulfillmentTypes: {
            PICKUP: 'pickup',
            DELIVERY: 'delivery',
            MANAGED_DELIVERY: 'managedDelivery',
        },
        setLocationData: function() {
            return $http.get(ENV.apiEndPoint + '/location/settings')
                .then(function(resp) {
                    service.initData(resp.data);
                })
                .catch(function(err) {
                    throw err;
                })
        },
        initData: function(data) {
            service.locationData = data.settings;
            service.priceListsData = data.settings.priceLists;
            service.descriptions = data.descriptions || {};
        },
        updateLocationImage: function(imageFormData){
            var apiUrl = ENV.apiEndPoint + '/image?type=location';

            return $http.post(apiUrl, imageFormData, {
                transformRequest: angular.identity,
                headers: {'Content-Type': undefined}
            })
            .then(function(response) {
                if (response.status !== 200) {
                    throw response.data;
                }
                return response.data;
            })
        },
        saveSettings: function(params, selectedPriceList) {
            void 0;

            if (params.hasOwnProperty('priceList')) {
                if (!selectedPriceList || !selectedPriceList.uniqueName) {
                    return Promise.reject('Invalid parameters supplied.');
                }
                params.priceList.uniqueName = selectedPriceList.uniqueName;
            }
            var url = new URL('/location/settings', ENV.apiEndPoint);
            var headers = {
                location: service.locationData.uniqueName,
            };
            return $http.put(url.toString(), params, { headers: headers })
                .then(function(response) {
                    if(response.status !== 200) {
                        throw response.data;
                    }
                    service.initData(response.data);

                    // running detached from update, so save operation will return faster
                    service.updateLocations();
                })
                .catch(function(err) {
                    void 0;
                    throw hsUtils.getMessageFromError(err, 'Failed to save settings.');
                });
        },
        updateLocations: function() {
            return $http.get(ENV.apiEndPoint + '/locations')
                .then(function(res) {
                    if(res.status !== 200) throw 'Failed to get locations.';

                    var selectedLocation = res.data.find(function (loc) {
                        return loc.uniqueName === service.locationData.uniqueName;
                    });
                    if (!selectedLocation) throw 'Failed to match location.';

                    var locationData = {
                        allLocations: res.data,
                        selectedLocation: selectedLocation,
                    };
                    localStorageService.set('location', locationData);

                    if (ENV.enablePriceList) {
                        localStorageService.set('selectedPriceList', {
                            uniqueName: selectedLocation.priceLists[0].uniqueName
                        });
                    }
                    $rootScope.$emit('locationUpdated');
                })
                .catch(function(err) {
                    throw hsUtils.getMessageFromError(err, 'Failed to set location.');
                });
        },
        omitRecursiveCheckFields: [
            'address',
            'fromEmail',
            'orderCutoff',
            'deliveryProviderConfigs',
            'volumeLimits',
            'slotsOverrides',
            'dailySlotsOverrides'
        ],
        customCopy: function(source) {
            var destination = Array.isArray(source) ? [] : {};
            
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    if (source[key] instanceof File) {
                        // Directly copy the File object
                        destination[key] = source[key];
                    } else if (typeof source[key] === 'object' && source[key] !== null) {
                        // Recursively copy other objects
                        destination[key] = service.customCopy(source[key]);
                    } else {
                        // Directly copy primitive values
                        destination[key] = source[key];
                    }
                }
            }
            
            return destination;
        },
        getSettingsChanges: function(original, updated) {
            original = service.customCopy(original); // Need to remove angular hash keys before comparing
            updated = service.customCopy(updated);
            var changed = {};
            var keys = new Set(Object.keys(original));

            for (var key of Object.keys(updated)) {
                keys.add(key);
            }
            for (var fieldName of keys) {
                var valO = original[fieldName];
                var valU = updated[fieldName];
                
                if (_.isEqual(valO, valU)) continue;

                if (!hsUtils.isObject(valO)) {
                    changed[fieldName] = valU;
                    continue;
                }

                if (service.omitRecursiveCheckFields.includes(fieldName)) {
                    changed[fieldName] = valU;
                    continue;
                }

                var changesObj = service.getSettingsChanges(valO, valU);

                if (Object.keys(changesObj).length) {
                    changed[fieldName] = changesObj;
                }
            }
            return changed;
        },
        hasDescription: function(key) {
            return !!service.getDescription(key);
        },
        getDescription: function(key) {
            if (!hsUtils.isNonEmptyString(key)) return '';

            return service.descriptions[key] || '';
        },
        showDescription: function(key, fieldName) {
            var description = service.getDescription(key);
            ngDialog.openConfirm({
                data: {
                    heading: fieldName || '',
                    subHeading: description,
                    confirmBtnText: 'OK',
                },
                template: 'partials/popup/confirm-popup.html'
            }).then(function() {});
        },
        isUserAllowed: function() {
            return $rootScope.loggedIn && $rootScope.currentUser.isAdmin && !$rootScope.currentUser.isAdminRestricted;
        },
        redirectUser: function() {
            if (!$rootScope.loggedIn) {
                if (Object.keys($location.search()).length) {
                    var routeParams = $location.search();
                    routeParams.multipleParams = true;
                    routeParams.urlPath = $location.path();

                    $location.path('/login').search(routeParams);
                } else {
                    $location.url('/login?redirect=' + $location.path());
                }
            } else if (!$rootScope.currentUser.isAdmin) {
                $location.url('/');
            } else if ($rootScope.currentUser.isAdminRestricted) {
                $location.url('/admin/manager-dashboard');
            }
        },
        isHomesomeAccount: function() {
            return hsAdmin.isHomesomeAccount();
        },
        isPreorder: function(priceList) {
            return hsUtils.isObject(priceList) && priceList.type === service.priceListTypes.PREORDER;
        },
        isCatering: function(priceList) {
            return hsUtils.isObject(priceList) && priceList.type === service.priceListTypes.CATERING;
        },
        isSamePriceList: function(pl1, pl2) {
            if (pl1 === null && pl2 === null) return true;
            if (hsUtils.isObject(pl1) !== hsUtils.isObject(pl2)) return false;

            return pl1.uniqueName === pl2.uniqueName;
        },
        sortDailySlots: function(slots) {
            return slots.sort(function(a, b) {
                if (a.startHour > b.startHour) return 1;
                if (a.startHour < b.startHour) return -1;

                if (a.startMin > b.startMin) return 1;
                if (a.startMin < b.startMin) return -1;

                if (a.closingHour > b.closingHour) return 1;
                if (a.closingHour < b.closingHour) return -1;

                if (a.closingMin > b.closingMin) return 1;
                if (a.closingMin < b.closingMin) return -1;

                return 0;
            });
        },
        sortSlots: function(slots) {
            return slots.sort(function(a, b) {
                var A = service.parseSlotString(a.displayName);
                var B = service.parseSlotString(b.displayName);

                if (A.startHour > B.startHour) return 1;
                if (A.startHour < B.startHour) return -1;

                if (A.startMin > B.startMin) return 1;
                if (A.startMin < B.startMin) return -1;

                if (A.endHour > B.endHour) return 1;
                if (A.endHour < B.endHour) return -1;

                if (A.endMin > B.endMin) return 1;
                if (A.endMin < B.endMin) return -1;

                return 0;
            });
        },
        parseSlotString: function(str) {
            var components = str.split('-');
            var start = components[0].trim();
            var end = components[1].trim();

            var startHour = service.getHoursFromString(start);
            var startMin = service.getMinutesFromString(start);
            var endHour = service.getHoursFromString(end);
            var endMin = service.getMinutesFromString(end);

            if (endHour === 0 && endMin === 0) {
                endHour = 24;
            }
            return {
                startHour: startHour,
                startMin: startMin,
                endHour: endHour,
                endMin: endMin,
            };
        },
        getHoursFromString: function(str) {
            if (str === 'Noon') return 12;
            if (str === 'Midnight') return 0;

            var period = str.endsWith('PM') ? 12 : 0;
            str = str.replace(/am|pm/i, '');

            var components = str.split(':');
            var hour = Number(components[0].trim());

            if (hour === 12) {
                hour = 0;
            }
            return hour + period;
        },
        getMinutesFromString: function(str) {
            if (str === 'Noon' || str === 'Midnight') return 0;

            str = str.replace(/am|pm/i, '');
            var minutes = str.split(':')[1];

            return !minutes ? 0 : Number(minutes.trim());
        },
    };
    return service;
}
angular.module('homesome.factories').factory('hsProduct', [
    hsProductService
]);

function hsProductService() {
    var service = {
        getLocationInStoreString: function(locationInStore) {
            var stringArray = [];
            if (locationInStore.aisle) {
                stringArray.push('Aisle: ' + locationInStore.aisle);
            }
            if (locationInStore.section) {
                stringArray.push('Section: ' + locationInStore.section);
            }
            if (locationInStore.shelf) {
                stringArray.push('Shelf: ' + locationInStore.shelf);
            }
            if (locationInStore.position) {
                stringArray.push('Position: ' + locationInStore.position);
            }
            var locationInStoreString = '';
            for (var i = 0; i < stringArray.length; i++) {
                locationInStoreString = locationInStoreString + stringArray[i];
                if(i !== stringArray.length-1) {
                    locationInStoreString = locationInStoreString + ' | ';
                }
            }
            return locationInStoreString;
        }
    };

    return service;
}
angular.module('homesome.factories').factory('hsAccountSettings', [ 
    accountSettingsService
]);

function accountSettingsService() {
    var service = {
        SECTIONS: {
            name: 'name',
            phoneNumber: 'phoneNumber',
            deliveryAddress: 'deliveryAddress',
            verifyPhoneNumber: 'verifyPhoneNumber',
            addPaymentMethod: 'addPaymentMethod',
            employeeID: 'employeeID'
        },
        PURPOSE: {
            updatePhoneNumber: 'updatePhoneNumber'
        },
        PAYMENT_METHOD_LOGO_MAP: {
            visa: 'visa.svg',
            mastercard: 'mastercard.svg',
            discover: 'discover.svg',
            dinersclub: 'dinersclub.svg',
            americanexpress: 'amex.svg',
            ebt: 'EBT.svg'
        }
    };
    return service;
}

hsApp.component('addressFormCa', {
    templateUrl: '/partials/components/address-forms/address-form-ca.html',
    bindings: {
        address: '<',
        validator: '<',
        isGoogleAddress: '<',
        styles: '<',
        eventName: '<',
        onIsGoogleAddressChange: '&',
        showV2: '<',
    },
    controller: [
        '$scope',
        'address',
        'hsUtils',
        '$timeout',
        addressFormCaController,
    ],
});


function addressFormCaController($scope, addressFac, hsUtils, $timeout) {
    var ctrl = this;
    var logPrefix = '[address-form-ca]: ';

    ctrl.addressAutoComplete = function (address) {
        // If the value of `street1` is not a string, it means that it is the object
        // reference as a result of the `ngAutocomplete` functionality, which means we
        // have to fill out the rest of the entity fields.
        
        if (hsUtils.isObject(address.street)) {
            var autoCompleteObject = address.street;
            // console.log(autoCompleteObject);
            var autoCompleteAddress = addressFac.getAutoCompleteAddressFromCa(autoCompleteObject);
            // console.log(autoCompleteAddress);
            ctrl.address.street = autoCompleteAddress.street1;
            ctrl.address.aptUnit = autoCompleteAddress.street2;
            ctrl.address.city = autoCompleteAddress.city;
            ctrl.address.state = autoCompleteAddress.province;
            ctrl.address.zip = autoCompleteAddress.zip;
            // unlock zip edit if invalid in Google
            ctrl.allowToEditZip = !ctrl.isValidZip(autoCompleteAddress.zip);
            ctrl.address.country = autoCompleteAddress.country;
            ctrl.hasSelectedAddress = true;
            ctrl.isFromGoogle = true;
            ctrl.onIsGoogleAddressChange({ isFromGoogle: ctrl.isFromGoogle });

            if (!ctrl.allowToEditZip && ctrl.needToClearInputError) {
                // If the previous address was invalid in Google, and now we have a valid one,
                // there may possible be an error in the input if it was invald.
                // The only way I could figure out how to clear it is by focusing on the input with a valid entry.
                ctrl.allowToEditZip = true;
                ctrl.needToClearInputError = false;

                $timeout(function () {
                    ctrl.addressForm.zip.$$element.focus();
                    ctrl.allowToEditZip = false;
                }, 0);
            }
            
            // Once autocomplete is done populating fields, focus on the Address 2 field
            // As street2 cannot be auto completed.
            // Putting it inside a TimeOut to ensure other events don't prevent this from happening
            setTimeout(function () {
                angular.element('#street2').focus();
            }, 50);
        } else if (ctrl.allowToEditZip) {
            // If the previous Google address was invalid, need to lock everything back up on user input.
            ctrl.address.zip = '';
            ctrl.allowToEditZip = false;
            ctrl.needToClearInputError = true;
        }
    };

    ctrl.isValidZip = function (zip) {
        var re = new RegExp('^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$');
        return re.test(zip);
    };

    ctrl.isValidAddress = function (address) {
        void 0;
        return addressFac.isValidAddress(address);
    };

    ctrl.$onInit = function () {
        ctrl.isFromGoogle = false;
        ctrl.hasSelectedAddress = false;
        ctrl.allowToEditZip = false;
        ctrl.needToClearInputError = false;

        void 0
        ctrl.validateAddressListener = $scope.$on(ctrl.eventName, function(_, cb) {
            void 0;
            var isValid = ctrl.addressForm.validate();
            if (ctrl.isGoogleAddress) {
                isValid = isValid && ctrl.isFromGoogle;
            }
            
            void 0;
            cb(isValid);
        });
        ctrl.hasOnInitRun = true;
    };

    ctrl.$onDestroy = function() {
        ctrl.validateAddressListener();
    }

    ctrl.handleKeyDown = function() {
        if (ctrl.isGoogleAddress && ctrl.hasSelectedAddress) {
            ctrl.isFromGoogle = false;
            ctrl.onIsGoogleAddressChange({isFromGoogle: ctrl.isFromGoogle});
        }
    }
}

hsApp.component('addressFormUs', {
    templateUrl: '/partials/components/address-forms/address-form-us.html',
    bindings: {
        address: '<',
        validator: '<',
        isGoogleAddress: '<',
        styles: '<',
        eventName: '<',
        onIsGoogleAddressChange: '&',
        showV2: '<',
    },
    controller: [
        '$scope',
        'address',
        'hsUtils',
        addressFormUsController,
    ],
});


function addressFormUsController($scope, addressFac, hsUtils) {
    var ctrl = this;
    var logPrefix = '[address-form-us]: ';

    ctrl.addressAutoComplete = function (address) {
        // If the value of `street1` is not a string, it means that it is the object
        // reference as a result of the `ngAutocomplete` functionality, which means we
        // have to fill out the rest of the entity fields.
        
        if (hsUtils.isObject(address.street)) {
            var autoCompleteObject = address.street;
            var autoCompleteAddress = addressFac.getAutoCompleteAddress(autoCompleteObject);
            ctrl.address.street = autoCompleteAddress.street1;
            ctrl.address.aptUnit = autoCompleteAddress.street2;
            ctrl.address.city = autoCompleteAddress.city;
            ctrl.address.state = autoCompleteAddress.state;
            ctrl.address.zip = autoCompleteAddress.zip;
            ctrl.address.country = autoCompleteAddress.country;
            ctrl.hasSelectedAddress = true;
            ctrl.isFromGoogle = true;
            ctrl.onIsGoogleAddressChange({ isFromGoogle: ctrl.isFromGoogle });
            
            // Once autocomplete is done populating fields, focus on the Address 2 field
            // As street2 cannot be auto completed.
            // Putting it inside a TimeOut to ensure other events don't prevent this from happening
            setTimeout(function () {
                angular.element('#street2').focus();
            }, 0);
        }
    };

    ctrl.isValidAddress = function (address) {
        void 0;
        return addressFac.isValidAddress(address);
    };

    ctrl.$onInit = function () {
        ctrl.isFromGoogle = false;
        ctrl.hasSelectedAddress = false;
        void 0
        ctrl.validateAddressListener = $scope.$on(ctrl.eventName, function(_, cb) {
            void 0;
            var isValid = ctrl.addressForm.validate();
            if (ctrl.isGoogleAddress) {
                isValid = isValid && ctrl.isFromGoogle;
            }
            
            void 0;
            cb(isValid);
        });
        ctrl.hasOnInitRun = true;
    };

    ctrl.$onDestroy = function() {
        ctrl.validateAddressListener();
    }

    ctrl.handleKeyDown = function() {
        if (ctrl.isGoogleAddress && ctrl.hasSelectedAddress) {
            ctrl.isFromGoogle = false;
            ctrl.onIsGoogleAddressChange({isFromGoogle: ctrl.isFromGoogle});
        }
    }
}

hsApp.component('addressForm', {
    templateUrl: '/partials/components/address-forms/address-form.html',
    bindings: {
        address: '<',
        isGoogleAddress: '<',
        showXsForm: '<',
        id: '<',
        showV2: '<',
        country: '<',
    },
    controller: [
        '$scope',
        '$rootScope',
        'address',
        'VALIDATORS',
        addressFormController,
    ],
});

var FORM_STYLES = {
    default: {
        street1: 'col-sm-8 col-xs-12',
        aptUnit: 'col-sm-4 col-xs-12',
        city: 'col-sm-4 col-xs-6',
        state: 'col-sm-4 col-xs-6',
        zip: 'col-sm-4 col-xs-6',
    },
    xs: {
        street1: 'col-xs-12',
        aptUnit: 'col-xs-12',
        city: 'col-xs-12',
        state: 'col-xs-6',
        zip: 'col-xs-6',
    },
};

var EVENT_NAME = 'validateAddress';

function addressFormController($scope, $rootScope, addressFac, VALIDATORS) {
    var ctrl = this;
    ctrl.hasOnInitRun = false;
    var logPrefix = '[address-form]: ';

    ctrl.isValidAddress = function (address) {
        return addressFac.isValidAddress(address);
    };

    ctrl.$onInit = function () { 
        if (!ctrl.country) {
            ctrl.country = $rootScope.country;
        }
        void 0;
        void 0;
        void 0;
        void 0
        ctrl.isGoogleAddress = !!ctrl.isGoogleAddress;
    
        ctrl.validator = VALIDATORS.ADDRESS[ctrl.country.toUpperCase()];
        if (!ctrl.validator) {
            void 0
        } else {
            void 0
        }

        ctrl.id = ctrl.id || '';

        ctrl.styles = FORM_STYLES.default;
        if (ctrl.showXsForm) {
            ctrl.styles = FORM_STYLES.xs;
        }

        ctrl.address._isValid = ctrl.isValidAddress(ctrl.address);
        ctrl.hasOnInitRun = true;
        void 0;
        ctrl.validateAddressListener = $scope.$on(EVENT_NAME + '-' + ctrl.id, function(_, cb) {
            void 0;
            $scope.$broadcast(ctrl.getBroadcastEventName(), function(isValid) {
                if (!isValid && ctrl.isGoogleAddress) {
                    ctrl.failedGoogleMapsReq = true;
                }
                cb(isValid);
            });
        });
    }

    ctrl.onIsGoogleAddressChange = function(isFromGoogle) {
        void 0;
        if (ctrl.isGoogleAddress) {
            ctrl.failedGoogleMapsReq = !isFromGoogle;
        }
    }

    ctrl.getBroadcastEventName = function() {
        return [EVENT_NAME, ctrl.country, ctrl.id].join('-');
    }

    ctrl.$onChanges = function (changesObj) {
        if (!ctrl.hasOnInitRun) {
            return;
        }
        
        if (changesObj.address) {
            ctrl.hasAddress = ctrl.isValidAddress(ctrl.address);
            ctrl.address = Object.assign(ctrl.address, { country: ctrl.country });
        }
    };

    ctrl.$onDestroy = function() {
        ctrl.validateAddressListener();
    }
}

hsApp.component('loyaltyDashboards', {
    templateUrl: '/partials/components/admin-loyalty-dashboard/loyalty-dashboard.html',
    bindings: {
        type : '@'
    },
    controller: [ '$location', 'hsUtils', 'hsApi', '$sce', loyaltyDashboardController ],
});

function loyaltyDashboardController($location, hsUtils, hsApi, $sce) {
    var ctrl = this;
    var logPrefix = '[loyaltyDashboardController]';
    ctrl.DASHBOARD_TYPES = {
        ELECTRONIC_JOURNAL: 'electronicJournal',
        LOYALTY_ANALYTICS: 'loyaltyAnalytics',
    };

    ctrl.TITLE = {};
    ctrl.TITLE[ctrl.DASHBOARD_TYPES.ELECTRONIC_JOURNAL] = 'Electronic Journal';
    ctrl.TITLE[ctrl.DASHBOARD_TYPES.LOYALTY_ANALYTICS] = 'Loyalty Analytics';

    ctrl.$onInit = function () {

        ctrl.isLoading = true;
        ctrl.error = null;
        ctrl.source = null;

        if (!ctrl.type) {
            ctrl.goBack();
        }

        hsApi.getLocations(true)
            .then(function(res) {
                var locations = res.data;

                // any location will work since config is the same at every location
                var location = locations[0];

                if (!hsUtils.isObject(location)) {
                    throw 'Failed to load locations';
                }

                ctrl.validateConfig(location.loyaltyDashboardConfig);

                ctrl.source = ctrl.getSource(location.loyaltyDashboardConfig);
            })
            .catch(function(err) {
                void 0;
                ctrl.error = 'Failed to load page. Please try again or contact support';
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.validateConfig = function(config) {
        if (!hsUtils.isNonEmptyObject(config)) {
            throw 'Invalid config: expected object';
        }
        if (!hsUtils.isNonEmptyString(config.domain)) {
            throw 'Invalid config: missing or invalid domain';
        }
        if (!hsUtils.isNonEmptyObject(config.dashboardIds) || !hsUtils.isNonEmptyString(config.dashboardIds[ctrl.type])) {
            throw 'Invalid config: missing or invalid dashboard id';
        }
    };

    ctrl.getSource = function(config) {
        var url = 'https://' + config.domain + '/app/dashboards?auth_provider_hint=anonymous1#/view/'
            + config.dashboardIds[ctrl.type] + '?embed=true&_g=()&show-time-filter=true&hide-filter-bar=true&_a=(filters:!())';
        return $sce.trustAsResourceUrl(url);
    };

    ctrl.goBack = function() {
        $location.url('/admin/loyalty-dashboards');
    }

    ctrl.getDashboardTitle = function() {
        return ctrl.TITLE[ctrl.type];
    }

    ctrl.getPageWrapperStyles = function() {
        return 'full-width';
    }

}
hsApp.component('addItemsToOrder', {
    templateUrl: '/partials/components/admin-order-v2/add-items-to-order.html',
    bindings: {
        isQuote: '<',
    },
    controller: [ '$scope', '$location', '$q', 'hsAdminOrder', 'hsUtils', 'hsSearch', 'NgTableParams', 'hsCart', 'ngDialog', 'toastr', 'hsPromos', addItemsToOrderController ],
});

function addItemsToOrderController($scope, $location, $q, hsAdminOrder, hsUtils, hsSearch, NgTableParams, hsCart, ngDialog, toastr, hsPromos) {
    var ctrl = this;
    var logPrefix = '[addItemsToOrder]:';

    ctrl.$onInit = function () {
        void 0;

        if (!hsAdminOrder.isFiltersSelectionComplete(ctrl.isQuote)) {
            $location.url(ctrl.getBaseUrl());
            return;
        }
        ctrl.pageLoading = true;
        ctrl.customItemLoading = false;
        ctrl.error = null;
        ctrl.searchInput = '';
        ctrl.productList = [];
        ctrl.searchResults = [];
        ctrl.searchInitialized = false;
        ctrl.ngTableParams = null;
        ctrl.tableLoading = false;
        ctrl.basket = null;
        ctrl.basketItemsIndex = {};
        ctrl.pastOrders = [];
        ctrl.showPastOrders = false;
        ctrl.pastOrdersInitialized = false;
        ctrl.user = hsAdminOrder.getSelectedUser();
        $q.all([ctrl.initializeProductList(), ctrl.setBasket()])
            .finally(function() {
                ctrl.createTable(ctrl.productList);
                ctrl.pageLoading = false;
            });

        $scope.forUserAddItemsCtrl = ctrl;

        hsPromos.getOngoingPromotions(ctrl.user, false, null, hsAdminOrder.getHeaders())
            .catch(function (err) {
                void 0;
            });

        $('#admin-order-custom-item').on('hidden.bs.modal', function (e) {
            ctrl.addingCustomItem = false;
            $scope.$apply();
        });
    }
    
    ctrl.initializeProductList = function() {
        return hsAdminOrder.getProductList()
            .then(function(products) {
                if (hsUtils.isNonEmptyArray(products)) {
                    ctrl.productList = products; 
                } else {
                    ctrl.productList = [];
                    ctrl.error = "Failed to load page. Please try again or contact support";
                    toastr.error("No Products Found");
                }
            })
            .catch(function(err) {
                ctrl.productList = [];
                toastr.error(hsUtils.getMessageFromError(err));
                ctrl.error = "Failed to load page. Please try again or contact support";
            });
    }

    ctrl.setBasket = function() {
        return hsAdminOrder.getUserCart()
            .then(function (res) {
                void 0;
                ctrl.basket = res;
                ctrl.setBasketItemsIndex();
            })
            .catch(function (err) {
                toastr.error(hsUtils.getMessageFromError(err));
                ctrl.error = "Failed to load page. Please try again or contact support";
            });
    };

    ctrl.setBasketItemsIndex = function() {
        if (!ctrl.basket || !ctrl.basket.basketItems) {
            ctrl.basketItemsIndex = {};
        }
        for (var basketItem of ctrl.basket.basketItems) {
            if (ctrl.basketItemsIndex.hasOwnProperty(basketItem.name)) {
                ctrl.basketItemsIndex[basketItem.name].push(JSON.parse(JSON.stringify(basketItem)));
            } else {
                ctrl.basketItemsIndex[basketItem.name] = [JSON.parse(JSON.stringify(basketItem))];
            }
        }
    }

    ctrl.getBasketItemQuantity = function(item) {
        var quantity = 0;
        if (!item || !item.name || !ctrl.basketItemsIndex.hasOwnProperty(item.name)) {
            return quantity;
        }
        for (var basketItem of ctrl.basketItemsIndex[item.name]) {
            quantity += basketItem.quantity;
        }
        return quantity;
    }

    ctrl.createTable = function(itemList) {
        ctrl.massageSearchResults(itemList);
        ctrl.ngTableParams = new NgTableParams(
            {count: 15},
            {counts: [15, 30, 50], dataset: itemList}
        );
    }

    ctrl.clearTable = function() {
        ctrl.ngTableParams = null;
    }

    ctrl.massageSearchResults = function(itemList) {
        for (var item of itemList) {
            var basketItem = ctrl.getBasketItem(item);
            item.adminForUserAddItem = true;
            item.isCustomItem = false;
            item.instructions = basketItem ? basketItem.instructions : (item.instructions || '');
            item.quantity = ctrl.getBasketItemQuantity(item);
            item.inStock = item.isInStock ? 'Yes' : 'No';
            item.tableDisplayName = hsCart.getProductDisplayName(item);
            item._isUpdating = false;
        }
    }

    ctrl.getBasketItem = function(item) {
        if (!item || !item.name || !ctrl.basketItemsIndex.hasOwnProperty(item.name)) {
            return null;
        }

        for (var basketItem of ctrl.basketItemsIndex[item.name]) {
            if (ctrl.selectedModifiersMatch(item, basketItem)) {
                return basketItem;
            }
        }

        return null;
    }

    ctrl.selectedModifiersMatch = function(item, basketItem) {
        var itemModifiers = Array.isArray(item.selectedModifiers) 
            ? item.selectedModifiers
            : [];
        var basketItemModifiers = Array.isArray(basketItem.selectedModifiers)
            ? basketItem.selectedModifiers
            : [];

        if (itemModifiers.length === 0) {
            return basketItemModifiers.length === 0;
        } else if (itemModifiers.length !== basketItemModifiers.length) {
            return false;
        }

        itemModifiers = JSON.parse(JSON.stringify(itemModifiers));
        basketItemModifiers = JSON.parse(JSON.stringify(basketItemModifiers));

        var compareNames = function(a, b) {
            if (a.name < b.name) {
                return -1;
            }
            if (a.name > b.name) {
                return 1;
            }
            return 0;
        }

        itemModifiers.sort(compareNames);
        basketItemModifiers.sort(compareNames);

        for (var i = 0; i < itemModifiers.length; i++) {
            if (itemModifiers[i].name !== basketItemModifiers[i].name) {
                return false;
            }
        }

        return true;
    }

    ctrl.syncBasketItem = function(item) {
        if (!ctrl.basketItemsIndex.hasOwnProperty(item.name)) {
            ctrl.basketItemsIndex[item.name] = [item];
            ctrl.basket.basketItems.push(item);    
        } else {
            var newQuantity = item.quantity > 0 ? item.quantity : 0;
            var foundInBasket = false;
            var foundInIndex = false;

            for (var basketItemEntry of ctrl.basket.basketItems.entries()) {
                // This loop works because we are only updating one item and then breaking.
                // If the scope of this function changes to syncing multiple items,
                // iterating this way will cause an issue because we are changing the indices
                // of the elements via splicing.

                var i = basketItemEntry[0];
                var basketItem = basketItemEntry[1];

                if (basketItem.name === item.name && ctrl.selectedModifiersMatch(item, basketItem)) {
                    foundInBasket = true; 
                    basketItem.quantity = newQuantity;
                    if (newQuantity === 0) {
                        ctrl.basket.basketItems.splice(i, 1);
                    }
                    break;
                }
            }

            var indexItems = ctrl.basketItemsIndex[item.name];
            for (var indexedItemEntry of indexItems.entries()) {
                var i = indexedItemEntry[0];
                var indexedItem = indexedItemEntry[1];

                if (ctrl.selectedModifiersMatch(item, indexedItem)) {
                    foundInIndex = true;  
                    indexedItem.quantity = newQuantity;
                    if (newQuantity === 0) {
                        ctrl.basket.basketItems.splice(i, 1);
                    }
                    break;
                }
            }
            if (ctrl.basketItemsIndex[item.name].length === 0) {
                delete ctrl.baksetItemsIndex[item.name];
            }

            if (!foundInBasket) {
                ctrl.basket.basketItems.push(item);
            }
            if (!foundInIndex) {
                ctrl.basketItemsIndex[item.name].push(item);
            }
        }
    }

    ctrl.search = function() {
        if (ctrl.searchInput !== '') {
            ctrl.tableLoading = true;
            var headers = hsAdminOrder.getHeaders();
            var target = {
                location: headers.location,
                priceList: headers.pricelist,
            };
            // Passing 'target' for the third argument may be a hacky way of forcing  
            // the location/priceList for the serach query.
            // The third argument (order) is only used within the function to set 
            // location/pricelist, but it could lead to bugs if the order argument
            // is used for some order-specific logic within the search function sometime 
            // in the future.
            hsSearch.search(ctrl.searchInput, null, target, false, true, false)
                .then(function(data) {
                    ctrl.searchResults = data.results[0] ? data.results[0] : [];
                    ctrl.createTable(ctrl.searchResults);
                    ctrl.searchInitialized = true;
                })
                .catch(function(err) {
                    void 0;
                })
                .finally(function() {
                    ctrl.tableLoading = false;
                });
        }
    }

    ctrl.clearSearch = function() {
        ctrl.searchInput = '';
        ctrl.searchResults = [];
        ctrl.clearTable();
        if (hsUtils.isNonEmptyArray(ctrl.productList)) {
            ctrl.createTable(ctrl.productList)
        }
        ctrl.searchInitialized = false;
    }

    ctrl.getItemIncrement = function(item) {
        var increment = 1;
        if (!item.sellByQty && item.unit === 'lb') {
            increment = 0.5;
        }
        if (item.unitIncrement) {
            increment = item.unitIncrement;
        }
        return increment;
    }

    ctrl.handleAddButtonClick = function(item) {
        if (item.hasModifiers) {
            ctrl.showProductPopup(item);
        } else {
            var newQuantity = item.quantity + ctrl.getItemIncrement(item);
            ctrl.setCartQuantity(item, newQuantity)
        }
    }

    ctrl.handlePlusButtonClick = function(item) {
        if (item.hasModifiers) {
            toastr.error('Cannot increment product with modifiers.');
        } else {
            var newQuantity = item.quantity + ctrl.getItemIncrement(item);
            ctrl.setCartQuantity(item, newQuantity);
        }
    }


    ctrl.handleMinusButtonClick = function(item) {
        if (item.hasModifiers) {
            toastr.error('Cannot decrement product with modifiers.');
        } else {
            var newQuantity = item.quantity - ctrl.getItemIncrement(item);
            ctrl.setCartQuantity(item, newQuantity);
        }
    }

    ctrl.handleCustomItemSubmit = function(customItem) {
        ctrl.customItemLoading = true;
        ctrl.setCartQuantity(customItem, customItem.quantity)
            .finally(function() {
                ctrl.customItemLoading = false;
            });
    }

    ctrl.setCartQuantity = function(item, newQuantity) {

        item._isUpdating = true;

        var basketItem = ctrl.getBasketItem(item);
        if (!basketItem) {
            basketItem = hsAdminOrder.getItemParams(item);
        }

        var basketItemCopy = JSON.parse(JSON.stringify(basketItem));
        basketItemCopy.quantity = newQuantity;

        if (newQuantity <= 0) {
            basketItemCopy.quantity = 0;
            return hsAdminOrder.removeItemFromCart(basketItemCopy)
                .then(function() {
                    ctrl.syncBasketItem(basketItemCopy);
                    item.quantity = ctrl.getBasketItemQuantity(item);
                    if (ctrl.ngTableParams) {
                        ctrl.ngTableParams.reload();
                    }
                    toastr.success('Item removed successfully.');     
                })
                .catch (function(err) {
                    var errorMessage = hsUtils.getMessageFromError(err);
                    void 0;
                    toastr.error(errorMessage);
                })
                .finally(function() {
                    item._isUpdating = false;
                });
        } else {
            return hsAdminOrder.updateItemInCart(basketItemCopy)
                .then(function() {
                    var successMessage = item.quantity === 0
                        ? 'Item added to cart successfully.'
                        : 'Quantity updated successfully.';
                    ctrl.syncBasketItem(basketItemCopy);
                    item.quantity = ctrl.getBasketItemQuantity(item);
                    if (ctrl.ngTableParams) {
                        ctrl.ngTableParams.reload();
                    }
                    toastr.success(successMessage);
                    if (ctrl.customItemLoading) {
                        $('#admin-order-custom-item').modal('hide');
                    }
                })
                .catch(function(err) {            
                    var errorMessage = hsUtils.getMessageFromError(err);
                    void 0;
                    toastr.error(errorMessage);
                })
                .finally(function() {
                    item._isUpdating = false;
                });
        }
    }

    ctrl.getInCartQuantity = function(item) {
        var inCartQuantity = '';

        if (item.quantity > 0) {
            inCartQuantity += item.quantity;
            if (item.unit === 'lb' && !item.sellByQty) {
                inCartQuantity += " lb";
            }
        }

        return inCartQuantity;
    }

    ctrl.shouldShowSearchBar = function() {
        return !ctrl.showPastOrders;
    }

    ctrl.shouldShowTable = function() {
        var dataSetPopulated = false;
        if (ctrl.showPastOrders) {
            dataSetPopulated = Array.isArray(ctrl.pastOrders) && ctrl.pastOrders.length > 0;
        } else {
            dataSetPopulated = hsUtils.isNonEmptyArray(ctrl.productList) || hsUtils.isNonEmptyArray(ctrl.searchResults);
        }
        return (
            ctrl.ngTableParams !== null
            && !ctrl.tableLoading
            && dataSetPopulated
        );
    }

    ctrl.shouldShowTableLoader = function() {
        return ctrl.tableLoading;
    }

    ctrl.shouldShowNotFoundMessage = function() {
        return (
            !ctrl.showPastOrders
            && ctrl.searchInitialized
            && !ctrl.tableLoading
            && ctrl.searchResults
            && ctrl.searchResults.length === 0
        );
    }

    ctrl.shouldShowNoPastOrdersMessage = function() {
        return (
            ctrl.showPastOrders
            && ctrl.pastOrdersInitialized
            && !ctrl.tableLoading
            && ctrl.pastOrders
            && ctrl.pastOrders.length === 0
        );
    }

    ctrl.openCustomItemPopup = function() {
        $('#admin-order-custom-item').modal('show');
        ctrl.addingCustomItem = true;
    }

    ctrl.showProductPopup = function(product) {
        var modalClass = '';
        if (product.hasImage) {
            modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
        } else {
            modalClass = 'ngdialog-theme-default email-capture';
        }
        product.addItemToOrder = true;

        hsAdminOrder.getProduct(product.name)
            .then(function(productResp) {
                var keysToAdd = ['nutritionInfo', 'ingredients', 'marketingCopy'];
                keysToAdd.forEach(function (key) {
                    if (key in productResp) {
                        product[key] = productResp[key];
                    }
                });
            })
            .catch(function(err) {
                toastr.error(hsUtils.getMessageFromError(err));
            })
            .finally(function() {
                ngDialog.open({
                    template: 'partials/popup/admin-product-item/admin-product-item-popup.html',
                    controller: 'ModalController',
                    className: modalClass,
                    data: product,
                    scope: $scope,
                });
            });
    }

    ctrl.handleAllItemsButtonClick = function() {
        if (ctrl.showPastOrders) {
            ctrl.clearTable();
            ctrl.showPastOrders = false;
            ctrl.tableLoading = true;
            if (ctrl.searchInitialized) {
                ctrl.createTable(ctrl.searchResults);
            } else {
                ctrl.createTable(ctrl.productList);
            }
            ctrl.tableLoading = false;    
        }
    }

    ctrl.handlePastOrdersButtonClick = function() {
        if (!ctrl.showPastOrders) {
            ctrl.clearTable();
            ctrl.showPastOrders = true;
            if (!ctrl.pastOrdersInitialized) {
                ctrl.initializePastOrders();
            } else {
                ctrl.tableLoading = true;
                ctrl.createTable(ctrl.pastOrders);
                ctrl.tableLoading = false;
            }  
        }
    }

    ctrl.initializePastOrders = function() {
        ctrl.tableLoading = true;
        hsAdminOrder.getUsersPastOrders()
            .then(function(res) {
                ctrl.pastOrders = res.orderedItems || [];
                ctrl.createTable(ctrl.pastOrders);
                ctrl.pastOrdersInitialized = true;
            })
            .catch(function(err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function() {
                ctrl.tableLoading = false;
            });
    }

    ctrl.getBaseUrl = function() {
        return hsAdminOrder.getBaseUrl(ctrl.isQuote);
    };

}
hsApp.component('addItemsToQuote', {
    templateUrl: '/partials/components/admin-order-v2/add-items-to-quote.html',
    bindings: {
        onClose: '&',
        quoteDetails: '<',
        onAddItem: '&',
        onQuantityChange: '&',
        onItemUpdate: '&',
    },
    controller: [
        '$scope',
        '$rootScope',
        '$q',
        'hsAdminOrder',
        'hsUtils',
        'hsSearch',
        'NgTableParams',
        'hsCart',
        'ngDialog',
        'toastr',
        'hsPromos',
        'hsAdmin',
        'hsApi',
        addItemsToQuoteController
    ],
});

function addItemsToQuoteController(
    $scope,
    $rootScope,
    $q,
    hsAdminOrder,
    hsUtils,
    hsSearch,
    NgTableParams,
    hsCart,
    ngDialog,
    toastr,
    hsPromos,
    hsAdmin,
    hsApi
) {
    var ctrl = this;
    var logPrefix = '[addItemsToQuote]:';

    ctrl.$onInit = function () {
        void 0;

        ctrl.onAdminPage = $rootScope.onAdminPage;
        ctrl.isLoading = true;
        ctrl.customItemLoading = false;
        ctrl.error = null;
        ctrl.searchInput = '';
        ctrl.productList = [];
        ctrl.searchResults = [];
        ctrl.searchInitialized = false;
        ctrl.ngTableParams = null;
        ctrl.tableLoading = false;
        ctrl.itemsIndex = {};
        ctrl.pastOrders = [];
        ctrl.showPastOrders = false;
        ctrl.pastOrdersInitialized = false;
        ctrl.user = ctrl.quoteDetails.userObj;
        
        ctrl.setItemsIndex(ctrl.quoteDetails.items);

        $q.all([ ctrl.initProductList(), ctrl.getLocationForQuote() ])
            .catch(function(err) {
                toastr.error(hsUtils.getMessageFromError(err));
                ctrl.error = "Failed to load page. Please try again or contact support";
            })
            .finally(function() {
                ctrl.createTable(ctrl.productList);
                ctrl.isLoading = false;
            });

        $scope.addItemsToQuoteCtrl = ctrl;

        hsPromos.getOngoingPromotions(ctrl.user, false, null, ctrl.getHeaders())
            .catch(function (err) {
                void 0;
            });

        $('#admin-order-custom-item').on('hidden.bs.modal', function (e) {
            ctrl.addingCustomItem = false;
            $scope.$apply();
        });
    };

    ctrl.$onChanges = function(changes) {
        if ('quoteDetails' in changes && changes.quoteDetails.currentValue && hsUtils.isNonEmptyArray(ctrl.productList)) {
            ctrl.setItemsIndex(ctrl.quoteDetails.items);
            ctrl.initItems(ctrl.productList);
            ctrl.initItems(ctrl.pastOrders);
            ctrl.initItems(ctrl.searchResults);

            if (ctrl.ngTableParams) {
                ctrl.ngTableParams.reload();
            } else {
                ctrl.createTable(ctrl.productList);
            }
        }
    };

    ctrl.getLocationForQuote = function() {
        return hsAdmin.getLocation(ctrl.quoteDetails.location)
            .then(function(res) {
                if (res.status !== 200) {
                    throw res;
                }
                ctrl.location = res.data;
            });
    };

    ctrl.getHeaders = function(forUser) {
        var headers = {
            location: ctrl.quoteDetails.location,
            pricelist: ctrl.quoteDetails.priceList,
        };
        if (forUser) {
            headers.targetuseremail = ctrl.user.email;
        }
        return headers;
    };
    
    ctrl.initProductList = function() {
        return hsAdmin.getProductList(ctrl.getHeaders())
            .then(function(products) {
                if (hsUtils.isNonEmptyArray(products)) {
                    ctrl.productList = products; 
                } else {
                    throw "No Products Found";
                }
            })
            .catch(function(err) {
                ctrl.productList = [];
                throw err;
            });
    };

    ctrl.setItemsIndex = function(items) {
        ctrl.items = items;
        ctrl.itemsIndex = {};

        for (var item of items) {
            if (ctrl.itemsIndex.hasOwnProperty(item.name)) {
                ctrl.itemsIndex[item.name].push(item);
            } else {
                ctrl.itemsIndex[item.name] = [ item ];
            }
        }
    };

    ctrl.getQuoteItemQuantity = function(item) {
        var quantity = 0;
        if (!item || !item.name || !ctrl.itemsIndex.hasOwnProperty(item.name)) {
            return quantity;
        }
        for (var quoteItem of ctrl.itemsIndex[item.name]) {
            quantity += quoteItem.quantity;
        }
        return quantity;
    };

    ctrl.createTable = function(itemList) {
        ctrl.initItems(itemList);
        ctrl.ngTableParams = new NgTableParams(
            {count: 15},
            {counts: [15, 30, 50], dataset: itemList}
        );
    };

    ctrl.clearTable = function() {
        ctrl.ngTableParams = null;
    };

    ctrl.initItems = function(itemList) {
        for (var item of itemList) {
            item.isQuoteAddItem = true;
            item.isCustomItem = false;
            item.instructions = item.instructions || '';
            item.quantity = ctrl.getQuoteItemQuantity(item);
            item.inStock = item.isInStock ? 'Yes' : 'No';
            item.tableDisplayName = hsCart.getProductDisplayName(item);

            var quoteItem = ctrl.getQuoteItem(item);

            if (quoteItem) {
                item.state = quoteItem.state;
                item.instructions = quoteItem.instructions || '';
            } else {
                delete item.state;
            }
        }
    };

    ctrl.getQuoteItem = function(item) {
        if (!item || !item.name || !ctrl.itemsIndex.hasOwnProperty(item.name)) {
            return null;
        }
        for (var quoteItem of ctrl.itemsIndex[item.name]) {
            if (ctrl.selectedModifiersMatch(item, quoteItem)) {
                return quoteItem;
            }
        }
        return null;
    };

    ctrl.selectedModifiersMatch = function(item, quoteItem) {
        var itemModifiers = Array.isArray(item.selectedModifiers) 
            ? item.selectedModifiers
            : [];
        var quoteItemModifiers = Array.isArray(quoteItem.selectedModifiers)
            ? quoteItem.selectedModifiers
            : [];

        if (itemModifiers.length === 0) {
            return quoteItemModifiers.length === 0;
        } else if (itemModifiers.length !== quoteItemModifiers.length) {
            return false;
        }

        itemModifiers = JSON.parse(JSON.stringify(itemModifiers));
        quoteItemModifiers = JSON.parse(JSON.stringify(quoteItemModifiers));

        var compareNames = function(a, b) {
            if (a.name < b.name) return -1;
            if (a.name > b.name) return 1;
            return 0;
        }

        itemModifiers.sort(compareNames);
        quoteItemModifiers.sort(compareNames);

        for (var i = 0; i < itemModifiers.length; i++) {
            if (itemModifiers[i].name !== quoteItemModifiers[i].name) {
                return false;
            }
        }
        return true;
    };

    ctrl.search = function() {
        if (ctrl.searchInput !== '') {
            ctrl.tableLoading = true;
            var headers = ctrl.getHeaders(ctrl.onAdminPage);
            var target = {
                location: headers.location,
                priceList: headers.pricelist,
            };
            hsSearch.search(ctrl.searchInput, null, target, false, true, false)
                .then(function(data) {
                    ctrl.searchResults = data.results[0] ? data.results[0] : [];
                    ctrl.createTable(ctrl.searchResults);
                    ctrl.searchInitialized = true;
                })
                .catch(function(err) {
                    void 0;
                })
                .finally(function() {
                    ctrl.tableLoading = false;
                });
        }
    };

    ctrl.clearSearch = function() {
        ctrl.searchInput = '';
        ctrl.searchResults = [];
        ctrl.clearTable();
        if (hsUtils.isNonEmptyArray(ctrl.productList)) {
            ctrl.createTable(ctrl.productList)
        }
        ctrl.searchInitialized = false;
    };

    ctrl.handleAddButtonClick = function(item) {
        if (item.hasModifiers) {
            ctrl.showProductPopup(item);
        } else {
            item._isUpdating = true;
            ctrl.onAddItem({ item: item })
                .then(function(action) {
                    toastr.success('Item added successfully.');     
                })
                .catch (function(err) {
                    var errorMessage = hsUtils.getMessageFromError(err);
                    void 0;
                    toastr.error(errorMessage);
                })
                .finally(function() {
                    item._isUpdating = false;
                });
        }
    };

    ctrl.handleIncrementButtonClick = function(item, buttonAction) {
        if (item.hasModifiers) {
            toastr.error('Cannot ' + buttonAction + ' product with modifiers.');
        } else {
            item._isUpdating = true;
            ctrl.onQuantityChange({ item: item, operation: buttonAction })
                .then(function(action) {
                    toastr.success('Item ' + action + ' successfully.');     
                })
                .catch (function(err) {
                    var errorMessage = hsUtils.getMessageFromError(err);
                    void 0;
                    toastr.error(errorMessage);
                })
                .finally(function() {
                    item._isUpdating = false;
                });
        }
    };

    ctrl.updateItemFromPopup = function(item, newQuantity) {
        item._isUpdating = true;

        var quoteItem = ctrl.getQuoteItem(item);

        if (!quoteItem) {
            quoteItem = hsAdminOrder.getItemParams(item);
            quoteItem._new = true;
        } else {
            quoteItem = JSON.parse(JSON.stringify(quoteItem));
            // We can't load instructions for modifier items into a popup,
            // so ignoring empty instructions for those.
            // this means can add or change, but not delete instructions.
            if (hsUtils.isNonEmptyString(item.instructions)
                || hsUtils.isString(item.instructions) && !hsUtils.isNonEmptyArray(item.selectedModifiers)
            ) {
                quoteItem.instructions = item.instructions;
            }
        }
        quoteItem.quantity = newQuantity;

        return ctrl.onItemUpdate({ item: quoteItem })
            .then(function(action) {
                toastr.success('Item ' + action + ' successfully.'); 
            })
            .catch(function(err) {
                var errorMessage = hsUtils.getMessageFromError(err);
                void 0;
                toastr.error(errorMessage);
            })
            .finally(function() {
                item._isUpdating = false;
            });
    };

    ctrl.getQuantityForDisplay = function(item) {
        var quantity = '';

        if (item.quantity > 0) {
            quantity += item.quantity;
            if (item.unit === 'lb' && !item.sellByQty) {
                quantity += " lb";
            }
        }

        return quantity;
    };

    ctrl.shouldShowSearchBar = function() {
        return !ctrl.showPastOrders;
    };

    ctrl.shouldShowTable = function() {
        var dataSetPopulated = false;
        if (ctrl.showPastOrders) {
            dataSetPopulated = Array.isArray(ctrl.pastOrders) && ctrl.pastOrders.length > 0;
        } else {
            dataSetPopulated = hsUtils.isNonEmptyArray(ctrl.productList) || hsUtils.isNonEmptyArray(ctrl.searchResults);
        }
        return (
            ctrl.ngTableParams !== null
            && !ctrl.tableLoading
            && dataSetPopulated
        );
    };

    ctrl.shouldShowTableLoader = function() {
        return ctrl.tableLoading;
    };

    ctrl.shouldShowNotFoundMessage = function() {
        return (
            !ctrl.showPastOrders
            && ctrl.searchInitialized
            && !ctrl.tableLoading
            && ctrl.searchResults
            && ctrl.searchResults.length === 0
        );
    };

    ctrl.shouldShowNoPastOrdersMessage = function() {
        return (
            ctrl.showPastOrders
            && ctrl.pastOrdersInitialized
            && !ctrl.tableLoading
            && ctrl.pastOrders
            && ctrl.pastOrders.length === 0
        );
    };

    ctrl.openCustomItemPopup = function() {
        $('#admin-order-custom-item').modal('show');
        ctrl.addingCustomItem = true;
    };

    ctrl.showProductPopup = function(product) {
        var modalClass = '';
        if (product.hasImage) {
            modalClass = 'ngdialog-theme-default email-capture ngdialog-full-width';
        } else {
            modalClass = 'ngdialog-theme-default email-capture';
        }
        product.addItemToOrder = true;

        return hsApi.getProduct(product.name, false, ctrl.getHeaders())
            .then(function(productResp) {
                var keysToAdd = ['nutritionInfo', 'ingredients', 'marketingCopy'];
                keysToAdd.forEach(function (key) {
                    if (key in productResp) {
                        product[key] = productResp[key];
                    }
                });
            })
            .catch(function(err) {
                toastr.error(hsUtils.getMessageFromError(err));
            })
            .finally(function() {
                ngDialog.open({
                    template: 'partials/popup/admin-product-item/admin-product-item-popup.html',
                    controller: 'ModalController',
                    className: modalClass,
                    data: product,
                    scope: $scope,
                });
            });
    };

    ctrl.handleItemsViewChange = function(value) {
        if (ctrl.showPastOrders) {
            ctrl.clearTable();
            if (!ctrl.pastOrdersInitialized) {
                ctrl.initializePastOrders();
            } else {
                ctrl.tableLoading = true;
                ctrl.createTable(ctrl.pastOrders);
                ctrl.tableLoading = false;
            }
        } else {
            ctrl.clearTable();
            ctrl.tableLoading = true;
            if (ctrl.searchInitialized) {
                ctrl.createTable(ctrl.searchResults);
            } else {
                ctrl.createTable(ctrl.productList);
            }
            ctrl.tableLoading = false;
        }
    };

    ctrl.initializePastOrders = function() {
        ctrl.tableLoading = true;
        var headers = ctrl.getHeaders(ctrl.onAdminPage);
        hsAdmin.getUsersPastOrders(headers)
            .then(function(res) {
                ctrl.pastOrders = res.orderedItems || [];
                ctrl.createTable(ctrl.pastOrders);
                ctrl.pastOrdersInitialized = true;
            })
            .catch(function(err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function() {
                ctrl.tableLoading = false;
            });
    };

    ctrl.closeView = function() {
        ctrl.onClose();
    };

    ctrl.addCustomItem = function(item) {
        ctrl.onAddItem({ item: item })
            .then(function(res) {
                $('#admin-order-custom-item').modal('hide');
                toastr.success(' Successfully added item.');
            })
            .catch(function(err) {
                var errorMessage = hsUtils.getMessageFromError(err);
                void 0;
                toastr.error(errorMessage);
            });
    };

}

hsApp.component('forUserCart', {
    templateUrl: '/partials/components/admin-order-v2/cart.html',
    bindings: {
        isQuote: '<',
    },
    controller: [ '$scope', 'hsAdminOrder', 'hsUtils', '$location', 'globalFunctions', 'hsCart', 'hsPromos', 'ngDialog', 'toastr', 'ENV', forUserCartController ],
});

function forUserCartController($scope, hsAdminOrder, hsUtils, $location, globalFunctions, hsCart, hsPromos, ngDialog, toastr, ENV) {
    var ctrl = this;
    var logPrefix = '[forUserCart]: ';

    ctrl.$onInit = function () {
        void 0;

        if (!hsAdminOrder.isFiltersSelectionComplete(ctrl.isQuote)) {
            $location.url(ctrl.getBaseUrl());
            return;
        }
        ctrl.isLoading = true;
        ctrl.error = null;
        ctrl.basket = null;
        ctrl.categorizedItems = null;
        ctrl.replaceAll = false;
        ctrl.replaceNone = false;
        ctrl.user = hsAdminOrder.getSelectedUser();
        ctrl.updatingOptOutOptions = false;

        ctrl.getUserCart()
            .catch(function (err) {
                ctrl.error = hsUtils.getMessageFromError(err);
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
        hsPromos.getOngoingPromotions(ctrl.user, false, null, hsAdminOrder.getHeaders())
            .catch(function (err) {
                void 0;
            });
        $scope.$watch('hsPromos.ongoingPromotions', ctrl.addPotentialSavings);
    };

    ctrl.addPotentialSavings = function () {
        if (!hsUtils.isObject(ctrl.basket)) return;

        ctrl.basket.basketItems.forEach(function (item) {
            var promotion = hsPromos.getPotentialSavingsPromo(item);
            if (promotion && promotion.membersOnly) {
                item.potentialSavingsPromo = promotion;
            }
        });
    };

    ctrl.getUserCart = function() {
        return hsAdminOrder.getUserCart()
            .then(function (res) {
                ctrl.basket = res;

                ctrl.processItems(res.basketItems);
                ctrl.addPotentialSavings();
                ctrl.initLimitedUsePromos(res.limitedUsePromos);
            });
    };

    ctrl.initLimitedUsePromos = function (limitedUsePromos) {
        if (hsUtils.isObject(limitedUsePromos) && Object.keys(limitedUsePromos).length) {
            Object.keys(limitedUsePromos).forEach(function (key, i) {
                var promo = limitedUsePromos[key];
                promo.index = i + 1;
                promo.endsOn = new Date(promo.endDate.year, promo.endDate.month - 1, promo.endDate.date)
                    .toDateString().split(' ').slice(1, -1).join(' ');
            });
        }
    };

    ctrl.isEmpty = function () {
        if (!hsUtils.isObject(ctrl.basket)) return true;
        return !hsUtils.isNonEmptyArray(ctrl.basket.basketItems);
    };

    ctrl.processItems = function (basketItems) {
        var replaceAll = true;
        var replaceNone = true;

        for (var item of basketItems) {
            replaceAll = replaceAll && item.canReplace;
            replaceNone = replaceNone && !item.canReplace;
        }
        ctrl.replaceNone = replaceNone;
        ctrl.replaceAll = replaceAll;
        var data = globalFunctions.filterProductsByCategory(basketItems);
        ctrl.categorizedItems = data;
    };

    ctrl.getProductDisplayName = function (item) {
        return hsCart.getProductDisplayName(item);
    };

    ctrl.getIsPickupOnly = function(item) {
        return hsCart.getIsPickupOnly(item);
    };

    ctrl.getRelevantPromotionForPrice = function (item) {
        return hsPromos.getRelevantPromotionForPrice(item, item.promotion);
    };

    ctrl.setItemQuantity = function (item, updateType, quantityBtnSelector) {
        quantityBtnSelector = '#' + quantityBtnSelector;
        var updateBtnSelector = quantityBtnSelector.replace('quantity', 'update-btn');

        var quantity = $(quantityBtnSelector).val();

        var inputElement = $(quantityBtnSelector);
        var limits = hsCart.checkQuantityLimits(item, inputElement);
        if (updateType === 'add' && limits.max.reached) {
            inputElement.val(limits.max.value);
            toastr.error(limits.max.message);
            return;
        }
        if (updateType === 'subtract' && limits.min.reached) {
            inputElement.val(limits.min.value);
            toastr.error(limits.min.message);
            return;
        }

        hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
    };

    ctrl.shouldShowSubstitutionOption = function () {
        if (ctrl.isQuote) return false;

        var selectedPriceList = hsAdminOrder.getSelectedPriceList();
        if (hsUtils.isObject(selectedPriceList) && selectedPriceList.disableProductSubstitutionOption === true) {
            return false;
        }

        var selectedLocation = hsAdminOrder.getSelectedLocation();
        if (hsUtils.isObject(selectedLocation) && selectedLocation.disableProductSubstitutionOption === true) {
            return false;
        }
        
        return true;
    };

    ctrl.showLeaveOutPopup = function () {
        var modalClass = 'ngdialog-theme-default email-capture';

        ngDialog.open({
            template: 'partials/popup/leave-out-items-popup.html',
            controller:'ModalController',
            closeByNavigation: true,
            className: modalClass
        });
    };

    ctrl.calculateEstimatedPricePerItem = function (priceObj, isXs) {
        return hsCart.calculateEstimatedPricePerItem(priceObj, isXs);
    };

    ctrl.showInstructionUpdate = function(item) {
        item._showInstructions = !item._showInstructions;
    };

    ctrl.calculateAvailableTimeString = function (availableObj) {
        return hsCart.calculateAvailableTimeString(availableObj, 'item');
    };

    ctrl.showAvailableTimes = function (product) {
        var $availableTimesScope = $scope.$new(true);
        $availableTimesScope.product = product;

        ngDialog.open({
            template: '<div><available-times product="product"></available-times></div>',
            scope: $availableTimesScope,
            plain: true,
            closeByDocument: true,
            closeByNavigation: true,
        });
    };

    ctrl.shouldShowMembershipDiscount = function (item, showPotentialSavings) {
        return hsPromos.shouldShowMembershipDiscount(item, item.promotion)
            || showPotentialSavings && hsPromos.shouldShowMembershipDiscount(item, item.potentialSavingsPromo);
    };

    ctrl.shouldShowSaving = function(item) {
        if (!item || !item.promotion || item.adminChangedPrice) return false;
        if (item.promotion.type === hsPromos.types.FREE_ITEM) return true;
        if (!hsPromos.isValidPrice(item.promotion.promotionPrice)) return false;
        if (item.promotion.promotionPrice === item.price) return false;

        return true;
    };

    ctrl.updateItemQuantity = function (item, index, category) {
        item._isUpdating = true;
        var inputElement = $('#quantity-' + category +'-'+ index);
        var validationError = hsCart.validateQuantity(item, inputElement, true);

        if (validationError) {
            toastr.error(validationError);
            return;
        }
        var quantity = parseFloat(inputElement.val());

        var copy = hsAdminOrder.getItemParams(item);
        copy.quantity = quantity;

        hsAdminOrder.updateItemInCart(copy)
            .then(function(response){
                $('#update-btn-'+ category +'-'+ index).addClass('hidden');
                item.quantity = quantity;
                return ctrl.getUserCart();
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                item._isUpdating = false;
            });
    };

    ctrl.updateInstructions = function (item) {
        item._isUpdating = true;

        hsAdminOrder.updateItemInCart(item)
            .then(function(response){
                item._showInstructions = false;
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                item._isUpdating = false;
            });
    };

    ctrl.updateCanReplace = function (item, canReplace) {
        item._isUpdating = true;
        var copy = hsAdminOrder.getItemParams(item);
        copy.canReplace = canReplace;

        hsAdminOrder.updateItemInCart(copy)
            .then(function(response){
                item.canReplace = canReplace;
                ctrl.processItems(ctrl.basket.basketItems);
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                item._isUpdating = false;
            });
    };

    ctrl.updateCanReplaceAll = function (canReplace) {
        ctrl.isLoading = true;
        var items = [];

        for (var item of ctrl.basket.basketItems) {
            var copy = hsAdminOrder.getItemParams(item);
            copy.canReplace = canReplace;
            copy._item = item;
            items.push(copy);
        }
        hsAdminOrder.updateItemsInCart(items)
            .then(function(response){
                for (var item of items) {
                    item._item.canReplace = item.canReplace;
                }
                ctrl.processItems(ctrl.basket.basketItems);
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.removeItem = function (item) {
        item._isUpdating = true;

        hsAdminOrder.removeItemFromCart(item)
            .then(function(response){
                return ctrl.getUserCart();
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                item._isUpdating = false;
            });
    };

    ctrl.getDisplayUnit = function (item) {
        return item.unit.toLowerCase() === 'lb' && !item.sellByQty ? 'LB' : 'CT';
    };

    ctrl.roundNumber = function (number) {
        return hsUtils.roundNumber(number);
    };

    ctrl.calculatePricePerQuantity = function (priceObj) {
        return hsCart.calculatePricePerQuantity(priceObj);
    };

    ctrl.shouldShowUnit = function (promotion) {
        if (ENV.hideItemUnit) return false;
        if (hsUtils.isObject(promotion) && promotion.type === hsPromos.types.FREE_ITEM && !promotion.optOut) return false;
        return true;
    };

    ctrl.getLimitedUsePromoName = function (promo) {
        return hsPromos.getLimitedUsePromoName(promo);
    };

    ctrl.updatePromoOptOut = function (promo, value) {
        if (ctrl.updatingOptOutOptions) return;

        ctrl.updatingOptOutOptions = promo.index;

        hsAdminOrder.updateCartOptions(promo, value)
            .then(function(response){
                // promo.optOut = value;
                ctrl.isLoading = true;
                return ctrl.getUserCart();
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                toastr.error(message);
            })
            .finally(function () {
                ctrl.updatingOptOutOptions = false;
                ctrl.isLoading = false;
            });
    };

    ctrl.hasLimitedUsePromos = function () {
        return hsUtils.isObject(ctrl.basket.limitedUsePromos) && Object.keys(ctrl.basket.limitedUsePromos).length;
    };

    ctrl.getBaseUrl = function() {
        return hsAdminOrder.getBaseUrl(ctrl.isQuote);
    };
}
hsApp.component('forUserCheckout', {
    templateUrl: '/partials/components/admin-order-v2/checkout.html',
    bindings: {
        isQuote: '<',
    },
    controller: [ '$scope', 'hsAdminOrder', 'hsUserPayments', 'hsAdmin', 'hsUtils', '$location', 'hsCart', 'ngDialog', 'toastr', 'ENV', 'localStorageService', forUserCheckoutController ],
});

function forUserCheckoutController($scope, hsAdminOrder, hsUserPayments, hsAdmin, hsUtils, $location, hsCart, ngDialog, toastr, ENV, localStorageService) {
    var ctrl = this;
    var logPrefix = '[forUserCheckout]: ';

    ctrl.$onInit = function () {
        void 0;
        if (!hsAdminOrder.isFiltersSelectionComplete(ctrl.isQuote)) {
            $location.url(ctrl.getBaseUrl());
            return;
        }
        ctrl.isLoading = true;
        ctrl.error = null;
        ctrl.basket = null;
        ctrl.selectedFulfillmentMethod = hsAdminOrder.SELECTED_FILTERS.fulfillmentMethod;
        ctrl.selectedFulfillmentDate = hsAdminOrder.getFulfillmentDateString(hsAdminOrder.SELECTED_FILTERS.fulfillmentDate);
        ctrl.selectedFulfillmentTime = hsAdminOrder.getFulfillmentTimeString(hsAdminOrder.SELECTED_FILTERS.fulfillmentTime);
        ctrl.fulfillment = null;
        ctrl.discountCode = !ctrl.isQuote ? localStorageService.get('discountCode') || null : null;
        ctrl.showDiscountCodeBox = true;
        ctrl.updatingDiscount = false;

        ctrl.adminDiscountTypes = hsAdmin.adminDiscountTypes;
        ctrl.selectedAdminDiscountType = ctrl.adminDiscountTypes.PERCENT;
        ctrl.discountValue = 0;
        ctrl.discountPercent = 0;
        ctrl.adminDiscount = null;

        ctrl.total = null;
        ctrl.selectedTip = null;
        ctrl.selectedShopperTip = null;
        ctrl.placingOrder = false;

        $scope.hsAdminOrder = hsAdminOrder;
        ctrl.selectedFilters = hsAdminOrder.SELECTED_FILTERS;
        ctrl.selectedUser = hsAdminOrder.getSelectedUser();
        ctrl.fulfillmentMethods = hsAdminOrder.fulfillmentMethods;
        ctrl.steps = hsAdminOrder.steps;
        ctrl.applicablePaymentMethods = hsAdminOrder.getApplicableUserPaymentMethods(hsAdminOrder.SELECTED_FILTERS.user);
        ctrl.showPaymentMethod = false;

        ctrl.getUserCart()
            .catch(function (err) {
                ctrl.error = hsUtils.getMessageFromError(err);
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
        $scope.$watch('hsAdminOrder.SELECTED_FILTERS.user.paymentMethods', function() {
            ctrl.applicablePaymentMethods = hsAdminOrder.getApplicableUserPaymentMethods(hsAdminOrder.SELECTED_FILTERS.user); 
        });
    };

    ctrl.initTips = function (type) {
        if (!ctrl.fulfillment.tips || ctrl.isQuote) return;

        var tipsSource = type === 'shopper' ? ctrl.fulfillment.shopperTips : ctrl.fulfillment.tips;
        var propertySelectedTip = type === 'shopper' ? 'selectedShopperTip' : 'selectedTip';

        angular.forEach(tipsSource, function(tip){
            tip.title = tip.display;
            tip.checked = ctrl[propertySelectedTip] && ctrl[propertySelectedTip].title === tip.title;

            if (tip.checked || !ctrl[propertySelectedTip]) {
                ctrl.total = tip.total;
                ctrl[propertySelectedTip] = tip;
                tip.checked = true;
            }
        });
        var otherTipNode = {
            display: 'Other',
            title: 'Other',
            value: ctrl[propertySelectedTip].title === 'Other' ? ctrl[propertySelectedTip].value : ctrl.fulfillment.tips[0].value,
            checked: ctrl[propertySelectedTip].title === 'Other',
        };
        otherTipNode.total = ctrl.fulfillment.total + otherTipNode.value;
        tipsSource.push(otherTipNode);

        if(ctrl[propertySelectedTip].total) {
            ctrl.processTip(ctrl[propertySelectedTip], type);
        }
    };

    ctrl.processTip = function (tip, type) {
        var tipsSource = type === 'shopper' ? ctrl.fulfillment.shopperTips : ctrl.fulfillment.tips;
        var propertyTips = type === 'shopper' ? 'selectedShopperTip' : 'selectedTip';
        var propertyCustomTip = type === 'shopper' ? 'customShopperTip' : 'customTip';
        var addValue = 0;

        if (type !== 'shopper' && ctrl.selectedShopperTip) {
            addValue = ctrl.selectedShopperTip.value;
        } else if (type === 'shopper' && ctrl.selectedTip && ctrl.selectedFulfillmentMethod === 'delivery') {
            addValue = ctrl.selectedTip.value;
        }
        if (tip.title === 'Other') {
            ctrl.total = ctrl.fulfillment.total + tip.value + addValue;
            ctrl[propertyCustomTip] = tip.value;
        } else {
            ctrl.total = tip.total + addValue;
        }

        ctrl[propertyTips] = tip;

       angular.forEach(tipsSource, function(tipVal) {
            tipVal.checked = tipVal.title === tip.title;
       });
    };

    ctrl.applyCustomTip = function (type) {
        var tipsSource = type === 'shopper' ? ctrl.fulfillment.shopperTips : ctrl.fulfillment.tips;
        var propertySelectedTip = type === 'shopper' ? 'selectedShopperTip' : 'selectedTip';
        var propertyCustomTip = type === 'shopper' ? 'customShopperTip' : 'customTip';

        angular.forEach(tipsSource, function(tipVal) {
            if (tipVal.title === 'Other') {                 
                tipVal.checked = true;
                ctrl[propertySelectedTip] = tipVal;
            } else {
                tipVal.checked = false;
            }
        });
        var addValue = 0;

        if (type !== 'shopper' && ctrl.selectedShopperTip) {
            addValue = ctrl.selectedShopperTip.value;
        } else if (type === 'shopper' && ctrl.selectedTip && ctrl.selectedFulfillmentMethod === 'delivery') {
            addValue = ctrl.selectedTip.value;
        }
        var customTip = parseFloat(ctrl[propertyCustomTip]) || 0;
        ctrl[propertySelectedTip].value = customTip;
        ctrl.total = ctrl.fulfillment.total + addValue + customTip;
    };

    ctrl.isEmpty = function () {
        if (!hsUtils.isObject(ctrl.basket)) return true;
        return !hsUtils.isNonEmptyArray(ctrl.basket.basketItems);
    };

    ctrl.showServiceFeePopup = function () {
        var modalClass = 'ngdialog-theme-default email-capture';

        ngDialog.open({
            template: 'partials/popup/service-fee-details-popup.html',
            controller:'ModalController',
            className: modalClass,
            data: ctrl.fulfillment
        });
    };

    ctrl.toggleDiscountCode = function () {
        ctrl.showDiscountCodeBox = !ctrl.showDiscountCodeBox;
    };

    ctrl.showCreditCardHoldPopup = function () {
        var modalClass = 'ngdialog-theme-default email-capture';

        ngDialog.open({
            template: 'partials/popup/credit-card-hold-popup.html',
            controller:'ModalController',
            className: modalClass
        });
    };

    ctrl.clearAdminDiscount = function() {
        ctrl.applyAdminDiscount(true);
    }

    ctrl.setAdminDiscountObj = function(clearDiscount) { 
        if (clearDiscount) {
            ctrl.adminDiscount = null;
            return;    
        }

        ctrl.adminDiscount = {
            type: ctrl.selectedAdminDiscountType
        };

        if (ctrl.selectedAdminDiscountType === ctrl.adminDiscountTypes.PERCENT) {
            ctrl.adminDiscount.percent = ctrl.discountPercent;
        } 
        
        if (ctrl.selectedAdminDiscountType === ctrl.adminDiscountTypes.DOLLAR){
            ctrl.adminDiscount.value = ctrl.discountValue;
        }
    }

    ctrl.processApplyDiscount = function() {
        if (typeof ctrl.adminDiscountValidate === 'function' && ctrl.adminDiscountValidate()) {
            if (ctrl.basket.discount.code) {
                $('#discount-confirmation-popup').modal('show');
                return;
            }
            ctrl.applyAdminDiscount();
        }
    };

    ctrl.closePopup = function() {
        $('#discount-confirmation-popup').modal('hide');
    };

    ctrl.applyAdminDiscount = function(clearDiscount) {
        ctrl.closePopup();
        ctrl.setAdminDiscountObj(clearDiscount);    

        ctrl.updatingDiscount = true;
        ctrl.getUserCart()
            .then(function() {
                if (clearDiscount && !ctrl.basket.discount.code) {
                    toastr.success("The discount has been cleared successfully.");
                }
                if (!clearDiscount && ctrl.basket.discount.code) {
                    toastr.success("The discount has been applied successfully.");
                }
            })
            .catch(function (err) {
                ctrl.error = hsUtils.getMessageFromError(err);
            })
            .finally(function () {
                ctrl.updatingDiscount = false;
            });   
    };

    ctrl.applyDiscountCode = function () {
        localStorageService.set('discountCode', ctrl.discountCode);
        ctrl.updatingDiscount = true;

        ctrl.getUserCart()
            .catch(function (err) {
                ctrl.error = hsUtils.getMessageFromError(err);
            })
            .finally(function () {
                ctrl.updatingDiscount = false;
            });
    };

    ctrl.hasChangedPercent = function() {
        return ctrl.discountPercent !== (ctrl.basket.discount.percent || 0);
    }

    ctrl.hasChangedDollar = function() {
        return ctrl.discountValue !== ctrl.basket.discount.value;
    }

    ctrl.onAdminDiscountChange = function(value) {
        ctrl.selectedAdminDiscountType = value.typeValue;
        ctrl.discountPercent = value.percentValue;
        ctrl.discountValue = value.dollarValue;
        ctrl.adminDiscountValidate = value.validate;
    };

    ctrl.disableApplyButton = function() {
        return ctrl.updatingDiscount
            || (ctrl.selectedAdminDiscountType === ctrl.adminDiscountTypes.PERCENT && !ctrl.hasChangedPercent())
            || (ctrl.selectedAdminDiscountType === ctrl.adminDiscountTypes.DOLLAR && !ctrl.hasChangedDollar())
    };

    ctrl.getDiscountText = function() {
        if (!hsUtils.isObject(ctrl.basket) || !hsUtils.isObject(ctrl.basket.discount) || !hsUtils.isPositiveNumber(ctrl.basket.discount.value)) {
            return '-';
        }

        if (hsUtils.isPositiveNumber(ctrl.basket.discount.percent)) {
            return '-$' + (ctrl.basket.discount.value.toFixed(2)) + ' (' + ctrl.basket.discount.percent.toFixed(2) + '%)';
        }
        
        return '-$' + (ctrl.basket.discount.value.toFixed(2));
    };

    ctrl.placeOrder = function () {
        if (ctrl.total > 0 && ctrl.total < 0.5) {
            ctrl.error = 'Order not placed: Your current charge is $' + (+ctrl.total.toFixed(2))
                + ' and Credit Card Charges must be $0 or  $0.50. Please adjust to proceed';
                return;
        }

        ctrl.placingOrder = true;
        var params = {};

        if (ctrl.discountCode) {
            params.discountCode = ctrl.discountCode;
        }
        if (ctrl.adminDiscount) {
            params.adminDiscount = ctrl.adminDiscount;
        }
        if (ctrl.selectedTip && ctrl.selectedFulfillmentMethod === 'delivery') {
            params.tip = ctrl.selectedTip.value;
        }
        if (ctrl.selectedShopperTip) {
            params.shopperTip = ctrl.selectedShopperTip.value;
        }
        hsAdminOrder.placeOrder(params, ctrl.isQuote)
            .then(function (obj) {
                obj.userEmail = hsAdminOrder.getSelectedUser().email;
                ctrl.discountCode = null;
                localStorageService.remove('discountCode');
                hsAdminOrder.clearFilters(ctrl.isQuote)
                    .catch(function (err) {
                        void 0;
                    });

                $location.url(ctrl.getBaseUrl() + '/confirmation' + ctrl.getConfirmationParams(obj));
            })
            .catch(function (err) {
                ctrl.error = hsUtils.getMessageFromError(err);
            })
            .finally(function () {
                ctrl.placingOrder = false;
            });

    };

    ctrl.getConfirmationParams = function (obj) {
        var params;

        if (ctrl.isQuote) {
            params = '?quoteId=' + encodeURIComponent(obj.id);
        } else {
            params = '?orderKey=' + encodeURIComponent(obj.key);
        }

        if (ctrl.isQuote) {
            params += '&userEmail=' + encodeURIComponent(obj.userEmail);
        }
        return params;
    };

    ctrl.getTipLabel = function() {
        var location = hsAdminOrder.getSelectedLocation();
        return hsCart.getTipLabel(location.managedDeliveryTipShare);
    };

    ctrl.getTipDisclaimer = function() {
        var location = hsAdminOrder.getSelectedLocation();
        return hsCart.getTipDisclaimer(location.managedDeliveryTipShare);
    };

    ctrl.getBaseUrl = function() {
        return hsAdminOrder.getBaseUrl(ctrl.isQuote);
    };

    ctrl.togglePaymentMethod = function () {
        ctrl.showPaymentMethod = !ctrl.showPaymentMethod;
    };

    ctrl.isHouseChargeAvailable = function() {
        return hsUserPayments.isHouseChargeAvailable(ctrl.selectedUser);
    };

    ctrl.handleAddPaymentMethod = function(userData) {
        ctrl.isUpdatingPaymentMethod = true;
        hsAdminOrder.setPaymentMethods(userData, 'add');
        ctrl.isUpdatingPaymentMethod = false;
    };

    ctrl.deletePaymentMethod = function (paymentMethod) {
        return hsAdminOrder.getDeletePopup().then(function (confirm) {
            ctrl.isUpdatingPaymentMethod = true;

            return hsAdminOrder.deletePaymentMethod(paymentMethod.pmid)
                .then(function (res) {
                    if(res.status !== 200) {
                        throw res.data;
                    }
                    return hsAdminOrder.setPaymentMethods(res.data.user);
                })
                .catch(function (err) {
                    toastr.error(hsUtils.getMessageFromError(err, 'Failed to delete payment'));
                })
                .finally(function () {
                    ctrl.isUpdatingPaymentMethod = false;
                });
        }, function (reject) {
            void 0;
            return;
        });
    };

    ctrl.getPaymentProcessor = function() {
        return hsAdminOrder.getPaymentProcessor();
    }

    ctrl.setPaymentMethod = function (value) {
        var paymentMethod = ctrl.selectedUser.paymentMethods.find(function(pm) {
            return pm.pmid === value.pmid;
        });
        hsAdminOrder.setFilterPaymentMethod(paymentMethod);
    }

    ctrl.getUserCart = function() {
        return hsAdminOrder.getUserCart(ctrl.discountCode, hsAdminOrder.getSelectedAddress(), ctrl.adminDiscount)
            .then(function (res) {
                ctrl.basket = res;

                if (ctrl.isEmpty()) {
                    var redirectUrl = ctrl.getBaseUrl() + '/cart';
                    $location.url(redirectUrl);
                    return;
                }
                ctrl.fulfillment = res.orderFee[ctrl.selectedFulfillmentMethod];
                ctrl.total = ctrl.fulfillment.total;

                if (ctrl.fulfillment.tips) {
                    var tipsCopy = JSON.parse(JSON.stringify(ctrl.fulfillment.tips));
                    ctrl.initTips();

                    if (ENV.enableSeparateTips || ctrl.selectedFulfillmentMethod === ctrl.fulfillmentMethods.PICKUP) {
                        ctrl.fulfillment.shopperTips = tipsCopy;
                        ctrl.initTips('shopper');
                    }
                }
                if (hsUtils.isObject(ctrl.adminDiscount) 
                    && (hsUtils.isPositiveNumber(ctrl.adminDiscount.value) || hsUtils.isPositiveNumber(ctrl.adminDiscount.percent)) 
                    && !ctrl.fulfillment.discount.code
                    ) {
                    ctrl.adminDiscount = null;
                    toastr.error('Discount not applied to order.');
                }
                if (ctrl.discountCode && !ctrl.fulfillment.discount.code) {
                    ctrl.discountCode = null;
                    localStorageService.remove('discountCode');
                    toastr.error('Discount code is invalid, already used or not applicable to your account.');
                }
                ctrl.showDiscountCodeBox = !ctrl.discountCode;

                if (ctrl.fulfillment.unavailable) {
                    ctrl.error = ctrl.fulfillment.unavailable.reasonDisplay;
                }
            });
    };

    ctrl.handleSelectChargeType = function(value) {
        if (value.hasOwnProperty('isHouseChargeOrder')) {
            hsAdminOrder.setHouseCharge(value.isHouseChargeOrder);
        }
    };

    ctrl.showError = function() {
        return ctrl.error && (ctrl.isQuote || ctrl.showPaymentMethod || !hsAdminOrder.getSelectedPriceList().chargeUser);
    };

    ctrl.showContinue = function() {
        return !ctrl.isQuote && !ctrl.showPaymentMethod && hsAdminOrder.getSelectedPriceList().chargeUser && !ctrl.isLoading;
    };

    ctrl.showPlaceOrder = function() {
        return !ctrl.fulfillment.unavailable && !ctrl.error && (
            ctrl.isQuote || !hsAdminOrder.getSelectedPriceList().chargeUser
        );
    };
}
hsApp.component('forUserConfirmation', {
    templateUrl: '/partials/components/admin-order-v2/confirmation.html',
    bindings: {
        isQuote: '<',
    },
    controller: [ '$location', 'hsAdminOrder', forUserConfirmationController ],
});

function forUserConfirmationController($location, hsAdminOrder) {
    var ctrl = this;
    var logPrefix = '[forUserConfirmation]: ';

    ctrl.$onInit = function () {
        if (!ctrl.isQuote) {
            ctrl.key = $location.search().orderKey;
            $location.search('orderKey', null);
        } else {
            ctrl.key = $location.search().quoteId;
            ctrl.userEmail = $location.search().userEmail;
            $location.search('quoteId', null);
            $location.search('userEmail', null);
        }

        if (!ctrl.key) {
            $location.url(hsAdminOrder.getBaseUrl(ctrl.isQuote));
        }
    };

    ctrl.getKey = function () {
        return ctrl.isQuote ? ctrl.key : encodeURIComponent(ctrl.key);
    };

    ctrl.getLink = function () {
        return (!ctrl.isQuote ? '/admin/order?orderId=' : '/admin/quote/') + ctrl.getKey();
    };

    ctrl.handleBackClick = function() {
        return !ctrl.isQuote ? '/admin/dashboard' : '/admin/quotes';
    };
}

hsApp.component('quoteCheckout', {
    templateUrl: '/partials/components/admin-order-v2/quote-checkout.html',
    bindings: {
        isForUser: '<'
    },
    controller: [ '$routeParams', '$scope', '$rootScope', '$q', '$location', 'hsAdminOrder', 'hsApi', 'hsUtils', 'hsUserPayments', 'toastr', 'ngDialog', 'localStorageService', 'globalFunctions', 'ENV', 'hsCart', quoteCheckoutController ],
});

function quoteCheckoutController($routeParams, $scope, $rootScope, $q, $location, hsAdminOrder, hsApi, hsUtils, hsUserPayments, toastr, ngDialog, localStorageService, globalFunctions, ENV, hsCart) {
    var ctrl = this;
    var logPrefix = '[quoteCheckout]: ';

    ctrl.VIEWS = {
        PAYMENT: 'payment',
        SUMMARY: 'summary' 
    };

    ctrl.$onInit = function () {
        void 0;
        ctrl.quoteId = $routeParams.quoteId;

        ctrl.backLink = (ctrl.isForUser ? '/admin' : '') + '/quote/' + ctrl.quoteId;

        ctrl.error = null;
        ctrl.orderError = null;

        ctrl.quoteDetails = null;

        ctrl.isLoading = true;
        
        ctrl.updatingPaymentMethod = false;
        ctrl.isHouseChargeOrder = false;
        
        ctrl.locations = null;
        ctrl.location = null;
        ctrl.priceList = null;
        ctrl.acceptCreditCard = true;
        ctrl.tips = {
            shopperTip: 0,
            driverTip: 0,
        };
        ctrl.selectedShopperTip = null;
        ctrl.selectedDriverTip = null;
        ctrl.shopperTipArray = [];
        ctrl.driverTipArray = [];
        ctrl.customShopperTip = 0;
        ctrl.customDriverTip = 0;

        ctrl.emptyAddress = {
            street: '',
            aptUnit: '',
            city: '',
            state: '',
            zip: '',
        };

        ctrl.currentView = ctrl.VIEWS.PAYMENT;

        var promises = [
            ctrl.getLocations(),
            ctrl.initQuoteDetails()
        ];
        $q.all(promises)
            .then(function() {
                if (![ hsAdminOrder.quoteStates.PENDING, hsAdminOrder.quoteStates.EXPIRED ].includes(ctrl.quoteDetails.state)) {
                    $location.url((ctrl.isForUser ? '/admin' : '') + '/quote/' + ctrl.quoteId);
                } else {
                    ctrl.setLocationPriceList();
                    ctrl.setTipArrays();   
                    ctrl.setCheckoutMethod();

                    ctrl.acceptCreditCard = typeof ctrl.priceList.chargeUser === 'boolean'
                        ? ctrl.priceList.chargeUser
                        : ctrl.location.chargeUser;

                    if (!ctrl.acceptCreditCard) {
                        ctrl.currentView = ctrl.VIEWS.SUMMARY;
                    }
                }
            })
            .catch(function(err) {
                ctrl.error = "We have encountered an error. We apologize for any inconvenience this may cause.";
            })
            .finally(function(){
                ctrl.isLoading = false;
            });
    };

    ctrl.setSelectedCard = function(value) {
        var pmid = value.pmid;	
        ctrl.paymentMethod = ctrl.paymentMethods.find(function(paymentMethod) {
            return paymentMethod.pmid === pmid;
        }) || null;
    };

    ctrl.isQuoteForLoggedInUser = function() {
        var quoteUser = ctrl.quoteDetails.userObj;
        var loggedInUser = $rootScope.currentUser || {};

        return $rootScope.loggedIn && loggedInUser.email === quoteUser.email;
    };

    ctrl.setCheckoutMethod = function() {
        if (ctrl.isForUser || ctrl.isQuoteForLoggedInUser()) {
            ctrl.paymentMethods = ctrl.quoteDetails.userObj.paymentMethods || [];
            ctrl.paymentMethod = ctrl.paymentMethods.find(function(pm) {
                return pm.paymentProcessor !== hsUserPayments.PAYMENT_PROCESSORS.forage && pm.default;
            }) || null;
            ctrl.savePaymentOnUser = !ctrl.isForUser;
        } else {
            ctrl.paymentMethod = null;
            ctrl.paymentMethods = [];
            ctrl.savePaymentOnUser = false;
        }
    };

    ctrl.isHouseChargeAvailable = function() {
        return hsUserPayments.isHouseChargeAvailable(ctrl.quoteDetails.userObj);
    };

    ctrl.handleSelectChargeType = function(value) {
        if (hsUtils.isNonEmptyObject(value) && hsUtils.isBoolean(value.isHouseChargeOrder)) {
            ctrl.isHouseChargeOrder = value.isHouseChargeOrder;
        }
    };

    ctrl.setTipArrays = function() {
        var fulfillmentObj = Object.values(ctrl.priceList.fulfillment).find(function(fulfillment){
            return fulfillment.name === ctrl.quoteDetails.fulfillmentMethod;
        });

        if (!hsUtils.isNonEmptyArray(fulfillmentObj.standardTips)) {
            return;
        }

        var otherTipObj = {
            display: "Other",
        };
        ctrl.shopperTipArray = JSON.parse(JSON.stringify(fulfillmentObj.standardTips));
        ctrl.shopperTipArray.push(JSON.parse(JSON.stringify(otherTipObj)));
        ctrl.selectedShopperTip = ctrl.shopperTipArray[0];
        ctrl.processShopperTip();
        
        if (ctrl.quoteDetails.fulfillmentMethod === hsAdminOrder.fulfillmentMethods.DELIVERY) {
            ctrl.driverTipArray = JSON.parse(JSON.stringify(fulfillmentObj.standardTips)); 
            ctrl.driverTipArray.push(JSON.parse(JSON.stringify(otherTipObj)));
            ctrl.selectedDriverTip = ctrl.driverTipArray[0];
            ctrl.processDriverTip();
        }
    };

    ctrl.updateOrderTotalWithTip = function() {
        ctrl.quoteDetails.total = +(ctrl.quoteDetails.originalTotal + ctrl.tips.driverTip + ctrl.tips.shopperTip).toFixed(2);
    };
    
    ctrl.processShopperTip = function() {
        if (ctrl.selectedShopperTip.display === 'Other') {
            ctrl.tips.shopperTip = +(ctrl.customShopperTip || 0).toFixed(2);
        } else {
            var multiplier = +((ctrl.selectedShopperTip.percentage/100).toFixed(2));
            ctrl.tips.shopperTip = +(multiplier * ctrl.quoteDetails.subTotal).toFixed(2);
        }   

        ctrl.updateOrderTotalWithTip();
        
    };

    ctrl.processDriverTip = function() {
        if (ctrl.selectedDriverTip.display === 'Other') {
            ctrl.tips.driverTip = +(ctrl.customDriverTip || 0).toFixed(2);
        } else {
            var multiplier = +((ctrl.selectedDriverTip.percentage/100).toFixed(2));
            ctrl.tips.driverTip = +(multiplier * ctrl.quoteDetails.subTotal).toFixed(2);
        }

        ctrl.updateOrderTotalWithTip();
    };

    ctrl.setLocationPriceList = function() {
        ctrl.location = ctrl.locations.find(function(location) {
            return location.uniqueName === ctrl.quoteDetails.location;
        });

        ctrl.priceList = ctrl.location.priceLists.find(function(priceList) {
            return priceList.uniqueName === ctrl.quoteDetails.priceList;
        });
    };

    ctrl.getLocations = function() {
        return hsApi.getLocations()
            .then(function(locations) {
                ctrl.locations = locations.data;
            })
            .catch(function(err) {
                void 0;
                throw err;
            });
    };

    ctrl.setAddress = function() {
        ctrl.address = ctrl.emptyAddress;

        if (hsUtils.isNonEmptyObject(ctrl.quoteDetails) 
            && hsUtils.isNonEmptyObject(ctrl.quoteDetails.userObj) 
            && hsUtils.isNonEmptyObject(ctrl.quoteDetails.userObj.address)
        ) {
            ctrl.address = ctrl.quoteDetails.userObj.address;
        }

        if (hsUtils.isNonEmptyObject(ctrl.quoteDetails.deliveryAddress)) {
            ctrl.address = ctrl.quoteDetails.deliveryAddress;
        }
    };

    ctrl.initQuoteDetails = function() {
        return hsAdminOrder.getQuoteDetails(ctrl.quoteId, ctrl.isForUser)
            .then(function(quoteDetails) {
                ctrl.quoteDetails = quoteDetails;
                ctrl.quoteDetails.originalTotal = ctrl.quoteDetails.total;
                ctrl.setAddress();
            })
            .catch(function(err) {
                void 0;
                throw err;
            });
    };

    ctrl.handleAddCard = function(userData, paymentMethod) {
        if (ctrl.isForUser) {
            ctrl.isLoading = true;
            return hsUserPayments.addPaymentMethod(
                paymentMethod, 
                ctrl.quoteDetails.userObj.email, 
                ctrl.location.uniqueName, 
                ctrl.priceList.uniqueName
            )
                .then(function(res) {
                    if (res && res.data && res.data.user) {
                        var newUserData = res.data.user;
                        ctrl.quoteDetails.userObj = newUserData;
                        ctrl.setCheckoutMethod();
                        toastr.success('Card added successfully');
                    } else {
                        var errorMessage = 'Failed to add card';
                        if (res && res.data && res.data.message) {
                            errorMessage = res.data.message;
                        }
                        toastr.error(errorMessage);
                    }
                })
                .catch(function(err) {
                    toastr.error((err.message || 'Failed to add card'));
                })
                .finally(function() {
                    ctrl.isLoading = false;
                });
        } else if (ctrl.savePaymentOnUser) {
            ctrl.quoteDetails.userObj = userData;
            ctrl.setCheckoutMethod();
        } else {
            ctrl.paymentMethod = paymentMethod;
            ctrl.paymentMethods = [
                ctrl.paymentMethod
            ];
            ctrl.switchView(ctrl.VIEWS.SUMMARY);
            $scope.$apply();
        }
    };

    ctrl.handleDeletePaymentMethod = function(value) {
        ngDialog.openConfirm({
            data: {
                heading: 'Are You Sure?',
                subHeading: 'Please confirm that you want to delete payment method.',
                confirmBtnText: 'Confirm',
                cancelBtnText: 'Cancel'
            },
            template: 'partials/popup/confirm-popup.html',
        }).then(function (confirm) {
            if (ctrl.isForUser || ctrl.isQuoteForLoggedInUser()) {
                ctrl.isLoading = true;

                return (ctrl.isForUser
                    ? hsUserPayments.deletePaymentMethod(value.pmid, 
                        ctrl.quoteDetails.userObj.email, 
                        ctrl.location.uniqueName, 
                        ctrl.priceList.uniqueName
                    )
                    : hsUserPayments.deletePaymentMethod(value.pmid)
                )
                    .then(function(res) {
                        ctrl.quoteDetails.userObj = res;
                        ctrl.setCheckoutMethod();
                        toastr.success('Card Removed Successfully');
                    })
                    .catch(function(err) {
                        toastr.error(err);
                    })
                    .finally(function(){
                        ctrl.isLoading = false;
                    });
                
            } else {
                ctrl.setCheckoutMethod();
            }
        }, function (reject) {
            void 0;
            return;
        });
    };

    ctrl.handlePlaceOrder = function() {
        var headers = {
            location: ctrl.quoteDetails.location,
            pricelist: ctrl.quoteDetails.priceList,
        };

        var quote = {
            id: ctrl.quoteId,
        };

        if (ctrl.acceptCreditCard) {
            if (ctrl.isHouseChargeOrder) {
                quote.houseCharge = ctrl.isHouseChargeOrder;
            } else {
                quote.paymentMethod = ctrl.paymentMethod;
            }
        }

        var apiParams = {
            quote: quote
        };
        
        if (ctrl.quoteDetails.fulfillmentMethod !== hsAdminOrder.fulfillmentMethods.PICKUP) {
            if(ENV.driverTip){
                apiParams.quote.tip = +(ctrl.tips.driverTip).toFixed(2);
            }

            if(ENV.enableSeparateTips){
                apiParams.quote.shopperTip = +(ctrl.tips.shopperTip || 0).toFixed(2);
            }
        } else {
            apiParams.quote.shopperTip = +(ctrl.tips.shopperTip).toFixed(2);
        }

        ctrl.isLoading = true;
        hsAdminOrder.placeOrderForQuote(apiParams, headers)
            .then(function(response) {
                localStorageService.set('orderConfirmed', response);
                globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Quote Order', 'User placed Order Successfully.');
                if (ctrl.isForUser) {
                    $location.url('/admin/quote/' + ctrl.quoteId + '/confirmation?orderKey=' + encodeURIComponent(response.key));    
                } else {
                    $location.url('/cart/checkout/confirm');
                }
            })
            .catch(function(err) {
                if (err.status == 402) {
                    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'Order failed because of payment issues.');
                    ctrl.orderError = "Sorry, the payment card associated with your account was declined. To proceed with the order, please make sure the card has enough funds or ask the issuing bank to authorize this transaction or enter a new payment card.";
                } else {
                    globalFunctions.sendGAEvent(globalFunctions.GAEventType.USER_JOURNEY, 'Order', 'Order failed.');
                    ctrl.orderError = hsUtils.getMessageFromError(err.data, "Something went wrong. Please try again.");
                }
                ctrl.isLoading = false;
            })
    };

    ctrl.getDiscountDisplayText = function() {
        return hsAdminOrder.getDiscountDisplayText(ctrl.quoteDetails);
    };

    ctrl.showCreditCardHoldPopup = function() {
        var modalClass = 'ngdialog-theme-default email-capture';

        ngDialog.open({
            template: 'partials/popup/credit-card-hold-popup.html',
            controller:'ModalController',
            className: modalClass
        });
    };

    ctrl.showShopperTip = function() {
        return ctrl.shopperTipArray.length > 0 && (ENV.enableSeparateTips || ctrl.quoteDetails.fulfillmentMethod === hsAdminOrder.fulfillmentMethods.PICKUP);
    };

    ctrl.showDriverTip = function() {
        return ctrl.driverTipArray.length > 0;
    };

    ctrl.getTipLabel = function() {
        return hsCart.getTipLabel(ctrl.location.managedDeliveryTipShare);
    };

    ctrl.switchView = function(view) {
        ctrl.currentView = view;
    };

    ctrl.getPageTitle= function() {
        if (ctrl.currentView === ctrl.VIEWS.PAYMENT) {
            return 'Add Payment Method';
        }
        return 'Checkout';
    };
}
hsApp.component('quoteDetails', {
    bindings: {
        isAdminScreen: '@',
        backLink: '@',
    },
    templateUrl: '/partials/components/admin-order-v2/quote-details.html',
    controller: [
        '$routeParams',
        '$location',
        '$rootScope',
        '$scope',
        'hsAdminOrder',
        'hsUtils',
        'hsCart',
        'hsPromos',
        'globalFunctions',
        'hsProduct',
        'toastr',
        'hsAdmin',
        '$timeout',
        quoteDetailsController
    ],
});

function quoteDetailsController(
    $routeParams,
    $location,
    $rootScope,
    $scope,
    hsAdminOrder,
    hsUtils,
    hsCart,
    hsPromos,
    globalFunctions,
    hsProduct,
    toastr,
    hsAdmin,
    $timeout
) {
    var ctrl = this;
    var logPrefix = '[quoteDetails]: ';

    ctrl.QUOTE_STATE_DISPLAY_TEXT = hsAdminOrder.quoteStateDisplayText;

    ctrl.QUOTE_STATE_TAG_STYLE_MAP = hsAdminOrder.quoteStateTagStyleMap;

    ctrl.FULFILLMENT_METHOD_DISPLAY_TEXT = hsAdminOrder.fulfillmentMethodDisplayText;

    ctrl.$onInit = function () {
        void 0;
        ctrl.quoteId = $routeParams.quoteId;
        ctrl.isAddItemView = false;

        ctrl.editSections = {
            FULFILLMENT_DATE_TIME: 'fulfillment-date-time',
            DELIVERY_ADDRESS: 'delivery-address',
            DELIVERY_INSTRUCTIONS: 'delivery-instructions',
            ORDER_FEE: 'order-fee',
            SERVICE_FEE: 'service-fee',
            BOTTLE_FEE: 'bottle-fee',
            DISCOUNT: 'discount',
        };
        ctrl.editSectionTemplates = {
            'fulfillment-date-time': '../partials/components/admin-order-v2/quote-details-edit-fulfillment-date-time.html',
            'delivery-address': '../partials/components/admin-order-v2/quote-details-edit-delivery-address.html',
            'delivery-instructions': '../partials/components/admin-order-v2/quote-details-edit-delivery-instructions.html',
            'order-fee': '../partials/components/admin-order-v2/quote-details-edit-fees.html',
            'service-fee': '../partials/components/admin-order-v2/quote-details-edit-fees.html',
            'bottle-fee': '../partials/components/admin-order-v2/quote-details-edit-fees.html',
            'discount': '../partials/components/admin-order-v2/quote-details-edit-discount.html',
        };
        ctrl.editing = null;
        ctrl.loadingEditPage = false;

        ctrl.availableTimes = null;
        ctrl.emptyDatesObject = {};
        ctrl.updateParams = null;
        ctrl.emptyAddress = {
            street: '',
            aptUnit: '',
            city: '',
            state: '',
            zip: '',
        };
        ctrl.itemState = {};

        ctrl.quoteDetails = null;
        ctrl.sortedItems = null;
        ctrl.error = null;

        ctrl.isLoading = true;
        ctrl.getQuoteDetails()
            .then(function(quoteDetails) {
                ctrl.initQuoteDetails(quoteDetails)
            })
            .finally(function() {
                ctrl.isLoading = false;
            });


        $('#edit-quote-details').on('hidden.bs.modal', function (e) {
            ctrl.handleCloseEditPopup();
        });
    };

    ctrl.handleCloseEditPopup = function() {
        ctrl.updateParams = null;
    };

    ctrl.getQuoteDetails = function() {
        return hsAdminOrder.getQuoteDetails(ctrl.quoteId)
            .catch(function(err) {
                void 0;
                ctrl.error = "We have encountered an error while displaying the quote. We apologize for any inconvenience this may cause.";
            });
    };

    ctrl.initQuoteDetails = function(quoteDetails) {
        ctrl.quoteDetails = quoteDetails;
        ctrl.sortedItems = globalFunctions.filterProductsByCategory(ctrl.quoteDetails.items);
        ctrl.initItemsDefaults(ctrl.quoteDetails.items);
    };

    ctrl.initItemsDefaults = function(items) {
        if (!hsUtils.isNonEmptyArray(items)) return;

        items.forEach(function(item) {
            var id = ctrl.getItemId(item);
            // This is done so after one update is in progress
            // and another field is opened, on the completion
            // of the first update, the current editing state is preserved.
            if (!(id in ctrl.itemState)) {
                ctrl.itemState[id] = {
                    id: id,
                    showQuantityInput: false,
                    showPriceInput: false,
                    showInstructionsInput: false,
                    updatedInstructions: item.instructions || '',
                    updatedQuantity: item.quantity,
                    updatedWeight: '',
                    updatedPrice: '',
                    isUpdating: false,
                };
            }
            item.state = ctrl.itemState[id];
        });
    };

    ctrl.initDiscount = function() {
        var discount = ctrl.quoteDetails.discount;

        ctrl.updateParams = {
            selectedDiscount: 'adminDiscount',
        };
        ctrl.updateParams.adminDiscount = ctrl.getAdminDiscountParams(discount);
        ctrl.updateParams.discountCode = ctrl.getCouponDiscountParams(discount);

        if (!hsUtils.isObject(discount)) return;

        if (hsUtils.isNonEmptyString(discount.code) && discount.type !== 'adminDiscount') {
            ctrl.updateParams.selectedDiscount = 'coupon';
        }
    };

    ctrl.getAdminDiscountParams = function(discount) {
        var adminDiscountParams = {
            typeValue: hsAdmin.adminDiscountTypes.PERCENT,
            percentValue: 0,
            dollarValue: 0,
        };
        if (!hsUtils.isObject(discount)) return adminDiscountParams;

        if (discount.type === 'adminDiscount') {
            if ('percent' in discount) {
                adminDiscountParams.typeValue = hsAdmin.adminDiscountTypes.PERCENT;
                adminDiscountParams.percentValue = discount.percent;
            } else {
                adminDiscountParams.typeValue = hsAdmin.adminDiscountTypes.DOLLAR;
                adminDiscountParams.dollarValue = discount.value;
            }
        }
        return adminDiscountParams;
    };

    ctrl.getCouponDiscountParams = function(discount) {
        var discountCode = '';

        if (!hsUtils.isObject(discount)) return discountCode;

        if (discount.type !== 'adminDiscount') {
            discountCode = discount.code || '';
        }
        return discountCode;
    };

    ctrl.getErrorText = function() {
        if (hsUtils.isNonEmptyString(ctrl.error)) {
            return ctrl.error;
        } else if (ctrl.isQuoteExpired()) {
            return ctrl.getExpiredQuoteDisplayText();
        }
    };

    ctrl.getErrorTitle = function() {
        if (hsUtils.isNonEmptyString(ctrl.error)) {
            return "Failed to Load Details!";
        } else if (ctrl.isQuoteExpired()) {
            return "Quote Expired!";
        }
    };

    ctrl.getExpiredQuoteDisplayText = function() {
        var expiredQuoteText = '<span class="text-secondary-14">It seems that the quote you were viewing has expired. We apologize for any inconvenience this may cause.</span>';

        if (hsUtils.isNonEmptyString(ctrl.quoteDetails.supportPhoneNumber)) {
            expiredQuoteText += '<br /><br /> <hr />\
            <span class="text-secondary-14">To request a new quote, call us at</span> <br>\
            <span class="text-primary-16">' + ctrl.quoteDetails.supportPhoneNumber + '</span>';
        }
        return expiredQuoteText;
    };

    ctrl.isQuoteExpired = function() {
        return ctrl.quoteDetails && ctrl.quoteDetails.state === "expired";
    };

    ctrl.getFormattedDate = function (dateString) {
        return hsUtils.convertISOStringToDisplayTime(dateString);
    };

    ctrl.getQuoteStateDisplayText = function() {
        return ctrl.QUOTE_STATE_DISPLAY_TEXT[ctrl.quoteDetails.state] || '';
    };

    ctrl.getFulfillmentMethodDisplayText = function() {
        return ctrl.FULFILLMENT_METHOD_DISPLAY_TEXT[ctrl.quoteDetails.fulfillmentMethod] || '';
    };

    ctrl.getAddressDisplayTextLine1 = function() {
        return hsUtils.getAddressLine1(ctrl.quoteDetails.deliveryAddress);
    };

    ctrl.getAddressDisplayTextLine2 = function() {
        return hsUtils.getAddressLine2(ctrl.quoteDetails.deliveryAddress);
    };

    ctrl.getProductDisplayName = function(item) {
        return hsCart.getProductDisplayName(item);
    };

    ctrl.getRelevantPromotionForPrice = function (item) {
        return hsPromos.getRelevantPromotionForPrice(item, item.promotion);
    };

    ctrl.getProductItemizedTotal = function(item) {
        return hsCart.getProductItemizedTotal(item);
    };

    ctrl.getLocationInStoreString = function(locationInStore) {
        return hsProduct.getLocationInStoreString(locationInStore);
    };

    ctrl.calculateUnitQuantity = function(priceObj) {
        return hsCart.calculateUnitQuantity(priceObj);
    };

    ctrl.roundNumber = function(number) {
        return hsUtils.roundNumber(number);
    };
    
    ctrl.getDiscountDisplayText = function() {
        return hsAdminOrder.getDiscountDisplayText(ctrl.quoteDetails);
    };

    ctrl.isDeliveryQuote = function() {
        return ctrl.quoteDetails.fulfillmentMethod === hsAdminOrder.fulfillmentMethods.DELIVERY;
    };

    ctrl.beginCheckoutFlow = function() {
        var redirectUrl = '/quote/' + ctrl.quoteId + '/checkout';
        if (ctrl.isAdminScreen) {
            redirectUrl = '/admin' + redirectUrl;
        }
        return redirectUrl;
    };

    ctrl.showPlaceOrderButton = function() {
        return [ hsAdminOrder.quoteStates.PENDING, hsAdminOrder.quoteStates.EXPIRED ].includes(ctrl.quoteDetails.state);
    };

    ctrl.showEditButton = function() {
        return [ hsAdminOrder.quoteStates.PENDING, hsAdminOrder.quoteStates.EXPIRED ].includes(ctrl.quoteDetails.state) && ctrl.isAdminScreen;
    };
    
    ctrl.isDeletedUserAccount = function() {
        return hsAdminOrder.isDeletedUserAccount(ctrl.quoteDetails);
    };
    
    ctrl.getUserFullName = function() {
        if (ctrl.isDeletedUserAccount()) {
            return "Deleted User";
        }
        return ctrl.quoteDetails.userObj.firstName + ' ' + ctrl.quoteDetails.userObj.lastName;
    };

    ctrl.getUserEmail = function() {
        if (ctrl.isDeletedUserAccount()) {
            return "Not Available";
        }
        return ctrl.quoteDetails.userObj.email;
    };

    ctrl.getUserPhoneNumber = function() {
        if (ctrl.isDeletedUserAccount()) {
            return "Not Available";
        }
        return ctrl.quoteDetails.userObj.phoneNumber;
    };

    ctrl.getHeaderFromQuoteDetails = function() {
        return {
            location: ctrl.quoteDetails.location,
            pricelist: ctrl.quoteDetails.priceList
        };
    };

    ctrl.initDateTimeSelector = function() {
        ctrl.updateParams = {
            deliveryDate: null,
            deliveryTime: null,
        };

        var headers = ctrl.getHeaderFromQuoteDetails();

        ctrl.loadingEditPage = true;
        hsAdminOrder.getAvailableTimes(headers)
            .then(function(availableTimes) {
                ctrl.availableTimes = hsAdminOrder.indexAvailableTimesByDay(availableTimes);
            })
            .catch(function(err) {
                void 0;
                ctrl.updateError = "Failed to load available date and time options";
                ctrl.availableTimes = null;
                ctrl.updateParams = null;
            })
            .finally(function() {
                ctrl.loadingEditPage = false;
            });
    };

    ctrl.closeEditPopup = function() {
        $('#edit-quote-details').modal('hide');
        ctrl.editing = null;
    };

    ctrl.initDeliveryAddressUpdate = function() {
        ctrl.updateParams = {
            deliveryAddress: JSON.parse(JSON.stringify(ctrl.quoteDetails.deliveryAddress)),
        };
    };

    ctrl.toggleUpdatePopup = function(section) {
        ctrl.editing = section;
        ctrl.loadingEditPage = false;
        $('#edit-quote-details').modal('show');
        if (ctrl.editing === ctrl.editSections.FULFILLMENT_DATE_TIME) {
            ctrl.initDateTimeSelector();
        }

        if (ctrl.editing === ctrl.editSections.DELIVERY_ADDRESS) {
            ctrl.initDeliveryAddressUpdate();
        }
        if ([ ctrl.editSections.ORDER_FEE, ctrl.editSections.SERVICE_FEE, ctrl.editSections.BOTTLE_FEE ].includes(ctrl.editing)) {
            ctrl.initFeesUpdate();
        }
        if (ctrl.editing === ctrl.editSections.DELIVERY_INSTRUCTIONS) {
            ctrl.updateParams = {
                deliveryInstructions: ctrl.quoteDetails.deliveryInstructions || '',
            };
        }
        if (ctrl.editing === ctrl.editSections.DISCOUNT) {
            ctrl.initDiscount()
        }
    };

    ctrl.areAnyTimesAvailable = function () {
        return (ctrl.availableTimes
            && ctrl.shouldUseSlots()
            && ctrl.quoteDetails.fulfillmentMethod
            && hsUtils.isNonEmptyObject(ctrl.availableTimes[ctrl.quoteDetails.fulfillmentMethod])
        );
    };

    ctrl.shouldUseSlots = function () {
        var enableCustomFulfillmentTimes = ctrl.availableTimes && ctrl.availableTimes.enableCustomFulfillmentTimes;

        return ctrl.isQuote && (!$rootScope.onAdminPage || !enableCustomFulfillmentTimes);
    };

    ctrl.getMinAvailableDate = function () {
        if (!ctrl.areAnyTimesAvailable()) return null;

        var keys = Object.keys(ctrl.availableTimes[ctrl.quoteDetails.fulfillmentMethod]);
        return keys[0];
    };

    ctrl.getMaxAvailableDate = function () {
        if (!ctrl.areAnyTimesAvailable()) return null;

        var keys = Object.keys(ctrl.availableTimes[ctrl.quoteDetails.fulfillmentMethod]);
        return keys[keys.length - 1];
    };

    ctrl.getAvailableSlots = function () {
        var fulfillmentDateTime = ctrl.updateParams.deliveryDate;
        if (!ctrl.areAnyTimesAvailable() || !fulfillmentDateTime) return null;

        var dateString = hsUtils.getDateString(fulfillmentDateTime);
        return ctrl.availableTimes[ctrl.quoteDetails.fulfillmentMethod][dateString];
    };

    ctrl.getAvailableDates = function () {
        if (!ctrl.areAnyTimesAvailable()) return ctrl.emptyDatesObject;

        return ctrl.availableTimes[ctrl.quoteDetails.fulfillmentMethod];
    };

    ctrl.setUpdatedDate = function(date) {
        ctrl.updateParams.deliveryDate = date || null;

        if (ctrl.updateParams.deliveryTime) {
            var slots = ctrl.getAvailableSlots();
            if (!hsUtils.isNonEmptyArray(slots) || !slots.includes(ctrl.updateParams.deliveryTime)) {
                ctrl.updateParams.deliveryTime = null;
            }
        }
    };

    ctrl.setUpdatedTime = function(time) {
        ctrl.updateParams.deliveryTime = time || null;
    };

    ctrl.canUpdateFulfillmentDateTime = function() {
        var deliveryTimeSelected = hsUtils.isNonEmptyString(ctrl.updateParams.deliveryTime);

        if (hsUtils.isObject(ctrl.updateParams.deliveryTime)) {
            deliveryTimeSelected = hsUtils.isNonEmptyString(ctrl.updateParams.deliveryTime.hour)
                && hsUtils.isNonEmptyString(ctrl.updateParams.deliveryTime.minute)
                && hsUtils.isNonEmptyString(ctrl.updateParams.deliveryTime.meridian);
        }

        return ctrl.updateParams.deliveryDate && deliveryTimeSelected;
    };

    ctrl.hasAddressChanged = function() {
        delete ctrl.updateParams.deliveryAddress._isValid;
        delete ctrl.updateParams.deliveryAddress.country;
        return !_.isEqual(ctrl.updateParams.deliveryAddress, ctrl.quoteDetails.deliveryAddress);
    };

    ctrl.updateDeliveryAddress = function() {
        $scope.$broadcast('validateAddress-quote-details-edit-address', function(isValid) {
            if (!isValid) return;
            var params = {
                quote: {
                    deliveryAddress: JSON.parse(JSON.stringify(ctrl.updateParams.deliveryAddress))
                }
            };
            return ctrl.updateQuoteDetails(params, null);
        });
    };

    ctrl.updateQuoteDetails = function(params, errorMessage) {
        var headers = ctrl.getHeaderFromQuoteDetails();
        ctrl.loadingEditPage = true;
        return hsAdminOrder.updateQuoteDetails(params, headers, ctrl.quoteDetails.id)
            .then(function(quoteDetails) {
                ctrl.initQuoteDetails(quoteDetails);
                ctrl.closeEditPopup();
            })
            .catch(function(err) {
                void 0;
                toastr.error((errorMessage || err));
                ctrl.loadingEditPage = false;
            });
    };

    ctrl.updateQuoteItem = function(params, errorMessage) {
        return ctrl._updateQuoteItem(params)
            .then(function(quoteDetails) {
                ctrl.closeEditPopup();
            })
            .catch(function(err) {
                void 0;
                toastr.error((errorMessage || err));
            });
    };

    ctrl._updateQuoteItem = function(params) {
        var headers = ctrl.getHeaderFromQuoteDetails();

        return hsAdminOrder.updateQuoteItem(params, headers, ctrl.quoteDetails.id)
            .then(function(quoteDetails) {
                ctrl.initQuoteDetails(quoteDetails);
            });
    };

    ctrl.updateQuoteItemFromPopup = function(item) {
        var id = ctrl.getItemId(item);

        if (hsUtils.isNonEmptyArray(item.selectedModifiers)) {
            item.selectedModifiers = item.selectedModifiers.map(function(modifier) {
                return modifier.name;
            });
        }
        if (item._new) {
            return ctrl.addItemToQuote(item).then(function() {
                return 'added';
            });
        }
        if (!(item.quantity > 0)) {
            return ctrl._removeItem(item).then(function() {
                return 'removed';
            });
        }
        item.itemName = item.name;

        return ctrl._updateQuoteItem({ item: item })
            .then(function(quoteDetails) {

                if (id in ctrl.itemState) {
                    ctrl.itemState[id].updatedQuantity = item.quantity;
                    ctrl.itemState[id].updatedWeight = '';
                    ctrl.itemState[id].showQuantityInput = false;
                }
                return 'updated';
            });
    };

    ctrl.updateFulfillmentDateTime = function() {
        var params = {
            quote: {
                deliveryDate: hsAdminOrder.getFulfillmentDateString(ctrl.updateParams.deliveryDate),
                deliveryTime: hsAdminOrder.getFulfillmentTimeString(ctrl.updateParams.deliveryTime)
            }
        };

        var errorMessage = "Failed to update quote " + ctrl.getFulfillmentMethodDisplayText() + " date and time. Please try again or contact support.";
        return ctrl.updateQuoteDetails(params, errorMessage);

    };

    ctrl.getUpdatePopupTitle = function() {
        switch (ctrl.editing) {
            case ctrl.editSections.ORDER_FEE:
                return 'Update ' + (ctrl.isDeliveryQuote() ? 'Delivery ' : 'Order ') + ' Charges';
            case ctrl.editSections.SERVICE_FEE:
                return 'Update Service Fee';
            case ctrl.editSections.BOTTLE_FEE:
                return 'Update Bottle Fee';
            default:
                return '';
        }
    };

    ctrl.hasFeeChanged = function() {
        var propertyName = ctrl.getPropertyNameUnderUpdate();

        if (propertyName) {
            return ctrl.updateParams[propertyName] !== ctrl.quoteDetails[propertyName];
        }
        return false;
    };

    ctrl.initFeesUpdate = function() {
        var propertyName = ctrl.getPropertyNameUnderUpdate();

        if (propertyName) {
            ctrl.updateParams = {};
            ctrl.updateParams[propertyName] = ctrl.quoteDetails[propertyName];
        } else {
            ctrl.updateParams = null;
        }
    };

    ctrl.getPropertyNameUnderUpdate = function() {
        switch (ctrl.editing) {
            case ctrl.editSections.ORDER_FEE:
                return 'orderFee';
            case ctrl.editSections.SERVICE_FEE:
                return 'serviceFee';
            case ctrl.editSections.BOTTLE_FEE:
                return 'bottleFee';
            default:
                return null;
        }
    };

    ctrl.updateFee = function() {
        var propertyName = ctrl.getPropertyNameUnderUpdate();

        if (!propertyName) return;

        var params = { quote: {} };
        params.quote[propertyName] = ctrl.updateParams[propertyName];

        // This will revert admin changes and reset the fee to the originally calculated value.
        if (params.quote[propertyName] === undefined) {
            params.quote[propertyName] = null;
        }
        return ctrl.updateQuoteDetails(params);
    };

    ctrl.onAdminDiscountChange = function(value) {
        ctrl.updateParams.adminDiscount = value;
    };

    ctrl.hasAdminDiscountChanged = function() {
        var existingParams = ctrl.getAdminDiscountParams(ctrl.quoteDetails.discount);
        return existingParams.typeValue !== ctrl.updateParams.adminDiscount.typeValue
            || existingParams.typeValue === hsAdmin.adminDiscountTypes.PERCENT
                && existingParams.percentValue !== ctrl.updateParams.adminDiscount.percentValue
            || existingParams.typeValue === hsAdmin.adminDiscountTypes.DOLLAR
                && existingParams.dollarValue !== ctrl.updateParams.adminDiscount.dollarValue
    };

    ctrl.updateAdminDiscount = function() {
        if (!ctrl.updateParams.adminDiscount.validate || !ctrl.updateParams.adminDiscount.validate()) return;

        var adminDiscount = {
            type: ctrl.updateParams.adminDiscount.typeValue,
        };
        if (adminDiscount.type === hsAdmin.adminDiscountTypes.PERCENT) {
            if (ctrl.updateParams.adminDiscount.percentValue === 0) {
                adminDiscount = null;
            } else {
                adminDiscount.percent = ctrl.updateParams.adminDiscount.percentValue;
            }
        } else {
            if (ctrl.updateParams.adminDiscount.dollarValue === 0) {
                adminDiscount = null;
            } else {
                adminDiscount.value = ctrl.updateParams.adminDiscount.dollarValue;
            }
        }
        return ctrl.updateQuoteDetails({ quote: { adminDiscount: adminDiscount } });
    };

    ctrl.haveInstructionsChanged = function() {
        return ctrl.updateParams.deliveryInstructions !== ctrl.quoteDetails.deliveryInstructions;
    };

    ctrl.updateDeliveryInstructions = function() {
        var params = { quote: { deliveryInstructions: ctrl.updateParams.deliveryInstructions } };
        return ctrl.updateQuoteDetails(params);
    };

    ctrl.shouldShowItemQuantityUpdateButton = function(item) {
        return ctrl.quoteDetails.state === hsAdminOrder.quoteStates.PENDING;
    };

    ctrl.toggleItemQuantityInput = function(item) {
        item.state.showQuantityInput = !item.state.showQuantityInput;
    };

    ctrl.toggleItemPriceInput = function(item) {
        item.state.showPriceInput = !item.state.showPriceInput;
    };

    ctrl.updateQuantityInputValue = function (item, updateType, quantityBtnSelector) {
        quantityBtnSelector = '#' + quantityBtnSelector;
        var updateBtnSelector = quantityBtnSelector.replace('quantity', 'update-btn');
        hsCart.updateQuantity(item, updateType, quantityBtnSelector, updateBtnSelector);
        item.state.updatedQuantity = $(quantityBtnSelector).val();
    };

    ctrl.getCommonItemParams = function(item) {
        var params = {
            itemName: item.name,
        };
        if (hsUtils.isNonEmptyArray(item.selectedModifiers)) {
            params.selectedModifiers = item.selectedModifiers.map(function(modifier) {
                return modifier.name
            });
        }
        return params;
    };

    ctrl.updateItemQuantity = function (item) {
        var quantity = $('#quantity-' + item.state.id).val();
        var params = ctrl.getCommonItemParams(item);
        params.quantity = +quantity;
        item.state.isUpdating = true;

        return ctrl.updateQuoteItem({ item: params })
            .then(function() {
                item.state.updatedWeight = '';
                item.state.showQuantityInput = false;
            })
            .finally(function() {
                item.state.isUpdating = false;
            });
    };

    ctrl.updateItemPrice = function(item) {
        var price = $('#price-' + item.state.id).val();

        if (price === '' || isNaN(price)) return;

        var params = ctrl.getCommonItemParams(item);
        params.price = +price;
        item.state.isUpdating = true;

        return ctrl.updateQuoteItem({ item: params })
            .finally(function() {
                item.state.updatedPrice = '';
                item.state.isUpdating = false;
                item.state.showPriceInput = false;
            });
    };

    ctrl.handleInstructionsOnBlur = function(item) {
        if (item.state.isUpdating || item.instructions !== item.state.updatedInstructions) return;

        item.state.onBlur = $timeout(function() {
            item.state.showInstructionsInput = false;
            // need some delay to handle two events: on-blur in combination with toggle or save
        }, 250);
    };

    ctrl.toggleEditInstructions = function(item, currentState) {
        if (item.state.isUpdating) return;

        if (!item.state.showInstructionsInput) {
            item.state.showInstructionsInput = true;
            item.state.updatedInstructions = item.instructions;

            $timeout(function() {
                var element = $('#item-instructions-' + item.state.id);

                if (element) {
                    element.focus();
                }
            }, 0);
        } else {
            if (item.instructions !== item.state.updatedInstructions) {
                ctrl.updateItemInstructions(item);
            } else {
                if (item.state.onBlur) {
                    $timeout.cancel(item.state.onBlur);
                    delete item.state.onBlur;
                }
                item.state.showInstructionsInput = false;
            }
        }
    };

    ctrl.updateItemInstructions = function(item) {
        if (item.state.onBlur) {
            $timeout.cancel(item.state.onBlur);
            delete item.state.onBlur;
        }
        if (item.state.isUpdating) return;

        if (item.instructions === item.state.updatedInstructions) {
            item.state.showInstructionsInput = false;
            return;
        }
        var params = ctrl.getCommonItemParams(item);
        params.instructions = item.state.updatedInstructions;
        item.state.isUpdating = true;

        return ctrl.updateQuoteItem({ item: params })
            .finally(function() {
                item.state.isUpdating = false;
                item.state.showInstructionsInput = false;
            });
    };

    ctrl.getItemId = function(item) {
        var id = item.name;

        if (hsUtils.isNonEmptyArray(item.selectedModifiers)) {
            id += item.selectedModifiers.map(function(modifier) {
                return modifier.name
            }).join('');
        }
        return id.replace(/[^a-zA-Z0-9]/g, '-');
    };

    ctrl.removeItem = function(item) {
        if (item.state.isUpdating) return;

        item.state.isUpdating = true;

        var headers = ctrl.getHeaderFromQuoteDetails();

        return ctrl._removeItem(item)
            .catch(function(err) {
                void 0;
                toastr.error((err));
                item.state.isUpdating = false;
            });
    };

    ctrl._removeItem = function(item) {
        var id = item.state.id;
        var headers = ctrl.getHeaderFromQuoteDetails();

        return hsAdminOrder.removeQuoteItem(item, headers, ctrl.quoteDetails.id)
            .then(function(quoteDetails) {
                delete ctrl.itemState[id];
                ctrl.initQuoteDetails(quoteDetails);
            });
    };

    ctrl.showAddItem = function(show) {
        ctrl.isAddItemView = show;
    };

    ctrl.addItemToQuote = function(item) {
        var headers = ctrl.getHeaderFromQuoteDetails();

        if (item.isCustomItem) {
            item.itemName = item.displayName;
        } else {
            item.itemName = item.name;
            item.quantity = item.quantity || ctrl.getItemIncrement(item);
        }
        return hsAdminOrder.addQuoteItem(item, headers, ctrl.quoteDetails.id)
            .then(function(quoteDetails) {
                ctrl.initQuoteDetails(quoteDetails);
            });
    };

    ctrl.handleQuantityChangeFromPopup = function (item, operation) {
        var increment = (operation === 'decrement' ? -1 : 1) * ctrl.getItemIncrement(item);
        var newQuantity = item.quantity + increment;

        if (!(newQuantity > 0)) {
            return ctrl._removeItem(item).then(function() {
                return 'removed';
            });
        } else {
            var params = ctrl.getCommonItemParams(item);
            params.quantity = newQuantity;

            return ctrl._updateQuoteItem({ item: params })
                .then(function() {
                    item.state.updatedQuantity = params.quantity;
                    item.state.updatedWeight = '';
                    item.state.showQuantityInput = false;

                    return 'updated';
                });
        }

    };

    ctrl.getItemIncrement = function(item) {
        var increment = 1;
        if (!item.sellByQty && item.unit === 'lb') {
            increment = 0.5;
        }
        if (item.unitIncrement) {
            increment = item.unitIncrement;
        }
        return increment;
    };
}

hsApp.component('quotes', {
    templateUrl: '/partials/components/admin-order-v2/quotes.html',
    controller: [ '$location', 'hsAdminOrder', 'hsUtils', 'NgTableParams', 'toastr', quotesController ],
});

function quotesController($location, hsAdminOrder, hsUtils, NgTableParams, toastr) {
    var ctrl = this;
    var logPrefix = '[quotes]: ';

    ctrl.QUOTE_STATE_DISPLAY_TEXT = hsAdminOrder.quoteStateDisplayText;
    ctrl.QUOTE_STATE_TAG_STYLE_MAP = hsAdminOrder.quoteStateTagStyleMap;
    ctrl.FULFILLMENT_METHOD_DISPLAY_TEXT = hsAdminOrder.fulfillmentMethodDisplayText;

    ctrl.$onInit = function () {
        void 0;
        ctrl.isLoading = true;
        ctrl.error = null;
        ctrl.quotes = null;
        ctrl.listQuotes()
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.listQuotes = function() {
        return hsAdminOrder.listQuotes(true)
            .then(function(quotes) {
                ctrl.quotes = quotes;
                ctrl.createTable();
            })
            .catch(function(err) {
                void 0;
                ctrl.error = "We have encountered an error while displaying the quotes. We apologize for any inconvenience this may cause.";
            });
    };

    ctrl.isDeletedUserAccount = function(quote) {
        return hsAdminOrder.isDeletedUserAccount(quote);
    }

    ctrl.getTableData = function() {
        if (!hsUtils.isNonEmptyArray(ctrl.quotes)) {
            return [];
        }

        return ctrl.quotes.map(function(quote) {
            return {
                id: quote.id,
                deletedAccount: ctrl.isDeletedUserAccount(quote), 
                customerName: ctrl.isDeletedUserAccount(quote) ? 'Deleted User' : quote.userObj.firstName + ' ' + quote.userObj.lastName,
                createdOn: hsUtils.convertISOStringToDisplayTime(quote.timeCreated),
                createdDate: new Date(quote.timeCreated),
                fulfillmentDateTime: new Date(quote.fulfillmentDateTime),
                fulfillment: quote.deliveryDate + ' ' + quote.deliveryTime,
                mode: ctrl.FULFILLMENT_METHOD_DISPLAY_TEXT[quote.fulfillmentMethod],
                location: quote.locationDisplayName,
                items: quote.items.length,
                price: quote.amountToCharge,
                status: quote.state,
                stateDescription: quote.stateDescription,
            };
        });
    };

    ctrl.createTable = function() {
        var tableData = ctrl.getTableData();
        ctrl.ngTableParams = new NgTableParams(
            {count: 15},
            {counts: [15, 30, 50], dataset: tableData}
        );
    };
    
    ctrl.hasNoQuotes = function() {
        return hsUtils.isEmptyArray(ctrl.quotes);
    };

    ctrl.navigateToCreateNewQuoteFlow = function() {
        $location.url('/admin/create-quote');
    };

    ctrl.getQuoteIdDisplayText = function(id) {
        return '. . . ' + id.slice(-8);
    };

    ctrl.sendQuoteEmail = function(id) {
        hsAdminOrder.sendQuoteEmail(id)
            .then(function() {
                toastr.success('Email sent');
            })
            .catch(function(err) {
                toastr.error(err);
            });
    }


}
hsApp.component('selectOrderFilters', {
    templateUrl: '/partials/components/admin-order-v2/select-order-filters.html',
    bindings: {
        isQuote: '<',
    },
    controller: [ '$timeout', '$rootScope', '$scope', 'hsAdminOrder', 'hsUserPayments', 'hsUtils', '$filter', 'globalFunctions', 'ngDialog', '$location', selectOrderFiltersController ],
});

function selectOrderFiltersController($timeout, $rootScope, $scope, hsAdminOrder, hsUserPayments, hsUtils, $filter, globalFunctions, ngDialog, $location) {
    var ctrl = this;
    var logPrefix = '[selectOrderFilters]: ';

    ctrl.$onInit = function () {
        void 0;
        ctrl.isLoading = true;
        ctrl.availableTimes = null;
        ctrl.emptyDatesObject = {};

        ctrl.initForms();
        ctrl.initLoaders();
        ctrl.initErrors();

        ctrl.selectedFilters = hsAdminOrder.SELECTED_FILTERS;
        
        ctrl.fulfillmentMethods = hsAdminOrder.fulfillmentMethods;
        ctrl.fulfillmentMethodDisplayNames = {
            'pickup': 'Pickup',
            'delivery': 'Delivery'
        };
        ctrl.steps = hsAdminOrder.steps;
        ctrl.currentStep = ctrl.steps.PRICELIST;
        ctrl.nextSteps = hsAdminOrder.getNextSteps(ctrl.isQuote);
        
        hsAdminOrder.getTenantAvailability(ctrl.selectedFilters.address, ctrl.isQuote)
            .catch(function(err) {
                void 0;
                ctrl.error = "Failed to load page. Please try again or contact support";
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
        ctrl.getUsers();
        $scope.hsAdminOrder = hsAdminOrder;

        ctrl.options = null;
        $scope.$watch('hsAdminOrder.options', function() {
            ctrl.options = hsAdminOrder.options;
        });

        ctrl.availableOptions = null;
        $scope.$watch('hsAdminOrder.availableOptions', function() {
            ctrl.availableOptions = hsAdminOrder.availableOptions;
        });

        ctrl.users = null;
        $scope.$watch('hsAdminOrder.users', function() {
            ctrl.users = hsAdminOrder.users;
        });

        ctrl.userSearchQueryResult = null;
        $scope.$watch('hsAdminOrder.userSearchQueryResult', function() {
            ctrl.userSearchQueryResult = hsAdminOrder.userSearchQueryResult;
            if (ctrl.userSearchQueryResult && ctrl.userSearchQueryResult.length) {
                ctrl.clearUserError();
            }
        });
        $scope.$watch('hsAdminOrder.SELECTED_FILTERS.deliveryInstructions', function() {
            ctrl.deliveryInstructionsInput = hsAdminOrder.SELECTED_FILTERS.deliveryInstructions || '';
        });
        $scope.$watch('hsAdminOrder.SELECTED_FILTERS.user', function() {
            ctrl.applicablePaymentMethods = hsAdminOrder.getApplicableUserPaymentMethods(hsAdminOrder.SELECTED_FILTERS.user);
        });

        if (ctrl.isQuote) {
            $scope.$watchGroup(
                [
                    'hsAdminOrder.SELECTED_FILTERS.location',
                    'hsAdminOrder.SELECTED_FILTERS.priceList',
                    'hsAdminOrder.SELECTED_FILTERS.fulfillmentMethod',
                ],
                function() {
                    ctrl.getAvailableTimes();
                }
            );
        }
    }

    ctrl.initLoaders = function() {
        ctrl.isLoadingUser = false;
        ctrl.isLoadingPaymentMethod = false;
        ctrl.isLoadingAddress = false;
        ctrl.isLoadingDeliveryInstructions = false;
    }

    ctrl.initErrors = function() {
        ctrl.error = null;
        ctrl.userError = null;
        ctrl.addressError = null;
        ctrl.deliveryInstructionsError = null;
        ctrl.stepsErrors = {
            user: false,
            paymentMethod: false,
            location: false,
            priceList: false,
            fulfillmentMethod: false,
            deliveryInstructions: false,
            fulfillmentDateTime: false,
        };
    }

    ctrl.initForms = function() {
        ctrl.searchQuery = null;
        ctrl.isNewUser = false;
        ctrl.address = {};
        ctrl.showUpdateAddressForm = false;
        ctrl.deliveryInstructionsInput = '';
        $timeout(function() {
            // this is required so that the date-time-selector form updates
            // to the values in hsAdminOrder.SELECTED_FILTERS
            $scope.$apply();
        }, 0);
    }

    ctrl.proceed = function () {
        ctrl.setStepsErrors();
        if (!hsAdminOrder.isFiltersSelectionComplete(ctrl.isQuote)) {
            return;
        }
        $location.url(hsAdminOrder.getBaseUrl(ctrl.isQuote) + '/add-items');
    };

    ctrl.setStepsErrors = function (option) {
        switch (option) {
            case ctrl.steps.USER:
                ctrl.stepsErrors.user = !ctrl.selectedFilters.user;
                break;
            case ctrl.steps.LOCATION:
                ctrl.stepsErrors.location = !ctrl.selectedFilters.location;
                break;
            case ctrl.steps.PRICELIST:
                ctrl.stepsErrors.priceList = !ctrl.selectedFilters.priceList;
                break;
            case ctrl.steps.FULFILLMENT_METHOD:
            case ctrl.steps.ADDRESS:
                ctrl.stepsErrors.fulfillmentMethod = !ctrl.selectedFilters.fulfillmentMethod;
                ctrl.setAddressStepError();
                break;
            case ctrl.steps.DELIVERY_INSTRUCTIONS:
                ctrl.stepsErrors.deliveryInstructions = ctrl.selectedFilters.fulfillmentMethod === 'delivery'
                    && hsUtils.isNonEmptyString(ctrl.deliveryInstructionsError)
                break;
            case ctrl.steps.FULFILLMENT_DATE:
            case ctrl.steps.FULFILLMENT_TIME:
                if (ctrl.stepsErrors.fulfillmentDateTime && ctrl.selectedFilters.fulfillmentDate && ctrl.selectedFilters.fulfillmentTime) {
                    ctrl.stepsErrors.fulfillmentDateTime = false;
                }
                break;
            default:
                ctrl.setAllStepsErrors();
        }
    };

    ctrl.setAllStepsErrors = function () {
        ctrl.stepsErrors.user = !ctrl.selectedFilters.user;
        ctrl.stepsErrors.location = !ctrl.selectedFilters.location;
        ctrl.stepsErrors.priceList = !ctrl.selectedFilters.priceList;
        ctrl.stepsErrors.fulfillmentMethod = !ctrl.selectedFilters.fulfillmentMethod;
        ctrl.stepsErrors.fulfillmentDateTime = !ctrl.selectedFilters.fulfillmentDate || !ctrl.selectedFilters.fulfillmentTime;
        ctrl.setAddressStepError();
    };

    ctrl.setAddressStepError = function () {
        if (!ctrl.stepsErrors.fulfillmentMethod
            && ctrl.selectedFilters.fulfillmentMethod === hsAdminOrder.fulfillmentMethods.DELIVERY
            && !ctrl.selectedFilters.address
        ) {
            ctrl.stepsErrors.fulfillmentMethod = true;
        }
    };

    ctrl.getUsers = function() {
        ctrl.isLoadingUser = true;
        return hsAdminOrder.getUsers()
            .catch(function(err) {
                ctrl.userError = err; 
            })
            .finally(function() {
                ctrl.isLoadingUser = false;
            })

    }

    ctrl.switchStep = function(step) {
        if (ctrl.isQuote && step === ctrl.steps.FULFILLMENT_DATE_TIME) {
            ctrl.setStepsErrors(ctrl.steps.LOCATION);
            ctrl.setStepsErrors(ctrl.steps.PRICELIST);
            ctrl.setStepsErrors(ctrl.steps.FULFILLMENT_METHOD);
        }
        ctrl.currentStep = step;
    }

    ctrl.getUser = function(value) {
        if (!hsUtils.isObject(value)) {
            throw 'Invalid User';
        }

        return hsAdminOrder.getUser(value.email);
    }

    ctrl.setFilterPriceList = function(option, value) {
        hsAdminOrder.setFilter(option, value, ctrl.isQuote)
            .then(function(response) {
                if (response.switchStep) {
                    ctrl.switchStep(ctrl.nextSteps[option]);
                }
            })
            .catch(function (err) {
                void 0;
            })
            .finally(function() {
                ctrl.setStepsErrors(option);
            });
    }

    ctrl.handleAddressError = function() {
        var userAddress = hsAdminOrder.getUserAddress();

        if (hsUtils.isObject(userAddress) && ctrl.selectedFilters.fulfillmentMethod === ctrl.fulfillmentMethods.DELIVERY) {
            ctrl.addressError = 'Cannot deliver to specified address. Please enter a new address or select Pickup';
            ctrl.address = Object.assign({}, userAddress);
        } else {
            ctrl.addressError = null;
            ctrl.address = {};
        }

        ctrl.showUpdateAddressForm = true;
    }

    ctrl.checkFulfillmentAddress = function() {
        if (!hsUtils.isObject(ctrl.selectedFilters.address)) {
            ctrl.handleAddressError();
            return false;
        } else {
            ctrl.addressError = null;
            ctrl.showUpdateAddressForm = false;
            return true;
        }
    }

    ctrl.setFilterUser = function(option, value, currentStepOverride) {
        ctrl.isLoadingUser = true;
        ctrl.isLoadingPaymentMethod = true;
        ctrl.isLoadingAddress = true;
        ctrl.isLoadingDeliveryInstructions = true;
        return ctrl.getUser(value)
            .then(function(response) {
                return hsAdminOrder.setFilter(option, response, ctrl.isQuote)
                    .then(function(res) {
                        ctrl.addressError = null;
                        var isValidAddress = ctrl.checkFulfillmentAddress();

                        if (res.switchStep && (isValidAddress || currentStepOverride !== ctrl.steps.ADDRESS)) {
                            ctrl.switchStep(ctrl.nextSteps[currentStepOverride || option]);
                        }
                    });
            })
            .catch(function(err) {
                ctrl.handleAddressError();
                ctrl.switchStep(ctrl.steps.FULFILLMENT_METHOD);
            })
            .finally(function() {
                ctrl.setStepsErrors(option);

                if (hsUtils.isNonEmptyString(ctrl.selectedFilters.fulfillmentMethod)) {
                    ctrl.setStepsErrors(ctrl.steps.FULFILLMENT_METHOD);
                }
                ctrl.setStepsErrors(ctrl.steps.DELIVERY_INSTRUCTIONS);
                ctrl.isLoadingUser = false;
                ctrl.isLoadingPaymentMethod = false;
                ctrl.isLoadingAddress = false;
                ctrl.isLoadingDeliveryInstructions = false;
            })
    }

    ctrl.setFilterFulfillmentMethod = function(option, value) {

        var deliverySelected = ctrl.selectedFilters.fulfillmentMethod !== hsAdminOrder.fulfillmentMethods.DELIVERY
            && value === hsAdminOrder.fulfillmentMethods.DELIVERY;

        ctrl.addressError = null;
        hsAdminOrder.setFilter(option, value, ctrl.isQuote)
            .then (function(response) {
                if (deliverySelected) {
                    var userAddress = hsAdminOrder.getUserAddress();
                    if (hsUtils.isObject(userAddress)) {
                        ctrl.address = Object.assign({}, userAddress);
                        ctrl.setFilter(ctrl.steps.ADDRESS, userAddress);
                    }
                } else {
                    if (response.switchStep) {
                        ctrl.switchStep(ctrl.nextSteps[option]);
                    }
                }
            })
            .catch(function (err) {
                if (deliverySelected) {
                    ctrl.handleAddressError();
                }
            })
            .finally(function() {
                ctrl.setStepsErrors(option);
            });
    }

    ctrl.setFulfillmentDate = function(option, fulfillmentDate) {
        if (isNaN(Date.parse(fulfillmentDate))) {
            return;
        }
        hsAdminOrder.setFilter(option, fulfillmentDate, ctrl.isQuote)
            .finally(function () {
                if (ctrl.isQuote && ctrl.selectedFilters.fulfillmentTime) {
                    var slots = ctrl.getAvailableSlots();

                    if (!hsUtils.isNonEmptyArray(slots) || !slots.includes(ctrl.selectedFilters.fulfillmentTime)) {
                        // clear the time selection by toggling the already selected value
                        ctrl.setFulfillmentTime(ctrl.steps.FULFILLMENT_TIME, ctrl.selectedFilters.fulfillmentTime);
                    }
                }
                ctrl.setStepsErrors(option);
            });
    }

    ctrl.setFulfillmentTime = function(option, fulfillmentTime) {
        if (!ctrl.shouldUseSlots() && !hsUtils.isObject(fulfillmentTime) || ctrl.shouldUseSlots() && !hsUtils.isNonEmptyString(fulfillmentTime)) {
            return;
        }
        hsAdminOrder.setFilter(option, fulfillmentTime, ctrl.isQuote)
            .finally(function () {
                ctrl.setStepsErrors(option);
            });
    }
    ctrl.setFilterLocation = function(option, value) {
        hsAdminOrder.setFilter(option, value, ctrl.isQuote)
            .then(function(response) {
                if (response.switchStep) {
                    ctrl.switchStep(ctrl.nextSteps[option]);
                }
            })
            .catch(function(err) {
                ctrl.handleAddressError();
            })
            .finally(function(){
                ctrl.setStepsErrors(option);
                ctrl.isLoadingAddress = false;
            });
    };

    ctrl.setFilter = function(option, value) {
        switch(option) {
            case ctrl.steps.PRICELIST:
                ctrl.setFilterPriceList(option, value);
                break;
            case ctrl.steps.USER:
                return ctrl.setFilterUser(option, value);
                break;
            case ctrl.steps.FULFILLMENT_METHOD:
                ctrl.setFilterFulfillmentMethod(option, value);
                break;
            case ctrl.steps.DELIVERY_INSTRUCTIONS:
                ctrl.setFilterDeliveryInstructions(option, value);
                break;
            case ctrl.steps.ADDRESS:
                ctrl.setFilterUser(ctrl.steps.USER, ctrl.selectedFilters.user, ctrl.steps.ADDRESS);
                break;
            case ctrl.steps.LOCATION:
                ctrl.setFilterLocation(option, value);
                break;
            case ctrl.steps.FULFILLMENT_DATE:
                ctrl.setFulfillmentDate(option, value);
                break;
            case ctrl.steps.FULFILLMENT_TIME:
                ctrl.setFulfillmentTime(option, value);
                break;
            default:
                hsAdminOrder.setFilter(option, value, ctrl.isQuote);
                break;
        }
    }

    ctrl.clearUserError = function() {
        ctrl.userError = null;
    }

    ctrl.clearSearchField = function() {
        ctrl.clearUserError();
        ctrl.searchQuery = null;
    }

    ctrl.searchUser = function() {
        var searchParam = ctrl.searchQuery;
        try {
            hsAdminOrder.filterUsers(searchParam);
        } catch(err) {
            ctrl.userError = err;
        }
    }

    ctrl.getSelectedUserName = function() {
        var selectedUser = ctrl.selectedFilters.user
        if (!hsUtils.isObject(selectedUser)) {
            return null;
        }

        return ctrl.getUserDetails(selectedUser, 'fullName');
    }

    ctrl.getUserDetails = function(user, field) {
        if (!hsUtils.isObject(user)) {
            return null;
        }
        
        switch(field){
            case 'fullName':
                return user.firstName + ' ' + user.lastName || '';
            case 'email':
                return user.email || '';
            case 'phoneNumber':
                return user.phoneNumber || '';
            default:
                return '';
        };
    }

    ctrl.toggleUserSelection = function() {
        ctrl.clearUserError();
        ctrl.isNewUser = !ctrl.isNewUser;
    }

    ctrl.getUserBody = function(newUser) {
        var phoneNumber = newUser.phoneNumber.trim();
        phoneNumber = $filter('bcTelephone')(phoneNumber, 'clean');
        var body = {
            newUser: {
                emailId: newUser.email.trim().toLowerCase(),
                firstName: newUser.firstName.trim(),
                lastName: newUser.lastName.trim(),
                phoneNumber: phoneNumber,
            }
        };

        return body;
    }

    ctrl._signup = function(body) {
        return hsAdminOrder.signup(body)
            .then(function(response) {
                var newUser = response.data;
                return ctrl.getUsers()
                    .then(function() {
                        ctrl.searchQuery = newUser.email;
                        ctrl.searchUser();
                        ctrl.setFilter(ctrl.steps.USER, newUser);
                        ctrl.isNewUser = false;
                    })
            })
            .catch(function(err) {
                ctrl.userError = err;
                ctrl.isLoadingUser = false;
            });
    }

    ctrl.handlePhoneNumberVerificationSignup = function(body) {
        var phoneNumber = body.newUser.phoneNumber;
        var $newScope = $scope.$new(true);
        $newScope.phoneNumber = phoneNumber;

        ngDialog.open({
            template: '<div><code-verification '
                + 'phone-number="phoneNumber" '
                + 'on-close="closeThisDialog(value)" '
                + '></code-verification></div>',
            className: 'ngdialog-theme-default',
            plain: true,
            scope: $newScope,
        }).closePromise
            .then(function(data) {
                void 0;
                if (data.value) {
                    if (data.value.error) {
                        ctrl.userError = data.value.error;
                        ctrl.isLoadingUser = false;
                    } else if (data.value === 'success') {
                        ctrl._signup(body);
                    } else {
                        ctrl.userError = 'Could not verify phone number. Please try again.';        
                        ctrl.isLoadingUser = false;
                    }
                }
            })
            .catch(function(err) {
                void 0;
                ctrl.userError = 'Could not verify phone number. Please try again.';
                ctrl.isLoadingUser = false;
            })

    }
    
    ctrl.processNewUser = function(value) {
        var body = ctrl.getUserBody(value);

        ctrl.isLoadingUser = true;
        var selectedLocation = globalFunctions.getSelectedLocationFromStorage();
        if (selectedLocation.requiresPhoneNumberVerification) {
            ctrl.handlePhoneNumberVerificationSignup(body);
        } else {
            ctrl._signup(body);
        }
    }

    ctrl.toggleShowUpdateAddressForm = function () {
        ctrl.showUpdateAddressForm = !ctrl.showUpdateAddressForm;
    }

    ctrl.setAddress = function() {
        $scope.$broadcast('validateAddress-admin-order-address', function(isValid) {
            if (!isValid) {
                return;
            } 

            var newAddress = Object.assign({}, ctrl.address);
            var userData = {
                userParams: {
                    address: newAddress,
                },
            };

            ctrl.isLoadingAddress = true;
            hsAdminOrder.updateUser(userData)
                .then(function(response){
                    var updatedUser = response.data;
                    ctrl.setFilterUser(ctrl.steps.USER, updatedUser, ctrl.steps.ADDRESS)
                    
                })
                .catch(function(err) {
                    ctrl.addressError = "Failed to updated address. Please try again or contact support";
                    ctrl.isLoadingAddress = false;
                });
        });
    }

    ctrl.setFilterDeliveryInstructions = function(option, value) {
        ctrl.deliveryInstructionsError = null;

        if (ctrl.selectedFilters.deliveryInstructions === ctrl.deliveryInstructionsInput) {
            return ctrl.switchStep(ctrl.nextSteps[option]);
        }

        var userData = {
            userParams: {
                deliveryInstructions: value
            }
        };

        ctrl.isLoadingDeliveryInstructions = true;
        return hsAdminOrder.updateUser(userData)
            .then(function(response) {
                var updatedUser = response.data;
                ctrl.setFilterUser(ctrl.steps.USER, updatedUser, option);
            })
            .catch(function(error) {
                void 0;
                ctrl.deliveryInstructionsError = "Failed to update delivery instructions. Please try again or contact support";
                ctrl.isLoadingDeliveryInstructions = false;
            });
    }

    ctrl.formatAddress = function(address) {
        if(hsUtils.isObject(address)) {
            return address.street + ' ' + (address.aptUnit ? address.aptUnit + ', ' : ', ') 
            + address.city + ', ' + address.state + ' ' + address.zip;
        }

        return '';

    }

    ctrl.getFulfillmentMethodDescription = function() {
        if (ctrl.selectedFilters.fulfillmentMethod === ctrl.fulfillmentMethods.PICKUP) {
            return ctrl.selectedFilters.fulfillmentMethod;
        } else if (ctrl.selectedFilters.fulfillmentMethod === ctrl.fulfillmentMethods.DELIVERY) {
            var fulfillmentMethod = ctrl.selectedFilters.fulfillmentMethod;
            var address = ctrl.selectedFilters.address;
            var addressDisplay = ctrl.formatAddress(address);
            return fulfillmentMethod + (addressDisplay ? ' - ' + addressDisplay : '');
        }
    }

    ctrl.getDeliveryInstructionsDescription = function() {
        if (typeof ctrl.selectedFilters.deliveryInstructions === 'string') {
            return ctrl.selectedFilters.deliveryInstructions.length > 50
                ? ctrl.selectedFilters.deliveryInstructions.slice(0, 50) + '...'
                : ctrl.selectedFilters.deliveryInstructions;
        }
        return '';
    }

    ctrl.getFulfillmentDateTimeString = function() {
        var retVal = [];
        var fulfillmentDate = hsAdminOrder.getFulfillmentDateString(hsAdminOrder.SELECTED_FILTERS.fulfillmentDate);
        var fulfillmentTime = hsAdminOrder.getFulfillmentTimeString(hsAdminOrder.SELECTED_FILTERS.fulfillmentTime);

        if (hsUtils.isNonEmptyString(fulfillmentDate)) {
            retVal.push(fulfillmentDate);
        }

        if (hsUtils.isNonEmptyString(fulfillmentTime)) {
            retVal.push(fulfillmentTime);
        }

        return retVal.join(' - ');
    }

    ctrl.isFulfillmentDisabled = function(fulfillmentMethod) {
        return !ctrl.availableOptions.fulfillments.includes(fulfillmentMethod);
    }

    ctrl.isPriceListDisabled = function(priceList) {
        return !ctrl.availableOptions.priceLists.includes(priceList);
    }

    ctrl.isLocationDisabled = function(location) {
        for (var availLocation of ctrl.availableOptions.locations) {
            if (availLocation.name  === location.name) {
                return false;
            }
        }
        return true;
    }

    ctrl.canUpdateFulfillmentMethod = function() {
        return hsUtils.isObject(ctrl.selectedFilters.user);
    }

    ctrl.clearFilters = function() {
        ctrl.isLoading = true;
        hsAdminOrder.clearFilters(ctrl.isQuote)
            .then(function() {
                ctrl.initForms();
                ctrl.initErrors();
                ctrl.initLoaders();
                ctrl.currentStep = ctrl.steps.PRICELIST;
            })
            .catch(function(err) {
                void 0;
                ctrl.error = "Failed to load page. Please try again or contact support.";
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    }

    ctrl.canSelectDateTime = function () {
        return !ctrl.isQuote || ctrl.selectedFilters.location && ctrl.selectedFilters.priceList && ctrl.selectedFilters.fulfillmentMethod;
    };

    ctrl.getTimeSelectionUnavailableString = function () {
        var required = [];
        var str = 'Please select';

        if (!ctrl.selectedFilters.location) {
            required.push(' location');
        }
        if (!ctrl.selectedFilters.priceList) {
            required.push(' pricelist');
        }
        if (!ctrl.selectedFilters.fulfillmentMethod) {
            required.push(' fulfillment');
        }
        if (required.length === 1) {
            str += required[0];
        } else {
            for (var i = 0; i < required.length; i++) {
                if (i === required.length - 1) {
                    str += ' and' + required[i];
                } else {
                    str += required[i] + ',';
                }
            }
        }
        str += '.';
        return str;
    };

    ctrl.getAvailableTimes = function () {
        if (ctrl.isQuote && ctrl.canSelectDateTime()) {
            ctrl.loadingDateTime = true;

            hsAdminOrder.getAvailableTimes()
                .then(function (availableTimes) {
                    ctrl.availableTimes = ctrl.indexAvailableTimesByDay(availableTimes);
                })
                .catch(function (err) {
                    void 0;
                    ctrl.availableTimes = null;
                })
                .finally(function () {
                    ctrl.loadingDateTime = false;
                });
        }
    };

    ctrl.indexAvailableTimesByDay = function (availableTimes) {
        return hsAdminOrder.indexAvailableTimesByDay(availableTimes);
    };

    ctrl.areAnyTimesAvailable = function () {
        return (ctrl.availableTimes
            && ctrl.shouldUseSlots()
            && ctrl.selectedFilters.fulfillmentMethod
            && hsUtils.isNonEmptyObject(ctrl.availableTimes[ctrl.selectedFilters.fulfillmentMethod])
        );
    };

    ctrl.shouldUseSlots = function () {
        var enableCustomFulfillmentTimes = ctrl.availableTimes && ctrl.availableTimes.enableCustomFulfillmentTimes;

        return ctrl.isQuote && (!$rootScope.onAdminPage || !enableCustomFulfillmentTimes);
    };

    ctrl.getMinAvailableDate = function () {
        if (!ctrl.areAnyTimesAvailable()) return null;

        var keys = Object.keys(ctrl.availableTimes[ctrl.selectedFilters.fulfillmentMethod]);
        return keys[0];
    };

    ctrl.getMaxAvailableDate = function () {
        if (!ctrl.areAnyTimesAvailable()) return null;

        var keys = Object.keys(ctrl.availableTimes[ctrl.selectedFilters.fulfillmentMethod]);
        return keys[keys.length - 1];
    };

    ctrl.getAvailableSlots = function () {
        if (!ctrl.areAnyTimesAvailable() || !ctrl.selectedFilters.fulfillmentDate) return null;

        var dateString = hsUtils.getDateString(ctrl.selectedFilters.fulfillmentDate);
        return ctrl.availableTimes[ctrl.selectedFilters.fulfillmentMethod][dateString];
    };

    ctrl.getAvailableDates = function () {
        if (!ctrl.areAnyTimesAvailable()) return ctrl.emptyDatesObject;

        return ctrl.availableTimes[ctrl.selectedFilters.fulfillmentMethod];
    };

    ctrl.handleBackClick = function() {
        if (ctrl.isQuote) {
            return '/admin/quotes';
        }
        return '/admin/dashboard';
    };
}
hsApp.component('bulkAddProducts', {
    templateUrl: '/partials/components/bulk-product-operations/bulk-add-products.html',
    controller: ['toastr', 'hsBulkProductOps', 'globalFunctions', 'hsUtils', 'NgTableParams', '$location', 'ngDialog', '$scope', 'hsAdmin', bulkAddProductsController],
});

function bulkAddProductsController(toastr, hsBulkProductOps, globalFunctions, hsUtils, NgTableParams, $location, ngDialog, $scope, hsAdmin) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.fileInputElement = null;
        ctrl.fileInputElementId = 'fileInput';
        ctrl.eventAdded = false;
        ctrl.validFound = false;
        ctrl.invalidFound = false;
        ctrl.result = null;
        ctrl.validationCsvHeaders = null;
        ctrl.csvTemplateHeaders = [
            'upc', 
            'itemName', 
            'category', 
            'subCategory', 
            'price', 
            'organic', 
            'brand', 
            'unit',
            'sellByQty',
            'avgWeight',
            'ingredients', 
            'disclaimer', 
            'bottleFee',
            'isTaxable',
            'taxRate',
            'isInStock',
            'isInactive',
            'minQuantity',
            'maxQuantity',
            'isPickupOnly',
        ];
        ctrl.tableParams = null;
        ctrl.keysToExclude = [ '$$hashKey', 'apiError' ];
        ctrl.keyAlias = {
            type: 'category',
            subType: 'subCategory',
            displayName: 'itemName',
        };
        ctrl.tutorialDocumentation = 'https://gethomesome.zendesk.com/hc/en-us/articles/12321213629716';
        ctrl.syncPriceListsPopup = {
            elementId: 'sync-bulk-add-products-popup',
            dataToPropagate: null,
        };

        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        });
    };

    ctrl.loadCSV = function (val) {
        if (!ctrl.fileInputElement) {
            ctrl.fileInputElement = document.getElementById(ctrl.fileInputElementId);
        }
        ctrl.fileInputElement.value = null;

        if (!ctrl.eventAdded) {
            ctrl.eventAdded = true;

            ctrl.fileInputElement.addEventListener('change', function(event) {
                var file = null;
                try {
                    file = event.target.files[0];
                    void 0
                }
                catch (err) {
                    void 0;
                }
                ctrl.parseFile(file);
            });
        }
        ctrl.fileInputElement.click();
    };

    ctrl.parseFile = function (file) {
        ctrl.error = '';
        ctrl.isLoading = true;
        ctrl.selectedView = 'valid';
        ctrl.parsed = null;
        ctrl.tableParams = null;
        ctrl.validFound = false;
        ctrl.invalidFound = false;
        ctrl.result = null;


        hsBulkProductOps.getParsedFile(file)
            .then(function (data) {
                ctrl.parsed = data;
                toastr.success('Successfully parsed file');
            })
            .catch(function (err) {
                toastr.error('Error parsing file');
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
                if (!ctrl.error) {
                    ctrl.selectView(ctrl.selectedView);
                }
            });
    };

    ctrl.getCount = function(parsedData, type) {
        if (!hsUtils.isObject(parsedData) || !Object.keys(parsedData).length) return 0;
        if (type === 'valid') {
            return Object.keys(parsedData.productsWithoutErrors).length;
        } else if (type === 'invalid') {
            return Object.keys(parsedData.productsWithErrors).length;
        } else {
            throw new Error("Invalid view");
        }
    };

    ctrl.selectView = function (view) {
        ctrl.selectedView = view;
        if (view === 'valid') {
            if (hsUtils.isObject(ctrl.parsed) && hsUtils.isObject(ctrl.parsed.productsWithoutErrors) && Object.keys(ctrl.parsed.productsWithoutErrors).length) {
                ctrl.setTableData(Object.values(ctrl.parsed.productsWithoutErrors));
                ctrl.validFound = true;
            }
        } else if (view === 'invalid') {
            if (hsUtils.isObject(ctrl.parsed) && hsUtils.isObject(ctrl.parsed.productsWithErrors) && Object.keys(ctrl.parsed.productsWithErrors).length) {
                ctrl.setTableData(Object.values(ctrl.parsed.productsWithErrors));
                ctrl.invalidFound = true;
            }
        } else {
            throw new Error("Invalid view selected");
        }
    };

    ctrl.setTableData = function (data) {
        if (!hsUtils.isNonEmptyArray(data)) {
            throw new Error("Invalid Table Data");
        }
        
        ctrl.cols = [];
        var firstElement = data[0];
        for (var entries of Object.entries(firstElement)) {
            var key = entries[0];
            if (ctrl.keysToExclude.includes(key)) continue;
            var filter = {};
            filter[key] = 'text';
            ctrl.cols.push({
                field: key,
                title: ctrl.keyAlias.hasOwnProperty(key) ? ctrl.keyAlias[key] : key,
                visible: true,
                filter: filter
            });
        }

        ctrl.tableParams = new NgTableParams(
            {
                counts: globalFunctions.ngTableConfig.counts,
            },
            {
                counts: globalFunctions.ngTableConfig.counts,
                dataset: data
            }
        );
    };

    ctrl.backButton = function() {
        if (ctrl.parsed) {
            return ngDialog.openConfirm({
                data: {
                    heading: 'Cancel Add Product',
                    subHeading: 'Are you sure you would like to go back? All saved changes will be lost!',
                    confirmBtnText: 'Yes',
                    cancelBtnText: 'No'
                },
                template: 'partials/popup/confirm-popup.html'
            })
                .then(function(ok) {
                    $location.url('/admin/products/bulk-ops');
                })
                .catch(function(cancel) {});
        }

        $location.url('/admin/products/bulk-ops');
    }

    ctrl.addProducts = function() {
        ctrl.error = '';
        ctrl.isLoading = true;

        hsBulkProductOps.bulkAddProducts(ctrl.parsed.productsToAdd, ctrl.parsed.csvHeaders)
            .then(function (data) {
                ctrl.syncPriceListsPopup.dataToPropagate = {
                    productsToAdd: ctrl.parsed.productsToAdd,
                    csvHeaders: ctrl.parsed.csvHeaders
                };
                ctrl.openSyncPriceListsPopupOrContinue();
                ctrl.result = data;
                toastr.success('Successfully Added Products');
            })
            .catch(function (err) {
                void 0;
                ctrl.dataToPropagate = null;
                toastr.error('Error Adding Products');
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    }
    
    ctrl.getResultsMessage = function(result) {
        void 0
        var success = result.productsAdded;
        var errors = result.productsWithErrors;
        var retVal = "<br><h3 class=\"mtop0 mbot0\">Done Adding Products!</h3><br>" 
            + "Success: " + success.length + "<br>"
            + "Errors: " + errors.length + "<br>"
            + "Products will appear online in a few minutes. Check your email for detailed results!";

        return retVal;
    }

    ctrl.exportErrors = function() {
        var headersToExclude = ['apiError', '$$hashKey'];
        var productsWithErrors = ctrl.parsed.productsWithErrors;
        
        if (!hsUtils.isObject(productsWithErrors) || !Object.keys(productsWithErrors).length) {
            toastr.error("No Products To Exports");
            return;
        }

        productsWithErrors = Object.values(productsWithErrors);
        var headersSet = !!ctrl.validationCsvHeaders;
        
        var exportData = [];
        for (var errorProduct of productsWithErrors) {
            for (var header of headersToExclude) {
                delete errorProduct[header];
            }
            if (!headersSet) {
                ctrl.validationCsvHeaders = Object.keys(errorProduct);
                headersSet = true;
            }
            exportData.push(errorProduct);
        }
        
        return exportData;

    }

    ctrl.getProcessingLocationText = function() {
        var location = globalFunctions.getSelectedLocationFromStorage();
        if (ENV.enablePriceList) {
            var pricelist = globalFunctions.getAdminSelectedPriceListFromStorage();
            return '<br>Location: ' + location.name 
                + "<br>Pricelist: " + pricelist.title;
        }
        return '<br>Location: ' + location.name;
    }

    ctrl.propagateUpdateToTarget = function(target) {
        var productsToAdd = ctrl.syncPriceListsPopup.dataToPropagate.productsToAdd;
        var csvHeaders = ctrl.syncPriceListsPopup.dataToPropagate.csvHeaders;
        return hsBulkProductOps.bulkAddProducts(productsToAdd, csvHeaders, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        if (hsAdmin.shouldShowSyncPriceListsPopup()) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                ctrl.handleUpdateCompletion();
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        } else {
            ctrl.handleUpdateCompletion();
        }
    };

    ctrl.handleUpdateCompletion = function() {
        ctrl.parsed = null;
        ctrl.validFound = false;
        ctrl.invalidFound = false;
    };
}
hsApp.component('binaryOptionButton', {
    templateUrl: '/partials/components/common/binary-option-button.html',
    bindings: {
        valueA: '<',
        valueB: '<',
        labelA: '<',
        labelB: '<',
        handleClick: '&',
        model: '='
    },
    controller: [ binaryOptionButtonController ],
});

function binaryOptionButtonController() {
    var ctrl = this;
    var logPrefix = '[binaryOptionButton]: ';

    ctrl.$onInit = function () {
        void 0;
    }
}
hsApp.component('hsButtonSwitch', {
    templateUrl: '/partials/components/common/button-switch.html',
    bindings: {
        model: '<',
        onChange: '&',

    },  
    controller: [ 'hsUtils', hsButtonSwitchController ],
});

function hsButtonSwitchController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        if (!hsUtils.isBoolean(ctrl.model)) {
            ctrl.model = false;
        }
    };

    ctrl.toggleSwitch = function() {
        ctrl.model = !ctrl.model;
        ctrl.onChange({value: ctrl.model});
    };
}
hsApp.component('dateTimeSelector', {
    templateUrl: '/partials/components/common/dateTimeSelector.html',
    bindings: {
        initDate: '<',
        initTime: '<',
        minDate: '<',
        maxDate: '<',
        availableSlots: '<',
        availableDates: '<',
        showSlots: '<',
        onSelectDate: '&',
        onSelectTime: '&',
        scrollableSlotsContainer: '<',
        datePopupPlacement: '<',
    },  
    controller: [ 'hsUtils', dateTimeSelectorController ],
});

function dateTimeSelectorController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        if (!hsUtils.isNonEmptyString(ctrl.datePopupPlacement)) {
            ctrl.datePopupPlacement = 'top-right';
        }
        
        ctrl.datePicker = {
            open: false,
            format: 'MM-dd-yyyy',
            selectedDate: ctrl.initDate || null,
            dateOptions: {
                showWeeks: false,
                formatYear: 'yy',
                minDate: ctrl.getMinDate(),
                maxDate: ctrl.getMaxDate(),
                showClear: false,
            },
        };

        if (ctrl.showSlots) {
            ctrl.datePicker.dateOptions.dateDisabled = ctrl.isDateDisabled;
        }

        ctrl.timePicker = {
            availableHours: ctrl.getAvailableHours(),
            availableMinutes: ctrl.getAvailableMinutes(),
            meridians: ['AM', 'PM'],
            selectedTime: ctrl.initTime || {
                hour: null,
                minute: null,
                meridian: null,
            },
        }
    };

    ctrl.isDateDisabled = function (data) {
        if (!hsUtils.isObject(ctrl.availableDates)) return false;

        var dateString = hsUtils.getDateString(data.date);

        return !(dateString in ctrl.availableDates);
    };

    ctrl.getMaxDate = function () {
        if (ctrl.maxDate) {
            var date = new Date(ctrl.maxDate);

            if (!isNaN(date.getTime())) return date;

            return new Date(); // This will make all dates unavailable
        }
        return new Date(2030, 0, 0);
    };

    ctrl.getMinDate = function () {
        if (ctrl.minDate) {
            var date = new Date(ctrl.minDate);

            if (!isNaN(date.getTime())) return date;
        }
        return new Date();
    };

    ctrl.getAvailableMinutes = function () {
        var availableMinutes = [];
        for (var i = 0; i <= 59; i+=15) {
            if (i < 10) {
                availableMinutes.push('0' + i);
            } else {
                availableMinutes.push(i.toString());
            }
        }
        return availableMinutes;
    }

    ctrl.getAvailableHours = function() {
        var availableHours = [];
        for (var i = 1; i <= 12; i++) {
            if (i < 10) {
                availableHours.push('0' + i);
            } else {
                availableHours.push(i.toString());
            }
        }

        return availableHours;
    }

    ctrl.selectDate = function() {
        ctrl.onSelectDate({ date: ctrl.datePicker.selectedDate });
    }

    ctrl.selectTime = function() {
        var selectedTime = ctrl.timePicker.selectedTime;
        if (hsUtils.isNonEmptyString(selectedTime.hour) 
                && hsUtils.isNonEmptyString(selectedTime.minute) 
                && hsUtils.isNonEmptyString(selectedTime.meridian)) {
            ctrl.onSelectTime({ time: Object.assign({}, selectedTime) });
        }
        
    }

    ctrl.selectSlot = function(slot) {
        ctrl.onSelectTime({ time: slot });
    };

    ctrl.toggleDatePicker = function() {
        ctrl.datePicker.open = !ctrl.datePicker.open;
    }
}
hsApp.component('errorPage', {
    templateUrl: '/partials/components/common/error-page.html',
    bindings: {
        errorTitle: '<',
        errorMessage: '<'       
    },
    controller: [ 'hsUtils', errorPageController ],
});

function errorPageController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if (!hsUtils.isNonEmptyString(ctrl.errorTitle)) { 
            ctrl.errorTitle = "Something Went Wrong.";
        }

        if (!hsUtils.isNonEmptyString(ctrl.errorMessage)) { 
            ctrl.errorMessage = "We're sorry, something went wrong.";
        }
    }
}
hsApp.component('hsConfirmPopup', {
    templateUrl: '/partials/components/common/hs-confirm-popup.html',
    bindings: {
        popupId: '@',
        title: '@',
        description: '@',
        cancelButton: '@',
        confirmButton: '@',
        onCancel: '&',
        onConfirm: '&'
    },
    controller: [ 'hsUtils', hsConfirmPopupController ],
});

function hsConfirmPopupController(hsUtils) {
    var ctrl = this;
    var logPrefix = '[hsConfirmPopup]: ';

    ctrl.$onInit = function () {
        void 0;
        if (!hsUtils.isString(ctrl.popupId)) {
            ctrl.popupId = 'hs-confirm-popup';
        }

        if (!hsUtils.isString(ctrl.title)) {
            ctrl.title = 'Confirm action';
        }

        if (!hsUtils.isString(ctrl.description)) {
            ctrl.description = 'Are you sure you want to proceed?';
        }

        if (!hsUtils.isString(ctrl.cancelButton)) {
            ctrl.cancelButton = 'No';
        }

        if (!hsUtils.isString(ctrl.confirmButton)) {
            ctrl.confirmButton = 'Yes';
        }
    };
}
hsApp.component('hsBanner', {
    templateUrl: '/partials/components/common/hsBanner.html',
    bindings: {
        type: '@',
        text: '@',
        isPersistent: '<',
    },  
    controller: [ 'hsUtils', hsBannerController ],
});

function hsBannerController(hsUtils) {
    var ctrl = this;
    
    ctrl.bannerTypes = {
        'warning': {
            image: '../../../images/ui-v2/icon-svg/warning.svg',
            css: 'hs-banner-warning',
        },
    };

    ctrl.$onInit = function() {
        ctrl.displayBanner = true;

        if (!ctrl.bannerTypes.hasOwnProperty(ctrl.type)) {
            void 0;
            ctrl.displayBanner = false;
        }

        if (!hsUtils.isNonEmptyString(ctrl.text)) {
            void 0;
            ctrl.displayBanner = false;
        }

        if (!hsUtils.isBoolean(ctrl.isPersistent)) {
            ctrl.isPersistent = false;
        }
    };

    ctrl.getBannerClass = function() {
        return ctrl.bannerTypes[ctrl.type].css;
    };

    ctrl.getBannerIcon = function() {
        return ctrl.bannerTypes[ctrl.type].image;
    };

    ctrl.getCloseIcon = function() {
        return '../../../images/ui-v2/icon-svg/close.svg';
    };

    ctrl.closeBanner = function() {
        ctrl.displayBanner = false;
    };

}
hsApp.component('hsLoader', {
    templateUrl: '/partials/components/common/hsLoader.html',
    bindings: {
        text: '@',
        positionRelative: '<'
    },  
    controller: [ 'hsUtils', hsLoaderController ],
});

function hsLoaderController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        if (!hsUtils.isNonEmptyString(ctrl.text)) {
            ctrl.text = 'Loading... Please wait!';
        }

        if (ctrl.positionRelative === false) {
            ctrl.positionRelative = '';
        } else {
            ctrl.positionRelative = 'position-relative';
        }
    };
}
hsApp.component('hsIncrementerButton', {
    templateUrl: '/partials/components/common/incrementer-button.html',
    bindings: {
        model: '<',
        step: '<',
        minVal: '<',
        onChange: '&',
    },  
    controller: [ 'hsUtils', hsIncrementerButtonController ],
});

function hsIncrementerButtonController(hsUtils) {
    var ctrl = this;
    var logPrefix = '[hsIncrementerButton]:';

    ctrl.$onInit = function () {
        void 0;
        if (!hsUtils.isNumber(ctrl.step)) {
            ctrl.step = 1;
        }

        if (!hsUtils.isNumber(ctrl.minVal)) {
            ctrl.minVal = 0;
        }

        if (!hsUtils.isNumber(ctrl.model)) {
            ctrl.model = ctrl.minVal;
        }
    };

    ctrl.increment = function() {
        ctrl.model += ctrl.step;
        ctrl.onChange({value: ctrl.model});
    };

    ctrl.decrement = function() {
        var newValue = ctrl.model - ctrl.step;
        ctrl.model = Math.max(newValue, ctrl.minVal);
        ctrl.onChange({value: ctrl.model});
    };
}
hsApp.component('plusMinusButton', {
    templateUrl: '/partials/components/common/plus-minus-button.html',
    bindings: {
        value: '<',
        onPlus: '&',
        onMinus: '&',
        showDeleteButton: '<',
        productData: '<'
    },
    controller: [ 'hsUtils', plusMinusButtonController ],
});

function plusMinusButtonController(hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if (!hsUtils.isNumber(ctrl.value)) {
            ctrl.value = 0;
        }
    };

    ctrl.plus = function() {
        ctrl.onPlus({ operation: 'add' });
    };

    ctrl.minus = function() {
        ctrl.onMinus({ operation: 'subtract' });
    };

    ctrl.getMinusImage = function() {
        if (ctrl.showDeleteButton) {
            return './images/ui-v2/icon-svg/delete-icon.svg';
        }
        return './images/ui-v2/icon-svg/minus-icon.svg';
    };

    ctrl.getTooltipTemplate = function () {
        return "<div class=\"modifier-tooltip-container\"> \
        <p align=\"left\"> Customized product. Adjust quantity or remove on cart page. </p> \
        </div>"
    }
}
hsApp.component('svgContainer', {
    templateUrl: '/partials/components/common/svg-container.html',
    bindings: {
        svgUrl: '<',
        onClick: '&',
    },
    controller: [ 
        'hsUtils', 
        svgContainerController 
    ],
});

function svgContainerController(
    hsUtils
) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if(!hsUtils.isNonEmptyString(ctrl.svgUrl)) {
            ctrl.svgUrl = null;
            void 0;
        }
    };
}
hsApp.component('uploadImageContainer', {
    templateUrl: '/partials/components/common/upload-image-container.html',
    bindings: {
        width: '<',
        height: '<',
        existingImageLink: '<',
        onUpload: '&',
        instructions: '@',
        inputId : '@',
        imgId: '@',
    },
    controller: ['$timeout', 'hsImageUpload', 'hsUtils', 'toastr', uploadImageContainerController ],
});

function uploadImageContainerController($timeout, hsImageUpload, hsUtils, toastr) {
    var ctrl = this;
    var logPrefix = '[uploadImageContainerController]: ';

    ctrl.$onInit = function () {
        ctrl.imageUpload = null;
        ctrl.error = null;

        if (!hsUtils.isPositiveInteger(ctrl.width)) {
            ctrl.width = 786;
        }
        if (!hsUtils.isPositiveInteger(ctrl.height)) {
            ctrl.height = 580;
        }
        if (!hsUtils.isNonEmptyString(ctrl.instructions)) {
            ctrl.instructions = "Upload only .jpg or .png format with a size of " + ctrl.width + "x" + ctrl.height + " pixels";
        }
        if (!hsUtils.isNonEmptyString(ctrl.inputId)) {
            ctrl.inputId = "uploadImage";
        }
        if (!hsUtils.isNonEmptyString(ctrl.imgId)) {
            ctrl.imgId = "locationImage";
        }

        ctrl.initExistingImageLink();

    };

    ctrl.initExistingImageLink = function() {
        hsImageUpload.checkIfImageExists(ctrl.existingImageLink)
            .then(function(exists) {
                if (exists) {
                    $timeout(function() {
                        document.getElementById(ctrl.imgId).src = ctrl.existingImageLink;
                        ctrl.imageUpload = ctrl.existingImageLink;
                    }, 0);
                }
            });
    };

    ctrl.attachUploadedFile = function() {
        try {
            var newImage = ctrl.imageUpload[0];
            if (newImage) {
                ctrl.onUpload({image: newImage, width: ctrl.width, height: ctrl.height})
                    .then(function(response) {
                        document.getElementById(ctrl.imgId).src = URL.createObjectURL(newImage);
                        ctrl.imageUpload = newImage;
                        ctrl.error = null;
                    })
                    .catch(function(err) {
                        document.getElementById(ctrl.imgId).src = null;
                        ctrl.imageUpload = null;
                        ctrl.throwErrorState(err.message || 'Failed to upload image');
                    });
            } else {
                // prevents imageUpload from showing when 'cancel' is clicked
                if (ctrl.error) {
                    ctrl.imageUpload = null;
                }
            }
        } catch (error) {
            document.getElementById(ctrl.imgId).src = null;
            ctrl.imageUpload = null;
            ctrl.throwErrorState('Failed to upload image')
        }
    }

    ctrl.updateUploadedImage = function() {
        var uploadImgPopup = document.getElementById(ctrl.inputId);
        uploadImgPopup.click();
    }

    // This will become more complex once the images are properly stored
    ctrl.deleteImage = function() {
        document.getElementById(ctrl.imgId).src = null;
        ctrl.imageUpload = null;
    }

    ctrl.throwErrorState = function(errorMessage) {
        if (errorMessage) {
            ctrl.error = errorMessage;
        } else {
            ctrl.error = "Error uploading image.";
        }
    }
}

hsApp.component('chatWindow', {
    templateUrl: '/partials/components/conversations/chat-window.html',
    bindings: {
        customerName: '<',
        deliveryDate: '<',
        messages: '<',
        orderId: '<',
        onClick: '&',
        lastReadMessageIndex: '<',
        lockConversation: '<',
        isConnected: '<',
    },
    controller: ['toastr', 'hsConversations', 'hsScroll', 'hsUtils', '$scope', '$timeout', '$q', chatWindowController],
});

function chatWindowController(toastr, hsConversations, hsScroll, hsUtils, $scope, $timeout, $q) {

    var ctrl = this;
    ctrl.logPrefix = ':chatWindow';

    ctrl.$onInit = function () {
        ctrl.initialized = false;
        ctrl.hasScrolled = false;
        ctrl.sendingMessage = false;
        ctrl.imageFromCamera = null;
        ctrl.imageBuffer = [];

        if (ctrl.lockConversation) {
            toastr.warning("A packer must be assigned to start a conversation with the customer.");
        }

        angular.element(document).ready(function () {
            ctrl.dom.initChatTextArea();
        });
    };

    ctrl.$onChanges = function (val) {

        if (ctrl.messagesLoaded(val) && ctrl.lastReadMessageInitialized(val)) {
            angular.element(document).ready(function () {
                ctrl.dom.initChatScrollContainer(ctrl.orderId); 
                if (!ctrl.hasScrolled) {
                    $timeout(function() {
                        ctrl.dom.getLastReadMessagePosition();
                        ctrl.dom.refreshLastViewedMessageIndex(ctrl.orderId);
                    });
                }  
            });
        }

        if (ctrl.scrollRefreshRequired(val)) {
            ctrl.dom.getLastReadMessagePosition();
            ctrl.dom.refreshLastViewedMessageIndex(ctrl.orderId);
        }

    }

    ctrl.messagesLoaded = function(val) {
        return val.messages && val.messages.currentValue.length && hsUtils.isUndefinedOrEmptyObj(val.messages.previousValue);
    }

    ctrl.lastReadMessageInitialized = function(val) {
        return val.lastReadMessageIndex
            && (typeof val.lastReadMessageIndex.currentValue === 'number' || val.lastReadMessageIndex.currentValue === null)
            && hsUtils.isUndefinedOrEmptyObj(val.lastReadMessageIndex.previousValue);
    }

    ctrl.scrollRefreshRequired = function(val) {
        if (!ctrl.initialized) return false;

        var hasMessages = val.messages && hsUtils.isNonEmptyArray(val.messages.currentValue);
        var hadMessages = val.messages && hsUtils.isNonEmptyArray(val.messages.previousValue);
        var messagesChanged = hasMessages && (!hadMessages || val.messages.currentValue.length > val.messages.previousValue.length);
        return messagesChanged && !ctrl.hasScrolled;
    }

    ctrl.sendMessage = function () {

        var message = ctrl.textInput;
        if ((!message && !ctrl.imageBuffer[0]) || ctrl.sendingMessage) return;
        void 0;
        ctrl.sendingMessage = true;

        var compressionQueue = [];
        for (var i = 0; i < ctrl.imageBuffer.length; i++) {
            var img = ctrl.imageBuffer[i];
            compressionQueue.push(hsUtils.resizeImage(img));
        }

        if (hsUtils.isNonEmptyArray(compressionQueue)) {
            $q.all(compressionQueue).then(function(results) {    
                sendMessageReq(results);
            });
        } else {
            sendMessageReq();
        }

        function sendMessageReq(images) {
            return hsConversations.sendMessage(message, ctrl.orderId, images).then(function(res) {
                void 0;
                ctrl.textInput = '';
                var textArea = document.getElementById("ta1");
                textArea.style.height = "30px;";
                textArea.style.height = "auto";
                ctrl.imageBuffer.length = 0;
                ctrl.dom.scrollToBottom();
            }).catch(function(err){
                void 0;
                toastr.error("Couldn't send message");
                void 0;
            })
            .finally(function () {
                ctrl.sendingMessage = false;
            });
        }
        
    }

    ctrl.getClass = function(author) {
        if (ctrl.isAdmin(author)) {
            return 'box-admin';
        }
        return 'box-user';
    };

    ctrl.isAdmin = function(author) {
        return author.includes('@');
    }

    ctrl.getMessageTime = function(date) {
        return hsUtils.isToday(date) ? hsUtils.convertISOStringToTimestamp(date) : hsUtils.convertISOStringToChatDisplayTime(date);
    }

    ctrl.captureImage = function() {
        if (ctrl.imageFromCamera) {
            if (ctrl.imageBuffer.length === 0) {
                ctrl.imageBuffer.push(ctrl.imageFromCamera[0]);
                $timeout(function() {
                    $scope.$digest();
                });
            }
        }
    };

    ctrl.resetCameraImage = function() {
        ctrl.imageFromCamera = null;
        ctrl.dom.clearCameraInputValue();
        $timeout(function() {
            $scope.$digest();
        });
    }

    ctrl.hasBufferedImages = function() {
        return ctrl.imageBuffer && ctrl.imageBuffer.length > 0;
    }

    ctrl.dom = {
        initChatTextArea: function() {
            var textArea = document.getElementById("ta1");
            if (textArea) {
                textArea.addEventListener("input", function () {

                    if (this.scrollHeight < 100) {
                        this.style.height = "auto";
                        this.style.height = this.scrollHeight + "px";
                    } else {
                        this.style.overflowY = "scroll";
                    }
                });
            }
        },
        getViewedMessageIndexes: function() {
            var messages = $('[id^="msg-"]');
            var container = $('#chat')[0];
            var visibleMessages = hsScroll.getVisibleElements(messages, container);
            var viewedMessageIndexes = visibleMessages.map(function(message) {
                return parseInt(message.id.replace('msg-', ''));
            });
            return viewedMessageIndexes;
        },
        initChatScrollContainer: function(orderId) {
            var container = $('#chat')[0];
            container.addEventListener("scroll", function() {
                ctrl.hasScrolled = true;
                ctrl.dom.refreshLastViewedMessageIndex(orderId);
            });
        },
        getLastReadMessagePosition: function() {
            if (typeof ctrl.lastReadMessageIndex !== "number") {
                ctrl.hasScrolled = true;
                return;
            }
            var lastMsgId = '#msg-'+ctrl.lastReadMessageIndex;
            var message = $(lastMsgId)[0];
            var container = $('#chat')[0];

            // If the message isn't yet in the container, scroll to bottom
            if (!message.length) {
                container.scrollTop = container.scrollHeight;
                ctrl.hasScrolled = true;
                return;
            }

            var position = hsScroll.getPositionInScrollContainer(message, container);
            var messageHeight = message.offsetHeight;
            container.scrollTop = position + messageHeight;
            ctrl.hasScrolled = true;
        },
        refreshLastViewedMessageIndex: function(orderId) {
            var lastMessageIndexInView = ctrl.dom.getLastMessageIndexInView();
            if (typeof lastMessageIndexInView === 'number') {
                hsConversations.updateUnreadMessagesCount(lastMessageIndexInView, orderId)
                .then(function() {
                    ctrl.initialized = true;
                })
                .catch(function(err) {
                    void 0;
                });
            } else {
                ctrl.initialized = true;
            }
        },
        getLastMessageIndexInView: function() {
            var viewedMessageIndexes = ctrl.dom.getViewedMessageIndexes();
            if (viewedMessageIndexes.length) {
                return viewedMessageIndexes[viewedMessageIndexes.length-1];
            }
            return null;
        },
        scrollToBottom: function() {
            var container = $('#chat')[0];
            container.scrollTop = container.scrollHeight;
            ctrl.hasScrolled = true;
        },
        clearCameraInputValue: function() {
            var cameraInput = document.getElementById('open-camera');
            cameraInput.value = null;
        }
    }
}

hsApp.component('conversation', {
    templateUrl: '/partials/components/conversations/conversation.html',
    bindings: {
        orderData: '<',
        userData: '<',
        onClick: '&',
        autoSendMessage: '<',
        packerRequired: '<'
    },
    controller: ['toastr', '$scope', 'hsConversations', conversationController],
});

function conversationController(toastr, $scope, hsConversations) {
    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
        $scope.hsConversations = hsConversations;
        ctrl.isConnected = false;
        ctrl.messages = [];
        ctrl.conversation = {};
        ctrl.showChatWindow = false;
        ctrl.lockConversation = ctrl.packerRequired && !ctrl.isPackerAssigned();
        ctrl.watchConnectionState();
    };

    ctrl.$onChanges = function (changes) {
        if (!ctrl.conversationInitialized && changes.orderData && changes.orderData.currentValue && changes.orderData.currentValue.id) {
            ctrl.initConversation();
        }

        if (changes.orderData && changes.orderData.currentValue && changes.orderData.previousValue && changes.orderData.currentValue.packer !== changes.orderData.previousValue.packer) {
            ctrl.lockConversation = ctrl.packerRequired && !ctrl.isPackerAssigned();
        }
    }

    ctrl.openChatWindow  = function () {
        if (!ctrl.isConnected) {
            void 0;
            // We can trigger some action here
        }
        ctrl.showChatWindow = true;
    };

    ctrl.closeChatWindow = function () {
        ctrl.showChatWindow = false;
    };

    ctrl.initConversation = function () {
        if (ctrl.orderData && ctrl.orderData.id && !ctrl.conversationInitialized && ctrl.orderData.conversations) {

            var conversationData = ctrl.orderData.conversations[ctrl.orderData.conversations.length-1];
            var latestConversationId = conversationData.conversationID;

            hsConversations.initOrderConversation(latestConversationId, true).then(function () {
                ctrl.conversationInitialized = true;

                var unreadMessagesWatchString = 'hsConversations.conversationIndex["' + ctrl.orderData.id + '"].unreadMessagesCount';
                var umcWatcher = $scope.$watch(unreadMessagesWatchString, function(newCount) {
                    ctrl.unreadMessagesCount = newCount;
                });
                $scope.$on('$destroy', umcWatcher);

                var lastReadMessageIndexWatchString = 'hsConversations.conversationIndex["' +ctrl.orderData.id + '"].lastReadMessageIndex';
                var lmiWatcher = $scope.$watch(lastReadMessageIndexWatchString, function(newIndex) {
                    ctrl.lastReadMessageIndex = newIndex;
                });
                $scope.$on('$destroy', lmiWatcher);

                var watchString = 'hsConversations.conversationIndex["' + ctrl.orderData.id + '"].messages';

                var deregister = $scope.$watch(watchString, function (newVal, oldVal) {
                    void 0;
                    if (newVal && (oldVal !== newVal || Object.values(newVal).length !== ctrl.messages.length)) {

                        ctrl.messages = Object.values(newVal).sort(function (a, b) {
                            return a.state.index - b.state.index;
                        }).map(function (message) {

                            var msg = {
                                text: message.state.body,
                                index: message.state.index,
                                author: message.state.author,
                                dateCreated: message.dateCreated,
                                twilioMessage: message
                            };

                            return msg;
                        });

                    }
                });

                $scope.$on('$destroy', deregister);
            }).catch(function (error) {
                void 0;
            });

        }
    };

    ctrl.watchConnectionState = function () {
        var deregister = $scope.$watch('hsConversations.isConnected', function (newVal, oldVal) {
            void 0;
            if (!!newVal !== ctrl.isConnected) {
                ctrl.isConnected = !!newVal;
            }
        });

        $scope.$on('$destroy', deregister);
    };

    ctrl.isPackerAssigned = function() {
        return !!ctrl.orderData && !!ctrl.orderData.packer;
    }
}

hsApp.component('floatingButton', {
    templateUrl: '/partials/components/conversations/floating-button.html',
    bindings: {
        orderId: '<',
        onClick: '&',
        showChatWindow: '<',
        unreadMessagesCount: '<',
        isConnected: '<',
    },
    controller: ['toastr', floatingButtonController],
});

function floatingButtonController(toastr) {
    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
    };
}

hsApp.component('imageBufferComponent', {
    templateUrl: '/partials/components/conversations/image-buffer-component.html',
    bindings: {
        imageBuffer: '<',
        resetCameraImage: '&',
        sendingMessage: '<'
    },
    controller: ['toastr', imageBufferComponentController],
});

function imageBufferComponentController(toastr) {

    var ctrl = this;
    var logPrefix = ':imageBufferComponent';

    // Left these unimplemented
    // we are working with one image for now.
    ctrl.panLeft = function() {

    }

    ctrl.panRight = function() {

    }

    ctrl.deleteImage = function(index) {
        if (ctrl.sendingMessage) {
            toastr.error('Cannot delete a loaded image while sending.');
            return;
        }
        ctrl.imageBuffer.splice(index, 1);
        ctrl.resetCameraImage();
    }
}


hsApp.component('imagePreviewComponent', {
    templateUrl: '/partials/components/conversations/image-preview-component.html',
    bindings: {
        image: '<',
        index: '<',
        onDelete: '&'
    },
    controller: ['hsUtils', 'hsDialog', imagePreviewComponentController],
});

function imagePreviewComponentController(hsUtils, hsDialog) {

    var ctrl = this;
    ctrl.logPrefix = ':imagePreviewComponent:';
    ctrl.loading = true;

    ctrl.$onInit = function () {
        ctrl.parseImage(ctrl.image).then(function(result) {
            ctrl.imageSrc = result;
        });
    };

    ctrl.parseImage = function(file) {
        return hsUtils.readAsDataURL(file);
    }

    ctrl.zoom = function() {
        hsDialog.openZoomDialog(ctrl.imageSrc);
    }
}


hsApp.component('imageZoomComponent', {
    templateUrl: '/partials/components/conversations/image-zoom-component.html',
    bindings: {
        image: '<'
    },
    controller: [imageZoomComponentController],
});

function imageZoomComponentController() {

    var ctrl = this;
    ctrl.logPrefix = ':imageZoomComponent:';

    ctrl.isPortraitImage = function() {
        var img = $("#img");
        return img.height() > img.width();
    };
}
hsApp.component('orderConversation', {
    templateUrl: '/partials/components/conversations/order-conversation.html',
    bindings: {
        unreadCount: '<',
        conversation: '<',
    },
    controller: ['toastr', orderConversationController],
});

function orderConversationController(toastr) {
    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
    };

    ctrl.onClick = function () {
        void 0;
    }
}

hsApp.component('twImage', {
    templateUrl: '/partials/components/conversations/tw-image.html',
    bindings: {
        message: '=',
        orderId: '<'
    },
    controller: ['hsConversations', '$scope', 'hsDialog', twImageController],
});

function twImageController(hsConversations, $scope, hsDialog) {

    var ctrl = this;
    ctrl.logPrefix = 'twImage: ';

    ctrl.$onInit = function() {
        
        $scope.hsConversations = hsConversations;
        ctrl.src = (ctrl.message.twilioMessage && ctrl.message.twilioMessage.imageUrl) || null;
        var watchString = 'hsConversations.conversationIndex["' + ctrl.orderId + '"].messages[' + ctrl.message.index + '].imageUrl';
        var deregister = $scope.$watch(watchString, function (newVal, oldVal) {
            if (newVal && newVal !== oldVal) {
                ctrl.src = newVal;
                ctrl.loading = false;
            }
        });
        $scope.$on('$destroy', deregister);

        if (ctrl.message && ctrl.message.twilioMessage && hsConversations.hasImage(ctrl.message.twilioMessage)) {
            ctrl.loading = true;
            ctrl.loadImage(ctrl.message.twilioMessage)
                .catch(function(err) {
                    void 0;
                })
                .finally(function() {
                    ctrl.loading = false;
                });
        }
    }

    ctrl.loadImage = function(message) {
        return hsConversations.loadImage(message);
    }

    ctrl.fetchImageUrl = function(message) {
        ctrl.loading = true;
        hsConversations.fetchImageUrl(message)
            .then(function(url) {
                ctrl.src = url;
            })
            .catch(function() {
                void 0;
            })
            .finally(function() {
                ctrl.loading = false;
            });
    }

    ctrl.zoom = function() {
        hsDialog.openZoomDialog(ctrl.src);
    }

}


hsApp.component('couponsCreateView', {
    templateUrl: '/partials/components/coupons/coupons-create-view.html',
    bindings: {
        priceLists: '<',
        onViewChange: '&',
    },
    controller: ['toastr', 'hsCoupons', 'VALIDATORS', '$scope', 'hsAdmin', couponsCreateViewController],
});

function couponsCreateViewController(toastr, hsCoupons, VALIDATORS, $scope, hsAdmin) {
    var ctrl = this;
    var logPrefix = '[coupons]: ';

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.isLoading = false;
        ctrl.validationRules = VALIDATORS.COUPONS;
        ctrl.models = {
            code: '',
            description: '', 
            excludeServiceFee: false,
            expiry: {},
            forUser: false,
            image: '',
            isHidden: false,
            minOrder: 0,
            noofOrderConstraint: 0,
            singleUse: false,
            timesRedeemable: '',
            title: '',
            userEmail: '',
            value: {
                numValue: 0,
            },
        };
        var now = new Date();
        ctrl.datePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: now,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.datePicker.opened = !ctrl.datePicker.opened;
            },
            model: now,
        };
        ctrl.initOptions();
        ctrl.onDateChange();

        ctrl.editDisabled = {
            code: false,
            userEmail: true,
            excludeServiceFee: true,
            value: {
                numValue: false,
                isPercentage: false,
            },
            fulfillmentMethod: false,
            timesRedeemable: false,
        };
        ctrl.syncPriceListsPopup = {
            elementId: 'sync-create-coupon-popup',
            dataToPropagate: null,
        };
    };

    ctrl.initOptions = function () {
        ctrl.options = hsCoupons.getCouponFormOptions();

        if (Array.isArray(ctrl.priceLists)) {
            for (var i = 0; i < ctrl.priceLists.length; i++) {
                var pl = ctrl.priceLists[i];

                ctrl.options.pricelist.push({
                    name: pl.title,
                    value: pl.uniqueName,
                });
            }
        }
        ctrl.models.pricelist = ctrl.options.pricelist[0];

        for (var fieldName in ctrl.options) {
            if (!Array.isArray(ctrl.options[fieldName])) {
                for (var nestedFieldName in ctrl.options[fieldName]) {
                    ctrl.models[fieldName][nestedFieldName] = ctrl.options[fieldName][nestedFieldName][0];
                }
            } else {
                ctrl.models[fieldName] = ctrl.options[fieldName][0];
            }
        }
    };

    ctrl.onDateChange = function () {
        if (!(ctrl.datePicker.model instanceof Date)) return;
        ctrl.models.expiry.year = ctrl.datePicker.model.getFullYear();
        ctrl.models.expiry.month = ctrl.datePicker.model.getMonth();
        ctrl.models.expiry.day = ctrl.datePicker.model.getDate();
    };

    ctrl.onForUserChange = function(val) {
        ctrl.editDisabled.userEmail = !val;
    };

    ctrl.onSingleUseChange = function(val) {
        ctrl.editDisabled.timesRedeemable = val;
    };

    ctrl.onTypeChange = function() {
        var disable = ctrl.models.type.value === hsCoupons.couponTypes.PROMOTIONAL;

        ctrl.editDisabled.excludeServiceFee = disable;
        ctrl.editDisabled.value.numValue = !disable;
        ctrl.editDisabled.value.isPercentage = !disable;
        ctrl.editDisabled.fulfillmentMethod = !disable;

        if (ctrl.models.type.value === hsCoupons.couponTypes.FREE_DELIVERY) {
            var deliveryOption = ctrl.options.fulfillmentMethod.find(function(option) {
                return option.value === hsCoupons.fulfillmentMethods.DELIVERY;
            });
            ctrl.models.fulfillmentMethod = deliveryOption;
        }
    };
    
    ctrl.back = function () {
        ctrl.onViewChange();
    };

    ctrl.saveCoupon = function () {
        if (ctrl.couponForm.validate()) {
            var coupon = hsCoupons.getCouponObject(ctrl.models);

            void 0;

            ctrl.isLoading = true;

            hsCoupons.createCoupon(coupon)
                .then(function (res) {
                    toastr.success('Successfully Created');
                    ctrl.syncPriceListsPopup.dataToPropagate = coupon;
                    ctrl.openSyncPriceListsPopupOrContinue();
                })
                .catch(function (err) {
                    void 0;
                    toastr.error('Failed to create coupon');
                    ctrl.syncPriceListsPopup.dataToPropagate = null;
                    ctrl.error = err;
                })
                .finally(function () {
                    ctrl.isLoading = false;
                });
        }
    };    

    ctrl.propagateUpdateToTarget = function(target) {
        return hsCoupons.createCoupon(ctrl.syncPriceListsPopup.dataToPropagate, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        // don't show popup if setting pricelist field since this update can not be propagated as is
        if (!ctrl.syncPriceListsPopup.dataToPropagate.pricelist && hsAdmin.shouldShowSyncPriceListsPopup(true)) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                ctrl.handleUpdateCompletion();
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        } else {
            ctrl.handleUpdateCompletion();
        }
    };

    ctrl.handleUpdateCompletion = function() {
        ctrl.onViewChange();
    };

    ctrl.isPropagationErrorDueToUnavailable = function(err) {
        if (!err) return false;
        return (
            err.status === 404
            || (err.data && err.data.message === 'Coupon being created for invalid pricelist')
        );
    };
}

hsApp.component('couponsEditView', {
    templateUrl: '/partials/components/coupons/coupons-edit-view.html',
    bindings: {
        priceLists: '<',
        selectedCoupon: '<',
        onViewChange: '&',
    },
    controller: ['toastr', 'hsCoupons', 'VALIDATORS', '$scope', 'hsAdmin', couponsEditViewController],
});

function couponsEditViewController(toastr, hsCoupons, VALIDATORS, $scope, hsAdmin) {
    var ctrl = this;
    var logPrefix = '[coupons]: ';

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.isLoading = false;
        ctrl.validationRules = VALIDATORS.COUPONS;
        ctrl.models = {
            code: ctrl.selectedCoupon.code,
            description: ctrl.selectedCoupon.description, 
            excludeServiceFee: ctrl.selectedCoupon.excludeServiceFee || false,
            expiry: {
                day: ctrl.selectedCoupon.expiry.day,
                month: ctrl.selectedCoupon.expiry.month,
                year: ctrl.selectedCoupon.expiry.year,
            },
            forUser: ctrl.selectedCoupon.forUser,
            fulfillmentMethod: ctrl.selectedCoupon.fulfillmentMethod,
            image: ctrl.selectedCoupon.image,
            isHidden: ctrl.selectedCoupon.isHidden,
            minOrder: ctrl.selectedCoupon.minOrder,
            noofOrderConstraint: ctrl.selectedCoupon.noofOrderConstraint,
            singleUse: ctrl.selectedCoupon.singleUse,
            timesRedeemable: ctrl.selectedCoupon.timesRedeemable || '',
            title: ctrl.selectedCoupon.title,
            userEmail: ctrl.selectedCoupon.userEmail || '',
            value: {
                numValue: ctrl.selectedCoupon.value.numValue,
            },
        };
        ctrl.datePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.datePicker.opened = !ctrl.datePicker.opened;
            },
            model: new Date(ctrl.models.expiry.year, ctrl.models.expiry.month, ctrl.models.expiry.day),
        };
        ctrl.initOptions();
        ctrl.onDateChange();

        ctrl.editDisabled = {
            code: true,
            forUser: true, // Need to change how coupons are stored. Can't switch because user coupons are stored differently
            userEmail: true, // because of ^^
            excludeServiceFee: ctrl.models.type.value === hsCoupons.couponTypes.PROMOTIONAL,
            value: {
                numValue: ctrl.models.type.value === hsCoupons.couponTypes.FREE_DELIVERY,
                isPercentage: ctrl.models.type.value === hsCoupons.couponTypes.FREE_DELIVERY,
            },
            fulfillmentMethod: ctrl.models.type.value === hsCoupons.couponTypes.FREE_DELIVERY,
            timesRedeemable: ctrl.models.singleUse,
        };
        ctrl.syncPriceListsPopup = {
            elementId: 'sync-edit-coupon-popup',
            dataToPropagate: null,
        }
    };

    ctrl.initOptions = function () {
        ctrl.options = hsCoupons.getCouponFormOptions();

        if (Array.isArray(ctrl.priceLists) && ctrl.priceLists.length) {
            for (var i = 0; i < ctrl.priceLists.length; i++) {
                var pl = ctrl.priceLists[i];

                ctrl.options.pricelist.push({
                    name: pl.title,
                    value: pl.uniqueName,
                });
            }
        }

        for (var fieldName in ctrl.options) {
            if (!Array.isArray(ctrl.options[fieldName])) {
                for (var nestedFieldName in ctrl.options[fieldName]) {
                    var value = ctrl.selectedCoupon[fieldName][nestedFieldName];
                    var found = ctrl.options[fieldName][nestedFieldName].find(function (option) { return value === option.value; });
                    ctrl.models[fieldName][nestedFieldName] = found;
                }
            } else {
                var value = ctrl.selectedCoupon[fieldName];
                var found = ctrl.options[fieldName].find(function (option) { return value === option.value; });
                ctrl.models[fieldName] = found;
            }
        }

        if (!ctrl.models.pricelist) {
            ctrl.models.pricelist = ctrl.options.pricelist[0];
        }
    };

    ctrl.onDateChange = function () {
        if (!(ctrl.datePicker.model instanceof Date)) return;
        ctrl.models.expiry.year = ctrl.datePicker.model.getFullYear();
        ctrl.models.expiry.month = ctrl.datePicker.model.getMonth();
        ctrl.models.expiry.day = ctrl.datePicker.model.getDate();
    };

    ctrl.onForUserChange = function(val) {
        ctrl.editDisabled.userEmail = !val;
    };

    ctrl.onSingleUseChange = function(val) {
        ctrl.editDisabled.timesRedeemable = val;
    };

    ctrl.onTypeChange = function() {
        var disable = ctrl.models.type.value === hsCoupons.couponTypes.PROMOTIONAL;

        ctrl.editDisabled.excludeServiceFee = disable;
        ctrl.editDisabled.value.numValue = !disable;
        ctrl.editDisabled.value.isPercentage = !disable;
        ctrl.editDisabled.fulfillmentMethod = !disable;

        if (ctrl.models.type.value === hsCoupons.couponTypes.FREE_DELIVERY) {
            var deliveryOption = ctrl.options.fulfillmentMethod.find(function(option) {
                return option.value === hsCoupons.fulfillmentMethods.DELIVERY;
            });
            ctrl.models.fulfillmentMethod = deliveryOption;
        }
    };
    
    ctrl.back = function () {
        ctrl.onViewChange();
    };

    ctrl.saveCoupon = function () {
        if (ctrl.couponForm.validate()) {
            var coupon = hsCoupons.getCouponObject(ctrl.models);

            void 0;

            ctrl.isLoading = true;

            hsCoupons.updateCoupon(coupon)
                .then(function (res) {
                    toastr.success('Successfully Updated');
                    ctrl.syncPriceListsPopup.dataToPropagate = coupon;
                    ctrl.openSyncPriceListsPopupOrContinue();
                })
                .catch(function (err) {
                    void 0;
                    toastr.error('Failed to update coupon');
                    ctrl.syncPriceListsPopup.dataToPropagate = null;
                    ctrl.error = err;
                })
                .finally(function () {
                    ctrl.isLoading = false;
                });
        }
    };    

    ctrl.propagateUpdateToTarget = function(target) {
        return hsCoupons.updateCoupon(ctrl.syncPriceListsPopup.dataToPropagate, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        // don't show popup if setting pricelist field since this update can not be propagated as is
        if (!ctrl.syncPriceListsPopup.dataToPropagate.pricelist && hsAdmin.shouldShowSyncPriceListsPopup(true)) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                ctrl.handleUpdateCompletion();
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        } else {
            ctrl.handleUpdateCompletion();
        }
    };

    ctrl.handleUpdateCompletion = function() {
        ctrl.onViewChange();
    };

    ctrl.isPropagationErrorDueToUnavailable = function(err) {
        if (!err) return false;
        return (
            err.status === 404
            || (err.data && err.data.message === 'Invalid pricelist key')
        );
    };
}

hsApp.component('couponsMain', {
    templateUrl: '/partials/components/coupons/coupons-main.html',
    controller: [couponsMainController],
});

function couponsMainController() {
    var ctrl = this;
    var logPrefix = '[coupons]: ';
    var loadMoreStep = 20;

    ctrl.$onInit = function () {
        ctrl.error = '';

        const now = new Date();

        ctrl.startDate = now;
        ctrl.endDate = now;
        ctrl.view = 'coupons';
        ctrl.selectedDelivery = {};
        ctrl.priceLists = [];
    };

    ctrl.selectView = function (view) {
        ctrl.view = view || 'coupons';
        void 0
    };

    ctrl.onStartDateChange = function (date) {
        ctrl.startDate = date;
    };

    ctrl.onEndDateChange = function (date) {
        ctrl.endDate = date;
    };

    ctrl.onSetSelectedCoupon = function(coupon) {
        ctrl.selectedCoupon = coupon;
    };

    ctrl.setPriceLists = function(priceLists) {
        ctrl.priceLists = priceLists;
    };

}

hsApp.component('couponsView', {
    templateUrl: '/partials/components/coupons/coupons-view.html',
    bindings: {
        onViewChange: '&',
        onSetSelectedCoupon: '&',
        setPriceLists: '&',
    },
    controller: ['toastr', 'hsCoupons', '$filter', couponsViewController],
});

function couponsViewController(toastr, hsCoupons, $filter) {
    var ctrl = this;
    var logPrefix = '[coupons]: ';

    ctrl.$onInit = function () {
        ctrl.loadMoreStep = 20;
        ctrl.error = '';
        ctrl.isLoading = true;
        ctrl.coupons = [];
        ctrl.filteredCoupons = [];
        ctrl.loadMoreData = [];

        ctrl.getCoupons();
    };

    ctrl.getCoupons = function () {
        return hsCoupons.getCoupons()
            .then(function (res) {
                void 0;
                ctrl.coupons = res.coupons;
                ctrl.priceLists = res.priceLists;
                ctrl.setPriceLists({ priceLists: res.priceLists});
                ctrl.initFilters(ctrl.coupons);
                ctrl.filterCoupons();
            })
            .catch(function (err) {
                void 0;

                if (err.message) {
                    ctrl.error = err.message;
                } else {
                    ctrl.error = 'Failed to get coupons';
                }
                toastr.error(ctrl.error);
                ctrl.coupons = [];
                ctrl.loadMoreData = [];
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.initFilters = function (coupons) {
        ctrl.setDefaultFilters();
        var availableOptions = ctrl.collectAvailableFilterOptions(coupons);
        ctrl.applyAvailableFilterOptions(availableOptions);
    };

    ctrl.setDefaultFilters = function () {
        ctrl.filters = {
            options: hsCoupons.getOptionsFilters(),
            input: hsCoupons.getInputFilters(),
            models: {},
        };
        for (var fieldName in ctrl.filters.options) {
            var defaultOption = Object.values(ctrl.filters.options[fieldName]).find(function (o) { return o.default; });
            if (!defaultOption) {
                defaultOption = ctrl.filters.options[fieldName].all;
            }
            ctrl.filters.models[fieldName] = defaultOption;
        }
        for (var fieldName in ctrl.filters.input) {
            ctrl.filters.models[fieldName] = {
                value: '',
                comparator: ctrl.filters.input[fieldName].comparator,
            };
        }
        void 0;
    };

    ctrl.collectAvailableFilterOptions = function (coupons) {
        if (!Array.isArray(coupons)) return {};

        var availableOptions = {};

        for (var i = 0; i < coupons.length; i++) {
            var coupon = coupons[i];

            for (var fieldName in ctrl.filters.options) {
                var value = coupon[fieldName];
                var converter = hsCoupons.getOptionFilterValueConverter(fieldName);

                if (converter) {
                    value = converter(value);
                }
                if (!(fieldName in availableOptions)) {
                    availableOptions[fieldName] = [];
                }
                if (!availableOptions[fieldName].includes(value)) {
                    availableOptions[fieldName].push(value);
                }
            }
        }
        void 0;
        return availableOptions;
    };

    ctrl.applyAvailableFilterOptions = function (availableOptions) {
        for (var fieldName in ctrl.filters.options) {
            var optionsFilter = ctrl.filters.options[fieldName];

            for (var value in optionsFilter) {
                if (!availableOptions[fieldName]) {
                    continue;
                }
                if (!availableOptions[fieldName].includes(value) && !optionsFilter[value].default) {
                    delete optionsFilter[value];
                }
            }
        }
    };

    ctrl.filterCoupons = function () {
        ctrl.filteredCoupons = ctrl.coupons;

        for (var fieldName in ctrl.filters.models) {
            var model = ctrl.filters.models[fieldName];
            var filterObj = {};
            filterObj[fieldName] = model.value;
            ctrl.filteredCoupons = $filter('filter')(ctrl.filteredCoupons, filterObj, model.comparator);
        }
        ctrl.loadMoreData = [];
        ctrl.loadMore();
    };

    ctrl.resetFilters = function () {
        ctrl.setDefaultFilters();
        ctrl.filterCoupons();
    };

    ctrl.getCouponDisplayType = function (coupon) {
        return hsCoupons.getCouponDisplayType(coupon.type);
    };

    ctrl.getCouponDisplayValue = function (coupon) {
        return hsCoupons.getCouponDisplayValue(coupon.value);
    };

    ctrl.getCouponDisplayExpiration = function (coupon) {
        return hsCoupons.getCouponDisplayExpiration(coupon.expiry);
    };

    ctrl.getDisplayPriceListName = function (coupon) {
        return hsCoupons.getDisplayPriceListName(coupon.pricelist, ctrl.priceLists);
    };

    ctrl.getDisplayMaxOrders = function (coupon) {
        return hsCoupons.getDisplayMaxOrders(coupon.noofOrderConstraint);
    };

    ctrl.getDisplayMaxUses = function (coupon) {
        return hsCoupons.getDisplayMaxUses(coupon.timesRedeemable, coupon.singleUse);
    };

    ctrl.loadMore = function () {
        var currentLength = ctrl.loadMoreData.length;
        var totalLength = ctrl.filteredCoupons.length;

        if (currentLength < totalLength) {
            var endCount = Math.min(currentLength + ctrl.loadMoreStep, totalLength);
            ctrl.loadMoreData = ctrl.loadMoreData.concat(ctrl.filteredCoupons.slice(currentLength, endCount));
        }
    };

    ctrl.showCreateCoupon = function () {
        ctrl.onViewChange({ view: 'createCoupon' });
    };

    ctrl.showEditCoupon = function (coupon) {
        ctrl.onViewChange({ view: 'editCoupon' });
        ctrl.onSetSelectedCoupon({ selectedCoupon: coupon });
    };

}

hsApp.component('deliveriesImportView', {
    templateUrl: '/partials/components/delivery-service/deliveries-import-view.html',
    bindings: {
        onViewChange: '&'
    },
    controller: ['globalFunctions', 'hsDelivery', 'toastr', 'NgTableParams', deliveriesImportViewController],
});

function deliveriesImportViewController(globalFunctions, hsDelivery, toastr, NgTableParams) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';
    var loadMoreStep = 20;

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.isLoading = false;
        ctrl.eventAdded = false;
        ctrl.parsed = null;
        ctrl.selectedView = 'valid';
        ctrl.importResultsView = false;
        ctrl.importResults = null;
        ctrl.fileInputElement = null;
        ctrl.statsBtnClass = {
            deliveryObjectsCreated: 'btn-primary',
            existingDeliveries: 'btn-secondary',
            errors: 'btn-warning',
            total: 'btn-info'
        };
    
        ctrl.statsBtnDisplayNames = {
            deliveryObjectsCreated: 'Created',
            existingDeliveries: 'Already Exist',
            errors: 'Errors',
            total: 'Total'
        };
    };

    ctrl.back = function () {
        ctrl.onViewChange();
    };

    ctrl.loadCSV = function (val) {
        if (!ctrl.fileInputElement) {
            ctrl.fileInputElement = document.getElementById('fileInput');
        }
        ctrl.fileInputElement.value = null;

        if (!ctrl.eventAdded) {
            ctrl.eventAdded = true;

            ctrl.fileInputElement.addEventListener('change', function(event) {
                var file = null;
                try {
                    file = event.target.files[0];
                }
                catch (err) {
                    void 0;
                }
              ctrl.parseFile(file);
            });
        }
        ctrl.fileInputElement.click();
    };

    ctrl.parseFile = function (file) {
        ctrl.error = '';
        ctrl.isLoading = true;
        ctrl.selectedView = 'valid';
        ctrl.parsed = null;
        ctrl.importResultsView = false;
        ctrl.importResults = null;

        hsDelivery.getParsedFile(file)
            .then(function (data) {
                void 0;
                ctrl.processParsed(data);
                toastr.success('Successfully parsed file');
            })
            .catch(function (err) {
                void 0;
                toastr.error('Error parsing file');
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.processParsed = function (data) {
        ctrl.parsed = {
            valid: data.validRows,
            invalid: data.rowsWithErrors,
            duplicates: data.duplicateRowsInCsv,
            existing: data.existingDeliveries,
        };
        ctrl.setTableData(ctrl.parsed[ctrl.selectedView]);
    };

    ctrl.selectView = function (view) {
        ctrl.selectedView = view;

        ctrl.setTableData(ctrl.parsed[view]);
    };

    ctrl.importValid = function () {
        ctrl.error = '';
        ctrl.isLoading = true;

        hsDelivery.importDeliveryObjects(ctrl.parsed.valid)
            .then(function (res) {
                ctrl.fileInputElement.value = null;
                ctrl.parsed = null;
                ctrl.importResultsView = true;
                ctrl.importResults = res;
                toastr.success('Successfully imported deliveries');

            })
            .catch(function (err) {
                void 0;
                toastr.error('Error importing deliveries');
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.setTableData = function (data) {
        ctrl.tableParams = new NgTableParams(
            {
                count: globalFunctions.ngTableConfig.count,
            },
            {
                counts: globalFunctions.ngTableConfig.counts,
                dataset: data,
            }
        );
    };

    ctrl.getImportedResultClass = function (key) {
        return ctrl.statsBtnClass[key] || 'btn-primary';
    };

    ctrl.getImportedResultDisplayName = function (key) {
        return ctrl.statsBtnDisplayNames[key] || '';
    };

}

hsApp.component('deliveriesPopup', {
    templateUrl: '/partials/components/delivery-service/deliveries-popup.html',
    bindings: {
        deliveries: '<',
        onClose: '&',
    },
    controller: [deliveriesPopupController],
});

function deliveriesPopupController() {
    var ctrl = this;

    ctrl.$onInit = function () {};

}

hsApp.component('deliveriesView', {
    templateUrl: '/partials/components/delivery-service/deliveries-view.html',
    bindings: {
        startDate: '<',
        endDate: '<',
        onViewChange: '&',
        onStartDateChange: '&',
        onEndDateChange: '&',
        onSetSelectedDelivery: '&',
    },
    controller: ['$scope', 'toastr', 'hsDelivery', 'hsUtils', '$filter', 'ngDialog', deliveriesViewController],
});

function deliveriesViewController($scope, toastr, hsDelivery, hsUtils, $filter, ngDialog) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';

    ctrl.$onInit = function () {
        ctrl.loadMoreStep = 20;
        ctrl.error = '';
        ctrl.isLoading = true;
        ctrl.deliveries = [];
        ctrl.filteredDeliveries = [];
        ctrl.loadMoreData = [];
        ctrl.showActionsPopup = false;

        ctrl.filtersWithOptions = ['state', 'deliverable', 'deliveryDateStr', 'deliveryTimeStr', 'containsAlcohol'];
        ctrl.filters = {
            selected: {},
            options: {
                models: {},
                availableSelection: {},
            },
            toTransform: {},
        };
        ctrl.setDefaultFilters();

        ctrl.startDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.startDatePicker.opened = !ctrl.startDatePicker.opened;
            },
            model: ctrl.startDate,
        };
        ctrl.endDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: ctrl.startDatePicker.model,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.endDatePicker.opened = !ctrl.endDatePicker.opened;
            },
            model: ctrl.endDate,
        };

        ctrl.filterDisplayNames = {
            unscheduled: 'Unscheduled',
            quoted: 'Quoted',
            pending: 'Pending',
            pickup: 'Pickup',
            pickup_complete: 'Pickup Complete',
            dropoff: 'Dropoff',
            delivered: 'Delivered',
            canceled: 'Canceled',
            returned: 'Returned',
            failed: 'Failed',
            scheduling: 'Scheduling',

            unknown: 'Unknown',
            deliverable: 'Deliverable',
            'cannot deliver': 'Undeliverable',

            true: 'Yes',
            false: 'No',
        };

        ctrl.getDeliveries();

        ctrl.refreshInterval = setInterval(function() {
            ctrl.getDeliveries();
        }, 60000);
    };

    ctrl.$onDestroy = function() {
        clearInterval(ctrl.refreshInterval);
    };

    ctrl.onDateChange = function (changed) {
        ctrl.isLoading = true;

        if (ctrl.bulkScheduling) {
            ctrl.toggleBulkSchedule();
        }

        if (changed === 'startDate') {
            ctrl.onStartDateChange({ date: ctrl.startDatePicker.model });
            ctrl.endDatePicker.options.minDate = ctrl.startDatePicker.model;

            if (ctrl.startDatePicker.model > ctrl.endDatePicker.model) {
                ctrl.endDatePicker.model = ctrl.startDatePicker.model;
                ctrl.onEndDateChange({ date: ctrl.endDatePicker.model });
            }
        }
        if (changed === 'endDate') {
            ctrl.onEndDateChange({ date: ctrl.endDatePicker.model });
        }
        ctrl.getDeliveries();
    };

    ctrl.getDeliveries = function () {
        return hsDelivery.getDeliveries(ctrl.startDatePicker.model, ctrl.endDatePicker.model)
            .then(function (deliveries) {
                void 0;
                ctrl.deliveries = ctrl.processDeliveries(deliveries);
                ctrl.filterDeliveries();
            })
            .catch(function (err) {
                void 0;

                if (err.message) {
                    ctrl.error = err.message;
                } else {
                    ctrl.error = 'Failed to get deliveries';
                }
                toastr.error(ctrl.error);
                ctrl.deliveries = [];
                ctrl.loadMoreData = [];
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.processDeliveries = function (deliveries) {
        if (!Array.isArray(deliveries)) return [];

        var date = new Date();

        var allFilterOption = {
            name: 'All',
            value: 'All',
        }

        var stateAvailableFilters = [];
        var stateFinalFilters = [];

        var deliverableAvailableFilters = [];
        var deliverableFinalFilters = [];

        var deliveryDateAvailableFilters = [];
        var deliveryDateFinalFilters = [];

        var deliveryTimeAvailableFilters = [];
        var deliveryTimeFinalFilters = [];

        var containsAlcoholAvailableFilters = [];
        var containsAlcoholFinalFilters = [];

        for (var i = 0; i < deliveries.length; i++) {
            var delivery = deliveries[i];

            delivery.fullName = delivery.firstName + ' ' + delivery.lastName;
            delivery.addressStr = hsDelivery.getAddress(delivery.address);
            delivery.deliveryDateStr = hsDelivery.getDeliveryDate(delivery.deliveryDate);
            delivery.deliveryTimeStr = hsDelivery.getDeliveryTime(delivery.deliveryTime);
            delivery.phoneNumberStr = delivery.phoneNumber.replace(/[^0-9]/g, '');

            if (!stateAvailableFilters.includes(delivery.state)) {
                stateAvailableFilters.push(delivery.state);
                stateFinalFilters.push({
                    name: ctrl.filterDisplayNames[delivery.state],
                    value: delivery.state
                });
            }
            if (!deliverableAvailableFilters.includes(delivery.deliverable)) {
                deliverableAvailableFilters.push(delivery.deliverable);
                deliverableFinalFilters.push({
                    name: ctrl.filterDisplayNames[delivery.deliverable],
                    value: delivery.deliverable
                });
            }
            if (!deliveryDateAvailableFilters.includes(delivery.deliveryDateStr)) {
                deliveryDateAvailableFilters.push(delivery.deliveryDateStr);
                deliveryDateFinalFilters.push({
                    name: delivery.deliveryDateStr,
                    value: delivery.deliveryDateStr,
                    filterValue: new Date(delivery.deliveryDate.year, delivery.deliveryDate.month-1, delivery.deliveryDate.date),
                });
            }
            if (!deliveryTimeAvailableFilters.includes(delivery.deliveryTimeStr)) {
                deliveryTimeAvailableFilters.push(delivery.deliveryTimeStr);
                
                date = new Date();
                date.setHours(delivery.deliveryTime.hour, delivery.deliveryTime.minute)

                deliveryTimeFinalFilters.push({
                    name: delivery.deliveryTimeStr,
                    value: delivery.deliveryTimeStr,
                    filterValue: date,
                });
            }
            if (delivery.containsAlcohol !== undefined && !containsAlcoholAvailableFilters.includes(delivery.containsAlcohol)) {
                containsAlcoholAvailableFilters.push(delivery.containsAlcohol);
                containsAlcoholFinalFilters.push({
                    name: ctrl.filterDisplayNames[delivery.containsAlcohol],
                    value: delivery.containsAlcohol
                });
            }
        }

        stateFinalFilters.sort(ctrl.sortObjectsByKey);
        deliverableFinalFilters.sort(ctrl.sortObjectsByKey);
        deliveryDateFinalFilters.sort(ctrl.sortDeliveryDateTimeFilters);
        deliveryTimeFinalFilters.sort(ctrl.sortDeliveryDateTimeFilters);
        containsAlcoholFinalFilters.sort(ctrl.sortObjectsByKey);

        ctrl.filters.options.availableSelection.state = [allFilterOption].concat(stateFinalFilters);
        ctrl.filters.options.availableSelection.deliverable = [allFilterOption].concat(deliverableFinalFilters);
        ctrl.filters.options.availableSelection.deliveryDateStr = [allFilterOption].concat(deliveryDateFinalFilters);
        ctrl.filters.options.availableSelection.deliveryTimeStr = [allFilterOption].concat(deliveryTimeFinalFilters);
        ctrl.filters.options.availableSelection.containsAlcohol = [allFilterOption].concat(containsAlcoholFinalFilters);

        return deliveries;
    };

    ctrl.sortObjectsByKey = function(a, b) {
        if (!hsUtils.isObject(a) || !hsUtils.isObject(b)) return 0;

        var x = a.name; var y = b.name;
        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    }

    ctrl.sortDeliveryDateTimeFilters = function (a, b) {

        if (!hsUtils.isObject(a) || !hsUtils.isObject(b)) return 0;

        var x = a.filterValue; var y = b.filterValue;
        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    };

    ctrl.filterDeliveries = function () {
        ctrl.filteredDeliveries = $filter('filter')(ctrl.deliveries, ctrl.filters.selected);
        ctrl.loadMoreData = [];
        ctrl.loadMore();
    };

    ctrl.loadMore = function () {
        var currentLength = ctrl.loadMoreData.length;
        var totalLength = ctrl.filteredDeliveries.length;

        if (currentLength < totalLength) {
            var endCount = Math.min(currentLength + ctrl.loadMoreStep, totalLength);
            ctrl.loadMoreData = ctrl.loadMoreData.concat(ctrl.filteredDeliveries.slice(currentLength, endCount));
        }
    };

    ctrl.showResetFilters = function () {
        for (var option of Object.keys(ctrl.filters.selected)) {
            if (ctrl.filters.selected[option]) return true;
        }
        return false;
    };
    
    ctrl.setDefaultFilters = function () {
        ctrl.filters.selected = {
            fullName: '',
            id: '',
            addressStr: '',
            state: '',
            deliverable: '',
            deliveryDateStr: '',
            deliveryTimeStr: '',
            phoneNumberStr: '',
            orderTotal: '',
            containsAlcohol: '',
        };
        ctrl.filters.toTransform = {
            phoneNumberStr: '',
        };
        ctrl.filtersWithOptions.forEach(function (key) {
            ctrl.filters.options.models[key] = { name:'All', value:'All' };

            if (!Array.isArray(ctrl.filters.options.availableSelection[key])) {
                ctrl.filters.options.availableSelection[key] = [{ name:'All', value: 'All' }];
            }
        });
    };

    ctrl.resetFilters = function () {
        ctrl.setDefaultFilters();
        ctrl.filterDeliveries();
    };

    ctrl.onOptionsFilterChange = function (type) {
        var newValue = ctrl.filters.options.models[type].value === 'All' ? '' : ctrl.filters.options.models[type].value;
        ctrl.processSpecialFilter(type, newValue);
    };

    ctrl.onPhoneNumberFilterChange = function () {
        var newValue = ctrl.filters.toTransform.phoneNumberStr.replace(/[^0-9]/g, '');
        ctrl.processSpecialFilter('phoneNumberStr', newValue);
    };

    ctrl.processSpecialFilter = function (type, newValue) {
        if (ctrl.filters.selected[type] !== newValue) {
            ctrl.filters.selected[type] = newValue;
            ctrl.filterDeliveries();
        }
    };

    ctrl.getDeliveryDate = function (date) {
        return hsDelivery.getDeliveryDate(date);
    };

    ctrl.getDeliveryTime = function (time) {
        return hsDelivery.getDeliveryTime(time);
    };

    ctrl.getDeliveryState = function (state) {
        return hsDelivery.getDisplayDeliveryState(state);
    };

    ctrl.getDeliverableState = function (state) {
        return hsDelivery.getDisplayDeliverableState(state);
    };

    ctrl.getQuotedFee = function (state) {
        return hsDelivery.getDisplayQuotedFee(state);
    };

    ctrl.showAddDelivery = function () {
        ctrl.onViewChange({ view: 'addDelivery' });
    };

    ctrl.showEditDelivery = function (delivery) {
        ctrl.onViewChange({ view: 'editDelivery' });
        ctrl.onSetSelectedDelivery({ selectedDelivery: delivery })
    };

    ctrl.showImportDeliveries = function () {
        ctrl.onViewChange({ view: 'importDeliveries' });
    };

    ctrl.cancelDelivery = function (delivery, event) {
        event.stopPropagation();

        return ngDialog.openConfirm({
            data: {
                heading: 'Cancel Delivery',
                subHeading: 'Are you sure you would like to cancel the delivery?',
                confirmBtnText: 'Yes',
                cancelBtnText: 'No'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function(ok) {
                ctrl.isLoading = true;

                hsDelivery.cancelDelivery(delivery)
                    .then(function (res) {
                        toastr.success('Canceled');
                        return ctrl.getDeliveries();
                    })
                    .catch(function (err) {
                        void 0;
                        toastr.error('Failed to cancel');
                    })
                    .finally(function () {
                        ctrl.isLoading = false;
                    });
                })
            .catch(function(cancel) {});

    };

    ctrl.deleteDeliveryObject = function (delivery, event) {
        event.stopPropagation();

        return ngDialog.openConfirm({
            data: {
                heading: 'Delete Delivery',
                subHeading: 'Are you sure you would like to delete the delivery?',
                confirmBtnText: 'Yes',
                cancelBtnText: 'No'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function(ok) {
                ctrl.isLoading = true;

                hsDelivery.deleteDeliveryObject(delivery)
                    .then(function (res) {
                        toastr.success('Deleted');
                        return ctrl.getDeliveries();
                    })
                    .catch(function (err) {
                        void 0;
                        toastr.error('Failed to delete');
                    })
                    .finally(function () {
                        ctrl.isLoading = false;
                    });
                })
            .catch(function(cancel) {});

    };

    ctrl.showDeliveriesPopup = function (delivery) {
        var $newScope = $scope.$new(true);
        $newScope.deliveries = delivery.deliveries;

        return ngDialog.open({
            template: '<deliveries-popup '
                + 'on-close="closeThisDialog()" '
                + 'deliveries="deliveries" '
                + '></deliveries-popup>',
            className: 'ngdialog-theme-default hds-deliveries-dialog',
            plain: true,
            scope: $newScope,
        }).closePromise
            .then(function(data) {
                void 0;
                // if (data.value && !isNaN(data.value)) {
                //     ctrl.selectedItem.price = Number(data.value);
                //     return 'success';
                // }
            })
            .catch(function(err) {
                void 0;
            });
    };

    ctrl.showScheduleDeliveryPopup = function (delivery, event) {
        event.stopPropagation();

        var $newScope = $scope.$new(true);
        $newScope.delivery = delivery;

        return ngDialog.open({
            template: '<schedule-delivery-popup '
                + 'on-close="closeThisDialog(value)" '
                + 'delivery="delivery" '
                + '></schedule-delivery-popup>',
            className: 'ngdialog-theme-default',
            plain: true,
            scope: $newScope,
        }).closePromise
            .then(function(data) {
                if (data.value === 'success') {
                    ctrl.getDeliveries();
                }
            })
            .catch(function(err) {
                void 0;
            });
    };

    ctrl.isDeliverable = function (delivery) {
        return hsDelivery.isDeliverable(delivery);
    };

    ctrl.isUndeliverable = function (delivery) {
        return hsDelivery.isUndeliverable(delivery);
    };

    ctrl.toggleBulkSchedule = function () {
        ctrl.selectedDeliveriesToSchedule = {};
        ctrl.bulkScheduling = !ctrl.bulkScheduling;
        if (ctrl.showActionsPopup) {
            ctrl.showActionsPopup = !ctrl.showActionsPopup;
        } 

        if (ctrl.bulkScheduling) {
            ctrl.filteredDeliveries.forEach(function (del) {
                var canSchedule = ctrl.canSchedule(del);
                ctrl.selectedDeliveriesToSchedule[del.id] = {
                    selected: canSchedule,
                    disabled: !canSchedule,
                };
            });
        }
    };

    ctrl.selectDeliveryToBulkSchedule = function (delivery, event) {
        event.stopPropagation();

        var delivery = ctrl.selectedDeliveriesToSchedule[delivery.id];

        if (!delivery || delivery.disabled) return;

        delivery.selected = !delivery.selected;
    };

    ctrl.bulkSchedule = function () {
        ctrl.isLoading = true;
        var deliveryIds = Object.keys(ctrl.selectedDeliveriesToSchedule).filter(function (id) {
            return ctrl.selectedDeliveriesToSchedule[id].selected;
        });
        hsDelivery.bulckScheduleDeliveries(deliveryIds)
            .then(function (res) {
                toastr.success('Bulk request sent');
                ctrl.toggleBulkSchedule();
            })
            .catch(function (err) {
                void 0;
                toastr.error('Failed to send bulk request');
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.canSchedule = function (delivery) {
        return hsDelivery.canScheduleDelivery(delivery);
    };

    ctrl.canDelete = function (delivery) {
        return hsDelivery.canDeleteDelivery(delivery);
    };

    ctrl.canEdit = function (delivery) {
        return hsDelivery.canEditDelivery(delivery);
    };

    ctrl.canCancel = function (delivery) {
        return hsDelivery.canCancelDelivery(delivery);
    };

    ctrl.getPickupTimeTitle = function (delivery) {
        return hsDelivery.getPickupTimeTitle(delivery);
    };

    ctrl.getPickupTimeDisplay = function (delivery) {
        return hsDelivery.getPickupTimeDisplay(delivery);
    };

    ctrl.getDeliveryTimeTitle = function (delivery) {
        return hsDelivery.getDeliveryTimeTitle(delivery);
    };

    ctrl.getDeliveryTimeDisplay = function (delivery) {
        return hsDelivery.getDeliveryTimeDisplay(delivery);
    };

    ctrl.showTrackDeliveryButton = function (delivery) {
        return hsDelivery.showTrackDeliveryButton(delivery);
    };

    ctrl.trackLastDelivery = function (delivery) {
        return hsDelivery.trackLastDelivery(delivery);
    };

    ctrl.toggleActionsPopup = function() {
        ctrl.showActionsPopup = !ctrl.showActionsPopup;
    }
}

hsApp.component('deliveryAddView', {
    templateUrl: '/partials/components/delivery-service/delivery-add-view.html',
    bindings: {
        onViewChange: '&'
    },
    controller: ['toastr', 'hsDelivery', 'address', deliveryAddViewController],
});

function deliveryAddViewController(toastr, hsDelivery, address) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.isLoading = false;
        ctrl.addressWasAutoFilled = false;
        ctrl.model = {
            id: '',
            firstName: '',
            lastName: '',
            businessName: '',
            address: {
                street: '',
                aptUnit: '',
                city: '',
                state: '',
                zip: '',
            },
            phoneNumber: '',
            deliveryDate: {
                year: '',
                month: '',
                date: '',
            },
            deliveryTime: {
                hour: '',
                minute: '',
            },
            bagCount: 0,
            tip: 0,
            orderTotal: 0,
            instructions: '',
            containsAlcohol: false,
        };

        var now = new Date();

        ctrl.datePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: now,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.datePicker.opened = !ctrl.datePicker.opened;
            },
            model: null,
        };
        ctrl.onDateChange();
    };

    ctrl.back = function () {
        ctrl.onViewChange();
    };

    ctrl.createDelivery = function () {
        void 0
    };

    ctrl.addressAutoComplete = function () {
        ctrl.addressWasAutoFilled = false;

        if (typeof ctrl.model.addressInputField !== 'string' && ctrl.model.addressInputField) {
            ctrl.addressWasAutoFilled = true;
            ctrl.updateAddressModel();
        }
    };

    ctrl.updateAddressModel = function () {
        if (!ctrl.model.addressInputField || typeof ctrl.model.addressInputField  === 'string' || !ctrl.addressWasAutoFilled) {
            return;
        }
        var parsedAddress = address.getAutoCompleteAddress(ctrl.model.addressInputField);
        ctrl.model.address.street = parsedAddress.street1;
        ctrl.model.address.city = parsedAddress.city;
        ctrl.model.address.state = parsedAddress.state;
        ctrl.model.address.zip = parsedAddress.zip;
    };

    ctrl.getDisplayAddress = function () {
        var address = ctrl.model.address;

        if (!address || !address.street || !address.city || !address.state || !address.zip) return '';


        return ': ' + address.street + ' ' + address.aptUnit + ', ' + address.city + ', ' + address.state + ', ' + address.zip;
    };

    ctrl.onDateChange = function () {
        if (!(ctrl.datePicker.model instanceof Date)) return;
        ctrl.model.deliveryDate.year = ctrl.datePicker.model.getFullYear();
        ctrl.model.deliveryDate.month = ctrl.datePicker.model.getMonth() + 1;
        ctrl.model.deliveryDate.date = ctrl.datePicker.model.getDate();
    };

    ctrl.onTimeChange = function () {
        if (!ctrl.model.deliveryTimeInputField) return;

        var time = ctrl.model.deliveryTimeInputField;

        ctrl.model.deliveryTime.hour = time.getHours();
        ctrl.model.deliveryTime.minute = time.getMinutes();
    };

    ctrl.createDeliveryObject = function () {
        ctrl.error = '';
        var data = Object.assign({}, ctrl.model);

        if (!data.id) {
            delete data.id;
        }
        if (!isNaN(data.bagCount)) {
            data.bagCount = +data.bagCount;
        }
        if (!isNaN(data.orderTotal)) {
            data.orderTotal = +data.orderTotal;
        }
        if (!isNaN(data.tip)) {
            data.tip = +data.tip;
        }
        void 0;
        ctrl.isLoading = true;

        hsDelivery.createDeliveryObject(data)
            .then(function (res) {
                toastr.success('Successfully created');
                ctrl.onViewChange();

            })
            .catch(function (err) {
                void 0;
                toastr.error(err);
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

}

hsApp.component('deliveryEditView', {
    templateUrl: '/partials/components/delivery-service/delivery-edit-view.html',
    bindings: {
        onViewChange: '&',
        selectedDelivery: '<',
    },
    controller: ['toastr', 'hsDelivery', 'address', '$filter', deliveryEditViewController],
});

function deliveryEditViewController(toastr, hsDelivery, address, $filter) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';

    ctrl.$onInit = function () {
    
        ctrl.error = '';
        ctrl.isLoading = false;
        ctrl.addressWasAutoFilled = false;
        ctrl.model = {
            id: ctrl.selectedDelivery.id,
            firstName: ctrl.selectedDelivery.firstName,
            lastName: ctrl.selectedDelivery.lastName,
            businessName: ctrl.selectedDelivery.businessName,
            phoneNumber: ctrl.selectedDelivery.phoneNumber,
            bagCount: ctrl.selectedDelivery.bagCount,
            tip: ctrl.selectedDelivery.tip,
            orderTotal: ctrl.selectedDelivery.orderTotal,
            instructions: ctrl.selectedDelivery.instructions,
            containsAlcohol: ctrl.selectedDelivery.containsAlcohol,
        };

        var address = {
            street: ctrl.selectedDelivery.address.street,
            aptUnit: ctrl.selectedDelivery.address.aptUnit,
            city: ctrl.selectedDelivery.address.city,
            state: ctrl.selectedDelivery.address.state,
            zip: ctrl.selectedDelivery.address.zip,
        }

        ctrl.model.address = address;
        ctrl.model.addressInputField = ctrl.createAddressDisplay(address);

        var date = {
            year: ctrl.selectedDelivery.deliveryDate.year,
            month: ctrl.selectedDelivery.deliveryDate.month,
            date: ctrl.selectedDelivery.deliveryDate.date,
        };

        var time = {
            hour: ctrl.selectedDelivery.deliveryTime.hour,
            minute: ctrl.selectedDelivery.deliveryTime.minute,
        };

        ctrl.model.deliveryDate = date;
        ctrl.model.deliveryTime = time;

        var now = new Date();

        ctrl.datePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: now,
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.datePicker.opened = !ctrl.datePicker.opened;
            },
            model: new Date(date.year, date.month-1, date.date),
        };
        ctrl.onDateChange();

        setTimeout(function () {
            var element = $("#deliveryTime");
            var hour = (time.hour < 10) ? '0' + time.hour : time.hour;
            var minute = (time.minute < 10) ? '0' + time.minute : time.minute;

            element.val(hour + ':' + minute);
        }, 0);

    };

    ctrl.validationRules = {
        rules: {
            id:{
                required:true,
            },
            firstName:{
                required:true,
            },
            lastName:{
                required:true,
            },
            phoneNumber:{
                required:true,
                phoneUS: true
            },
            addressInputField:{
                required:true,
            },
            deliveryDate:{
                required:true,
            },
            deliveryTime:{
                required:true,
            },
            orderTotal:{
                required:true,
                number: true,
            },
        }
    };

    ctrl.createAddressDisplay = function(address) {

        if (!address || !address.street || !address.city || !address.state || !address.zip) return '';

        return address.street + ', ' + address.city + ', ' + address.state + ', ' + address.zip;
    };
    
    ctrl.back = function () {
        ctrl.onViewChange();
    };

    ctrl.editDelivery = function () {
        void 0;
    };

    ctrl.addressAutoComplete = function () {
        ctrl.addressWasAutoFilled = false;

        if (typeof ctrl.model.addressInputField !== 'string' && ctrl.model.addressInputField) {
            ctrl.addressWasAutoFilled = true;
            ctrl.updateAddressModel();
        }
    };

    ctrl.updateAddressModel = function () {
        if (!ctrl.model.addressInputField || typeof ctrl.model.addressInputField  === 'string' || !ctrl.addressWasAutoFilled) {
            return;
        }
        var parsedAddress = address.getAutoCompleteAddress(ctrl.model.addressInputField);
        ctrl.model.address.street = parsedAddress.street1;
        ctrl.model.address.city = parsedAddress.city;
        ctrl.model.address.state = parsedAddress.state;
        ctrl.model.address.zip = parsedAddress.zip;
    };

    ctrl.getDisplayAddress = function () {
        var address = ctrl.model.address;

        if (!address || !address.street || !address.city || !address.state || !address.zip) return '';

        return address.street + (!ctrl.isEmptyValue(address.aptUnit) ? ' ' + 
                address.aptUnit : '') + ', ' + address.city + ', ' + address.state + 
                ', ' + address.zip;
    };

    ctrl.isEmptyValue = function(value) {
        return [undefined, null, ''].includes(value);
    }

    ctrl.onDateChange = function () {
        if (!(ctrl.datePicker.model instanceof Date)) return;
        ctrl.model.deliveryDate.year = ctrl.datePicker.model.getFullYear();
        ctrl.model.deliveryDate.month = ctrl.datePicker.model.getMonth() + 1;
        ctrl.model.deliveryDate.date = ctrl.datePicker.model.getDate();
    };

    ctrl.onTimeChange = function () {
        if (!ctrl.model.deliveryTimeInputField) return;

        var time = ctrl.model.deliveryTimeInputField;
        void 0

        ctrl.model.deliveryTime.hour = time.getHours();
        ctrl.model.deliveryTime.minute = time.getMinutes();
    };

    ctrl.editDeliveryObject = function () {
        if (ctrl.editDeliveryForm.validate()){

            ctrl.error = '';
            var data = Object.assign({}, ctrl.model);

            if (!data.id) {
                ctrl.error = 'Can\'t update without ID';
                return;
            }
            if (!isNaN(data.bagCount)) {
                data.bagCount = +data.bagCount;
            }
            if (!isNaN(data.orderTotal)) {
                data.orderTotal = +data.orderTotal;
            }
            if (!isNaN(data.tip)) {
                data.tip = +data.tip;
            }
            void 0;
            ctrl.isLoading = true;

            var deliveryObjId = data.id
            delete data.id

            hsDelivery.updateDeliveryObject(deliveryObjId, data)
                .then(function (res) {
                    toastr.success('Successfully edited');
                    ctrl.onViewChange();

                })
                .catch(function (err) {
                    void 0;
                    toastr.error(err);
                    ctrl.error = err;
                })
                .finally(function () {
                    ctrl.isLoading = false;
                });
        }
    };    
}

hsApp.component('deliveryService', {
    templateUrl: '/partials/components/delivery-service/delivery-service.html',
    bindings: {
        
    },
    controller: ['$rootScope', 'globalFunctions', '$location', '$scope', 'ENV', 'toastr', 'VALIDATORS', 'hsDelivery', deliveryServiceController],
});

function deliveryServiceController($rootScope, globalFunctions, $location, $scope, ENV, toastr, VALIDATORS, hsDelivery) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';
    var loadMoreStep = 20;

    ctrl.$onInit = function () {
        ctrl.error = '';

        const now = new Date();

        ctrl.startDate = now;
        ctrl.endDate = now;
        ctrl.view = 'deliveries';
        ctrl.selectedDelivery = {};
    };

    ctrl.selectView = function (view) {
        ctrl.view = view || 'deliveries';
        void 0
    };

    ctrl.onStartDateChange = function (date) {
        ctrl.startDate = date;
    };

    ctrl.onEndDateChange = function (date) {
        ctrl.endDate = date;
    };

    ctrl.onSetSelectedDelivery = function(delivery) {
        ctrl.selectedDelivery = delivery;
    };

}

hsApp.component('scheduleDeliveryPopup', {
    templateUrl: '/partials/components/delivery-service/schedule-delivery-popup.html',
    bindings: {
        delivery: '<',
        onClose: '&',
    },
    controller: ['hsDelivery', 'toastr', scheduleDeliveryPopupController],
});

function scheduleDeliveryPopupController(hsDelivery, toastr) {
    var ctrl = this;
    var logPrefix = '[deliveries]: ';

    ctrl.$onInit = function () {
        ctrl.error = '';
        ctrl.quote = null;
        ctrl.isLoading = true;
        ctrl.scheduleAsap = false;
        
        ctrl.getQuote();
    };

    ctrl.getQuote = function () {
        ctrl.error = '';
        void 0
        hsDelivery.getQuote(ctrl.delivery)
            .then(function (data) {
                void 0;
                ctrl.quote = data;
                if (data.error) {
                    ctrl.error = data.error;
                }
            })
            .catch(function (err) {
                void 0;
                ctrl.error = err;
            })
            .finally(function () {
                ctrl.isLoading = false;
            });
    };

    ctrl.getDeliveryDate = function () {
        return hsDelivery.getDeliveryDate(ctrl.delivery.deliveryDate);
    };

    ctrl.getDeliveryTime = function () {
        return hsDelivery.getDeliveryTime(ctrl.delivery.deliveryTime);
    };

    ctrl.setAsapDelivery = function (asap) {
        ctrl.scheduleAsap = asap;
    };

    ctrl.scheduleDelivery = function() {
        if (ctrl.schedulingDelivery) return;
        
        ctrl.error = '';
        ctrl.schedulingDelivery = true;

        hsDelivery.scheduleDelivery(ctrl.scheduleAsap, ctrl.delivery)
            .then(function (data) {
                void 0;
                void 0;
                toastr.success('Delivery Scheduled');
                ctrl.onClose({ value: 'success' });
            })
            .catch(function(err) {
                void 0;
                ctrl.error = err;
                toastr.error('Scheduling Failed');
            })
            .finally(function () {
                ctrl.schedulingDelivery = false;
            });
    };

}

hsApp.component('otpInput', {
    templateUrl: '/partials/components/design-system/otp-input.html',
    bindings: {
        collectOtp: '&',
        hasInvalidInput: '<',
        errorMessage: '@'
    },
    controller: [ 'hsUtils', '$timeout', '$attrs', otpInputController ],
});

function otpInputController(hsUtils, $timeout, $attrs) {
    var ctrl = this;
    var logPrefix = '[otpInput]';

    ctrl.segmentElements = {
        left: [ 'l0', 'l1', 'l2' ],
        right: [ 'r0', 'r1', 'r2' ]
    };
    ctrl.emptyCellPlaceholderSymbol = '';
    ctrl.defaults = {
        hasInvalidInput: false,
        errorMessage: 'The code you entered is invalid. Please try again.'
    };

    ctrl.$onInit = function() {
        void 0;
        ctrl.setDefaults();
        ctrl.initializeState();
        ctrl.activate('l0');
    };

    ctrl.setDefaults = function() {
        if (!hsUtils.isBoolean(ctrl.hasInvalidInput)) {
            ctrl.hasInvalidInput = ctrl.defaults.hasInvalidInput;
        }

        if (!hsUtils.isNonEmptyString(ctrl.errorMessage)) {
            ctrl.errorMessage = ctrl.defaults.errorMessage;
        }
    };

    ctrl.initializeState = function() {
        ctrl.state = {
            l0: {
                value: '',
                prev: null,
                next: 'l1',
                isFirstCell: true
            },
            l1: {
                value: '',
                prev: 'l0',
                next: 'l2'
            },
            l2: {
                value: '',
                prev: 'l1',
                next: 'r0',
            },
            r0: {
                value: '',
                prev: 'l2',
                next: 'r1',
            },
            r1: {
                value: '',
                prev: 'r0',
                next: 'r2',
            },
            r2: {
                value: '',
                prev: 'r1',
                next: null,
                isLastCell: true
            },
            activeCell: null,
            showAsInvalid: ctrl.hasInvalidInput
        };
    };

    ctrl.getDisabledStatus = function(cell) {
        return !ctrl.isActiveCell(cell);
    };

    ctrl.handleChange = function(cell) {
        ctrl.resetPresentation();

        if (!ctrl.isFilledCell(cell)) {
            // Just in case, so as not to interfere with backspace handling.
            return;
        }

        if (ctrl.canAdvance(cell)) {
            ctrl.advance(cell);
        }

        ctrl.sendOtp();
    };
    
    ctrl.handleKeyDown = function(event, cell) {
        if (event.keyCode === 8) {
            event.preventDefault();

            if (ctrl.isLastCell(cell) && ctrl.isFilledCell(cell)) {
                ctrl.clear(cell);
                ctrl.sendOtp();
                return;
            }

            ctrl.clear(cell);
            if (ctrl.canRetreat(cell)) {
                ctrl.retreat(cell);
                ctrl.clear(ctrl.state.activeCell);
            }
            ctrl.sendOtp();
        }
    };

    ctrl.shiftFocusToActiveCell = function() {
        var element = document.getElementById(ctrl.state.activeCell);
        if (element) {
            element.focus();
        }
    };

    ctrl.canAdvance = function(cell) {
        return ctrl.state[cell].next !== null;
    };

    ctrl.canRetreat = function(cell) {
        return ctrl.state[cell].prev !== null;
    };

    ctrl.advance = function(cell) {
        ctrl.activate(ctrl.state[cell].next);
    };

    ctrl.retreat = function(cell) {
        ctrl.activate(ctrl.state[cell].prev);
    };

    ctrl.clear = function(cell) {
        ctrl.state[cell].value = '';
    };

    ctrl.activate = function(cell) {
        ctrl.state.activeCell = cell;
        $timeout(function () {
            ctrl.shiftFocusToActiveCell();
        });
    };

    ctrl.isFirstCell = function(cell) {
        return !!ctrl.state[cell].isFirstCell;
    };

    ctrl.isLastCell = function(cell) {
        return !!ctrl.state[cell].isLastCell;
    };

    ctrl.isActiveCell = function(cell) {
        return ctrl.state.activeCell === cell;
    };

    ctrl.isFilledCell = function(cell) {
        return ctrl.state[cell].value !== '';
    };

    ctrl.isInactiveUnfilledCell = function(cell) {
        return !ctrl.isActiveCell(cell) && !ctrl.isFilledCell(cell);
    };

    ctrl.hasActiveCell = function(segment) {
        return ctrl.segmentElements[segment].includes(ctrl.state.activeCell);
    };

    ctrl.getClassForOtpSegment = function(segment) {
        if (ctrl.state.showAsInvalid) {
            return 'otp-segment-invalid';
        }
        if (ctrl.hasActiveCell(segment)) {
            return 'otp-segment-active';
        }
        return 'otp-segment-default';
    };

    ctrl.resetPresentation = function() {
        if (ctrl.state.showAsInvalid) {
            ctrl.state.showAsInvalid = false;
        }
    };

    ctrl.sendOtp = function () {
        var otp = '';
        Object.keys(ctrl.state).forEach(function (key) {
            if (ctrl.state[key].hasOwnProperty('value')) {
                otp += ctrl.state[key].value;
            }
        });
        if ('collectOtp' in $attrs && typeof ctrl.collectOtp === 'function') {
            ctrl.collectOtp({ otp: otp });
        }
    };
}
hsApp.component('primaryButton', {
    templateUrl: '/partials/components/design-system/primary-button.html',
    bindings: {
        type: '@',
        size: '@',        
        text: '@',
        svgStartUrl: '@',
        svgEndUrl: '@',
        svgLoadingUrl: '@',
        linkUrl: '@',
        onClick: '&',
        isFullWidth: '<',
        isDisabled: '<',
        isLoading: '<'
    },
    controller: [ 'hsUtils', '$attrs', primaryButtonController ],
});

function primaryButtonController(hsUtils, $attrs) {
    var ctrl = this;
    var logPrefix = '[primaryButtonController]:';

    ctrl.buttonTypeClasses = {
        'default': 'btn-primary-type-default',
        'success': 'btn-primary-type-success',
        'error': 'btn-primary-type-error',
        'danger': 'btn-primary-type-danger'
    };

    ctrl.buttonSizeClasses = {
        'sm': 'btn-primary-size-sm',
        'md': 'btn-primary-size-md',
        'lg': 'btn-primary-size-lg',
        'xl': 'btn-primary-size-xl',
    };

    ctrl.defaults = {
        fields: {
            type: 'default',
            size: 'md',
            text: null,
            svgStartUrl: null,
            svgEndUrl: null,
            svgLoadingUrl: '../../../images/design-system/icon-svg/loading.svg',
            linkUrl: null,
            isFullWidth: false,
            isDisabled: false,
            isLoading: false
        },
        presentations: {
            isDisabled: 'btn-primary-disabled',
            isLoading: 'btn-primary-loading'
        }
    };

    ctrl.$onInit = function() {
        void 0;
        ctrl.setDefaults();
    };

    ctrl.setDefaults = function() {
        if (!(ctrl.type in Object.keys(ctrl.buttonTypeClasses))) {
            ctrl.type = ctrl.defaults.fields.type;
        }

        if (!(ctrl.size in Object.keys(ctrl.buttonSizeClasses))) {
            ctrl.size = ctrl.defaults.fields.size;
        }

        if (!hsUtils.isNonEmptyString(ctrl.text)) {
            ctrl.text = ctrl.defaults.fields.text;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgStartUrl)) {
            ctrl.svgStartUrl = ctrl.defaults.fields.svgStartUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgEndUrl)) {
            ctrl.svgEndUrl = ctrl.defaults.fields.svgEndUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgLoadingUrl)) {
            ctrl.svgLoadingUrl = ctrl.defaults.fields.svgLoadingUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.linkUrl)) {
            ctrl.linkUrl = ctrl.defaults.fields.linkUrl;
        }

        if (!hsUtils.isBoolean(ctrl.isFullWidth)) {
            ctrl.isFullWidth = ctrl.defaults.fields.isFullWidth;
        }

        if (!hsUtils.isBoolean(ctrl.isDisabled)) {
            ctrl.isDisabled = ctrl.defaults.fields.isDisabled;
        }

        if (!hsUtils.isBoolean(ctrl.isLoading)) {
            ctrl.isLoading = ctrl.defaults.fields.isLoading;
        }
    };

    ctrl.handleClick = function() {
        if (ctrl.isDisabled || ctrl.isLoading) {
            return;
        } else if ('onClick' in $attrs && typeof ctrl.onClick === 'function') {
            ctrl.onClick();
        }
    };

    ctrl.getPresentationClasses = function() {
        var initialClasses = [];
        if (ctrl.isDisabled) {
            initialClasses.push(ctrl.defaults.presentations.isDisabled);
        } else if (ctrl.isLoading) {
            initialClasses.push(ctrl.defaults.presentations.isLoading);
        } else {
            initialClasses.push(ctrl.buttonTypeClasses[ctrl.type]);
        }
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getSizeClasses = function() {
        var initialClasses = [ctrl.buttonSizeClasses[ctrl.size]];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContainerClasses = function() {
        var initialClasses = ['btn-primary-container'];
        return ctrl.addAllLayerClasses(initialClasses); 
    };

    ctrl.getSurfaceClasses = function() {
        var initialClasses = ['btn-primary-surface'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContentsClasses = function() {
        var initialClasses = ['contents'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.addAllLayerClasses = function(classes) {
        if (ctrl.isFullWidth & !classes.includes('full-width')) {
            classes.push('full-width');
        }
        return classes.join(' ');
    };

    ctrl.shouldBeLink = function() {
        return ctrl.linkUrl && !ctrl.isDisabled;
    };
}
hsApp.component('secondaryButton', {
    templateUrl: '/partials/components/design-system/secondary-button.html',
    bindings: {
        type: '@',
        size: '@',        
        text: '@',
        svgStartUrl: '@',
        svgEndUrl: '@',
        linkUrl: '@',
        onClick: '&',
        isFullWidth: '<',
        isDisabled: '<'
    },
    controller: [ 'hsUtils', '$attrs', secondaryButtonController ],
});

function secondaryButtonController(hsUtils, $attrs) {
    var ctrl = this;
    var logPrefix = '[secondaryButtonController]:';

    ctrl.buttonTypeClasses = {
        'default': 'btn-secondary-type-default',
        'danger': 'btn-secondary-type-danger'
    };

    ctrl.buttonSizeClasses = {
        'sm': 'btn-secondary-size-sm',
        'md': 'btn-secondary-size-md',
        'lg': 'btn-secondary-size-lg',
        'xl': 'btn-secondary-size-xl',
    };

    ctrl.defaults = {
        fields: {
            type: 'default',
            size: 'md',
            text: null,
            svgStartUrl: null,
            svgEndUrl: null,
            linkUrl: null,
            isFullWidth: false,
            isDisabled: false
        },
        presentations: {
            isDisabled: 'btn-secondary-disabled'
        }
    };

    ctrl.$onInit = function() {
        void 0;
        ctrl.setDefaults();
    };

    ctrl.setDefaults = function() {
        if (!(ctrl.type in Object.keys(ctrl.buttonTypeClasses))) {
            ctrl.type = ctrl.defaults.fields.type;
        }

        if (!(ctrl.size in Object.keys(ctrl.buttonSizeClasses))) {
            ctrl.size = ctrl.defaults.fields.size;
        }

        if (!hsUtils.isNonEmptyString(ctrl.text)) {
            ctrl.text = ctrl.defaults.fields.text;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgStartUrl)) {
            ctrl.svgStartUrl = ctrl.defaults.fields.svgStartUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgEndUrl)) {
            ctrl.svgEndUrl = ctrl.defaults.fields.svgEndUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.linkUrl)) {
            ctrl.linkUrl = ctrl.defaults.fields.linkUrl;
        }

        if (!hsUtils.isBoolean(ctrl.isFullWidth)) {
            ctrl.isFullWidth = ctrl.defaults.fields.isFullWidth;
        }

        if (!hsUtils.isBoolean(ctrl.isDisabled)) {
            ctrl.isDisabled = ctrl.defaults.fields.isDisabled;
        }
    };

    ctrl.handleClick = function() {
        if (ctrl.isDisabled) {
            return;
        } else if ('onClick' in $attrs && typeof ctrl.onClick === 'function') {
            ctrl.onClick();
        }
    };

    ctrl.getPresentationClasses = function() {
        var initialClasses = [];
        if (ctrl.isDisabled) {
            initialClasses.push(ctrl.defaults.presentations.isDisabled);
        } else {
            initialClasses.push(ctrl.buttonTypeClasses[ctrl.type]);
        }
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getSizeClasses = function() {
        var initialClasses = [ctrl.buttonSizeClasses[ctrl.size]];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContainerClasses = function() {
        var initialClasses = ['btn-secondary-container'];
        return ctrl.addAllLayerClasses(initialClasses); 
    };

    ctrl.getSurfaceClasses = function() {
        var initialClasses = ['btn-secondary-surface'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContentsClasses = function() {
        var initialClasses = ['contents'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.addAllLayerClasses = function(classes) {
        if (ctrl.isFullWidth & !classes.includes('full-width')) {
            classes.push('full-width');
        }
        return classes.join(' ');
    };

    ctrl.shouldBeLink = function() {
        return ctrl.linkUrl && !ctrl.isDisabled;
    };
}
hsApp.component('tertiaryButton', {
    templateUrl: '/partials/components/design-system/tertiary-button.html',
    bindings: {
        type: '@',
        size: '@',        
        text: '@',
        svgStartUrl: '@',
        svgEndUrl: '@',
        linkUrl: '@',
        onClick: '&',
        isFullWidth: '<',
        isDisabled: '<'
    },
    controller: [ 'hsUtils', '$attrs', tertiaryButtonController ],
});

function tertiaryButtonController(hsUtils, $attrs) {
    var ctrl = this;
    var logPrefix = '[tertiaryButtonController]:';

    ctrl.buttonTypeClasses = {
        'default': 'btn-tertiary-type-default',
        'success': 'btn-tertiary-type-success',
        'danger': 'btn-tertiary-type-danger'
    };

    ctrl.buttonSizeClasses = {
        'sm': 'btn-tertiary-size-sm',
        'md': 'btn-tertiary-size-md',
        'lg': 'btn-tertiary-size-lg',
        'xl': 'btn-tertiary-size-xl',
    };

    ctrl.defaults = {
        fields: {
            type: 'default',
            size: 'md',
            text: null,
            svgStartUrl: null,
            svgEndUrl: null,
            linkUrl: null,
            isFullWidth: false,
            isDisabled: false
        },
        presentations: {
            isDisabled: 'btn-tertiary-disabled'
        }
    };

    ctrl.$onInit = function() {
        void 0;
        ctrl.setDefaults();
    };

    ctrl.setDefaults = function() {
        if (!(ctrl.type in Object.keys(ctrl.buttonTypeClasses))) {
            ctrl.type = ctrl.defaults.fields.type;
        }

        if (!(ctrl.size in Object.keys(ctrl.buttonSizeClasses))) {
            ctrl.size = ctrl.defaults.fields.size;
        }

        if (!hsUtils.isNonEmptyString(ctrl.text)) {
            ctrl.text = ctrl.defaults.fields.text;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgStartUrl)) {
            ctrl.svgStartUrl = ctrl.defaults.fields.svgStartUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.svgEndUrl)) {
            ctrl.svgEndUrl = ctrl.defaults.fields.svgEndUrl;
        }

        if (!hsUtils.isNonEmptyString(ctrl.linkUrl)) {
            ctrl.linkUrl = ctrl.defaults.fields.linkUrl;
        }

        if (!hsUtils.isBoolean(ctrl.isFullWidth)) {
            ctrl.isFullWidth = ctrl.defaults.fields.isFullWidth;
        }

        if (!hsUtils.isBoolean(ctrl.isDisabled)) {
            ctrl.isDisabled = ctrl.defaults.fields.isDisabled;
        }
    };

    ctrl.handleClick = function() {
        if (ctrl.isDisabled) {
            return;
        } else if ('onClick' in $attrs && typeof ctrl.onClick === 'function') {
            ctrl.onClick();
        }
    };

    ctrl.getPresentationClasses = function() {
        var initialClasses = [];
        if (ctrl.isDisabled) {
            initialClasses.push(ctrl.defaults.presentations.isDisabled);
        } else {
            initialClasses.push(ctrl.buttonTypeClasses[ctrl.type]);
        }
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getSizeClasses = function() {
        var initialClasses = [ctrl.buttonSizeClasses[ctrl.size]];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContainerClasses = function() {
        var initialClasses = ['btn-tertiary-container'];
        return ctrl.addAllLayerClasses(initialClasses); 
    };

    ctrl.getSurfaceClasses = function() {
        var initialClasses = ['btn-tertiary-surface'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.getContentsClasses = function() {
        var initialClasses = ['contents'];
        return ctrl.addAllLayerClasses(initialClasses);
    };

    ctrl.addAllLayerClasses = function(classes) {
        if (ctrl.isFullWidth & !classes.includes('full-width')) {
            classes.push('full-width');
        }
        return classes.join(' ');
    };

    ctrl.shouldBeLink = function() {
        return ctrl.linkUrl && !ctrl.isDisabled;
    };
}
hsApp.component('textInput', {
    templateUrl: '/partials/components/design-system/text-input.html',
    bindings: {
        labelText: '@',
        hasInvalidInput: '<',
        isDisabled: '<',
        errorMessage: '@'
    },
    controller: [ 'hsUtils', textInputController ],
});

function textInputController(hsUtils) {
    var ctrl = this;
    var logPrefix = '[textInputController]';
    
    ctrl.defaults = {
        labelText: '',
        hasInvalidInput: false,
        isDisabled: false,
        errorMessage: ''
    };

    ctrl.$onInit = function() {
        void 0;
        ctrl.setDefaults();
        ctrl.value = '';
        ctrl.isActive = false;
    };

    ctrl.setDefaults = function() {
        if (!hsUtils.isString(ctrl.labelText)) {
            ctrl.labelText = ctrl.defaults.labelText;
        }
        if (!hsUtils.isBoolean(ctrl.hasInvalidInput)) {
            ctrl.hasInvalidInput = ctrl.defaults.hasInvalidInput;
        }
        if (!hsUtils.isBoolean(ctrl.isDisabled)) {
            ctrl.isDisabled = ctrl.defaults.isDisabled;
        }
        if (!hsUtils.isString(ctrl.errorMessage)) {
            ctrl.errorMessage = ctrl.defaults.errorMessage;
        }
    };

    ctrl.refreshErrorState = function() {
        if (ctrl.hasInvalidInput) {
            ctrl.hasInvalidInput = false;
        }
    };

    ctrl.activate = function() {
        ctrl.isActive = true;
    };

    ctrl.deactivate = function() {
        ctrl.isActive = false;
    }

    ctrl.getApplicableInputClassesArr = function() {
        var applicableInputClassesArr = [];
        if (ctrl.hasLabelText()) {
            applicableInputClassesArr.push('labeled-input'); 
        }

        if (ctrl.isDisabled) {
            applicableInputClassesArr.push('disabled-input');
        } else if (ctrl.hasInvalidInput) {
            applicableInputClassesArr.push('invalid-input');
        } else if (ctrl.isActive) {
            applicableInputClassesArr.push('active-input');
        }

        return applicableInputClassesArr;
    };

    ctrl.getApplicableInputClasses = function() {
        var applicableInputClassesArr = ctrl.getApplicableInputClassesArr();
        return applicableInputClassesArr.join(' ');
    };

    ctrl.hasLabelText = function() {
        return !!ctrl.labelText;
    };

    ctrl.hasErrorMessage = function() {
        return !!ctrl.errorMessage;
    };

    ctrl.shouldShowErrorMessage = function() {
        return ctrl.hasInvalidInput && ctrl.hasErrorMessage();
    };
}
hsApp.component('forageInput', {
    templateUrl: '/partials/components/ebt/forage-input.html',
    bindings: {
        elementId: '<',
        isLoading: '<',
    },
    controller: [ forageInputController ],
});

function  forageInputController () {}

hsApp.component('refundEbt', {
    templateUrl: '/partials/components/ebt/refund-ebt.html',
    bindings: {
        order: '<',
        onClose: '&',
    },
    controller: [ 'ebtService', 'hsUtils', refundEbtController ],
});

function  refundEbtController (ebtService, hsUtils) {
    var ctrl = this;
    ctrl.refundValidationRules = {
        rules: {
            amount: {
                required: true,
                number: true,
                gt: 0,
            },
            reason: {
                required: true,
            },
        },
    };

    ctrl.$onInit = function() {
        ctrl.isLoading = false;
        ctrl.error = '';
        ctrl.amount = 0;
        ctrl.reason = '';
        ctrl.totalRefunded = ctrl.getTotalRefunded(ctrl.order.refundsEbt);
        ctrl.availableToRefund = Math.max(ctrl.order.amountChargedEbtSnap - ctrl.totalRefunded, 0);
    };

    ctrl.getTotalRefunded = function(refunds) {
        if (!hsUtils.isNonEmptyArray(refunds)) return 0;

        return refunds.reduce(function(sum, refund) {
            if ([ 'processing', 'succeeded' ].includes(refund.status)) {
                var amount = Number(refund.amount);

                if (amount) {
                    sum += amount;
                }
            }
            return sum;
        }, 0);
    };

    ctrl.submitRefund = function() {
        if (ctrl.isLoading || !ctrl.availableToRefund || !ctrl.form.validate()) return;

        ctrl.error = '';
        ctrl.isLoading = true;

        ebtService.submitRefund(ctrl.order.key, ctrl.amount, ctrl.reason)
            .then(function(orderData) {
                void 0;
                ctrl.onClose({ value: { orderData: orderData } });
            })
            .catch(function(err) {
                void 0;
                ctrl.error = err;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };
}

hsApp.component('lsSaveButton', {
    templateUrl: '/partials/components/location-settings-v2/location-settings-save-button.html',
    bindings: {
        show: '<',
        onSave: '&',
    },
    controller: [ locationSettingsSaveButtonController ],
});

function locationSettingsSaveButtonController() {
    var ctrl = this;
    var logPrefix = '[locationSettings]: ';


    ctrl.save = function () {
        ctrl.onSave();
    };
}
hsApp.component('locationSettingsV2', {
    templateUrl: '/partials/components/location-settings-v2/location-settings-v2.html',
    controller: [ 'hsUtils', '$scope', 'hsLocationSettings', 'ngDialog', 'ENV', locationSettingsController ],
});

function locationSettingsController(hsUtils, $scope, hsLocationSettings, ngDialog, ENV) {
    var ctrl = this;
    var logPrefix = '[locationSettings]: ';

    ctrl.$onInit = function () {
        void 0;

        if (!hsLocationSettings.isUserAllowed()) {
            hsLocationSettings.redirectUser();
            return;
        }

        ctrl.errorMessages = hsLocationSettings.errorMessages;
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.locationData = null;
        ctrl.priceListsData = null;
        ctrl.selectedPriceList = null;
        ctrl.initialized = false;

        ctrl.isLoading = true;
        hsLocationSettings.setLocationData()
            .then(function() {
                ctrl.initialized = true;
            })
            .catch(function(err) {
                void 0;
                ctrl.error = ctrl.errorMessages.LOAD_ERROR;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });

        ctrl.availableViews = hsLocationSettings.availableViews;
        ctrl.currentView = ctrl.availableViews.ABOUT;
        ctrl.DEFAULT_DRAWER = hsLocationSettings.DEFAULT_DRAWER;
        ctrl.currentDrawer = ctrl.DEFAULT_DRAWER;

        $scope.hsLocationSettings = hsLocationSettings;

        $scope.$watch('hsLocationSettings.locationData', function() {
            ctrl.locationData = hsLocationSettings.locationData;
        });

        $scope.$watch('hsLocationSettings.priceListsData', function() {
            ctrl.priceListsData = hsLocationSettings.priceListsData;
            ctrl.syncSelectedPriceList();
        });
    };

    ctrl.checkImageDimensions = function(imageSource) {
        var imageFormData = ctrl.getImageFormData(imageSource, true); 
        ctrl.isLoading = true;

        return hsLocationSettings.updateLocationImage(imageFormData)
            .finally(function() {
                ctrl.isLoading = false;
            });
    }

    ctrl.selectView = function(view, priceList) {
        if (ctrl.currentView === view && hsLocationSettings.isSamePriceList(ctrl.selectedPriceList, priceList)) return;

        if (ctrl.changed) {
            ctrl.showUnsavedChangesPopup()
                .then(function(switchView) {
                    if (switchView) {
                        ctrl.switchView(view, priceList);
                    }
                });
        } else {
            ctrl.switchView(view, priceList);
        }
    };

    ctrl.switchView = function(view, priceList) {
        ctrl.currentView = view;
        ctrl.changed = false;
        ctrl.selectedPriceList = priceList;
    };

    ctrl.setChanged = function(view, changed) {
        void 0;
        ctrl.changed = changed;
    };

    ctrl.getImageFormData = function(imageSource, checkDims) {
        var imageFormData = new FormData();
        imageFormData.append('file', imageSource.src);
        imageFormData.append('width', imageSource.width);
        imageFormData.append('height', imageSource.height);
        imageFormData.append('onlyDimensionsCheck', checkDims);
        return imageFormData;
    }

    ctrl.saveSettings = function(params) {
        ctrl.isLoading = true;
        var imageFormData;
        var imageSource;
        if (params && params.location && params.location.hasOwnProperty('imageSource')) {
            imageSource = params.location.imageSource;
            imageFormData = ctrl.getImageFormData(imageSource, false);
            delete params.location.imageSource;
        }

        // params contains image and location fields updates
        if(hsUtils.isNonEmptyObject(imageSource) && hsUtils.isNonEmptyObject(params.location)) {
            return hsLocationSettings.updateLocationImage(imageFormData)
                .then(function() {
                    return hsLocationSettings.saveSettings(params, ctrl.selectedPriceList)
                        .finally(function() {
                            ctrl.isLoading = false;
                        });
                })
                .catch(function(error) {
                    ctrl.isLoading = false;
                    throw error;
                });
        }

        // params contains only image
        if (hsUtils.isNonEmptyObject(imageSource)) {
            return hsLocationSettings.updateLocationImage(imageFormData)
                .then(function() {
                    return hsLocationSettings.setLocationData()
                        .finally(function() {
                            ctrl.isLoading = false;
                        });
                })
                .catch(function(error) {
                    ctrl.isLoading = false;
                    throw error;
                });
        }

        // only location fields updated
        return hsLocationSettings.saveSettings(params, ctrl.selectedPriceList)
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.switchDrawer = function(drawer) {
        ctrl.currentDrawer = drawer;
    };

    ctrl.showUnsavedChangesPopup = function() {
        return ngDialog.openConfirm({
            data: {
                heading: 'Unsaved Changes',
                subHeading: 'If you leave this section, the changes will be lost.',
                confirmBtnText: 'Continue',
                cancelBtnText: 'Cancel'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function() { return true; })
            .catch(function() { return false; });
    };

    ctrl.syncSelectedPriceList = function() {
        var updatedPriceList = null;
        if (ctrl.selectedPriceList && Array.isArray(ctrl.priceListsData)) {
            updatedPriceList = ctrl.priceListsData.find(function(priceList) {
                return priceList.uniqueName === ctrl.selectedPriceList.uniqueName;
            }) || null;
        }
        ctrl.selectedPriceList = updatedPriceList;
    };

    ctrl.isHomesomeAccount = function() {
        return hsLocationSettings.isHomesomeAccount();
    };
}
hsApp.component('masonryGridCard', {
    templateUrl: 'partials/components/masonry-grid/masonry-grid-card.html',
    controller: masonryGridCardController,
    bindings: {
        cardData: '<',
        grid: '<'
    }
});

function masonryGridCardController() {
    var ctrl = this;
    var logPrefix = '[masonry-grid-card-controller]: ';

    ctrl.$onInit = function() {
        void 0;
    }

    ctrl.getCardStyle = function() {
        var style = {
            'background-image': 'url(' + ctrl.cardData.imageURL + ')'
        };
        if (ctrl.grid.roundedCorners) {
            style['border-radius'] = '10px';
        }
        return style;
    }

    ctrl.getPositioningClass = function() {
        return (
            'masonry-grid-card-text-position-'
            + ctrl.cardData.textPositionY
            + '-'
            + ctrl.cardData.textPositionX
        );
    }

    ctrl.getTitleClass = function() {
        if (ctrl.cardData.isHero) {
            return 'title-hero';
        }
        return 'title-regular';
    }

    ctrl.needsButton = function() {
        return !!ctrl.cardData.needsButton;
    }
}

hsApp.component('masonryGrid', {
    templateUrl: 'partials/components/masonry-grid/masonry-grid.html',
    controller: ['hsMasonryGrid', '$rootScope', masonryGridController]
});

function masonryGridController(hsMasonryGrid, $rootScope) {
    var ctrl = this;
    var logPrefix = '[masonry-grid-controller]: ';

    ctrl.$onInit = function() {
        void 0;

        ctrl.isLoading = true;
        ctrl.initError = false;

        hsMasonryGrid.getGridData()
            .then(function(gridData) {
                ctrl.grid = gridData.grid;
                ctrl.cards = gridData.cards;
                ctrl.labelHeroCards(ctrl.cards, ctrl.grid.layout);
                ctrl.labelButtonCards(ctrl.cards, ctrl.grid.layout);
            })
            .catch(function(error) {
                void 0;
                ctrl.initError = true;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    }

    ctrl.getGridClass = function() {
        if (ctrl.isLoading) return;

        if (hsMasonryGrid.LAYOUTS[ctrl.grid.layout]) {
            if ($rootScope.screenWidth.xs) {
                return hsMasonryGrid.LAYOUTS.FOURTEEN_CELL.MOBILE.CLASS;
            }
            if ($rootScope.screenWidth.sm || $rootScope.screenWidth.md) {
                return hsMasonryGrid.LAYOUTS.FOURTEEN_CELL.TABLET.CLASS;
            }
            return hsMasonryGrid.LAYOUTS.FOURTEEN_CELL.DEFAULT.CLASS;
        }
        // Some validation should happen in front and/or back end to ensure that this
        // point is unreachable
    }

    ctrl.labelHeroCards = function(cards, layout) {
        var heroCards = hsMasonryGrid.LAYOUTS[layout].HERO_CARD_IDS;
        for (var card of cards) {
            if (heroCards.includes(card.id)) {
                card.isHero = true;
            }
        }
        return heroCards;
    }

    ctrl.labelButtonCards = function(cards, layout) {
        var buttonCards = hsMasonryGrid.LAYOUTS[layout].BUTTON_CARD_IDS;
        for (var card of cards) {
            if (buttonCards.includes(card.id)) {
                card.needsButton = true;
            }
        }
        return buttonCards;
    }
}
hsApp.component('allModifiers', {
    templateUrl: '/partials/components/modifiers/all-modifiers.html',
    controller: ['$scope', '$rootScope', 'hsAdmin', 'toastr', 'hsModifiers', 'globalFunctions', 'hsUtils', 'NgTableParams','$route', '$location', allModifiersController],
});

function allModifiersController($scope, $rootScope, hsAdmin, toastr, hsModifiers, globalFunctions, hsUtils, NgTableParams, $route, $location) {
    var ctrl = this;
    var logPrefix = '[allModifiersController]:';
    
    ctrl.$onInit = function() {
        ctrl.isLoading = true;

        ctrl.allModifiers = null;
        ctrl.tableParams = null;

        hsAdmin.initAdminPage('modifiers', false)
            .then(function() {
                return ctrl.loadModifiers();
            })
            .catch(function(err) {
                void 0;
                $location.url('/admin/manager-dashboard');
            })
    };

    ctrl.loadModifiers = function() {
        return hsModifiers.getAllModifiers()
            .then(function(modifiers) {
                ctrl.allModifiers = modifiers;
                ctrl.createTable();
            })
            .catch(function(err) {
                void 0;
                toastr.error(hsUtils.getMessageFromError(err, 'Error getting modifiers'));
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.createTable = function() {
        var tableData = [];
        for (var modifier of ctrl.allModifiers) {
            tableData.push(ctrl.getTableObject(modifier));
        }

        ctrl.tableParams = new NgTableParams(
            {
                counts: globalFunctions.ngTableConfig.counts,
            },
            {
                counts: globalFunctions.ngTableConfig.counts,
                dataset: tableData
            }
        );
    };

    ctrl.getTableObject = function(modifier) {
        return {
            name: modifier.name,
            displayName: modifier.displayName,
            options: modifier.options,
            filterableOptions: ctrl.getFilterableOptions(modifier.options),
            minSelections: modifier.minSelections || '-',
            maxSelections: modifier.maxSelections || '-',
            selectionRequired: ctrl.getBooleanDisplayValue(modifier.selectionRequired),
            singleSelection: ctrl.getBooleanDisplayValue(modifier.singleSelection),
        };
    };

    // required so we can filter for displayNames in ng table
    ctrl.getFilterableOptions = function(options) {
        var displayNames = options.map(function(option) {
            return option.displayName;
        });
        return displayNames.join(', ');
    };

    ctrl.getBooleanDisplayValue = function(boolean) {
        return !!boolean ? 'Yes' : 'No';
    };

    ctrl.shouldShowLoader = function() {
        return !!ctrl.isLoading;
    };

    ctrl.shouldShowTable = function() {
        return !ctrl.isLoading && hsUtils.isNonEmptyArray(ctrl.allModifiers);
    };

    ctrl.shouldShowNoModifiersMessage = function() {
        return !ctrl.isLoading && hsUtils.isEmptyArray(ctrl.allModifiers);
    };


    ctrl.editModifier = function(row) {
        let rowName = encodeURIComponent(row.name);
        $location.url('admin/modifiers/edit?name=' + rowName);
    };

    ctrl.selectAdminPricelist = function() {
        globalFunctions.showAdminPriceListPopup('modifiers', function (err, success) {
            if (success) {
                $route.reload();
            }
        });
    };

    ctrl.getSelectedPriceListTitle = function() {
        let title = '';
        var priceList = hsModifiers.getSelectedPriceList();
        if (hsUtils.isObject(priceList) && hsUtils.isNonEmptyString(priceList.title)) {
            title = priceList.title;
        }
        return title;
    };
}

hsApp.component('createModifier', {
    templateUrl: '/partials/components/modifiers/create-modifier.html',
    controller: ['hsModifiers', 'toastr', '$location', 'hsUtils', 'hsAdmin', '$scope', createModifierController],
});

function createModifierController(hsModifiers, toastr, $location, hsUtils, hsAdmin, $scope) {
    var ctrl = this;
    var logPrefix = '[create-modifier]';

    ctrl.$onInit = function() {
        ctrl.isLoading = true;
        void 0;
        ctrl.syncPriceListsPopup = {
            elementId: 'sync-create-modifier',
            dataToPropagate: null,
        };
        hsAdmin.initAdminPage('modifiers', false)
            .then(function() {
                ctrl.template = hsModifiers.TEMPLATES.CREATE_MODIFIER;
                ctrl.isLoading = false;
            })
            .catch(function(err) {
                void 0;
                $location.url('/admin/manager-dashboard');
            });
    };

    ctrl.handleSave = function(saveData) {
        if (!hsUtils.isObject(saveData.modifierData)) {
            toastr.error('Something went wrong');
            throw 'Invalid save data: ' + saveData;
        }
        var modifierData = Object.assign({}, saveData.modifierData);
        ctrl.isLoading = true;

        return hsModifiers.createModifier(modifierData)
            .then(function(res) {
                toastr.success("Successfully created modifier.");

                ctrl.syncPriceListsPopup.dataToPropagate = modifierData;
                ctrl.openSyncPriceListsPopupOrContinue();
                
                return modifierData;
            })
            .catch(function(err) {
                void 0;
                toastr.error("Something went wrong");
                ctrl.syncPriceListsPopup.dataToPropagate = null;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.propagateUpdateToTarget = function(target) {
        return hsModifiers.createModifier(ctrl.syncPriceListsPopup.dataToPropagate, false, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        if (hsAdmin.shouldShowSyncPriceListsPopup()) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                ctrl.handleUpdateCompletion();
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        } else {
            ctrl.handleUpdateCompletion();
        }
    };

    ctrl.handleUpdateCompletion = function () {
        var encodedName = encodeURIComponent(ctrl.syncPriceListsPopup.dataToPropagate.name);
        $location.url('/admin/modifiers/edit?name=' + encodedName);
    };

    ctrl.handleBackButtonClick = function() {
        $location.url('/admin/modifiers');
    };

}

hsApp.component('editModifier', {
    templateUrl: '/partials/components/modifiers/edit-modifier.html',
    controller: ['hsModifiers', 'hsUtils', 'hsAdmin', 'toastr', '$location', '$scope', editModifierController],
});

function editModifierController(hsModifiers, hsUtils, hsAdmin, toastr, $location, $scope) {
    var ctrl = this;
    var logPrefix = '[edit-modifier]';

    ctrl.$onInit = function() {
        ctrl.isLoading = true;
        void 0;
        ctrl.syncPriceListsPopup = {
            elementId: 'sync-edit-modifier',
            dataToPropagate: null,
        };
        hsAdmin.initAdminPage('modifiers', false)
            .then(function() {
                ctrl.template = hsModifiers.TEMPLATES.EDIT_MODIFIER;
                ctrl.isLoading = false;
            })
            .catch(function(err) {
                void 0;
                $location.url('/admin/manager-dashboard');
            });
    };

    ctrl.handleSave = function(saveData) {
        if (!hsUtils.isObject(saveData.modifierData) || !hsUtils.isArray(saveData.productUpdates)) {
            toastr.error('Something went wrong');
            throw 'Invalid save data: ' + saveData;
        }
        ctrl.isLoading = true;
        return hsModifiers.createModifierAndUpdateProducts(saveData, null)
            .then(function(res) {
                toastr.success("Successfully updated modifier and linked products. It may take a few minutes for the changes to be visible throughout the system.");

                ctrl.syncPriceListsPopup.dataToPropagate = saveData;
                ctrl.openSyncPriceListsPopupOrContinue();

                return res;
            })
            .catch(function(err) {
                toastr.error('Something went wrong while updating modifier or linked products. Please try again.');
                ctrl.syncPriceListsPopup.dataToPropagate = null;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.propagateUpdateToTarget = function(target) {
        return hsModifiers.createModifierAndUpdateProducts(ctrl.syncPriceListsPopup.dataToPropagate, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        if (hsAdmin.shouldShowSyncPriceListsPopup()) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        }
    };

    ctrl.handleBackButtonClick = function() {
        $location.url('/admin/modifiers');
    };

}

hsApp.component('modifierForm', {
    templateUrl: '/partials/components/modifiers/modifier-form.html',
    bindings: {
        template: '<',
        onSave: '&',
        externalIsLoading: '<',
        modifierData: '<',
        onBackButtonClick: '&',
    },
    controller: ['hsModifiers', 'hsUtils', 'toastr', '$location', 'hsSearch', 'NgTableParams', modifierFormController],
});

function modifierFormController(hsModifiers, hsUtils, toastr, $location, hsSearch, NgTableParams) {
    var ctrl = this;
    var logPrefix = '[modifier-form]';

    ctrl.TAX_MODIFICATIONS = hsModifiers.TAX_MODIFICATIONS;
    ctrl.TEMPLATES = hsModifiers.TEMPLATES;
    ctrl.DRAWERS = hsModifiers.DRAWERS;
    ctrl.PRODUCT_SELECTION_STATES = hsModifiers.PRODUCT_SELECTION_STATES;
    ctrl.MODIFIER_TYPES = hsModifiers.MODIFIER_TYPES;
    ctrl.TITLES = {
        CREATE_MODIFIER: 'Create Modifier',
        EDIT_MODIFIER: 'Edit Modifier',
    };
    ctrl.BUTTONS = {
        CREATE_MODIFIER: 'Create Modfiier',
        SAVE: 'Save',
    };
    ctrl.modifierValidator = hsModifiers.modifierValidator;
    ctrl.optionValidator = hsModifiers.optionValidator;

    ctrl.$onInit = function() {

        ctrl.isLoading = true;
        void 0;

        ctrl.initSelectedTemplate();
        ctrl.initSelectedDrawer();

        ctrl.modifier = null;
        ctrl.allProducts = [];
        ctrl.linkedProducts = [];
        ctrl.productUpdates = {
            toAdd: {},
            toRemove: {},
        };
        ctrl.optionEditor = null

        ctrl.productSelectionState = ctrl.PRODUCT_SELECTION_STATES.ALL_ITEMS;
        ctrl.productSelectionSearchInput = '';
        ctrl.productSelectionSearchResults = [];
        ctrl.productSelectionTable = {
            isLoading: true,
            ngTableParams: null,
        };

        if (ctrl.selectedTemplate === ctrl.TEMPLATES.EDIT_MODIFIER) {
            ctrl.initModifierName();
            ctrl.initEditModifierData();
        } else if (ctrl.selectedTemplate === ctrl.TEMPLATES.LIMITED_EDIT_MODIFIER) {
            ctrl.initLimitedEditModifier(ctrl.modfierData);
            ctrl.isLoading = false;
        } else if (ctrl.selectedTemplate === ctrl.TEMPLATES.CREATE_MODIFIER) {
            ctrl.modifier = ctrl.getNewModifierModel();
            ctrl.isLoading = false;
        } else {
            toastr.error('Something went wrong');
            ctrl.isLoading = false;
        };

    };

    ctrl.initSelectedTemplate = function() {
        var permissibleTemplates = [
            ctrl.TEMPLATES.CREATE_MODIFIER,
            ctrl.TEMPLATES.EDIT_MODIFIER,
            ctrl.TEMPLATES.LIMITED_EDIT_MODIFIER,
        ];
        if (!permissibleTemplates.includes(ctrl.template)) {
            toastr.error('Something went wrong');
            throw 'Invalid modifier form template: ' + ctrl.template;
        }
        ctrl.selectedTemplate = ctrl.template;
    };

    ctrl.initSelectedDrawer = function() {
        ctrl.selectedDrawer = null; 
        if (ctrl.template === ctrl.TEMPLATES.CREATE_MODIFIER
            || ctrl.template === ctrl.TEMPLATES.LIMITED_EDIT_MODIFIER    
        ) {
            ctrl.selectedDrawer = ctrl.DRAWERS.OPTIONS;
        }
    };

    ctrl.initModifierName = function() {
        var queryParams = $location.search();
        if (!hsUtils.isNonEmptyString(queryParams.name)) {
            $location.path('/admin/modifiers');
        }

        ctrl.modifierName = queryParams.name;
    };

    ctrl.initEditModifierData = function() {
         hsModifiers.getModifier(ctrl.modifierName)
            .then(function(modifier) {
                if (!hsUtils.isObject(modifier)) {
                    throw 'Invalid response from get modifier';
                }
                ctrl.sanitizeModifier(modifier);
                ctrl.modifier = modifier;

                return hsModifiers.getModifierProducts(ctrl.modifierName)
                    .then(function(productsRes) {
                        ctrl.allProducts = productsRes.allProducts;
                        ctrl.linkedProducts = productsRes.linkedProducts;
                        ctrl.createProductSelectionTable(ctrl.allProducts);
                        ctrl.productSelectionTable.isLoading = false;
                    })
                    .catch(function(err) {
                        void 0;
                        toastr.error('Something went wrong');
                    });

            })
            .catch(function(err) {
                void 0;
                toastr.error('Something went wrong');
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.initLimitedEditModifier = function(modifier) {
        if (!hsUtils.isObject(modifier) || hsUtils.isEmptyObject(modifier)) {
            modifier = ctrl.getNewModifierModel();
        }

        ctrl.modifier = JSON.parse(JSON.stringify(modifier));
        ctrl.sanitizeModifier(ctrl.modifier);

        ctrl.optionEditor = null;
    };

    ctrl.initDefaultOptionValues = function(modifier) {
        for (var option of modifier.options) {
            option.isDefault = modifier.defaultOption === option.name;
        }
    };

    ctrl.sanitizeModifier = function(modifier) {
        if (!Object.values(ctrl.MODIFIER_TYPES).includes(modifier.type)) {
            // this will set all modifiers that do not have a valid type to the default
            // so that it is updated the next time it is saved via UI
            modifier.type = ctrl.MODIFIER_TYPES.MODIFIER;
        }
        for (var i = 0; i < modifier.options.length; i++) {
            var option = modifier.options[i];
            if (!Object.values(ctrl.TAX_MODIFICATIONS).includes(option.taxModification)) {
                option.taxModification = ctrl.TAX_MODIFICATIONS.NONE;
            }
        }
        ctrl.initDefaultOptionValues(modifier);
    }

    ctrl.$onChanges = function(changes) {
        if (changes && changes.modifierData && changes.modifierData.currentValue) {
            ctrl.initLimitedEditModifier(changes.modifierData.currentValue);
        }
    };

    ctrl.getFormTitle = function() {
        if (ctrl.template === ctrl.TEMPLATES.CREATE_MODIFIER) {
            return ctrl.TITLES.CREATE_MODIFIER;
        }
        return ctrl.TITLES.EDIT_MODIFIER;
    };

    ctrl.getSaveButtonText = function() {
        if (ctrl.template === ctrl.TEMPLATES.CREATE_MODIFIER) {
            return ctrl.BUTTONS.CREATE_MODIFIER;
        }
        return ctrl.BUTTONS.SAVE;
    };

    ctrl.getNewModifierModel = function() {
        return JSON.parse(JSON.stringify(hsModifiers.NEW_MODIFIER));
    };

    ctrl.getNewOptionModel = function() {
        return Object.assign({ isDefault: false }, hsModifiers.NEW_MODIFIER_OPTION);
    };

    ctrl.isEmptyArray = function(arr) {
        return hsUtils.isEmptyArray(arr);
    }

    ctrl.addOption = function() {
        if (!ctrl.closeOptionEditor()) {
            return;
        }

        ctrl.modifier.options.push(ctrl.getNewOptionModel());

        ctrl.selectOptionToEdit(ctrl.modifier.options.length - 1);
    };

    ctrl.toggleDefaultOption = function(value, option) {
        for (var modOption of ctrl.modifier.options) {
            modOption.isDefault = false;
        }
        option.isDefault = value;
    };

    ctrl.togglePickupOnly = function(value, option) {
        option.isPickupOnly = value;
    };

    ctrl.hasDefaultOptionSet = function() {
        for (var option of ctrl.modifier.options) {
            if (option.isDefault) {
                return true;
            }
        }
        return false;
    }

    ctrl.selectOptionToEdit = function(index) {
        if (!ctrl.closeOptionEditor()) {
            return;
        }
        ctrl.optionEditor = ctrl.modifier.options[index];
        ctrl.modifier.options[index].editOption = true;
    };

    ctrl.getOptionEditorIndex = function() {
        for (var i = 0; i < ctrl.modifier.options.length; i++) {
            if (ctrl.modifier.options[i].editOption) {
                return i;
            }
        }
        return null;
    };

    ctrl.deleteOptionAtEditorIndex = function() {
        var editorIndex = ctrl.getOptionEditorIndex();
        if (editorIndex !== null) {
            ctrl.modifier.options.splice(editorIndex, 1);
            ctrl.optionEditor = null;
        }
    };

    ctrl.closeOptionEditor = function() {
        var editorIndex = ctrl.getOptionEditorIndex()

        if (editorIndex === null) {
            return true;
        } else if (!ctrl.optionForm.validate()) {
            return false;
        }

        ctrl.modifier.options[editorIndex].editOption = false;
        ctrl.optionEditor = null;

        return true;
    };

    ctrl.isSaveButtonDisabled = function() {
        return ctrl.shouldShowLoader() || ctrl.modifier.options.length === 0;
    };

    ctrl.getModifierData = function() {
        var modifierData = JSON.parse(JSON.stringify(ctrl.modifier));
        if(!hsUtils.isNonEmptyString(modifierData.name)) {
            modifierData.name = ctrl.getNewModifierName(modifierData);
        }
        for (var i = 0; i < modifierData.options.length; i++) {
            var option = modifierData.options[i];
            if (!hsUtils.isNonEmptyString(option.name)) {
                option.name = ctrl.getNewOptionName(option, i);
            }
            if (option.taxModification === ctrl.TAX_MODIFICATIONS.NONE) {
                delete option.taxModification;
            }
            if (option.isDefault) {
                modifierData.defaultOption = option.name;
            }
            delete option.isDefault;
            delete option.editOption;
        }
        if(!ctrl.hasDefaultOptionSet()) {
            modifierData.defaultOption = '';
        }
        return modifierData;
    };

    ctrl.getNewModifierName = function(modifier) {
        return ctrl.getNamePrefix(modifier.displayName) + '-mod-' + Date.now();
    };

    ctrl.getNewOptionName = function(option, i) {
        return ctrl.getNamePrefix(option.displayName) + '-mod-option-' + i + '-' + Date.now();
    };

    ctrl.getNamePrefix = function(str) {
        if (!hsUtils.isNonEmptyString(str)) {
            return '';
        }
        return str.replace(/[^a-zA-Z0-9]/g,'');
    }

    ctrl.saveModifier = function() {
        var isValidModifier = ctrl.modifierForm.validate();
        var isValidOption = ctrl.getOptionEditorIndex() === null || ctrl.optionForm.validate();
        if (!isValidModifier || !isValidOption) {
            return;
        }

        var saveData = { 
            modifierData: ctrl.getModifierData()
        };

        if (ctrl.template === ctrl.TEMPLATES.EDIT_MODIFIER) {
            saveData.productUpdates = ctrl.getProductUpdates();
        }
        
        ctrl.onSave({ saveData: saveData });
    };

    ctrl.shouldShowLoader = function() {
        return ctrl.isLoading || ctrl.externalIsLoading;
    };

    ctrl.shouldShowModifierForm = function() { 
        return !ctrl.shouldShowLoader() && ctrl.selectedTemplate !== ctrl.TEMPLATES.PRODUCT_SELECTION;
    };

    ctrl.shouldShowItemSelection = function() {
        return !ctrl.shouldShowLoader() && ctrl.selectedTemplate === ctrl.TEMPLATES.PRODUCT_SELECTION;
    };

    ctrl.setSelectedTemplate = function(template) {
        if (Object.values(ctrl.TEMPLATES).includes(template)) {
            ctrl.selectedTemplate = template;
        }
    };

    ctrl.setSelectedDrawer = function(drawer) {
        if (ctrl.getOptionEditorIndex() !== null && !ctrl.optionForm.validate()) {
            return;
        }
        if (Object.values(ctrl.DRAWERS).includes(drawer)) {
            if (ctrl.selectedDrawer !== drawer) {
                ctrl.selectedDrawer = drawer;
            } else {
                ctrl.selectedDrawer = null;
            }
        }
    };

    ctrl.removeLinkedProduct = function(product) {
        var linkedProductIndex = ctrl.getLinkedProductIndex(product);
        if (linkedProductIndex !== null) {
            ctrl.linkedProducts.splice(linkedProductIndex, 1);
        }
        if (ctrl.productUpdates.toAdd[product.name]) {
            delete ctrl.productUpdates.toAdd[product.name];
        }
        ctrl.productUpdates.toRemove[product.name] = product;
    };

    ctrl.addLinkedProduct = function(product) {
        var linkedProductIndex = ctrl.getLinkedProductIndex(product);
        if (linkedProductIndex === null) {
            ctrl.linkedProducts.push(product);
        }
        if(ctrl.productUpdates.toRemove[product.name]) {
            delete ctrl.productUpdates.toRemove[product.name];
        }
        ctrl.productUpdates.toAdd[product.name] = product;
    };

    ctrl.isLinkedProduct = function(product) {
        var index = ctrl.getLinkedProductIndex(product);
        return index !== null;
    };

    ctrl.getLinkedProductIndex = function(product) {
        var linkedProductIndex = null;
        for (var i = 0; i < ctrl.linkedProducts.length; i++) {
            if (ctrl.linkedProducts[i].name === product.name) {
                linkedProductIndex = i;
                break;
            }
        } 
        return linkedProductIndex;
    }

    ctrl.toggleLinkedProduct = function(product) {
        if (ctrl.isLinkedProduct(product)) {
            ctrl.removeLinkedProduct(product);
        } else {
            ctrl.addLinkedProduct(product);
        }
    };

    ctrl.setProductSelectionState = function(state) {
        if (Object.values(ctrl.PRODUCT_SELECTION_STATES).includes(state)) {
            ctrl.productSelectionState = state;
        }
        if (state === ctrl.PRODUCT_SELECTION_STATES.ALL_ITEMS) {
            ctrl.clearSearch();
        } else if (state === ctrl.PRODUCT_SELECTION_STATES.SELECTED_ITEMS) {
            ctrl.productSelectionTable.isLoading = true;
            ctrl.createProductSelectionTable(ctrl.linkedProducts);
            ctrl.productSelectionTable.isLoading = false;
        }
    };

    ctrl.searchProducts = function() {
        if(ctrl.productSelectionSearchInput !== '') {
            ctrl.productSelectionTable.isLoading = true;
            hsSearch.search(ctrl.productSelectionSearchInput, null, null, false, true, true)
                .then(function(data) {
                    ctrl.productSelectionSearchResults = data.results[0] ? data.results[0] : [];
                    ctrl.createProductSelectionTable(ctrl.productSelectionSearchResults);
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Something went wrong. Clear search and try again.');
                })
                .finally(function() {
                    ctrl.productSelectionTable.isLoading = false;
                });
        }
    };

    ctrl.clearSearch = function() {
        ctrl.productSelectionSearchInput = '';
        ctrl.productSelectionSearchResults = [];
        ctrl.createProductSelectionTable(ctrl.allProducts);
    };

    ctrl.createProductSelectionTable = function(itemList) {
        for (var item of itemList) {
            item.inStockDisplay = item.isInStock ? 'Yes' : 'No';
        }
        ctrl.productSelectionTable.ngTableParams = new NgTableParams(
            {count: 15},
            {counts: [15, 30, 50], dataset: itemList}
        );
    };

    ctrl.shouldShowProductSelectionTable = function() {
        return (
            ctrl.productSelectionTable.ngTableParams !== null
            && !ctrl.productSelectionTable.isLoading
        );
    };

    ctrl.getProductUpdates = function() {
        var productsRequiringRemoval = Object.values(ctrl.productUpdates.toRemove).filter(function(product) {
            return ctrl.productHasModifier(product, ctrl.modifierName);
        });
        var productsRequiringAddition = Object.values(ctrl.productUpdates.toAdd).filter(function(product) {
            return !ctrl.productHasModifier(product, ctrl.modifierName);
        });

        var updates = [];
        for (var product of productsRequiringRemoval) {
            var modifiersUpdate = [];
            for (var modifier of product.modifiers) {
                if (modifier.name !== ctrl.modifierName) {
                    modifiersUpdate.push(modifier.name);
                }
            }
            updates.push({
                name: product.name,
                modifiers: modifiersUpdate
            });
        }
        for(var product of productsRequiringAddition) {
            var modifiersUpdate = [];
            for (var modifier of product.modifiers) {
                modifiersUpdate.push(modifier.name);
            }
            modifiersUpdate.push(ctrl.modifierName);
            updates.push({
                name: product.name,
                modifiers: modifiersUpdate
            });
        }

        return updates;
    };

    ctrl.productHasModifier = function(product, modifierName) {
        if(!hsUtils.isNonEmptyArray(product.modifiers)) {
            return false;
        }
        for (var modifier of product.modifiers) {
            if (modifier.name === modifierName) {
                return true;
            }
        }
        return false;
    };

    ctrl.handleMinSelectionChange = function() {
        if (ctrl.modifier.minSelections === 0) {
            ctrl.modifier.selectionRequired = false;
        } else {
            ctrl.modifier.selectionRequired = true;
        }
        if (ctrl.modifier.minSelections > ctrl.modifier.maxSelections) {
            ctrl.modifier.maxSelections = ctrl.modifier.minSelections;
            ctrl.handleMaxSelectionChange();
        }
    };

    ctrl.handleMaxSelectionChange = function() {
        if (ctrl.modifier.maxSelections < ctrl.modifier.minSelections) {
            ctrl.modifier.minSelections = ctrl.modifier.maxSelections;
            ctrl.handleMinSelectionChange();
        }
    };

    ctrl.handleSingleSelectionChange = function(value) {
        if (value === true) {
            ctrl.modifier.minSelections = 0;
            ctrl.modifier.maxSelections = 0;
        }
    };

    ctrl.handleSelectionRequiredChange = function(value) {
        if (value === false) {
            ctrl.modifier.minSelections = 0;
        }
    };

    ctrl.handleBackButtonClick = function() {
        if (ctrl.selectedTemplate === ctrl.TEMPLATES.PRODUCT_SELECTION) {
            ctrl.selectedTemplate = ctrl.TEMPLATES.EDIT_MODIFIER;
        } else {
            ctrl.onBackButtonClick();
        }
    };

    ctrl.handleDragItemMoved = function(index) {
        ctrl.modifier.options.splice(index, 1);
        var editorIndex = ctrl.getOptionEditorIndex();
        if (editorIndex !== null) {
            ctrl.optionEditor = ctrl.modifier.options[editorIndex];
        }
    };

}
hsApp.component('productDetailsModifiers', {
    templateUrl: '/partials/components/modifiers/product-details-modifiers.html',
    bindings: {
        productName: '<',
        modifiers: '<',
        onClickModifier: '&'
    },
    controller: ['hsUtils', '$location', productDetailsModifiersController],
});

function productDetailsModifiersController(hsUtils, $location) {
    var ctrl = this;
    var logPrefix = '[productDetailsModifiersController]:';
    
    ctrl.$onInit = function() {
        ctrl.selectedModifier = null;
    };

    ctrl.handleDrawerClick = function(modifier) {
        if (modifier.name === ctrl.selectedModifier) {
            ctrl.selectedModifier = null;
        } else {
            ctrl.selectedModifier = modifier.name;
        }
    };

    ctrl.navigateToModifierSelection = function() {
        var path = $location.path();
        var backLink = path.split('/').reverse()[0].split('?')[0];
        if (!backLink) {
            backLink = '';
        }
        var encodedName = encodeURIComponent(ctrl.productName);
        var encodedBackLink = encodeURIComponent(backLink);
        var modifierSelectionUrl = '/admin/modifiers/product?name=' + encodedName + '&backLink=' + encodedBackLink;
        $location.url(modifierSelectionUrl);
    };

    ctrl.handleModifierClick = function(modifier) {
        return ctrl.onClickModifier({value: modifier});
    };
}

hsApp.component('productModifiers', {
    templateUrl: '/partials/components/modifiers/product-modifiers.html',
    controller: ['hsModifiers', 'toastr', '$location', 'hsUtils', 'hsAdmin', 'NgTableParams', 'globalFunctions', 'hsCart', '$scope', productModifiersController],
});

function productModifiersController(hsModifiers, toastr, $location, hsUtils, hsAdmin, NgTableParams, globalFunctions, hsCart, $scope) {
    var ctrl = this;
    var logPrefix = '[product-modifiers]';

    ctrl.TABS = {
        ALL_MODIFIERS: 'allModifiers',
        SELECTED_MODIFIERS: 'selectedModifiers'
    };

    ctrl.selectedTab = ctrl.TABS.ALL_MODIFIERS;
    ctrl.modifiers = [];
    ctrl.product = {};
    ctrl.selectedModifiers = [];
    ctrl.ngTableParams = null;
    ctrl.syncPriceListsPopup = {
        elementId: 'sync-add-modifiers-to-product',
        dataToPropagate: null,
    };

    ctrl.$onInit = function() {
        ctrl.isLoading = true;
        void 0;

        var queryParams = $location.search();
        if(hsUtils.isNonEmptyString(queryParams.backLink)) {
            ctrl.backLink = '/admin/products/' + queryParams.backLink;
        } else {
            ctrl.backLink = '/admin/products/all';
        }
        if (!hsUtils.isNonEmptyString(queryParams.name)) {
            return $location.url(ctrl.backLink);
        }
        ctrl.productName = queryParams.name;

        hsAdmin.initAdminPage('modifiers', false)
            .then(function() {
                ctrl.initData();
            })
            .catch(function(err) {
                void 0;
                $location.url('/admin/manager-dashboard');
            });
    };

    ctrl.initData = function() {
        hsModifiers.getAllModifiers()
            .then(function(modifiers) {
                ctrl.modifiers = modifiers;
                return hsModifiers.getProduct(ctrl.productName)
                    .then(function(product) {
                        ctrl.product = product;
                        ctrl.selectedModifiers = product.modifiers;
                        ctrl.createTable(ctrl.modifiers);
                    }).catch(function(err) {
                        void 0;
                        toastr.error('Something went wrong.');
                    });
                })
            .catch(function(err) {
                void 0;
                toastr.error('Something went wrong.');
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.shouldShowLoader = function() {
        return ctrl.isLoading;
    };

    ctrl.shouldShowTable = function() {
        return !ctrl.isLoading && !ctrl.shouldShowNoModifiersMessage();
    };

    ctrl.shouldShowNoModifiersMessage = function() {
        if (ctrl.selectedTab === ctrl.TABS.ALL_MODIFIERS) {
            return ctrl.modifiers.length === 0;
        } else if (ctrl.selectedTab === ctrl.TABS.SELECTED_MODIFIERS) {
            return ctrl.selectedModifiers.length === 0;
        }
        return false;
    };

    ctrl.setTab = function(tab) {
        if (ctrl.selectedTab === tab) {
            return;
        }
        if (tab === ctrl.TABS.ALL_MODIFIERS) {
            ctrl.createTable(ctrl.modifiers);
        } else if (tab === ctrl.TABS.SELECTED_MODIFIERS) {
            ctrl.createTable(ctrl.selectedModifiers);
        }
        ctrl.selectedTab = tab;
    };

    ctrl.createTable = function(modifiers) {
        ctrl.ngTableParams = new NgTableParams(
            {count: 15},
            {counts: [15, 30, 50], dataset: modifiers}
        );
    };

    ctrl.isSelectedModifier = function(modifier) {
        for (var selectedModifier of ctrl.selectedModifiers) {
            if (modifier.name === selectedModifier.name) {
                return true;
            }
        }
        return false;
    };

    ctrl.toggleSelectedModifier = function(modifier) {
        if (ctrl.isSelectedModifier(modifier)) {
            ctrl.removeSelectedModifier(modifier);
        } else {
            ctrl.addSelectedModifier(modifier);
        }
    };

    ctrl.removeSelectedModifier = function(modifier) {
        for (var i = 0; i < ctrl.selectedModifiers.length; i++) {
            if (ctrl.selectedModifiers[i].name === modifier.name) {
                ctrl.selectedModifiers.splice(i, 1);
                return;
            }
        }
    };

    ctrl.addSelectedModifier = function(modifier) {
        ctrl.selectedModifiers.push(modifier);
    };


    ctrl.openConfirmModifiersPopup = function() {
        var confirmationText = 'You are about to save the following modifiers for "' + ctrl.product.displayName + '":';
        if (ctrl.selectedModifiers.length) {
            confirmationText += '<ol class="text-left">'
            for (var i = 0; i < ctrl.selectedModifiers.length; i++) {
                confirmationText += '<li>';
                confirmationText += ctrl.selectedModifiers[i].displayName;
                confirmationText += '</li>';
            }
            confirmationText += '</ol>';
        } else {
            confirmationText += '<div class="ptop20">No Modifiers</div>';
        }
        globalFunctions.showConfirmationDialog(
            'Confirm',
            confirmationText,
            'Save',
            'Cancel', 
            function(cancel, save) {
                if (save) {
                    ctrl.saveProduct();
                }
            });
    };

    ctrl.saveProduct = function() {
        ctrl.isLoading = true;
        var modifierNames = ctrl.selectedModifiers.map(function(modifier) {
            return modifier.name;
        });
        var update = {
            name: ctrl.product.name,
            modifiers: modifierNames
        };
        hsModifiers.updateProducts([update])
            .then(function(res) {
                toastr.success('Successfully updated product. It may take a few minutes for the change to be visible throughout the system.');
                ctrl.syncPriceListsPopup.dataToPropagate = [update];
                ctrl.openSyncPriceListsPopupOrContinue();
            })
            .catch(function(err) {
                void 0;
                toastr.error('Something went wrong while updating product. Please try again.');
                ctrl.syncPriceListsPopup.dataToPropagate = null;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.getPriceString = function(product) {
        return '$' + product.price.toFixed(2);
    };

    ctrl.calculatePricePerQuantity = function(product) {
        return hsCart.calculatePricePerQuantity(product);
    };

    ctrl.propagateUpdateToTarget = function(target) {
        return hsModifiers.updateProducts(ctrl.syncPriceListsPopup.dataToPropagate, target);
    };

    ctrl.openSyncPriceListsPopupOrContinue = function() {
        if (hsAdmin.shouldShowSyncPriceListsPopup()) {
            $('#' + ctrl.syncPriceListsPopup.elementId).on('hidden.bs.modal', function(e) {
                ctrl.handleUpdateCompletion();
                $scope.$apply();
            });
            $('#' + ctrl.syncPriceListsPopup.elementId).modal('show');
        } else {
            ctrl.handleUpdateCompletion();
        }
    };

    ctrl.handleUpdateCompletion = function() {
        $location.url(ctrl.backLink);
    };

}
hsApp.component('addPaymentMethod', {
    templateUrl: '/partials/components/payments/add-payment-method.html',
    bindings: {
        onAdd: '&',
        onCancel: '&',
        deliveryAddress: '<',
        titleText: '<',
        titleTextCss: '<',
        hideEbt: '<',
        savePaymentOnUser: '<',
        country: '<',
        canCancel: '<',
        submitButtonText: '<',
        paymentProcessor: '<',
        isForUser: '<'
    },
    controller: [ 'globalFunctions', 'hsUtils', 'ebtService', '$rootScope', addPaymentMethodController ],
});

function addPaymentMethodController(globalFunctions, hsUtils, ebtService, $rootScope) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.tabOptions =  ctrl.getTabOptions();
        ctrl.selected = 0;

        if (!hsUtils.isString(ctrl.titleText)) {
            ctrl.titleText = 'Add New Payment Method';
        }

        if (!ctrl.titleTextCss) {
            ctrl.titleTextCss = 'option-titles mbot25';
        }

        if (!hsUtils.isBoolean(ctrl.hideEbt)) {
            ctrl.hideEbt = false;
        }

        if (!hsUtils.isBoolean(ctrl.savePaymentOnUser)) {
            ctrl.savePaymentOnUser = true;
        }

        if (!hsUtils.isBoolean(ctrl.canCancel)) {
            ctrl.canCancel = true;
        }

        if (!hsUtils.isNonEmptyString(ctrl.paymentProcessor)) {
            ctrl.paymentProcessor = $rootScope.paymentProcessor;
        }

        if (!hsUtils.isNonEmptyString(ctrl.submitButtonText)) {
            ctrl.submitButtonText = 'Save';
        }
    }

    ctrl.isEbtEnabled = function() {
        return ebtService.isEbtEnabled();
    }

    ctrl.getTabOptions = function() {
        var retVal = [
            {
                displayName: 'Credit/Debit',
                template: "/partials/components/user/credit-card-form-template.html",
                default: true
            },
        ];

        if (ctrl.isEbtEnabled() && !ctrl.hideEbt) {
            retVal.push({
                displayName: 'EBT/SNAP',
                template: "/partials/components/user/ebt-card-form-template.html",
            });
        }
        
        return retVal;
    }

    ctrl.isOptionSelected = function(index) {
        return ctrl.selected === index;
    }

    ctrl.selectTab = function(index) {
        ctrl.selected = index;
    }

    ctrl.cancelCreditCardForm = function() {
        ctrl.onCancel();
    }

    ctrl.onAddCardSuccess = function(userData, paymentMethod) {
        ctrl.onAdd({ userData: userData, paymentMethod:paymentMethod });
    }
}
hsApp.component('creditCardDetails', {
    templateUrl: '/partials/components/payments/credit-card-details.html',
    bindings: {
        paymentMethod: '<',
        onDelete: '&',
        onSelectCard: '&',
        hideHrAfterDetails: '<',
        selectedCard: '<',
        hideSelectCard: '<',
        hideSelectCardText: '<',
        hideCreditCardImage: '<',
    },
    controller: [ 'hsAccountSettings', 'hsUtils', creditCardDetailsController ],
});

function creditCardDetailsController(hsAccountSettings, hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.logoMap = hsAccountSettings.PAYMENT_METHOD_LOGO_MAP;
    }

    ctrl.deletePaymentMethod = function() {
        return ctrl.onDelete({
            value: {
                pmid: ctrl.paymentMethod.pmid
            }
        });
    }

    ctrl.selectCard = function() {
        return ctrl.onSelectCard({
            value: {
                pmid: ctrl.paymentMethod.pmid
            }
        });
    }

    ctrl.getCreditCardImageUrl = function() {
        var paymentMethodBrand = (ctrl.paymentMethod.cardBrand || '').toLowerCase().replace(/[^a-z]/gi, '');
        if (ctrl.logoMap.hasOwnProperty(paymentMethodBrand)) {
            return '../../../images/icons/' + ctrl.logoMap[paymentMethodBrand];
        }
        return '../../../images/icons/credit-card-default.svg';
    }

    ctrl.getCardDisplayName = function() {
        if (!hsUtils.isObject(ctrl.paymentMethod) || (!hsUtils.isNonEmptyString(ctrl.paymentMethod.cardLast4) && !hsUtils.isNonEmptyString(ctrl.paymentMethod.last4))) {
            return '';
        }
        
        return '* ' + (ctrl.paymentMethod.cardLast4 || ctrl.paymentMethod.last4);
    }
}

hsApp.component('ebtCardForm', {
    templateUrl: '/partials/components/payments/ebt-card-form.html',
    bindings: {
        onCancelClick: '&',
        onSuccess: '&',
        canCancel: '<'
    },
    controller: [ 'ebtService', '$scope', 'hsUserPayments', 'toastr', ebtCardFormController ],
});

function ebtCardFormController(ebtService, $scope, hsUserPayments, toastr) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.isLoading = false;
        ctrl.tokenizedCard = null;
        ctrl.initForage();
    }

    ctrl.initForage = function() {
        ctrl.isLoading = true;
        ebtService.getClient()
            .then(function(forage) {
                ctrl.initForageElement(forage);
            })
            .finally(function() {
                ctrl.isLoading = false;
                $scope.$apply();
            })
    }

    ctrl.initForageElement = function(forage) {
        var tokenizeEbtCardElement = forage.create('ebt_card_tokenize_number');
        tokenizeEbtCardElement.mount('tokenize-card-container');
        tokenizeEbtCardElement.on('change', function (event) {
            if (event.error) {
                ctrl.tokenizedCard = null;
                $scope.$apply();
                void 0;
                return;
            }

            if (event.complete) {
                forage.tokenizeEbtCardNumber(tokenizeEbtCardElement, { reusable: true })
                    .then(function(tokenizedEbtCardResult) {
                        ctrl.tokenizedCard = tokenizedEbtCardResult;
                        $scope.$apply();
                    });
            } else {
                ctrl.tokenizedCard = null;
                $scope.$apply();
            }
        })
    }

    ctrl.saveCardOnUser = function() {
        if (ctrl.tokenizedCard) {
            ctrl.isLoading = true;
            hsUserPayments.addPaymentMethod(ctrl.tokenizedCard)
                .then(function(response) {
                    if (response && response.data && response.data.user) {
                        ctrl.onSuccess({ userData: response.data.user });
                        toastr.success("Successfully added EBT Card");
                    } else {
                        void 0;
                        toastr.error(response.data.message);
                    }
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to add EBT Card');
                })
                .finally(function() {
                    ctrl.isLoading = false;
                })
        }
    }
}
hsApp.component('myAccountCreditCard', {
    templateUrl: '/partials/components/payments/my-account-credit-card.html',
    bindings: {
        paymentMethod: '<',
        showMenu: '<',
        onSuccess: '&',
    },
    controller: [ 'ENV', '$rootScope', '$http', 'toastr', 'hsUtils', 'hsUserPayments', 'ngDialog', myAccountCreditCardController ],
});

function myAccountCreditCardController(ENV, $rootScope, $http, toastr, hsUtils, hsUserPayments, ngDialog) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.ENV = ENV;
        ctrl.isUpdating = false;
    };

    ctrl.getCardBrand = function () {
        return ctrl.paymentMethod.cardBrand;
    };

    ctrl.getCardLast4 = function () {
        return ctrl.paymentMethod.cardLast4;
    };

    ctrl.setDefaultPaymentMethod = function ($event) {
        $event.stopPropagation();

        if (ctrl.isUpdating) return;
        ctrl.isUpdating = true;

        return hsUserPayments.setDefaultPaymentMethod(ctrl.paymentMethod.pmid)
            .then(function(userData) {
                return ctrl.onSuccess({ userData: userData });
            })
            .catch(function(err) {
                void 0;
                toastr.error(err);
            })
            .finally(function() {
                ctrl.isUpdating = false;
            });
    };

    ctrl.deletePaymentMethod = function ($event) {
        $event.stopPropagation();

        if (ctrl.isUpdating) return;

        return ngDialog.openConfirm({
            data: {
                heading: 'Delete Payment',
                subHeading: 'Are you sure you would like to delete ' + ctrl.paymentMethod.cardBrand + ' - ' + ctrl.paymentMethod.cardLast4 + '?',
                confirmBtnText: 'Yes',
                cancelBtnText: 'No'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function(ok) {
                ctrl.isUpdating = true;

                return hsUserPayments.deletePaymentMethod(ctrl.paymentMethod.pmid)
                    .then(function(userData) {
                        return ctrl.onSuccess({ userData: userData });
                    })
                    .catch(function(err) {
                        void 0;
                        toastr.error(err);
                    })
                    .finally(function() {
                        ctrl.isUpdating = false;
                    });
            })
            .catch(function(cancel) {});

    };

    ctrl.hasAddress = function () {
        return ctrl.paymentMethod.hasBillingAddress === true;
    };

    ctrl.getFormattedAddress = function () {
        var address = ctrl.paymentMethod.billingAddress;

        return address.street + ', ' + address.city + ', ' + address.state + ' ' + address.zip;
    };

    ctrl.getAddedDate = function () {
        if (!ctrl.paymentMethod.createdAt) return '';

        return hsUtils.getDateString(new Date(ctrl.paymentMethod.createdAt));
    };

}

hsApp.component('orderPaymentPopup', {
    templateUrl: '/partials/components/payments/order-payment-popup.html',
    bindings: {
        isForUser: '<',
        user: '<',
        paymentProcessor: '<',
        onSuccess: '&',
        onCancel: '&',
    },
    controller: [ 'hsAuth', 'hsUtils', orderPaymentPopupController ],
});

function orderPaymentPopupController(hsAuth, hsUtils) {
    var ctrl = this;
    ctrl.error = '';
    ctrl.isLoading = false;
    ctrl.showCreditCardForm = false;
    ctrl.paymentMethods = [];

    ctrl.$onInit = function() {
        void 0;
    };

    ctrl.$onChanges = function (changes) {
        if ('user' in changes && hsUtils.isObject(changes.user.currentValue)) {
            var user = changes.user.currentValue;
            ctrl.setPaymentMethods(user.paymentMethods);
            ctrl.deliveryAddress = user.address;
        }
    };

    ctrl.setPaymentMethods = function (paymentMethods) {
        if (hsUtils.isNonEmptyArray(paymentMethods)) {
            if (hsUtils.isNonEmptyString(ctrl.paymentProcessor)) {
                ctrl.paymentMethods = paymentMethods.filter(function(pm) {
                    return pm.paymentProcessor === ctrl.paymentProcessor;
                }).reverse();
            } else {
                ctrl.paymentMethods = paymentMethods;
            }
        } else {
            ctrl.paymentMethods = [];
        }
    };

    ctrl.selectPaymentMethod = function (paymentMethod) {
        ctrl.isLoading = true;
        ctrl.error = '';

        ctrl.onSuccess({ paymentMethodPmid: paymentMethod.pmid })
            .catch(function (err) {
                void 0;
                ctrl.error = 'Failed to update the order.';
            })
            .finally(function () {
                ctrl.isLoading = false;
            })
    };

    ctrl.toggleCreditCardForm = function() {
        ctrl.showCreditCardForm = !ctrl.showCreditCardForm;
    };

    ctrl.onAddCardSuccess = function (userData) {
        ctrl.toggleCreditCardForm();

        if (hsUtils.isObject(userData)) {
            hsAuth.saveUserLocal(userData);
        }
    };

}

hsApp.component('paymentMethods', {
    templateUrl: '/partials/components/payments/payment-methods.html',
    bindings: {
        isForUser: '<',
        paymentProcessor: '<',
        paymentMethods: '<',
        buttonsDisabled: '<',
        showDelete: '<',
        theme: '@',
        selected: '<',
        onSelect: '&',
        onCancel: '&',
        onAddClick: '&',
        onDeleteClick: '&',
    },
    controller: [ 'hsUtils', 'ngDialog', paymentMethodsController ],
});

function paymentMethodsController(hsUtils, ngDialog) {
    var ctrl = this;
    ctrl.pms = [];
    ctrl._selected = null;
    ctrl._theme = 'light';

    ctrl.$onInit = function() {
        if (ctrl.theme === 'dark') {
            ctrl._theme = 'dark';
        }
    };

    ctrl.$onChanges = function (changes) {
        if ('paymentMethods' in changes) {
            ctrl.setPaymentMethods(changes.paymentMethods.currentValue);
            ctrl.setSelectedPaymentMethod();
        }
    };

    ctrl.setPaymentMethods = function (paymentMethods) {
        if (hsUtils.isNonEmptyArray(paymentMethods)) {
            if (hsUtils.isNonEmptyString(ctrl.paymentProcessor)) {
                ctrl.pms = paymentMethods.filter(function(pm) {
                    return pm.paymentProcessor === ctrl.paymentProcessor;
                });
            } else {
                ctrl.pms = paymentMethods;
            }
        } else {
            ctrl.pms = [];
        }
    };

    ctrl.setSelectedPaymentMethod = function () {
        if (hsUtils.isNonEmptyArray(ctrl.pms)) {
            var selected = null;

            if (hsUtils.isObject(ctrl._selected)) {
                selected = ctrl.pms.find(function(pm) {
                    return pm.pmid === ctrl._selected.pmid;
                });
            }
            if (selected) {
                ctrl._selected = selected;
            } else if (hsUtils.isObject(ctrl.selected)) {
                ctrl._selected = ctrl.pms.find(function(pm) {
                    return pm.pmid === ctrl.selected.pmid;
                }) || ctrl.pms[0];
            } else {
                ctrl._selected = ctrl.pms[0];
            }
        } else {
            ctrl._selected = null;
        }
    };

    ctrl.isSelectedPaymentMethod = function (pm) {
        return ctrl._selected && ctrl._selected.pmid === pm.pmid;
    };

    ctrl.selectPaymentMethod = function (pm) {
        ctrl._selected = pm;
    };

    ctrl.toggleAddPayment = function () {
        ctrl.onAddClick();
    };

    ctrl.cancel = function () {
        ctrl.onCancel();
    };

    ctrl.applySelected = function () {
        if (!ctrl._selected) return;

        ctrl.onSelect({ paymentMethod: ctrl._selected });
    };

    ctrl.deleteSelectedPaymentMethod = function () {
        if (!ctrl._selected) return;

        return ngDialog.openConfirm({
            data: {
                heading: 'Delete Payment',
                subHeading: 'Are you sure you would like to delete ' + ctrl._selected.cardBrand + ' - ' + ctrl._selected.cardLast4 + '?',
                confirmBtnText: 'Yes',
                cancelBtnText: 'No'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function(ok) {
                ctrl.onDeleteClick({ paymentMethod: ctrl._selected });
            })
            .catch(function(cancel) {});

    };

}

hsApp.component('paymentWrapper', {
    templateUrl: '/partials/components/payments/payment-wrapper.html',
    bindings: {
        isHouseChargeAvailable: '<',
        isHouseChargeOrder: '<',
        onSelectChargeType: '&',
        selectedCard: '<',
        paymentMethods: '<',
        onSelectCard: '&',
        hideSelectCardTextCc: '<',
        hideSelectCardCc: '<',
        hideSelectCardTextEbt: '<',
        hideSelectCardEbt: '<',
        titleTextCss: '<',
        onSelectPaymentMethod: '&',
        deliveryAddress: '<',
        onAdd: '&',
        addPaymentTitleText: '<',
        addPaymentTitleTextCss: '<',
        onDelete: '&',
        hideEbt: '<',
        savePaymentOnUser: '<',
        country: '<',
        canCancel: '<',
        submitButtonText: '<',
        paymentProcessor: '<',
        isForUser: '<',
        selectPaymentMethodBtnText: '@',
        houseChargeBtnText: '@',
    },
    controller: [ 
        'hsUserPayments', 
        'hsUtils',
        'ebtService',
        paymentWrapperController 
    ],
});

function paymentWrapperController(
    hsUserPayments,
    hsUtils,
    ebtService
) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if (!hsUtils.isBoolean(ctrl.isForUser)) {
            ctrl.isForUser = false;
        }

        if (!hsUtils.isBoolean(ctrl.hideEbt)) {
            ctrl.hideEbt = false;
        }

        if (!hsUtils.isBoolean(ctrl.isHouseChargeOrder)) {
            ctrl.isHouseChargeOrder = false;
        }

        ctrl.addingPaymentMethod = !ctrl.hasCCPaymentMethod() && !ctrl.hasEbtPaymentMethod();
    };

    ctrl.getCanCancel = function() {
        if (hsUtils.isBoolean(ctrl.canCancel)) return ctrl.canCancel;

        return ctrl.hasCCPaymentMethod() || ctrl.hasEbtPaymentMethod();
    };

    ctrl.hasCCPaymentMethod = function() {
        if (!hsUtils.isNonEmptyArray(ctrl.paymentMethods)) return false;

        return ctrl.paymentMethods.find(function(pm) {
            return pm.paymentProcessor !== hsUserPayments.PAYMENT_PROCESSORS.forage;
        });
    };

    ctrl.hasEbtPaymentMethod = function() {
        if (!hsUtils.isNonEmptyArray(ctrl.paymentMethods)) return false;

        if (ctrl.hideEbt) return false;

        return ctrl.paymentMethods.find(function(pm) {
            return pm.paymentProcessor === hsUserPayments.PAYMENT_PROCESSORS.forage;
        });
    };

    ctrl.setIsHouseChargeOrder = function(val) {
        ctrl.isHouseChargeOrder = val === true;
        ctrl.onSelectChargeType({ 
            value: {
                isHouseChargeOrder: ctrl.isHouseChargeOrder 
            }
        });
    };

    ctrl.toggleAddPaymentMethod = function() {
        ctrl.addingPaymentMethod = !ctrl.addingPaymentMethod;
    };

    ctrl.selectPaymentMethod = function() {
        ctrl.onSelectPaymentMethod();
    };

    ctrl.showButtonIfOnlyEBTPaymentMethodIsAvailable = function() {
        return ctrl.hasEbtPaymentMethod() && !ctrl.hasCCPaymentMethod();
    };

    ctrl.processAddCard = function(userData, paymentMethod) {
        ctrl.toggleAddPaymentMethod();
        ctrl.onAdd({ userData, paymentMethod });
    };

    ctrl.getCreditCardEbtTitle = function() {
        var titleText = 'Credit Card';
        if (ebtService.isEbtEnabled()) {
            titleText = titleText + '/EBT';
        }

        return titleText;
    };
}

hsApp.component('productPrice', {
    templateUrl: '/partials/components/product/product-price.html',
    bindings: {
        productData: '<',
        promotion: '<',
        showMembershipDiscount: '<',
        volumePromotions: '<'
    },
    controller: [ 
        'hsPromos',
        'hsCart',
        productPriceController 
    ],
});

function productPriceController(
        hsPromos,
        hsCart
    ) {
    var ctrl = this;

    ctrl.$onInit = function() {
        if (ctrl.showMembershipDiscount) {
            ctrl.initMembershipDiscount();
        }
    };

    ctrl.initMembershipDiscount = function() {
        ctrl.priceString = ctrl.getProductPriceString(ctrl.productData.price);
        ctrl.discountPrice = 0;
        if (ctrl.promotion) {
            ctrl.discountPrice = ctrl.promotion.promotionPrice || 0;

            if (ctrl.promotion.userGroupDisplayName) {
                ctrl.membersDescription = ctrl.promotion.userGroupDisplayName;
            }
        }
        if (!ctrl.discountPrice) {
            if (ctrl.promotion && ctrl.promotion.type === hsPromos.types.FREE_ITEM) {
                ctrl.discountPriceString = 'Free';
            } else {
                ctrl.discountPriceString = ctrl.getProductPriceString(ctrl.productData.price);
            }
        } else {
            ctrl.discountPriceString = ctrl.getProductPriceString(ctrl.discountPrice);
        }
    };

    ctrl.getProductPriceString = function(price) {
        return '$' + price.toFixed(2) + ctrl.getProductUnit();
    };
    
    ctrl.shouldDisplayPromotionStylePrice = function() {
        if (!ctrl.promotion || !ctrl.promotion.type) return false;
        if (ctrl.promotion.type === hsPromos.types.FEATURED) return false;
        if (ctrl.productData.adminChangedPrice) return false;
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;
        if (ctrl.promotion.promotionPrice >= ctrl.productData.price) return false;

        return true;
    };

    ctrl.isPromotionPriceApplicable = function() {
        if (!ctrl.promotion) return false;
        if (!ctrl.promotion.isApplicable) return false;
        if (ctrl.productData.adminChangedPrice) return false;
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return true;
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;

        return true;
    };
    
    ctrl.getApplicablePrice = function() {
        if (ctrl.isPromotionPriceApplicable()) {
            return ctrl.getPromotionPrice();
        }
        return ctrl.getRegularPrice();
    };

    ctrl.getRegularPrice = function() {
        return ctrl.getProductPriceString(ctrl.productData.price);
    };

    ctrl.getPromotionPrice = function() {
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return 'Free';
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return '';

        return ctrl.getProductPriceString(ctrl.promotion.promotionPrice);
    };

    ctrl.getProductUnit = function() {
        return hsCart.calculatePricePerQuantityV2(ctrl.productData);
    }
}
hsApp.component('addItems', {
    templateUrl: '/partials/components/promotions/add-items.html',
    bindings: {
        itemGroup: '<',
        productsHash: '<',
        selectedItems: '<',
        onItemSelect: '&',
    },
    controller: ['$rootScope', 'globalFunctions', '$location', '$scope', 'ENV', 'hsPromos', 'toastr', 'VALIDATORS', 'hsSearch', '$filter', addItemsController],
});

function addItemsController($rootScope, globalFunctions, $location, $scope, ENV, hsPromos, toastr, VALIDATORS, hsSearch, $filter) {
    var ctrl = this;
    var logPrefix = '[addItems]: ';

    ctrl.$onInit = function() {
        ctrl.searchQuery = '';
        ctrl.promotionType = ctrl.itemGroup.type;

        ctrl.isLoading = false;
    };

    ctrl.$onChanges = function(changes) {
        if ('productsHash' in changes && changes.productsHash.currentValue) {
            ctrl.initProducts(Object.values(ctrl.productsHash), false, true);
        }
    };

    ctrl.initProducts = function(products, productFromHash, saveOriginal) {
        if (products) {
            ctrl.categorizedProducts = ctrl.categorizeProducts(products, productFromHash);
            if (saveOriginal) {
                ctrl.originalProducts = ctrl.categorizedProducts;
            }
        } else {
            ctrl.categorizedProducts = ctrl.originalProducts
        }
        ctrl.categories = Object.keys(ctrl.categorizedProducts);

        var categoryToSelect = null;
        if (ctrl.categories.length) {
            if (ctrl.categories.includes(ctrl.selectedCategory)) {
                categoryToSelect = ctrl.selectedCategory;
            } else {
                categoryToSelect = ctrl.categories[0];
            }
        }
        ctrl.selectCategory(categoryToSelect);
    };

    ctrl.selectCategory = function(category) {
        if (category) {
            ctrl.selectedCategory = category;
            ctrl.selectedProducts = ctrl.categorizedProducts[category];

            angular.forEach(Object.values(ctrl.selectedProducts), function(subCategory) {
                subCategory.infScrollProducts = subCategory.allProducts.slice(0, 20);
            });
        } else {
            ctrl.selectedCategory = '';
            ctrl.selectedProducts = [];
        }
    };

    ctrl.loadMore = function(subCategory) {
        var products = ctrl.selectedProducts[subCategory];
        var nextIndex = products.infScrollProducts.length;

        if (products.allProducts.length === nextIndex) return;

        products.infScrollProducts = products.infScrollProducts.concat(products.allProducts.slice(nextIndex, nextIndex + 20));
    };

    ctrl.searchProducts = function() {
        if (!ctrl.searchQuery) return;
        ctrl.loading = true;
        // str, filters, order, matchAllWords, includeAllItems
        hsSearch.search(ctrl.searchQuery, null, null, false, false, true)
            .then(function(data) {
                ctrl.searchedProducts = data.results[0] ? data.results[0] : [];
                ctrl.initProducts(ctrl.searchedProducts);
            })
            .catch(function(err) {
                void 0;
            })
            .finally(function() {
                ctrl.loading = false;
            });
    };

    ctrl.categorizeProducts = function(products, productFromHash) {
        var categorized = ctrl.getSortedCategories();

        angular.forEach(products, function(product) {
            if (productFromHash) {
                product = ctrl.productsHash[product.name];
            }
            try {
                var categoryNameWithoutSpaces = $filter('removeSpaces')(product.type);
            }
            catch (err) {
                // console.error(err);
                return;
            }
            if (!product.isHidden) {
                if (!(categoryNameWithoutSpaces in categorized)) {
                    categorized[categoryNameWithoutSpaces] = {
                        subCategories: {},
                    };
                }
                var category = categorized[categoryNameWithoutSpaces];
                category.name = product.type;

                var subCategoryNameWithoutSpaces = $filter('removeSpaces')(product.subType);
                if (!(subCategoryNameWithoutSpaces in category.subCategories)) {
                    category.subCategories[subCategoryNameWithoutSpaces] = {
                        products: [],
                    };
                }
                var subCategory = category.subCategories[subCategoryNameWithoutSpaces];
                subCategory.name = product.subType;
                subCategory.products.push(product.name);
            }

        });

        return ctrl.cleanCategorizedProducts(categorized);
    };

    ctrl.getSortedCategories = function() {
        var newObj = {};

        angular.forEach(Object.keys(ENV.categoryOrder), function(category) {
            newObj[category] = {
                subCategories: {},
            };
            if (category in ENV.subCategoryOrder) {
                angular.forEach(Object.keys(ENV.subCategoryOrder[category]), function(subCategory) {
                    newObj[category].subCategories[subCategory] = {
                        products: [],
                    };
                });
            }
        });
        return newObj;
    };

    ctrl.cleanCategorizedProducts = function(categorized) {
        var cleaned = {};

        angular.forEach(categorized, function(categoryValues, categoryName) {
            if (!categoryValues.name || !Object.keys(categoryValues.subCategories).length) return;

            cleaned[categoryValues.name] = {};

            angular.forEach(Object.keys(categoryValues.subCategories), function(subCategoryName) {
                var subCategory = categoryValues.subCategories[subCategoryName];
                if (!subCategory.name || !subCategory.products.length) return;

                cleaned[categoryValues.name][subCategory.name] = {
                    allProducts: subCategory.products,
                };
            });
        });

        return cleaned;
    };

    ctrl.resetSearch = function() {
        ctrl.searchQuery = '';
        ctrl.initProducts();
        ctrl.selectCategory(ctrl.categories[0]);
    };

    ctrl.toggleItemSelection = function(item) {
        if (item.name in ctrl.selectedItems) {
            delete ctrl.selectedItems[item.name];
            if (ctrl.isSelectedItemsView) {
                ctrl.initProducts(Object.values(ctrl.selectedItems), true);
            }
        } else {
            ctrl.selectedItems[item.name] = item;
        }
        ctrl.onItemSelect();
    };

    ctrl.isItemSelected = function(itemName) {
        return itemName in ctrl.selectedItems;
    };

    ctrl.toggleSelectedItemsView = function() {
        if (ctrl.isSelectedItemsView) {
            ctrl.isSelectedItemsView = false;
            ctrl.initProducts();
        } else {
            ctrl.isSelectedItemsView = true;
            ctrl.initProducts(Object.values(ctrl.selectedItems), true);
        }
    };

    ctrl.getItemPromotionPrice = function(item) {
        return hsPromos.getDiscountPrice(ctrl.productsHash[item.name], ctrl.itemGroup);
    };

}

hsApp.component('itemGroup', {
    templateUrl: '/partials/components/promotions/item-group.html',
    bindings: {
        promotion: '<',
        userGroups: '<',
        itemGroup: '<',
        productsHash: '<',
        isNewItemGroup: '<',
        selectedPriceList: '<',
        selectedItems: '=',
        onItemGroupCreate: '&',
        onItemGroupUpdate: '&',
        onItemGroupDelete: '&',
        onAddItems: '&',
        isItemGroupDirty: '=',
    },
    controller: ['$rootScope', 'globalFunctions', '$location', '$scope', 'ENV', 'hsPromos', 'toastr', 'VALIDATORS', "hsUtils", "hsLocationSettings", itemGroupController],
});

function itemGroupController($rootScope, globalFunctions, $location, $scope, ENV, hsPromos, toastr, VALIDATORS, hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[promotion]: ';
    var adminSelectedPriceList = globalFunctions.getAdminSelectedPriceListFromStorage();

    ctrl.types = hsPromos.types;
    ctrl.sourceTypes = hsPromos.sourceTypes;
    ctrl.rewardsTypes = hsPromos.rewardsTypes;
    ctrl.scopes = hsPromos.scopes;

    ctrl.display = {
        types: {},
        sourceTypes: {},
        rewardsTypes: {},
    };

    // do not allow preorder promotion for catering type
    if (hsUtils.isObject(adminSelectedPriceList) && adminSelectedPriceList.type !== hsLocationSettings.priceListTypes.CATERING) {
        ctrl.display.types[ctrl.types.PREORDER] = 'Preorder';
    }
    ctrl.display.types[ctrl.types.FEATURED] = 'Featured Item';
    ctrl.display.types[ctrl.types.DEAL] = 'Deal';
    ctrl.display.types[ctrl.types.DISCOUNT] = 'Discount';
    ctrl.display.types[ctrl.types.FREE_ITEM] = 'Free Item';
    ctrl.display.sourceTypes[ctrl.sourceTypes.INDIVIDUAL] = 'Individual Items';
    ctrl.display.sourceTypes[ctrl.sourceTypes.GROUP] = 'Category or Subcategory';
    ctrl.display.rewardsTypes[ctrl.rewardsTypes.DOLLAR] = 'Dollar';
    ctrl.display.rewardsTypes[ctrl.rewardsTypes.PERCENT] = 'Percent';

    ctrl.$onInit = function() {
        ctrl.validationRules = hsPromos.validators.itemGroup;
        ctrl.isItemGroupDirty = false;
        ctrl.isItemsDetailsView = false;

        if (ctrl.isNewItemGroup) {
            ctrl.itemGroup = {
                name: '',
                displayName: '',
                type: ctrl.types.FEATURED,
                sourceType: ctrl.sourceTypes.INDIVIDUAL,
                rewardsType: ctrl.rewardsTypes.DOLLAR,
                rewardsValue: '',
                scope: ctrl.scopes.SAME_ITEM,
                eligibilityQuantity: 0,
                // rewardsQuantity: 0,
                applyInIncrementsOnly: false,
                membersOnly: false,
                userGroups: [],
                maxUsesPerItem: 0,
                maxUsesPerOrder: 0,
            };
            ctrl.itemGroupIndex = -1;
        } else {
            ctrl.itemGroupIndex = ctrl.promotion.itemGroups.findIndex(function(itemGroup) {
                return itemGroup.name === ctrl.itemGroup.name;
            });
        }
        var now = new Date();
        ctrl.startDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.startDatePicker.opened = !ctrl.startDatePicker.opened;
            }
        };
        ctrl.endDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.endDatePicker.opened = !ctrl.endDatePicker.opened;
            }
        };
        
        ctrl.originalItemGroupName = ctrl.itemGroup.name;
        ctrl.initSelectedItems();
        if(ctrl.types.PREORDER === ctrl.itemGroup.type){
            ctrl.setFulfillmentDateModel();
        }
        ctrl.initUserGroupsOptions();

        ctrl.isLoading = false;
    };

    ctrl.initUserGroupsOptions = function() {
        ctrl.memberUserGroupsOptions = [];
        ctrl.regularUserGroupsOptions = [];
        ctrl.selectedUserGroups = [];
        ctrl.selectedUserGroupsBackup = [];
        ctrl.selectedUserGroupsOptions = [];

        if (!Array.isArray(ctrl.itemGroup.userGroups)) {
            ctrl.itemGroup.userGroups = [];
        }

        if (ctrl.userGroups) {
            for (var entry of Object.entries(ctrl.userGroups)) {
                var label = entry[0];
                var userGroup = entry[1];

                var option = {
                    label: userGroup.displayName || label,
                    id: label,
                };

                if (userGroup.isMemberGroup) {
                    ctrl.memberUserGroupsOptions.push(option);
                } else {
                    ctrl.regularUserGroupsOptions.push(option);
                }
            }
        }
        ctrl.selectedUserGroupsOptions = ctrl.itemGroup.membersOnly ? ctrl.memberUserGroupsOptions : ctrl.regularUserGroupsOptions;

        for (var userGroup of ctrl.selectedUserGroupsOptions) {
            if (ctrl.itemGroup.userGroups.includes(userGroup.id)) {
                ctrl.selectedUserGroups.push(userGroup);
            }
        }
        ctrl.selectedUserGroupsBackup = angular.copy(ctrl.selectedUserGroups);
    };

    ctrl.onMembersOnlyChange = function(membersOnly) {
        ctrl.selectedUserGroupsOptions = membersOnly ? ctrl.memberUserGroupsOptions : ctrl.regularUserGroupsOptions;
        ctrl.selectedUserGroups = [];
        ctrl.onUserGroupChange();
    };

    ctrl.onUserGroupChange = function(from) {
        if (ctrl.promotion.isEnded) {
            // there is no good way to handle "disabled" state for multi-select dropdown
            ctrl.selectedUserGroups = angular.copy(ctrl.selectedUserGroupsBackup);
            return;
        }
        ctrl.itemGroup.userGroups = ctrl.selectedUserGroups.map(function (ug) {
            return ug.id;
        });
        void 0
        ctrl.setDirty();
    };

    ctrl.setFulfillmentDateModel = function() {
        if (ctrl.isNewItemGroup) {
            ctrl.model = {
                startDate: new Date(),
                endDate: new Date(),
            };
            ctrl.model.endDate.setDate(ctrl.model.endDate.getDate() + 7);
        } else {
            ctrl.model = {
                startDate: new Date(ctrl.itemGroup.fulfillmentStartDate.year, ctrl.itemGroup.fulfillmentStartDate.month - 1, ctrl.itemGroup.fulfillmentStartDate.date),
                endDate: new Date(ctrl.itemGroup.fulfillmentEndDate.year, ctrl.itemGroup.fulfillmentEndDate.month - 1, ctrl.itemGroup.fulfillmentEndDate.date),
            };
        }
    };

    ctrl.getDate = function(dateObj) {
        var defaultValue = '--';

        if (!dateObj || typeof dateObj !== 'object' || !dateObj.year || !dateObj.month || !dateObj.date) {
            return defaultValue;
        }

        var date = new Date(dateObj.year, dateObj.month - 1, dateObj.date);
        if (isNaN(date.getTime())) return defaultValue;

        var day = date.getDate().toString().padStart(2, '0');
        var month = (date.getMonth() + 1).toString().padStart(2, '0');
        var year = date.getFullYear().toString().slice(2);

        return month + '/' + day + '/' + year;
    };

    ctrl.getDateObject = function(datObj) {
        var dateObj = {};
        dateObj.date = datObj.getDate();
        dateObj.month = datObj.getMonth() + 1;
        dateObj.year = datObj.getFullYear();
        return dateObj;
    }

    ctrl.onTypeChange = function() {
        var type = ctrl.itemGroup.type;
        ctrl.setDirty();

        if (type === ctrl.types.PREORDER) {
            ctrl.itemGroup.sourceType = ctrl.sourceTypes.INDIVIDUAL;
        }
        if (type === ctrl.types.DEAL) {
            ctrl.itemGroup.sourceType = ctrl.sourceTypes.INDIVIDUAL;
            ctrl.itemGroup.rewardsType = ctrl.rewardsTypes.DOLLAR;

            if (!ctrl.itemGroup.eligibilityQuantity) {
                ctrl.itemGroup.eligibilityQuantity = 0;
            }
            if (typeof ctrl.itemGroup.applyInIncrementsOnly !== 'boolean') {
                ctrl.itemGroup.applyInIncrementsOnly = false;
            }
            if (!ctrl.itemGroup.maxUsesPerItem) {
                ctrl.itemGroup.maxUsesPerItem = 0;
            }
            if (!ctrl.itemGroup.maxUsesPerOrder) {
                ctrl.itemGroup.maxUsesPerOrder = 0;
            }
            // if (!ctrl.itemGroup.rewardsQuantity) {
            //     ctrl.itemGroup.rewardsQuantity = 0;
            // }
        }
        if (type === ctrl.types.DISCOUNT) {
            if (!ctrl.itemGroup.sourceType) {
                ctrl.itemGroup.sourceType = ctrl.sourceTypes.INDIVIDUAL;
            }
            if (!ctrl.itemGroup.rewardsType) {
                ctrl.itemGroup.rewardsType = ctrl.rewardsTypes.DOLLAR;
            }
            if (!ctrl.itemGroup.eligibilityQuantity) {
                ctrl.itemGroup.eligibilityQuantity = 0;
            }
            if (typeof ctrl.itemGroup.applyInIncrementsOnly !== 'boolean') {
                ctrl.itemGroup.applyInIncrementsOnly = false;
            }
            if (!ctrl.itemGroup.maxUsesPerItem) {
                ctrl.itemGroup.maxUsesPerItem = 0;
            }
            if (!ctrl.itemGroup.maxUsesPerOrder) {
                ctrl.itemGroup.maxUsesPerOrder = 0;
            }
            // if (!ctrl.itemGroup.rewardsQuantity) {
            //     ctrl.itemGroup.rewardsQuantity = 0;
            // }
        }
        if (type === ctrl.types.FREE_ITEM) {
            if (!ctrl.itemGroup.sourceType) {
                ctrl.itemGroup.sourceType = ctrl.sourceTypes.INDIVIDUAL;
            }
            if (!ctrl.itemGroup.eligibilityQuantity) {
                ctrl.itemGroup.eligibilityQuantity = 0;
            }
            ctrl.itemGroup.applyInIncrementsOnly = !!ctrl.itemGroup.eligibilityQuantity;

            if (!ctrl.itemGroup.maxUsesPerItem) {
                ctrl.itemGroup.maxUsesPerItem = 1;
            }
            if (!ctrl.itemGroup.maxUsesPerOrder) {
                ctrl.itemGroup.maxUsesPerOrder = 0;
            }
            // if (!ctrl.itemGroup.rewardsQuantity) {
            //     ctrl.itemGroup.rewardsQuantity = 0;
            // }
        }
        if (type !== ctrl.types.FEATURED) {
            if (!ctrl.itemGroup.scope) {
                ctrl.itemGroup.scope = ctrl.scopes.SAME_ITEM;
            }
        }
    };

    ctrl.onEligibilityChange = function () {
        if (ctrl.itemGroup.eligibilityQuantity === 0) {
            ctrl.itemGroup.applyInIncrementsOnly = false;
        } else if (ctrl.itemGroup.type === ctrl.types.FREE_ITEM) {
            ctrl.itemGroup.applyInIncrementsOnly = true;
        }
        ctrl.setDirty();
    }

    ctrl.isItemInProducts = function(item) {
        return item && item.name in ctrl.productsHash;
    };

    ctrl.getItemDisplayName = function(item) {
        return ctrl.productsHash[item.name].displayName;
    };

    ctrl.isInactiveItem = function(item) {
        return ctrl.productsHash[item.name].isInactive;
    };

    ctrl.getItemCurrentPrice = function(item) {
        return ctrl.productsHash[item.name].price;
    };

    ctrl.getItemPromotionPrice = function(item) {
        return hsPromos.getDiscountPrice(ctrl.productsHash[item.name], ctrl.itemGroup);
    };

    ctrl.getItemGroupFromParams = function() {
        var itemGroup = {
            name: ctrl.itemGroup.name,
            displayName: ctrl.itemGroup.displayName,
            type: ctrl.itemGroup.type,
            sourceType: ctrl.itemGroup.sourceType,
        };
        if(itemGroup.type === ctrl.types.PREORDER){
            itemGroup.fulfillmentStartDate = ctrl.getDateObject(ctrl.model.startDate),
            itemGroup.fulfillmentEndDate = ctrl.getDateObject(ctrl.model.endDate)
        }
        if ([ctrl.types.DEAL, ctrl.types.DISCOUNT].includes(itemGroup.type)) {
            itemGroup.rewardsType = ctrl.itemGroup.rewardsType;
        }
        if ([ctrl.types.DISCOUNT].includes(itemGroup.type)) {
            itemGroup.rewardsValue = ctrl.itemGroup.rewardsValue;
        }
        if ([ctrl.types.DEAL, ctrl.types.DISCOUNT, ctrl.types.FREE_ITEM].includes(itemGroup.type)) {
            itemGroup.scope = ctrl.itemGroup.scope;
            itemGroup.eligibilityQuantity = ctrl.itemGroup.eligibilityQuantity;
            itemGroup.applyInIncrementsOnly = ctrl.itemGroup.applyInIncrementsOnly;
            itemGroup.membersOnly = ctrl.itemGroup.membersOnly;
            itemGroup.userGroups = ctrl.itemGroup.userGroups;
            itemGroup.maxUsesPerItem = ctrl.itemGroup.maxUsesPerItem;
            itemGroup.maxUsesPerOrder = ctrl.itemGroup.maxUsesPerOrder;
            // itemGroup.rewardsQuantity = ctrl.itemGroup.rewardsQuantity;
        }
        if (!ctrl.isNewItemGroup) {
            itemGroup.source = Object.values(ctrl.selectedItems);
        }
        void 0;
        return itemGroup;
    };

    ctrl.isValidItemGroup = function() {
        ctrl.error = '';

        if (!ctrl.itemGroupForm.validate()) return false;


        if (ctrl.itemGroup.type === ctrl.types.FEATURED) {
            if (ctrl.itemGroup.sourceType !== ctrl.sourceTypes.INDIVIDUAL) {
                ctrl.error = 'Incorrect source type.';
                return false;
            }
        }
        if (ctrl.itemGroup.type === ctrl.types.DEAL) {
            if (ctrl.itemGroup.sourceType !== ctrl.sourceTypes.INDIVIDUAL) {
                ctrl.error = 'Incorrect source type.';
                return false;
            }
            if (ctrl.itemGroup.rewardsType !== ctrl.rewardsTypes.DOLLAR) {
                ctrl.error = 'Incorrect discount type.';
                return false;
            }
        }
        if (ctrl.itemGroup.type === ctrl.types.DISCOUNT) {
            if (ctrl.itemGroup.sourceType !== ctrl.sourceTypes.INDIVIDUAL) {
                ctrl.error = 'Incorrect source type.';
                return false;
            }
            if (ctrl.itemGroup.rewardsType === ctrl.rewardsTypes.PERCENT && ctrl.itemGroup.rewardsValue >= 100)  {
                ctrl.error = 'Discount can not be 100%.';
                return false;
            }
            if (ctrl.itemGroup.rewardsType === ctrl.rewardsTypes.DOLLAR) {
                var items = Object.values(ctrl.selectedItems);
                void 0
                for (var i = 0; i < items.length; i++) {
                    var item = ctrl.productsHash[items[i].name];
                    if (!item) continue;

                    if (item.price <= ctrl.itemGroup.rewardsValue) {
                        ctrl.error = 'Discount price is greater than ' + item.displayName + ' price.';
                        return false;
                    }
                }
            }
        }
        if (ctrl.itemGroup.type === ctrl.types.FREE_ITEM) {
            if (ctrl.itemGroup.sourceType !== ctrl.sourceTypes.INDIVIDUAL) {
                ctrl.error = 'Incorrect source type.';
                return false;
            }
            if (ctrl.itemGroup.maxUsesPerItem === 0) {
                ctrl.error = 'Free Item promotion has to have Max Uses Per Item greater than zero.';
                return false;
            }
            // if (ctrl.itemGroup.rewardsQuantity === 0) {
            //     ctrl.error = 'Free Item promotion has to have Rewards Quantity greater than zero.';
            //     return false;
            // }
        }

        return true;
    };

    ctrl.createItemGroup = function() {
        if (ctrl.isValidItemGroup()) {
            var itemGroup = ctrl.getItemGroupFromParams();

            hsPromos.createItemGroup(ctrl.promotion, itemGroup)
                .then(function(newItemGroup) {
                    ctrl.originalItemGroupName = newItemGroup.name;
                    ctrl.onItemGroupCreate({ newItemGroup: newItemGroup });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to create itemGroup.');
                    ctrl.error = err.message;
                });
        }
    };

    ctrl.updateItemGroup = function() {
        if (ctrl.isValidItemGroup()) {
            var itemGroup = ctrl.getItemGroupFromParams();
            hsPromos.updateItemGroup(ctrl.promotion, itemGroup, ctrl.originalItemGroupName)
                .then(function(itemGroup) {
                    ctrl.originalItemGroupName = itemGroup.name;
                    ctrl.isItemGroupDirty = false;
                    ctrl.onItemGroupUpdate({ itemGroup: itemGroup });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to update itemGroup.');
                    ctrl.error = err.message;
                });
        }
    };

    ctrl.deleteItemGroup = function() {
        hsPromos.deleteItemGroup(ctrl.promotion, ctrl.originalItemGroupName)
            .then(function() {
                ctrl.onItemGroupDelete();
            })
            .catch(function(err) {
                void 0;
                toastr.error('Failed to delete itemGroup.');
                ctrl.error = err.message;
            });
    };

    ctrl.initSelectedItems = function() {
        var selected = {};

        if (ctrl.itemGroup.sourceType === hsPromos.sourceTypes.INDIVIDUAL && Array.isArray(ctrl.itemGroup.source)) {
            for (let i = 0; i < ctrl.itemGroup.source.length; i++) {
                var item = ctrl.itemGroup.source[i];
                item.maxAvailableQuantity = ctrl.itemGroup.source[i].maxAvailableQuantity || 0;
                selected[item.name] = item;
            }
        }
        ctrl.selectedItems = selected;
    };

    ctrl.isEmptyGroup = function() {
        if (!ctrl.selectedItems) return true;
        return !Object.keys(ctrl.selectedItems).length;
    };

    ctrl.setDirty = function() {
        ctrl.isItemGroupDirty = true;
    };

    ctrl.removeItem = function(item) {
        delete ctrl.selectedItems[item.name];
        ctrl.setDirty();
    };

    ctrl.getSelectionString = function() {
        return ctrl.selectedUserGroups.length + ' Selected';
    };

    ctrl.getItemUnit = function(item) {
        var itemObj = ctrl.productsHash[item.name];
        var unit = itemObj.unit;
        if (unit.toLowerCase() === 'lb' && !itemObj.sellByQty) {
            return 'LB';
        }
        return 'EA';
    }

}

hsApp.component('promoAdminItem', {
    templateUrl: '/partials/components/promotions/promo-admin-item.html',
    bindings: {
        itemGroup: '<',
        selectedItem: '<',
        productName: '<',
        productsHash: '<',
        isSelected: '<',
        onItemSelect: '&',
    },
    controller: ['$scope', 'hsCart', 'hsPromos', 'ngDialog', promoAdminItemController],
});


function promoAdminItemController($scope, hsCart, hsPromos, ngDialog) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.types = hsPromos.types;
        ctrl.product = ctrl.productsHash[ctrl.productName];
        ctrl.promotionType = ctrl.itemGroup.type;

        if (!ctrl.selectedItem) {
            ctrl.selectedItem = {
                name: ctrl.productName,
            };
        }
    };
    
    ctrl.getUnit = function() {
        return hsCart.calculatePricePerQuantity(ctrl.product);
    };

    ctrl.toggleItemSelection = function() {
        if (ctrl.promotionType === ctrl.types.DEAL && !ctrl.isSelected) {
            ctrl.showPromotionPricePopup()
                .then(function(res) {
                    if (res === 'success') {
                        ctrl.onItemSelect({ item: ctrl.selectedItem });
                    }
                });
        } else {
            ctrl.onItemSelect({ item: ctrl.selectedItem });
        }
    };

    ctrl.showPromotionPricePopup = function() {
        return ngDialog.open({
            template: '<promo-price-popup on-close="closeThisDialog(price)"></promo-price-popup>',
            className: 'ngdialog-theme-default',
            plain: true,
        }).closePromise
            .then(function(data) {
                if (data.value && !isNaN(data.value)) {
                    ctrl.selectedItem.price = Number(data.value);
                    return 'success';
                }
            })
            .catch(function(err) {
                void 0;
            });
    };

    ctrl.getItemPromotionPrice = function() {
        return hsPromos.getDiscountPrice(ctrl.productsHash[ctrl.selectedItem.name], ctrl.itemGroup);
    };
}

hsApp.component('promoBanner', {
    templateUrl: '/partials/components/promo-banner.html',
    bindings: {
        item: '<',
        promotion: '<',
    },
    controller: ['$scope', 'hsPromos', 'hsCart', promoBannerController],
});

function promoBannerController($scope, hsPromos, hsCart) {
    var ctrl = this;

    ctrl.$onChanges = function(changes) {
        if ('promotion' in changes) {
            if (changes.promotion.currentValue) {
                ctrl.message = hsPromos.getPromotionString(ctrl.promotion, ctrl.item);
            } else {
                ctrl.message = '';
            }
        }
    };

    ctrl.$onInit = function() {
        ctrl.message = hsPromos.getPromotionString(ctrl.promotion, ctrl.item);
    };

    ctrl.shouldShowMessage = function() {
        // return false; // hiding this for now
        if (!ctrl.item || !ctrl.promotion || !ctrl.message) return false;
        if (ctrl.item.membershipDiscount) return false;
        if (ctrl.promotion.type === hsPromos.types.FEATURED) return false;
        if ([hsPromos.types.DEAL, hsPromos.types.DISCOUNT].includes(ctrl.promotion.type)) {
            if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;
            if (ctrl.promotion.promotionPrice === ctrl.item.price) return false;
        }

        return true;
    };

    ctrl.getPromoMessage = function() {
        return hsPromos.getPromotionString(ctrl.promotion, ctrl.item);
    };

    ctrl.getProductPrice = function() {
        return hsCart.calculateProductPrice(ctrl.item);
    };

}

hsApp.component('promoPricePopup', {
    templateUrl: '/partials/components/promotions/promo-price-popup.html',
    bindings: {
        onClose: '&',
    },
    controller: ['$rootScope', 'globalFunctions', '$location', '$scope', 'ENV', 'hsPromos', 'toastr', 'VALIDATORS', 'hsSearch', '$filter', promoPricePopupController],
});

function promoPricePopupController($rootScope, globalFunctions, $location, $scope, ENV, hsPromos, toastr, VALIDATORS, hsSearch, $filter) {
    var ctrl = this;

    ctrl.setPrice = function() {
        if (ctrl.promoPriceForm.validate()) {
            ctrl.onClose({ price: ctrl.promoPrice });
        }
    };

}

hsApp.component('promoPrice', {
    templateUrl: '/partials/components/promo-price.html',
    bindings: {
        item: '<',
        promotion: '<',
        showOnePrice: '<',
        sizeClass: '@',
        colorClass: '@',
    },
    controller: ['$scope', 'hsPromos', 'hsCart', promoPriceController],
});

function promoPriceController($scope, hsPromos, hsCart) {
    var ctrl = this;

    ctrl.getBackgroundClass = function() {
        return ctrl.colorClass ? 'bg-' + ctrl.colorClass : 'bg-primary';
    };

    ctrl.getPriceClass = function() {
        if (!['xs', 'sm', 'md', 'lg'].includes(ctrl.sizeClass)) {
            void 0;
            return 'xs';
        }
        return ctrl.sizeClass;
    };

    ctrl.shouldDisplayPromotionStylePrice = function() {
        if (!ctrl.promotion || !ctrl.promotion.type) return false;
        if (ctrl.promotion.type === hsPromos.types.FEATURED) return false;
        if (ctrl.showOnePrice) return false;
        if (ctrl.item.adminChangedPrice) return false;
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return true;
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;
        if (ctrl.promotion.promotionPrice === ctrl.item.price) return false;

        return true;
    };

    ctrl.isPromotionPriceApplicable = function() {
        if (!ctrl.promotion) return false;
        if (!ctrl.promotion.isApplicable) return false;
        if (ctrl.item.adminChangedPrice) return false;
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return true;
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;

        return true;
    }

    ctrl.getApplicablePrice = function() {
        if (ctrl.isPromotionPriceApplicable()) {
            return ctrl.getPromotionPrice();
        }
        return ctrl.getRegularPrice();
    };

    ctrl.getRegularPrice = function() {
        return hsCart.calculateProductPrice(ctrl.item);
    };

    ctrl.getPromotionPrice = function() {
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return 'FREE';
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return '';

        return '$' + ctrl.promotion.promotionPrice.toFixed(2);
    }
}

hsApp.component('promoSavingsBadge', {
    templateUrl: '/partials/components/promotions/promo-savings-badge.html',
    bindings: {
        item: '<',
        promotion: '<',
        forUser: '<',
    },
    controller: ['$rootScope', '$scope', 'hsPromos', promoSavingsBadgeController],
});


function promoSavingsBadgeController($rootScope, $scope, hsPromos) {
    var ctrl = this;
    ctrl.savings = 0;

    ctrl.$onInit = function() {
        ctrl.calculateSavings();
    };

    ctrl.$onChanges = function(changes) {
        if ('promotion' in changes || 'item' in changes) {
            ctrl.calculateSavings();
        }
    };

    ctrl.calculateSavings = function() {
        if (ctrl.shouldShowBadge()) {
            var sellByQtyItem = ctrl.item.sellByQty && ctrl.item.unit === 'lb';
            var savings = 0;
            var quantity = ctrl.item.quantity;

            if (sellByQtyItem) {
                quantity = ctrl.item.packed ? ctrl.item.quantityWeight : quantity * ctrl.item.avgWeight;
            }
            var regularTotal = quantity * ctrl.item.price;

            if (Array.isArray(ctrl.item.priceBreakdown)) {
                var totalWithPromo = 0;

                for (var i = 0; i < ctrl.item.priceBreakdown.length; i++) {
                    var tier = ctrl.item.priceBreakdown[i];
                    var tierTotal = sellByQtyItem ? tier.weight * tier.price : tier.quantity * tier.price;
                    totalWithPromo += tierTotal;

                    if (tier.modifiersPrice) {
                        var modifiersTotal = tier.modifiersPrice * tier.quantity;
                        regularTotal += modifiersTotal;

                        if (tier.total > 0) {
                            totalWithPromo += modifiersTotal;
                        }
                    }
                }
                savings = regularTotal - totalWithPromo;
            } else {
                var promotionPrice = 0;

                if (ctrl.item.promotion && hsPromos.isValidPrice(ctrl.item.promotion.promotionPrice)) {
                    promotionPrice = ctrl.item.promotion.promotionPrice;
                }
                savings = regularTotal - quantity * promotionPrice;
            }

            if (savings && !isNaN(savings)) {
                ctrl.savings = savings;
                return;
            }
        }
        ctrl.savings = 0;
    };

    ctrl.shouldShowBadge = function() {
        if (!ctrl.item || !ctrl.promotion || ctrl.item.adminChangedPrice) return false;
        if (ctrl.promotion.type === hsPromos.types.FREE_ITEM) return true;
        if (!hsPromos.isValidPrice(ctrl.promotion.promotionPrice)) return false;
        if (ctrl.promotion.promotionPrice === ctrl.item.price) return false;

        return true;
    }

}

hsApp.component('promotion', {
    templateUrl: '/partials/components/promotions/promotion.html',
    bindings: {
        promotion: '<',
        isNewPromotion: '<',
        isPromotionDirty: '=',
        onPromotionCreate: '&',
        onPromotionUpdate: '&',
        onPromotionDelete: '&',
        onNewItemGroup: '&',
        onItemGroupSelect: '&',
    },
    controller: ['$rootScope', 'globalFunctions', '$location', '$scope', 'ENV', 'hsPromos', 'toastr', 'VALIDATORS', promotionController],
});

function promotionController($rootScope, globalFunctions, $location, $scope, ENV, hsPromos, toastr, VALIDATORS) {
    var ctrl = this;
    var logPrefix = '[promotion]: ';

    ctrl.$onInit = function() {
        ctrl.validationRules = hsPromos.validators.promotion;
        ctrl.isPromotionDirty = false;
        ctrl.error = '';

        ctrl.startDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()),
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.startDatePicker.opened = !ctrl.startDatePicker.opened;
            }
        };
        ctrl.endDatePicker = {
            format: 'MM-dd-yyyy',
            options: {
                showWeeks: false,
                minDate: new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()),
                startingDay: 1,
                showClear: false
            },
            opened: false,
            open: function () {
                ctrl.endDatePicker.opened = !ctrl.endDatePicker.opened;
            }
        };
        ctrl.setPromotionModel();

        ctrl.isLoading = false;
    };

    ctrl.setPromotionModel = function() {
        if (ctrl.isNewPromotion) {
            ctrl.model = {
                name: '',
                displayName: '',
                startDate: new Date(),
                endDate: new Date(),
                maxUses: 0,
                trackLocationsUsage: false,
                linkCode: '',
            };
            ctrl.model.endDate.setDate(ctrl.model.endDate.getDate() + 7);
        } else {
            ctrl.model = {
                name: ctrl.promotion.name,
                displayName: ctrl.promotion.displayName,
                startDate: new Date(ctrl.promotion.startDate.year, ctrl.promotion.startDate.month - 1, ctrl.promotion.startDate.date),
                endDate: new Date(ctrl.promotion.endDate.year, ctrl.promotion.endDate.month - 1, ctrl.promotion.endDate.date),
                maxUses: ctrl.promotion.maxUses || 0,
                trackLocationsUsage: typeof ctrl.promotion.trackLocationsUsage === 'boolean' ? ctrl.promotion.trackLocationsUsage : false,
                linkCode: ctrl.promotion.linkCode || '',
            };
        }
    };

    ctrl.getDate = function(dateObj) {
        var defaultValue = '--';

        if (!dateObj || typeof dateObj !== 'object' || !dateObj.year || !dateObj.month || !dateObj.date) {
            return defaultValue;
        }

        var date = new Date(dateObj.year, dateObj.month - 1, dateObj.date);
        if (isNaN(date.getTime())) return defaultValue;

        var day = date.getDate().toString().padStart(2, '0');
        var month = (date.getMonth() + 1).toString().padStart(2, '0');
        var year = date.getFullYear().toString().slice(2);

        return month + '/' + day + '/' + year;
    };

    ctrl.showItemGroupDetails = function(itemGroup) {
        ctrl.onItemGroupSelect({ itemGroup: itemGroup });
    };

    ctrl.getPromotionFromParams = function() {
        var params = {
            name: ctrl.model.name,
            displayName: ctrl.model.displayName,
            startDate: {
                year: ctrl.model.startDate.getFullYear(),
                month: ctrl.model.startDate.getMonth() + 1,
                date: ctrl.model.startDate.getDate(),
            },
            endDate: {
                year: ctrl.model.endDate.getFullYear(),
                month: ctrl.model.endDate.getMonth() + 1,
                date: ctrl.model.endDate.getDate(),
            },
            maxUses: ctrl.model.maxUses || 0,
        };
        if (ctrl.model.maxUses) {
            params.trackLocationsUsage = ctrl.model.trackLocationsUsage;

            if (ctrl.model.trackLocationsUsage) {
                params.linkCode = ctrl.model.linkCode;
            }
        }
        if (!ctrl.isNewPromotion) {
            params.id = ctrl.promotion.id;
        }

        return params;
    };

    ctrl.isValidTimePeriod = function() {
        if (!(ctrl.model.startDate instanceof Date) || !(ctrl.model.endDate instanceof Date)) return false;

        return ctrl.model.endDate >= ctrl.model.startDate;
    };

    ctrl.isValidPromotion = function() {
        ctrl.error = '';

        if (!ctrl.promoForm.validate()) return false;

        if (!ctrl.isValidTimePeriod()) {
            ctrl.error = 'Selected time period is invalid.';
            return false;
        }
        return true;
    };

    ctrl.changePromotionState = function(newState) {
        ctrl.error = '';
        var str;
        if (newState === true) {
            str = 'activat';
        } else {
            str = 'deactivat';
            newState = false;
        }
        if (ctrl.isPromotionDirty) {
            ctrl.error = 'You have unsaved changes. Please save before ' + str + 'ing.';
            return;
        }
        var promotion = {
            id: ctrl.promotion.id,
            isActive: newState,
        };
        hsPromos.updatePromotion(promotion)
            .then(function(promotion) {
                ctrl.onPromotionUpdate({ promotion: promotion });
            })
            .catch(function(err) {
                void 0;
                toastr.error('Failed to ' + str + 'e promotion.');
                ctrl.error = err.message;
            });
    };

    ctrl.activatePromotion = function() {
        ctrl.changePromotionState(true);
    };

    ctrl.deactivatePromotion = function() {
        ctrl.changePromotionState(false);
    };

    ctrl.reactivatePromotion = function() {
        ctrl.changePromotionState(true);
    };

    ctrl.createPromotion = function() {
        if (ctrl.isValidPromotion()) {
            var promotion = ctrl.getPromotionFromParams();

            hsPromos.createPromotion(promotion)
                .then(function(newPromotion) {
                    ctrl.onPromotionCreate({ newPromotion: newPromotion });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to create promotion.');
                    ctrl.error = err.message;
                });
        }
    };

    ctrl.updatePromotion = function() {
        if (ctrl.isValidPromotion()) {
            var promotion = ctrl.getPromotionFromParams();
            void 0;

            hsPromos.updatePromotion(promotion)
                .then(function(promotion) {
                    ctrl.onPromotionUpdate({ promotion: promotion });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to update promotion.');
                    ctrl.error = err.message;
                });
        }
    };

    ctrl.deletePromotion = function() {
        ctrl.error = '';

        hsPromos.deletePromotion(ctrl.promotion.id)
            .then(function() {
                ctrl.onPromotionDelete();
            })
            .catch(function(err) {
                void 0;
                toastr.error('Failed to delete promotion.');
                ctrl.error = err.message;
            });
    };

    ctrl.clonePromotion = function() {
        if (ctrl.isValidPromotion()) {
            var promotion = {
                id: ctrl.promotion.id,
                name: ctrl.model.name,
            };

            hsPromos.clonePromotion(promotion)
                .then(function(newPromotion) {
                    ctrl.onPromotionCreate({ newPromotion: newPromotion });
                })
                .catch(function(err) {
                    void 0;
                    toastr.error('Failed to clone promotion.');
                    ctrl.error = err.message;
                });
        }
    };

    ctrl.setDirty = function() {
        ctrl.isPromotionDirty = true;
    };

}

hsApp.component('promotions', {
    templateUrl: '/partials/components/promotions/promotions.html',
    controller: ['$rootScope', 'globalFunctions', 'localStorageService', '$route', '$location', '$scope', 'ENV', 'hsPromos', 'VALIDATORS', 'hsAdmin', 'toastr', '$filter', 'ngDialog', promotionsController],
});

function promotionsController($rootScope, globalFunctions, localStorageService, $route, $location, $scope, ENV, hsPromos, VALIDATORS, hsAdmin, toastr, $filter, ngDialog) {
    var ctrl = this;
    var logPrefix = '[promotions]: ';

    ctrl.$onInit = function() {
        ctrl.promotions = {
            All: [],
            Active: [],
            Inactive: [],
            'On-going': [],
            Ended: [],
        };
        ctrl.stateFilters = [
            {
                name: 'All',
                selected: true,
            },
            {
                name: 'Active',
                selected: false,
            },
            {
                name: 'Inactive',
                selected: false,
            },
            {
                name: 'On-going',
                selected: false,
            },
            {
                name: 'Ended',
                selected: false,
            },
        ];
        ctrl.isPromotionDetailView = false;
        ctrl.isNewPromotion = false;
        ctrl.selectedStateFilter = ctrl.stateFilters[0];
        ctrl.selectedItems = null;

        ctrl.getPromotions().finally(function() {
            ctrl.isLoading = false;
            ctrl.getProducts();
        });
    };

    ctrl.toggleFilter = function(filter) {
        angular.forEach(ctrl.stateFilters, function(filter) { filter.selected = false; });
        filter.selected = true;
        ctrl.selectedStateFilter = filter;
    };

    ctrl.getPromotions = function() {
        hsPromos.getUserGroups()
            .then(function (userGroups) {
                ctrl.userGroups = userGroups;
            })
            .catch(console.error);

        return hsPromos.getPromotions()
            .then(function(promotions) {
                ctrl.groupPromotions(promotions);
            })
            .catch(function(err) {
                void 0;
            });
    };

    ctrl.groupPromotions = function(promotions) {
        var grouped = {
            All: [],
            Active: [],
            Inactive: [],
            'On-going': [],
            Ended: [],
        };
        angular.forEach(promotions, function(promotion) {
            grouped.All.push(promotion);

            if (promotion.isEnded) {
                grouped.Ended.push(promotion);
            } else if (promotion.isActive) {
                grouped.Active.push(promotion);

                if (hsPromos.isPromotionOnGoing(promotion)) {
                    // this can be set in the backend
                    promotion.isOnGoing = true;
                    grouped['On-going'].push(promotion);
                }
            } else if (!promotion.isActive) {
                grouped.Inactive.push(promotion);
            }
        });
        ctrl.promotions = grouped;
    };

    ctrl.getStatus = function(promotion) {
        if (!promotion) return '';
        if (promotion.isEnded) return 'Ended';
        if (promotion.isOnGoing) return 'On-Going';
        if (promotion.isActive) return 'Active';
        return 'Inactive';
    };

    ctrl.getDate = function(dateObj) {
        var defaultValue = '--';

        if (!dateObj || typeof dateObj !== 'object' || !dateObj.year || !dateObj.month || !dateObj.date) {
            return defaultValue;
        }

        var date = new Date(dateObj.year, dateObj.month - 1, dateObj.date);
        if (isNaN(date.getTime())) return defaultValue;

        var day = date.getDate().toString().padStart(2, '0');
        var month = (date.getMonth() + 1).toString().padStart(2, '0');
        var year = date.getFullYear().toString().slice(2);

        return month + '/' + day + '/' + year;
    };

    ctrl.viewStatus = function() {
        if (ctrl.isPromotionDetailView) {
            if (ctrl.isNewPromotion) return 'newPromotion';
            if (ctrl.isItemGroupView) {
                if (ctrl.isAddItemsView) return 'addItems';
                if (ctrl.isNewItemGroup) return 'newItemGroup';
                return 'itemGroup';
            }
            return 'promotion';
        }
        return 'promotions';
    };

    ctrl.showPromotionDetails = function(promotion) {
        ctrl.selectedPromotion = promotion;
        ctrl.isPromotionDetailView = true;
    };

    ctrl.showNewItemGroup = function() {
        ctrl.isItemGroupView = true;
        ctrl.isNewItemGroup = true;
        ctrl.isItemGroupDirty = false;
    };

    ctrl.onItemGroupSelect = function(itemGroup) {
        void 0;
        ctrl.selectedItemGroup = JSON.parse(JSON.stringify(itemGroup));

        if (itemGroup.type === hsPromos.types.DEAL || itemGroup.type === hsPromos.types.DISCOUNT) {
            if (!ctrl.selectedItemGroup.eligibilityQuantity) {
                ctrl.selectedItemGroup.eligibilityQuantity = 0;
            }
            if (typeof ctrl.selectedItemGroup.applyInIncrementsOnly !== 'boolean') {
                ctrl.selectedItemGroup.applyInIncrementsOnly = false;
            }
        }

        ctrl.isItemGroupView = true;
        ctrl.isItemGroupDirty = false;
    };

    ctrl.getSelectedItemsCount = function() {
        try {
            return Object.keys(ctrl.selectedItems).length;
        }
        catch (err) {
            return 0;
        }
    };

    ctrl.onItemGroupCreate = function(itemGroup) {
        ctrl.selectedItemGroup = JSON.parse(JSON.stringify(itemGroup));
        ctrl.isNewItemGroup = false;
        ctrl.isItemGroupDirty = false;
    };

    ctrl.onItemGroupUpdate = function(itemGroup) {
        ctrl.selectedItemGroup = JSON.parse(JSON.stringify(itemGroup));
        ctrl.isNewItemGroup = false;
        ctrl.isItemGroupDirty = false;
    };

    ctrl.onItemGroupDelete = function() {
        ctrl.resetToPromotionView();
    };

    ctrl.showAddItems = function() {
        ctrl.isAddItemsView = true;
    };

    ctrl.selectAdminPricelist = function() {
        hsAdmin.selectAdminPricelist()
            .then(function(priceList) {
                ctrl.getPromotions();
                $route.reload();
            })
            .catch(function(err) {
                toastr.error(err);
            });
    };

    ctrl.getProducts = function() {
        return hsAdmin.getSelectedPriceList()
            .then(function(priceList) {
                var priceListUniqeName = null;
                if (priceList) {
                    priceListUniqeName = priceList.uniqueName;
                }
                return hsAdmin.getAllProducts(priceListUniqeName, true)
                    .then(function(res) {
                        if (res.status === 200) {
                            ctrl.processProducts(res.data.products);
                        } else {
                            void 0;
                            toastr.error('Error getting products.');
                        }
                    });
            })
            .catch(function(err) {
                void 0;
                toastr.error('Error getting products.');
            });
    };

    ctrl.processProducts = function(products) {
        var hashByName = {};

        for (let i = 0; i < products.length; i++) {
            var product = products[i];
            hashByName[product.name] = product;
        }
        ctrl.productsHash = hashByName;
    };

    ctrl.resetToPromotionsView = function() {
        if (ctrl.isPromotionDirty) {
            return ctrl.confirmUnsavedChanges()
                .then(function(val) {
                    if (val) {
                        reset();
                    }
                });
        }
        reset();

        function reset() {
            ctrl.selectedPromotion = null
            ctrl.isPromotionDetailView = false;
            ctrl.isNewPromotion = false;
            ctrl.isPromotionDirty = false;
            ctrl.resetToPromotionView();
        }
    };

    ctrl.resetToPromotionView = function() {
        if (ctrl.isItemGroupDirty) {
            return ctrl.confirmUnsavedChanges()
                .then(function(val) {
                    if (val) {
                        reset();
                    }
                });
        }
        reset();

        function reset() {
            ctrl.selectedItemGroup = null
            ctrl.isItemGroupView = false;
            ctrl.isNewItemGroup = false;
            ctrl.isItemGroupDirty = false;
            ctrl.resetToItemGroupView();
            ctrl.selectedItems = null;
        }
    };

    ctrl.resetToItemGroupView = function() {
        ctrl.isAddItemsView = false;
    };

    ctrl.confirmUnsavedChanges = function() {
        return ngDialog.openConfirm({
            data: {
                heading: 'Unsaved Changes',
                subHeading: 'You have unsaved changes which will be lost. Discard changes?',
                confirmBtnText: 'Yes',
                cancelBtnText: 'No'
            },
            template: 'partials/popup/confirm-popup.html'
        })
            .then(function(ok) { return ok; })
            .catch(function(cancel) { return cancel; });
    }

    ctrl.toggleNewPromotion = function() {
        ctrl.isPromotionDetailView = true;
        ctrl.isNewPromotion = true;
        ctrl.isPromotionDirty = false;
    };

    ctrl.onPromotionCreate = function(newPromotion) {
        ctrl.groupPromotions(hsPromos.promotions);
        ctrl.selectedPromotion = newPromotion;
        ctrl.isPromotionDetailView = true;
        ctrl.isNewPromotion = false;
        ctrl.isPromotionDirty = false;
    };

    ctrl.onPromotionUpdate = function(promotion) {
        ctrl.groupPromotions(hsPromos.promotions);
        ctrl.selectedPromotion = promotion;
        ctrl.isPromotionDetailView = true;
        ctrl.isNewPromotion = false;
        ctrl.isPromotionDirty = false;
    };

    ctrl.onPromotionDelete = function() {
        ctrl.groupPromotions(hsPromos.promotions);
        ctrl.resetToPromotionsView();
    };

    ctrl.onItemSelect = function(selectedItems) {
        ctrl.isItemGroupDirty = true;
    };

}

hsApp.component('orderReport', {
    templateUrl: '/partials/components/reports/order-report.html',
    bindings: {
        orderData: '<',
    },
    controller: ['hsCart', 'hsUtils', orderReportController],
});

function orderReportController(hsCart, hsUtils) {
    var ctrl = this;
    
    ctrl.getFormattedDate = function() {
        if (!hsUtils.isObject(ctrl.orderData) 
            || !hsUtils.isNonEmptyString(ctrl.orderData.deliveryDate)
            || !hsUtils.isNonEmptyString(ctrl.orderData.deliveryTime)
        ) {
            return '';
        }

        var deliveryDate = ctrl.orderData.deliveryDate;
        var deliveryTime = ctrl.orderData.deliveryTime;

        var deliveryDateArr = deliveryDate.split(' ');

        var day = deliveryDateArr[0];
        var month = deliveryDateArr[1];
        var year = deliveryDateArr[2];

        if (!hsUtils.isNonEmptyString(day)
            || !hsUtils.isNonEmptyString(month)
            || !hsUtils.isNonEmptyString(year)
        ) {
            return '';
        }

        return month + ' ' + day + ', ' + year + ' ' + deliveryTime;
    };

    ctrl.getProductDisplayName = function(item) {
        return hsCart.getProductDisplayName(item);
    };
}

hsApp.component('printArea', {
    transclude: true,
    templateUrl: '/partials/components/reports/print-area.html',
    bindings: {
        printAreaId: '@',
        printFrameId: '@',
        hide: '<',
    },
    controller: [printAreaController],
});

function printAreaController() {
    var ctrl = this;
}
hsApp.component('printItemsReport', {
    templateUrl: '/partials/components/reports/print-items-report.html',
    bindings: {
        orders: '<'
    },
    controller: ['hsUtils', printItemsReportController],
});

function printItemsReportController(hsUtils) {
    var ctrl = this;
    var logPrefix = '[print-items-report-controller]';

    ctrl.reportData = [];
    ctrl.fulfillmentDates = [];
    
    ctrl.$onInit = function() {
        void 0;
        ctrl.generateReport(angular.copy(ctrl.orders));
    };

    ctrl.$onChanges = function(changes) {
        if (changes) {
            ctrl.generateReport(angular.copy(ctrl.orders));
        }
    }

    ctrl.generateReport = function(orders) {
        var maxNumberOfDateColumns = 7;
        if (!hsUtils.isNonEmptyArray(orders)) {
            return;
        }
        var fulfillmentDates = new Set();
        var itemsCount = {};

        ctrl.sortOrdersByDeliveryDate(orders);

        for(var order of orders) {
            if (order.state === 'Cancelled') continue;
            if (fulfillmentDates.size >= maxNumberOfDateColumns) {
                break;
            }
            fulfillmentDates.add(order.deliveryDate);
            for(var item of order.items) {
                if (item.hasModifiers) {
                    ctrl.addItemsWithModifiersToReportData(order, item, itemsCount);
                } else {
                    ctrl.addItemsWithoutModifiersToReportData(order, item, itemsCount);
                }
            }
        }

        fulfillmentDates = Array.from(fulfillmentDates);

        var itemsCountArray = ctrl.groupAndSortItemsForDisplay(itemsCount);
        var reportRows = ctrl.buildReportRows(itemsCountArray);

        ctrl.reportData = reportRows;
        ctrl.fulfillmentDates = fulfillmentDates;
    };

    ctrl.sortOrdersByDeliveryDate = function(orders) {
        orders = orders.sort(function(a, b) {
            if (a.deliveryTimeMsec > b.deliveryTimeMsec) return 1;
            if (a.deliveryTimeMsec < b.deliveryTimeMsec) return -1;
            return 0;
        });
    }

    ctrl.addItemsWithoutModifiersToReportData = function(order, item, itemsCount) {
        var itemName = item.displayName;
        var instructions = item.instructions || '';
        var key = itemName + instructions;

        if (!itemsCount.hasOwnProperty(key)) {
            itemsCount[key] = {
                hasModifiers: false,
                type: hsUtils.getItemType(item),
                subType: hsUtils.getItemSubType(item),
                displayName: itemName,
                instructions: instructions,
                total: 0
            };
        }

        itemsCount[key].total += item.quantity;

        if (!itemsCount[key].hasOwnProperty(order.deliveryDate)) {
            itemsCount[key][order.deliveryDate] = 0;
        }
        itemsCount[key][order.deliveryDate] += item.quantity;
    }

    ctrl.addItemsWithModifiersToReportData = function(order, item, itemsCount) {
        var itemName = item.displayName;
        var instructions = item.instructions || '';
        var selectedModifiers = item.selectedModifiers.map(function(mod) {
            return mod.modifierDisplayName + mod.displayName;
        }).join("");
        var modifierSplitKey = itemName + instructions + selectedModifiers;
        
        if (!itemsCount.hasOwnProperty(itemName)) {
            itemsCount[itemName] = {
                displayName: itemName,
                hasModifiers: true,
                type: hsUtils.getItemType(item),
                subType: hsUtils.getItemSubType(item),
                modifierSplit: {},
                total: 0
            };
        }

        itemsCount[itemName].total += item.quantity;

        if (!itemsCount[itemName].hasOwnProperty(order.deliveryDate)) {
            itemsCount[itemName][order.deliveryDate] = 0;
        }
        itemsCount[itemName][order.deliveryDate] += item.quantity;

        if (!itemsCount[itemName].modifierSplit.hasOwnProperty(modifierSplitKey)) {
            itemsCount[itemName].modifierSplit[modifierSplitKey] = {
                displayName: itemName,
                selectedModifiers: item.selectedModifiers.map(function(mod) {
                    return mod.modifierDisplayName + ': ' + mod.displayName;
                }),
                instructions: instructions,
                total: 0
            };
        }

        itemsCount[itemName].modifierSplit[modifierSplitKey].total += item.quantity;

        if (!itemsCount[itemName].modifierSplit[modifierSplitKey].hasOwnProperty(order.deliveryDate)) {
            itemsCount[itemName].modifierSplit[modifierSplitKey][order.deliveryDate] = 0;
        }

        itemsCount[itemName].modifierSplit[modifierSplitKey][order.deliveryDate] += item.quantity;
    }

    ctrl.groupAndSortItemsForDisplay = function(itemsCount) {
        var itemsCountArray = Object.values(itemsCount).sort(function(a, b) {

            if (a.type > b.type) return 1;
            if (a.type < b.type) return -1;

            if (a.subType > b.subType) return 1;
            if (a.subType < b.subType) return -1;

            if (a.total > b.total) return -1;
            if (a.total < b.total) return 1;
            
            return 0;
        });

        return itemsCountArray;
    }

    ctrl.buildReportRows = function(itemsCountArray) {
        var reportRows = [];
        for (var itemData of itemsCountArray) {
            var modifierSplit = itemData.modifierSplit;
            delete itemData.modifierSplit;
            reportRows.push(itemData);
            if (itemData.hasModifiers) {
                var modifierSplitArray = Object.values(modifierSplit);
                for (var modifierData of modifierSplitArray) {
                    modifierData.modifierSplit = true;
                    reportRows.push(modifierData);
                }
            }
        }
        return reportRows;
    }
}
hsApp.component('reportDashboard', {
    templateUrl: '/partials/admin/reports/report-dashboard.html',
    controller: [ '$location', 'hsUtils', 'hsAdmin', 'hsApi', 'globalFunctions', '$sce', reportDashboardController ],
});

function reportDashboardController($location, hsUtils, hsAdmin, hsApi, globalFunctions, $sce) {
    var ctrl = this;
    var logPrefix = '[reportDashboardController]';

    ctrl.REPORT_TYPES = {
        BUSINESS_PERFORMANCE: 'businessPerformance',
        TRENDS_AND_OPERATIONS: 'trendsAndOperations',
    };

    ctrl.TITLE = {
        'businessPerformance': 'Business Performance',
        'trendsAndOperations': 'Trends & Operations'
    }

    ctrl.$onInit = function () {

        ctrl.isLoading = true;
        ctrl.reportType = ctrl.getReportType();
        ctrl.error = null;
        ctrl.source = null;

        if (!ctrl.reportType) {
            ctrl.goBack();
        }

        hsApi.getLocations(true)
            .then(function(res) {
                var locations = res.data;

                // any location will work since config is the same at every location
                var location = locations[0];

                if (!hsUtils.isObject(location)) {
                    throw 'Failed to load locations';
                }

                ctrl.validateConfig(location.ordersDashboardConfig);

                ctrl.source = ctrl.getSource(location.ordersDashboardConfig);
            })
            .catch(function(err) {
                void 0;
                ctrl.error = 'Failed to load page. Please try again or contact support';
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    };

    ctrl.getReportType = function() {
        var queryParams = $location.search();
        if (Object.values(ctrl.REPORT_TYPES).includes(queryParams.report)) {
            return queryParams.report;
        }

        return null;
    };

    ctrl.validateConfig = function(config) {
        if (!hsUtils.isNonEmptyObject(config)) {
            throw 'Invalid config: expected object';
        }
        if (config.enabled !== true) {
            throw 'Orders dashboard is disabled';
        }
        if (!hsUtils.isNonEmptyString(config.domain)) {
            throw 'Invalid config: missing or invalid domain';
        }
        if (!hsUtils.isNonEmptyObject(config.dashboardIds) || !hsUtils.isNonEmptyString(config.dashboardIds[ctrl.reportType])) {
            throw 'Invalid config: missing or invalid dashboard id';
        }
    };

    ctrl.getSource = function(config) {
        var url = 'https://' + config.domain + '/app/dashboards?auth_provider_hint=anonymous1#/view/'
            + config.dashboardIds[ctrl.reportType] + '?embed=true&_g=()&show-time-filter=true&hide-filter-bar=true&_a=(filters:!())';
        return $sce.trustAsResourceUrl(url);
    };

    ctrl.goBack = function() {
        $location.url('/admin/view-dashboards');
    }

    ctrl.getReportTitle = function() {
        return ctrl.TITLE[ctrl.reportType];
    }

    ctrl.getPageWrapperStyles = function() {
        return 'full-width';
    }

}
hsApp.component('searchBar', {
    templateUrl: '/partials/components/search/search-bar.html',
    bindings: {
        onSelect: '&',
        onChange: '&',
        searchQuery: '<',
        disableAutoFill: '<'
    },
    controller: [ 'hsSearch', 'hsUtils', '$timeout', '$rootScope', 'globalFunctions', '$location', searchBarController ],
});

function searchBarController(hsSearch, hsUtils, $timeout, $rootScope, globalFunctions, $location) {
    var ctrl = this;

    ctrl.$onInit = function () {
        void 0;
        var searchTerm;
        if (hsUtils.isNonEmptyString(ctrl.searchQuery)) {
            searchTerm = ctrl.searchQuery;
        } else {
            searchTerm = '';
        }

        ctrl.searchTerm = searchTerm;
        ctrl.searchOptions = [];
        ctrl.getAutofillOptions(true);
        ctrl.hideOptions = true;
        ctrl.MAX_OPTIONS = 10;
        ctrl.searching = false;

        $rootScope.$on( "$routeChangeStart", function(event, next, current) {
            if($location.path().indexOf('/search') === -1) {
                ctrl.clearSearchTermAndOptions();
            }
        });
    };

    ctrl.getAutofillOptions = function(hideOptions) {
        ctrl.searching = false;

        if (!hsUtils.isNonEmptyString(ctrl.searchTerm) || ctrl.searchTerm.length < 3) {
            ctrl.searchOptions = [];
            ctrl.onChange({ value: '' });
            return;
        }
        ctrl.onChange({ value: ctrl.searchTerm });

        if(ctrl.disableAutoFill) {
            return;
        }

        return hsSearch.autoCompleteQuery(ctrl.searchTerm)
            .then(function(res){
                if (ctrl.searchTerm.length && res !== 'ABORTED_REQUEST') {
                    ctrl.hideOptions = hideOptions || false;
                    ctrl.searchOptions = res.slice(0, ctrl.MAX_OPTIONS);
                }
            })
            .catch(function(err) {
                // nothing to be done here.
                // Silently ignoring error will result in no search options dropdown
                void 0;
                ctrl.searchOptions = [];
            });
    };

    ctrl.showClearInputButton = function() {
        return ctrl.searchTerm.length;
    };

    ctrl.clearSearchTermAndOptions = function() {
        ctrl.searchTerm = '';
        ctrl.searchOptions = [];
        ctrl.onChange({ value: '' });
    };

    ctrl.clearInput = function() {
        ctrl.clearSearchTermAndOptions();
        document.getElementsByName('searchBar')[0].focus();
    };

    ctrl.processMouseClickEvent = function (selectedOption, event) {
        if (hsUtils.isObject(event) && event.button === 0) {
            ctrl.selectOption(selectedOption);
        }   
    }

    ctrl.selectOption = function(selectedOption) {
        if (hsUtils.isObject(selectedOption) && hsUtils.isNonEmptyString(selectedOption.displayName)) {
            ctrl.hideOptions = true;
            document.getElementsByName('searchBar')[0].blur();
            ctrl.searchTerm = selectedOption.displayName;
            ctrl.onSelect({ value: selectedOption.displayName });
            ctrl.getAutofillOptions(true);
            ctrl.searching = true;
        } 
    };

    ctrl.setHideOptions = function(value) {
        if ($rootScope.screenWidth.xs && !ctrl.hideOptions) return;
        ctrl.hideOptions = value || false;
    };

    ctrl.processKeyPressEvent = function(event) {
        if (hsUtils.isObject(event) && event.key === 'Enter') {
            ctrl.selectOption({
                displayName: ctrl.searchTerm,
            });
        }
    };

    ctrl.setSearching = function(value) {
        ctrl.searching = value;
    }

    ctrl.isProduct = function(option) {
        return option.resultType === hsSearch.autofillOptionTypes.PRODUCT;
    };

    ctrl.getPlaceholder = function() {
        var retVal = "Search";
        var pricelist = globalFunctions.getSelectedPriceListFromStorage();
        if (hsUtils.isObject(pricelist) && hsUtils.isNonEmptyString(pricelist.title)) {
            retVal += ' ' + pricelist.title;
        }
        return retVal + '...';
    };

    ctrl.isSearchV2Enabled = function() {
        return hsSearch.isSearchV2Enabled();
    };
}
hsApp.component('stripePayments', {
    templateUrl: '/partials/components/stripe-embedded/stripe-payments.html',
    controller: [ '$location', '$rootScope', 'ENV', 'hsAdmin', 'hsStripe', stripePaymentsController ],
});

function stripePaymentsController($location, $rootScope, ENV, hsAdmin, hsStripe) {
    var ctrl = this;
    var logPrefix = '[stripePaymentsController]';

    ctrl.$onInit = function () {
        ctrl.isLoading = true;
        ctrl.banner = {
            type: 'warning',
            message: "Avoid capturing, canceling, or refunding payments directly through the Stripe interface, as it can lead to irreparable disruptions in Homesome's order management workflows. Proceeding against this advice limits or nullifies our capacity to assist in any resulting issues.",
            isPersistent: true,
        };
    };

    ctrl.$postLink = function() {
        hsAdmin.initAdminPage('stripePayments', false)
            .then(function() {
                if (!$rootScope.currentUser.hasBankAccountAccess) {
                    $location.url('/admin/reports');
                }
                var stripeConnectInstance = window.StripeConnect.init({
                    publishableKey: ENV.stripePublishableKey,
                    fetchClientSecret: ctrl.fetchClientSecret
                });
                var paymentComponent = stripeConnectInstance.create("payments");
                var container = document.getElementById("payments-container");
                container.appendChild(paymentComponent);
                ctrl.isLoading = false;
            })
            .catch(function(err) {
                void 0;
                ctrl.isLoading = false;
            });

    };

    ctrl.shouldShowLoader = function() {
        return ctrl.isLoading === true;
    };

    ctrl.fetchClientSecret = function() {
        return hsStripe.fetchStripeAccountSessionSecret()
            .then(function(res) {
                var clientSecret = res.data.clientSecret;
                return clientSecret;
            })
            .catch(function(err) {
                void 0;
                // returning undefined displays stripe-generated error message
                return undefined;
            });
    };
}
hsApp.component('hsTag', {
    bindings: {
        displayText: '@',
        containerStyles: '@',
    },
    templateUrl: '/partials/components/tags/hs-tag.html',
    controller: [ 'hsUtils', hsTagController ],
});

function hsTagController(hsUtils) {
    var ctrl = this;
    var logPrefix = '[hsTag]: ';

    ctrl.$onInit = function () {
        void 0;
        if(!hsUtils.isNonEmptyString(ctrl.displayText)) {
            ctrl.displayText = '';
        }

        if(!hsUtils.isNonEmptyString(ctrl.containerStyles)) {
            ctrl.containerStyles = 'hs-tag-default';
        }
    };
}

hsApp.component('accountSettingsV2', {
    templateUrl: '/partials/components/user/account-settings-v2.html',
    bindings: {
    },
    controller: [ 
        'hsAccountSettings', 
        'hsAuth', 
        'hsUtils', 
        'hsCart', 
        'hsApi', 
        'hsUserPayments', 
        'ngDialog', 
        'globalFunctions', 
        '$route', 
        'toastr', 
        '$scope', 
        'ebtService', 
        '$rootScope',
        'scrollToElement',
        '$timeout',
        '$location',
        accountSettingsController 
    ],
});

function accountSettingsController(
    hsAccountSettings, 
    hsAuth, 
    hsUtils, 
    hsCart, 
    hsApi, 
    hsUserPayments, 
    ngDialog, 
    globalFunctions, 
    $route, 
    toastr, 
    $scope, 
    ebtService,
    $rootScope,
    scrollToElement,
    $timeout,
    $location
) {
    var ctrl = this;

    ctrl.validationRules = {
        name: {
            rules: {
                firstName: {
                    required: true
                },
                lastName: {
                    required: true
                }
            },
            messages: {
                firstName: {
                    required: 'Please enter first name'
                },
                lastName: {
                    required: 'Please enter last name'
                }
            }
        },
        email: {
            rules: {
                email: {
                    required: true
                },
            },
            messages: {
                email: {
                    required: 'Please enter an email ID'
                },
            }
        },
        phoneNumber: {
            rules: {
                phoneNumber: {
                    required: true,
                    phoneUS: true
                },
            },
            messages: {
                phoneNumber: {
                    required: 'Please enter a phone number',
                    phoneUS: 'Please enter a valid phone number'
                },
            }
        },
        deliveryAddress: {
            rules: {},
            messages: {},
        },
        verifyPhoneNumber: {
            rules: {
                verificationCode: {
                    required: true,
                }
            },
            messages: {
                verificationCode: {
                    required: 'Please enter a verification code',
                }
            },
        },
        employeeID: {
            rules: {},
            messages: {}
        }
    };

    ctrl.$onInit = function() {
        ctrl.user = null;
        ctrl.updateParams = {};
        ctrl.verificationCode = null;
        ctrl.initError = null;
        ctrl.SECTIONS = hsAccountSettings.SECTIONS;
        ctrl.PURPOSE = hsAccountSettings.PURPOSE;
        var location = globalFunctions.getSelectedLocationFromStorage();
        if (!hsUtils.isObject(location)) {
            $location.url('/products');
            return;
        }
        if(ctrl.isEbtEnabled()) {
            ebtService.getClient()
                .then(function(forage) {
                    void 0;
                })
                .catch(function(err) {
                    void 0;
                });
        }
        ctrl.initUser();
    }

    ctrl.getScreenWidthContainer = function () {
        if ($rootScope.screenWidth.xs) {
            return 'full-width';
        } else if ($rootScope.screenWidth.sm || $rootScope.screenWidth.md) {
            return 'width-680-px';
        } else {
            return 'width-736-px';
        }
    }

    ctrl.getScreenWidthContent = function () {
        if ($rootScope.screenWidth.xs) {
            return 'full-width';
        } else if ($rootScope.screenWidth.sm || $rootScope.screenWidth.md) {
            return 'width-504-px';
        } else {
            return 'width-558-px';
        }
    }

    ctrl.initUser = function() {
        ctrl.isLoading = true;
        hsAuth.getUpdatedUser()
            .then(function(response) {
                if (response.status !== 200) {
                    throw new Error(response);
                }
                if (hsUtils.isObject(response) && hsUtils.isObject(response.data)) {
                    ctrl.user = response.data;
                    ctrl.initError = null;
                } else {
                    throw new Error("Failed to load account details.");
                }
            })
            .catch(function(err) {
                void 0
                ctrl.initError = 'Failed to load account details. Please refresh this page.';
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    }

    ctrl.isEbtEnabled = function() {
        return ebtService.isEbtEnabled();
    }
    
    ctrl.cancel = function() {
        ctrl.editing = null;
        ctrl.updateParams = {};
        ctrl.verificationCode = null;
    }

    ctrl.getDeliveryAddressDisplayStringLine1 = function() {
        if (!hsUtils.isObject(ctrl.user) || !hsUtils.isObject(ctrl.user.address)) {
            return '';
        }

        var address = ctrl.user.address;
        return address.street + (address.aptUnit ? ' ' + address.aptUnit : '');
    }

    ctrl.getDeliveryAddressDisplayStringLine2 = function() {
        if (!hsUtils.isObject(ctrl.user) || !hsUtils.isObject(ctrl.user.address)) {
            return '';
        }

        var address = ctrl.user.address;
        return address.city + ' ' + address.state + ' ' + address.zip;
    }

    ctrl.setNameSectionParams = function() {
        ctrl.updateParams.firstName = ctrl.user.firstName || '';
        ctrl.updateParams.lastName = ctrl.user.lastName || '';
    }

    ctrl.setPhoneNumberSectionParams = function() {
        ctrl.updateParams.phoneNumber = ctrl.user.phoneNumber || '';
    }

    ctrl.setDeliveryAddressSectionParams = function() {
        ctrl.updateParams.address = ctrl.user.address || {};
    }

    ctrl.setEmployeeIDSectionParams = function() {
        ctrl.updateParams.customUserData = {
            employeeID: ctrl.getEmployeeID()
        };
    }

    ctrl.getEmployeeID = function() {
        var employeeID = '';
        if (ctrl.user && ctrl.user.customUserData) {
            employeeID = ctrl.user.customUserData.employeeID || employeeID;
            
        }
        return employeeID;
    }

    ctrl.canHaveEmployeeID = function() {
        var location = globalFunctions.getSelectedLocationFromStorage();
        return (
            location
            && hsUtils.isObject(location.customUserDataSettings)
            && hsUtils.isObject(location.customUserDataSettings.employeeID)
        );
    }

    ctrl.editSection = function(section) {
        ctrl.disableFields = true;
        if (section === ctrl.SECTIONS.name) {
            ctrl.editing = section;
            ctrl.setNameSectionParams();
        } else if (section === ctrl.SECTIONS.phoneNumber) {
            ctrl.editing = section;
            ctrl.setPhoneNumberSectionParams();
        } else if (section === ctrl.SECTIONS.deliveryAddress) {
            ctrl.editing = section;
            ctrl.setDeliveryAddressSectionParams();
        } else if (section === ctrl.SECTIONS.addPaymentMethod) {
            ctrl.editing = section;
        } else if (section === ctrl.SECTIONS.employeeID) {
            ctrl.editing = section;
            ctrl.setEmployeeIDSectionParams();
        }
    }

    ctrl.updatePhoneNumber = function(form) {
        if (form.validate()) {
            ctrl.isLoading = true;
            ctrl.errorMessage = '';
            globalFunctions.getSelectedLocation()
                .then(function (location) {
                    if (location.requiresPhoneNumberVerification) {
                        ctrl.sendUserVerificationCode(false);
                    } else {
                        ctrl.updateUser(null, true)
                            .finally(function() {
                                ctrl.isLoading = false;
                            });
                    }
                })
                .catch(function(err) {
                    ctrl.errorMessage = 'Something went wrong. Please try again.';
                    ctrl.isLoading = false;
                })
                .finally(function() {
                    if (hsUtils.isNonEmptyString(ctrl.errorMessage)) {
                        toastr.error(ctrl.errorMessage);
                        ctrl.errorMessage = '';
                    }
                });
            }
    }

    ctrl.sendUserVerificationCode = function(shouldCall) {
        return hsAuth.sendUserVerificationCode(ctrl.updateParams.phoneNumber, shouldCall)
            .then(function() {
                ctrl.editing = ctrl.SECTIONS.verifyPhoneNumber;        
            })
            .catch(function(err) {
                ctrl.errorMessage = err.message;
            })
            .finally(function() {
                ctrl.isLoading = false;
            });
    }

    ctrl.updateUserDetails = function(newUser) {
        if (hsUtils.isObject(newUser)) {
            hsAuth.saveUserLocal(newUser);
            ctrl.user = newUser;
            ctrl.editing = null;
        }

    }

    ctrl.verifyPhoneNumber = function(form) {
        if (form.validate()) {
            ctrl.isLoading = true;
            hsAuth.verifyUserVerificationCode(ctrl.updateParams.phoneNumber, ctrl.verificationCode, ctrl.PURPOSE.updatePhoneNumber)
                .then(function(response) {
                    ctrl.updateUserDetails(response.data.user);
                    toastr.success('Account Updated Successfully');
                })
                .catch(function(err) {
                    toastr.error(err.message);
                })
                .finally(function() {
                    ctrl.isLoading = false;
                })
        }
    }

    ctrl.updateAddress = function() {
        $scope.$broadcast('validateAddress-my-account-delivery', function(isValid) {
            if (!isValid) return;
            ctrl.updateUser(null, true);
        });
    }
    
    ctrl.deletePaymentMethod = function(value) {
        ngDialog.openConfirm({
            data: {
                heading: 'Are You Sure?',
                subHeading: 'Please confirm that you want to delete payment method.',
                confirmBtnText: 'Confirm',
                cancelBtnText: 'Cancel'
            },
            template: 'partials/popup/confirm-popup.html',
        }).then(function (confirm) {
            ctrl.isLoading = true;
            $timeout(function(){
                scrollToElement('#hs-loader');
            }, 0);
            hsUserPayments.deletePaymentMethod(value.pmid)
                .then(function(resp) {
                    ctrl.updateUserDetails(resp);
                    toastr.success('Account Updated Successfully');
                })
                .catch(function(err) {
                    toastr.error(err);
                })
                .finally(function() {
                    ctrl.isLoading = false;
                    $timeout(function(){
                        scrollToElement('#payments-section');
                    }, 0);
                })
        }, function (reject) {
            void 0;
            return;
        });
    }

    ctrl.addingNewPaymentMethod = function(value) {
        ctrl.editing = value;
    }

    ctrl.clearEditing = function() {
        ctrl.editing = null;
    }

    ctrl.addPaymentMethod = function(value) {
        ctrl.updateUserDetails(value);
        $timeout(function(){
            scrollToElement('#payments-section');
        }, 0);
    }

    ctrl.setDefaultPaymentMethod = function(value) {
        ctrl.isLoading = true;
        $timeout(function(){
            scrollToElement('#hs-loader');
        }, 0);
        hsUserPayments.setDefaultPaymentMethod(value.pmid)
            .then(function(resp) {
                ctrl.updateUserDetails(resp);
                toastr.success('Account Updated Successfully');
            })
            .catch(function(err) {
                toastr.error(err);
            })
            .finally(function() {
                ctrl.isLoading = false;
                $timeout(function(){
                    scrollToElement('#payments-section');
                }, 0);
            })
    }

    ctrl.updateUser = function(form, skipValidation) {
        // skipValidation is used for components with their own internal validation (e.g. address-form)
        if (skipValidation || form.validate()) {
            var updateParams = {
                user: ctrl.updateParams,
            }
            ctrl.isLoading = true;
            $timeout(function(){
                scrollToElement('#hs-loader');
            }, 0);
            
            return hsCart.updateUser(updateParams)
                .then(function(response) {
                    if(response.status === 200){
                        ctrl.updateUserDetails(response.data);
                        toastr.success('Account Updated Successfully');
				    }else{
						toastr.error('Error Updating Account');
				    }

                    if(response.status === 403) {
                        $route.reload();
                    }
				    ctrl.isLoading = false;
                });
            
        }
    }

    ctrl.deleteAccount = function() {
        ngDialog.openConfirm({
            data: {
                heading: 'Are You Sure?',
                subHeading: 'Please confirm that you want to delete your account permanently. This action cannot be undone.',
                confirmBtnText: 'Confirm',
                cancelBtnText: 'Cancel'
            },
            template: 'partials/popup/confirm-popup.html',
        }).then(function (confirm) {
            hsApi.deleteUser()
                .then(function(res) {
                    if (res.status === 200) {
                        ngDialog.openConfirm({
                            data: {
                                heading: 'Success!',
                                subHeading: 'Success, please allow up to 24 hours for all your data to be deleted from our systems.',
                                confirmBtnText: 'Okay'
                            },
                            template: 'partials/popup/confirm-popup.html',
                            showClose: false,
                            closeByDocument: false,
                            closeByEscape: false
                        }).then(function (confirm) {
                            hsAuth.logoutUser();
                            ngDialog.close();
                        }, function (reject) {
                            void 0;
                            return;
                        });
                    } else if (res.status === 409) {
                        toastr.error('Cannot delete account at this time. You have one or more outstanding order. Try again once the order is completed or cancelled.');
                    } else {
                        toastr.error('Something went wrong. Please try again later.')
                    }
                });

            ngDialog.close();
        }, function (reject) {
            void 0;
            return;
        });
    }

    ctrl.hasChanged = function() {
        var updateParams = Object.assign({}, ctrl.updateParams);
        var existingParams = {};

        for (var param in updateParams) {
            existingParams[param] = ctrl.user[param];
        }

        return !_.isEqual(updateParams, existingParams);
    }

    ctrl.canUpdatePhoneNumber = function() {
        var location = globalFunctions.getSelectedLocationFromStorage();
        return hsUtils.isObject(location) && location.allowPhoneNumberUpdates;
    }

    ctrl.refreshPage = function() {
        $route.reload();
    }
}

hsApp.component('paymentMethodsMultiple', {
    templateUrl: '/partials/components/user/payment-methods-multiple.html',
    bindings: {
        paymentMethods: '<',
        onDelete: '&',
        onSelectCard: '&',
        selectedCard: '<',
        hideSelectCardTextCc: '<',
        hideSelectCardCc: '<',
        hideSelectCardTextEbt: '<',
        hideSelectCardEbt: '<',
        titleTextCss: '<',
        hideCreditCardImage: '<',
        hideEbt: '<'
    },
    controller: [ 'hsUtils', 'hsUserPayments', paymentMethodsMultipleController ],
});

function paymentMethodsMultipleController(hsUtils, hsUserPayments) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.paymentMethods = hsUserPayments.sortPaymentMethods(ctrl.paymentMethods);
        ctrl.initPaymentMethodsMultiple();
        if (!hsUtils.isObject(ctrl.selectedCard)) {
            ctrl.selectedCard = ctrl.creditCardPaymentMethods.find(function(paymentMethod) {
                return paymentMethod.default;
            });
        }
        if (!ctrl.titleTextCss) {
            ctrl.titleTextCss = 'option-titles mbot25';
        }
        
    }

    ctrl.initPaymentMethodsMultiple = function() {
        if(!hsUtils.isNonEmptyArray(ctrl.paymentMethods)) {
            ctrl.paymentMethods = null;
        }
        if (!hsUtils.isObject(ctrl.deliveryAddress)) {
            ctrl.deliveryAddress = {};
        }
        ctrl.creditCardPaymentMethods = [];
        ctrl.ebtPaymentMethods = [];
        ctrl.splitPaymentMethods();
    }

    ctrl.isLastPaymentMethod = function(index, paymentMethods) {
        return index === paymentMethods.length - 1;
    }

    ctrl.splitPaymentMethods = function() {
        if (!ctrl.paymentMethods) {
            return;
        }

        for(var paymentMethod of ctrl.paymentMethods) {
            if (paymentMethod.paymentProcessor === hsUserPayments.PAYMENT_PROCESSORS.forage) {
                ctrl.ebtPaymentMethods.push(paymentMethod);
            } else {
                ctrl.creditCardPaymentMethods.push(paymentMethod);
            }
        }
    }

    ctrl.deletePaymentMethod = function(value) {
        return ctrl.onDelete({
            value: value
        });
    }

    ctrl.selectCard = function(value) {
        ctrl.onSelectCard({
            value: value
        });
    }
}
hsApp.component('signUpForm', {
    templateUrl: '/partials/components/user/sign-up-form.html',
    bindings: {
        onAddUser: '&'
    },
    controller: [ 'VALIDATORS', signupV2Controller ],
});

function signupV2Controller(VALIDATORS) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.newUser = {};
        ctrl.addUserValidator = VALIDATORS.SIGN_UP_ADMIN;
    }

    ctrl.addUser = function(form) {
        if(form.validate()) {
            ctrl.onAddUser({ value: ctrl.newUser });
        }
    }
}

hsApp.component('lsEbtSettings', {
    templateUrl: '/partials/components/location-settings-v2/components/ebt-settings.html',
    bindings: {
        ebtConfig: '<',
        onChange: '&',
    },
    controller: [ 'hsLocationSettings', 'hsUtils', locationSettingsEbtSettingsController ],
});

function locationSettingsEbtSettingsController(hsLocationSettings, hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.form = null;
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.$onChanges = function(changes) {
        if (changes && changes.ebtConfig) {
            ctrl.models = ctrl.getModelObject();
        }
    };

    ctrl.getModelObject = function() {
        return JSON.parse(JSON.stringify(ctrl.ebtConfig));
    };

    ctrl.setChanged = function() {
        ctrl.onChange({ value: ctrl.models });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.checkFnsNumber = function() {
        if (!hsUtils.isNonEmptyString(ctrl.models.fnsNumber)) {
            ctrl.models.snapEnabled = false;
        }
        ctrl.setChanged();
    };
}
hsApp.component('lsOperatingHours', {
    templateUrl: '/partials/components/location-settings-v2/components/operating-hours.html',
    bindings: {
        operatingHours: '<',
        onChange: '&',
    },
    controller: [ '$scope', 'hsLocationSettings', locationSettingsOperatingHoursController ],
});

function locationSettingsOperatingHoursController($scope, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[locationSettings]: ';
    var CLOSED = 'Closed';
    var MIDNIGHT = 'Midnight';
    var ALL_DAY = '24 Hours';


    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.dayOptions = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
        ctrl.timeOptions = [MIDNIGHT,'1AM','2AM','3AM','4AM','5AM','6AM','7AM','8AM','9AM','10AM','11AM','Noon','1PM','2PM','3PM','4PM','5PM','6PM','7PM','8PM','9PM','10PM','11PM',MIDNIGHT];
        ctrl.selectedWeekday = null;
        ctrl.selectedOpenHour = null;
        ctrl.selectedOpenHourIndex = 0;
        ctrl.selectedClosingHour = null;
        ctrl.model = ctrl.operatingHours.slice();
        ctrl.model = JSON.parse(JSON.stringify(ctrl.operatingHours));
    };

    ctrl.$onChanges = function(changes) {
        if (changes && changes.operatingHours) {
            ctrl.model = JSON.parse(JSON.stringify(ctrl.operatingHours));
        }
    };

    ctrl.getOpenHourOptions = function() {
        return [ CLOSED ].concat(ctrl.timeOptions).slice(0, ctrl.timeOptions.length - 1);
    };

    ctrl.getClosingHourOptions = function() {
        return ctrl.timeOptions.slice(ctrl.selectedOpenHourIndex + 1)
    };

    ctrl.shouldDisableClosingHour = function() {
        return [ CLOSED ].includes(ctrl.selectedOpenHour);
    };

    ctrl.canAddHours = function() {
        return ctrl.selectedWeekday && ctrl.selectedOpenHour;
    };

    ctrl.getHoursString = function() {
        if (ctrl.selectedOpenHour === CLOSED) return CLOSED;
        if (ctrl.selectedOpenHour === MIDNIGHT &&  ctrl.selectedClosingHour === MIDNIGHT) return ALL_DAY;

        return ctrl.selectedOpenHour + ' - ' + ctrl.selectedClosingHour;
    };

    ctrl.addHours = function() {
        if (!ctrl.selectedWeekday || !ctrl.selectedOpenHour || !ctrl.selectedClosingHour && ctrl.selectedOpenHour !== CLOSED) {
            return;
        }
        var hours = {
            day: ctrl.selectedWeekday,
            hours: ctrl.getHoursString(),
        };


        var foundIndex = ctrl.model.findIndex(function(elem) {
            if (hours.day === elem.day) return true;
        });
        if (foundIndex === -1) {
            ctrl.model.push(hours);
        } else {
            var replaceExisting = [ CLOSED, ALL_DAY ].includes(hours.hours) || [ CLOSED, ALL_DAY ].includes(ctrl.model[foundIndex].hours);

            if (replaceExisting) {
                ctrl.model[foundIndex] = hours;
            } else {
                ctrl.model[foundIndex].hours += ', ' + hours.hours;
            }
        }

        ctrl.model.sort(function(a, b) {
            var aIndex = ctrl.dayOptions.indexOf(a.day);
            var bIndex = ctrl.dayOptions.indexOf(b.day);
            if (aIndex > bIndex) return 1;
            if (aIndex < bIndex) return -1;
            return 0;
        });
        ctrl.selectedWeekday = null;
        ctrl.selectedOpenHour = null;
        ctrl.selectedOpenHourIndex = 0;
        ctrl.selectedClosingHour = null;

        ctrl.onChange({ value: ctrl.model });
    };

    ctrl.selectOpenHour = function() {
        if (ctrl.selectedOpenHour === CLOSED) {
            ctrl.selectedClosingHour = '';
            return;
        }
        ctrl.selectedOpenHourIndex = ctrl.timeOptions.indexOf(ctrl.selectedOpenHour);
        var selectedClosingHourIndex = ctrl.timeOptions.lastIndexOf(ctrl.selectedClosingHour);

        if (!ctrl.selectedClosingHour || selectedClosingHourIndex <= ctrl.selectedOpenHourIndex) {
            ctrl.selectedClosingHour = ctrl.timeOptions[ctrl.selectedOpenHourIndex + 1];
        }
    };

    ctrl.removeHours = function(index) {
        ctrl.model.splice(index, 1);
        ctrl.onChange({ value: ctrl.model });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('lsRadiusConfig', {
    templateUrl: '/partials/components/location-settings-v2/components/radius-config.html',
    bindings: {
        deliveryProviderConfigs: '<',
        exceptionCities: '<',
        exceptionZipcodes: '<',
        country: '<',
        onChange: '&',
        registerValidator: '&',
    },
    controller: [ '$scope', 'hsLocationSettings', 'hsUtils', 'toastr', locationSettingsRadiusConfigController ],
});

function locationSettingsRadiusConfigController($scope, hsLocationSettings, hsUtils, toastr) {
    var ctrl = this;
    var logPrefix = '[radiusConfig]: ';

    ctrl.validation = {
        rules: {
            minimumOrder: {
                required: true,
                number: true,
                min: 0,
            },
            fee: {
                required: true,
                number: true,
                min: 0,
            },
            serviceFeeRate: {
                required: true,
                number: true,
                min: 0,
                max: 100,
            },
            minOrderWithNoFee: {
                required: true,
                number: true,
                min: 0,
            },
        },
        messages: {
            minimumOrder: {
                required: "Please enter minimum order value",
                number: "Please enter valid minimum order value",
                min: "Please enter minimum order value greater than 0",
            },
            fee: {
                required: "Please enter delivery fee value",
                number: "Please enter valid delivery fee value",
                min: "Please enter delivery fee value greater than 0",
            },
            serviceFeeRate: {
                required: "Please enter service fee rate",
                number: "Please enter valid service fee rate",
                min: "Please enter service fee rate between 0-100",
                max: "Please enter service fee rate between 0-100",
            },
            minOrderWithNoFee: {
                required: "Please enter min order for free delivery",
                number: "Please enter valid min order for free delivery",
                min: "Please enter value greater than 0",
            },

        },
    };

    ctrl.$onInit = function () {
        void 0;

        ctrl.error = null;
        ctrl.changed = false;
        ctrl.forms = {};
        ctrl.configDisplayNames = {
            threeMiles: '3 Miles',
            fiveMiles: '5 Miles',
            eightMiles: '8 Miles',
            tenMiles: '10 Miles',
            fifteenMiles: '15 Miles',

            fiveKilometers: '5 Km',
            eightKilometers: '8 Km',
            tenKilometers: '10 Km',
            fifteenKilometers: '15 Km',

            default: 'Default',
        };
        ctrl.DEFAULT_RADIUS = 'default';
        ctrl.autocompleteOptions = {
            componentRestrictions: { country: ctrl.country || 'US' },
            types: ['(cities)'],
        };
        ctrl.allowedCitiesInputField = '';
        ctrl.allowedZipcodesInputField = '';

        ctrl.initModels();
        ctrl.deregisterValidator = ctrl.registerValidator({f: ctrl.isValid});
    };

    ctrl.$onDestroy = function() {
        ctrl.deregisterValidator();
    }

    ctrl.isValid = function() {
        var forms = Object.values(ctrl.forms);
        return forms.every(function(form) { return form.validate(); });
    };

    ctrl.initModels = function() {
        if (
            !hsUtils.isObject(ctrl.deliveryProviderConfigs) 
            || !hsUtils.isArray(ctrl.exceptionCities) 
            || !hsUtils.isArray(ctrl.exceptionZipcodes)
            || !hsUtils.isNonEmptyString(ctrl.country)
        ) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
        ctrl.displayFields = {
            deliveryProviderConfigs: {},
        };

        for (var config of Object.keys(ctrl.models.deliveryProviderConfigs)) {
            var configSettings = ctrl.models.deliveryProviderConfigs[config];
            var serviceFeeRate = configSettings.serviceFeeRate || 0;
            ctrl.displayFields.deliveryProviderConfigs[config] = {
                serviceFeeRate: parseFloat((serviceFeeRate * 100).toFixed(2)),
            };
        }
    };

    ctrl.getModelObject = function() {
        return {
            deliveryProviderConfigs: ctrl.deliveryProviderConfigs,
            allowedCities: ctrl.exceptionCities,
            allowedZipcodes: ctrl.exceptionZipcodes,
        };
    };

    ctrl.$onChanges = function (changes) {
        if (changes && (changes.deliveryProviderConfigs || changes.allowedCities || changes.allowedZipcodes)) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.setChanged = function() {
        ctrl.onChange({ value: ctrl.models });
    };

    ctrl.setMinimumOrder = function(config) {
        var value = ctrl.models.deliveryProviderConfigs[config].minOrder;
        if (isNaN(value) || value === '') {
            ctrl.models.deliveryProviderConfigs[config].minOrder = 0;
        }
        
        ctrl.setChanged();
    }

    ctrl.setServiceFeeRate = function(config) {
        var value = ctrl.displayFields.deliveryProviderConfigs[config].serviceFeeRate;
        if (isNaN(value) || value === '') {
            ctrl.displayFields.deliveryProviderConfigs[config].serviceFeeRate = 0;
        }

        ctrl.models.deliveryProviderConfigs[config].serviceFeeRate = parseFloat((ctrl.displayFields.deliveryProviderConfigs[config].serviceFeeRate / 100).toFixed(5));
        ctrl.setChanged();
    }

    ctrl.setDeliveryFee = function(config) {
        var value = ctrl.models.deliveryProviderConfigs[config].minOrder;
        if (isNaN(value) || value === '') {
            ctrl.models.deliveryProviderConfigs[config].fee = 0;
        }
        
        ctrl.setChanged();
    }

    ctrl.setMinOrderWithNoFee = function(config) {
        var value = ctrl.models.deliveryProviderConfigs[config].minOrderWithNoFee;
        if (isNaN(value) || value === '') {
            ctrl.models.deliveryProviderConfigs[config].minOrderWithNoFee = 0;
        }
        
        ctrl.setChanged();
    }

    ctrl.isDefaultRadius = function(config) {
        return config === ctrl.DEFAULT_RADIUS;
    }

    ctrl.formatCity = function(city) {
        var cityArray = city.split(',');
        var index = cityArray[1].search(/[A-Z]{2}/);
        var state = '';
        if (index) {
            state = ', ' + cityArray[1].slice(index, index + 2);
        }
        return cityArray[0] + state;
    }

    ctrl.normalizeCity = function(city) {
        return city.split(',')[0].replace(/\s/g, '').toLowerCase();
    },

    ctrl.setHasExceptionCitiesOrZips = function() {
        var hasCities = settings.allowedCities.length > 0;
        var hasZips = settings.allowedZipcodes.length > 0;
        ctrl.models.hasExceptionCitiesOrZips = hasCities || hasZips;
    
    }

    ctrl.addCity = function() {
        if (!ctrl.allowedCitiesInputField || !ctrl.allowedCitiesInputField.formatted_address) {
            return;
        }
        var city = ctrl.formatCity(ctrl.allowedCitiesInputField.formatted_address);
        var normalized = ctrl.normalizeCity(city);

        // update displayName of city if it already exists
        for (var existingCity of ctrl.models.allowedCities) {
            if (existingCity.city === normalized) {
                existingCity.displayName = city;
                ctrl.allowedCitiesInputField = '';
                ctrl.setChanged();
                return;
            }
        }
        
        ctrl.models.allowedCities.push(
            {
                city: normalized, 
                displayName: city
            }
        );

        ctrl.models.allowedCities.sort(function(a, b){
            if (a.city < b.city) return -1;
            if (a.city > b.city) return 1;
            return 0
        });
        ctrl.allowedCitiesInputField = '';
        ctrl.setChanged();
    }

    ctrl.removeCity = function(index) {
        ctrl.models.allowedCities.splice(index, 1);
        ctrl.setChanged();
    }

    ctrl.getZipcodeLabel = function() {
        var country = ctrl.country;
        var zipcodeLabel;

        switch(country) {
            case 'CA':
                zipcodeLabel = 'Allowed Postal Codes';
                break;
            default:
                zipcodeLabel = 'Allowed Zipcodes';
                break;
         }
        return zipcodeLabel;
    }

    ctrl.getZipcodeMinLength = function() {
        var country = ctrl.country;
        var minLength;

        switch(country) {
            case 'CA':
                minLength = 7;
                break;
            default:
                minLength = 5;
                break;
        }
        return minLength;
    },

    ctrl.validateZipcode = function(zipcode) {	
        var country = ctrl.country;
        var isValid;

        switch(country) {
            case 'CA':
                var exp = new RegExp('^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$');
                var evalExp = exp.test(zipcode);
                isValid = {
                    value: evalExp, 
                    errorMsg: !evalExp ? 'Please enter a valid Canadian postal code': '',
                };
                break;
            default:
                isValid = { 
                    value: true, 
                    errorMsg: '', 
                };
                break;
        }
        return isValid;
    }

    ctrl.addZipcode = function() {
        if (!ctrl.allowedZipcodesInputField
            || ctrl.allowedZipcodesInputField.length !== ctrl.getZipcodeMinLength()
        ) {
            return;
        }

        var zipcode = ctrl.allowedZipcodesInputField;
        var isValid = ctrl.validateZipcode(zipcode);

        if (!isValid.value) {
            toastr.error(isValid.errorMsg);
            return;
        }

        if (ctrl.models.allowedZipcodes.includes(zipcode)) {
            ctrl.allowedZipcodesInputField = '';
            return;
        }
        ctrl.models.allowedZipcodes.push(zipcode);
        ctrl.models.allowedZipcodes.sort();
        ctrl.allowedZipcodesInputField = '';
        ctrl.setChanged();
    }

    ctrl.removeZipcode = function(index) {
        ctrl.models.allowedZipcodes.splice(index, 1);
        ctrl.setChanged();
    }

    ctrl.showDeliveryFee = function(deliveryFee) {
        return !hsUtils.isArray(deliveryFee);
    }

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('lsSlotsComponent', {
    templateUrl: '/partials/components/location-settings-v2/components/slots-component.html',
    bindings: {
        pickup: '<',
        delivery: '<',
        onChange: '&',
    },
    controller: [ '$scope', 'hsLocationSettings', 'hsUtils', locationSettingsSlotsComponentController ],
});

function locationSettingsSlotsComponentController($scope, hsLocationSettings, hsUtils) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.pickupType = null;
        ctrl.deliveryType = null;
        ctrl.combinedSlots = false;

        ctrl.initModels();
    };

    ctrl.$onChanges = function(changes) {
        // Don't trigger setChanged() on initialization.
        // Otherwise, SAVE button will show immediately if the existing volume limits
        // don't match to the newly calculated values.
        var notifyOnChange = false;

        if (changes && (changes.pickup || changes.delivery)) {
            if (hsUtils.isObject(ctrl.models)) {
                if (changes.pickup && hsUtils.isObject(ctrl.models.pickup) || changes.delivery && hsUtils.isObject(ctrl.models.delivery)) {
                    notifyOnChange = true;
                }
            }
            ctrl.initModels();
        }
        if (ctrl.notifyOnChange) {
            ctrl.setChanged();
        }
    };

    ctrl.setTypes = function() {
        if (ctrl.pickup) {
            ctrl.pickupType = ctrl.getType(ctrl.pickup);
        }
        if (ctrl.delivery) {
            ctrl.deliveryType = ctrl.getType(ctrl.delivery);
        }
    };

    ctrl.getType = function(fulfillment) {
        return fulfillment.dailySlots || fulfillment.dailySlotsOverrides
            ? 'dailySlots'
            : fulfillment.slots || fulfillment.slotsOverrides ? 'slots' : null;
    };

    ctrl.initModels = function() {
        ctrl.setTypes();
        ctrl.models = ctrl.getModelObject();
        ctrl.combinedSlots = false;

        if (ctrl.canSlotsBeCombined()) {
            ctrl.combinedSlots = ctrl.areSlotsTheSame();
        }
    };

    ctrl.getModelObject = function() {
        var models = {};

        if (ctrl.pickupType) {
            models.pickup = {};

            models.pickup[ctrl.pickupType] = JSON.parse(JSON.stringify(ctrl.pickup[ctrl.pickupType] || []));
            models.pickup[ctrl.pickupType + 'Overrides'] = JSON.parse(JSON.stringify(ctrl.pickup[ctrl.pickupType + 'Overrides'] || {}));
            models.pickup.closedWeekdays = Array.isArray(ctrl.pickup.closedWeekdays)
                ? JSON.parse(JSON.stringify(ctrl.pickup.closedWeekdays)) : [];
        }
        if (ctrl.deliveryType) {
            models.delivery = {};

            models.delivery[ctrl.deliveryType] = JSON.parse(JSON.stringify(ctrl.delivery[ctrl.deliveryType] || []));
            models.delivery[ctrl.deliveryType + 'Overrides'] = JSON.parse(JSON.stringify(ctrl.delivery[ctrl.deliveryType + 'Overrides'] || {}));
            models.delivery.closedWeekdays = Array.isArray(ctrl.delivery.closedWeekdays)
                ? JSON.parse(JSON.stringify(ctrl.delivery.closedWeekdays)) : [];
        }
        return models;
    };

    ctrl.setChanged = function() {
        var models = JSON.parse(JSON.stringify(ctrl.models));

        if (ctrl.combinedSlots) {
            ctrl.copyFulfillment('pickup', 'delivery', models);
        }
        ctrl.onChange({ value: models });
    };

    ctrl.copyFulfillment = function(source, target, models) {
        models[target][ctrl[source + 'Type']] = JSON.parse(JSON.stringify(models[source][ctrl[source + 'Type']]));
        models[target][ctrl[source + 'Type'] + 'Overrides'] = JSON.parse(JSON.stringify(models[source][ctrl[source + 'Type'] + 'Overrides']));
        models[target].closedWeekdays = JSON.parse(JSON.stringify(models[source].closedWeekdays));
    };

    ctrl.canSlotsBeCombined = function() {
        return ctrl.pickupType === ctrl.deliveryType && ctrl.pickupType !== null;
    };

    ctrl.areSlotsTheSame = function() {
        if (!ctrl.isSameSlots(ctrl.models.pickup[ctrl.pickupType], ctrl.models.delivery[ctrl.deliveryType])) return false;
        if (!ctrl.isSameSlots(ctrl.models.pickup[ctrl.pickupType + 'Overrides'], ctrl.models.delivery[ctrl.deliveryType + 'Overrides'])) return false;
        if (!ctrl.isSameClosedWeekdays(ctrl.models.pickup.closedWeekdays, ctrl.models.delivery.closedWeekdays)) return false;

        return true;
    };

    ctrl.isSameSlots = function(a, b) {
        return ctrl.getSlotsKey(a) === ctrl.getSlotsKey(b);
    };

    ctrl.getSlotsKey = function(slots) {
        return JSON.stringify(ctrl.getSortedObject(slots));
    };

    ctrl.getSortedObject = function(obj) {
        if (Array.isArray(obj)) return ctrl.sortObjectsInArray(obj);
        if (!hsUtils.isObject(obj)) return obj;

        var keys = Object.keys(obj).sort();
        var sorted = {};

        for (var key of keys) {
            sorted[key] = ctrl.getSortedObject(obj[key]);
        }
        return sorted;
    };

    ctrl.sortObjectsInArray = function(arr) {
        var sorted = [];

        for (var i = 0; i < arr.length; i++) {
            sorted[i] = ctrl.getSortedObject(arr[i]);
        }
        if (ctrl.pickupType === 'slots') {
            hsLocationSettings.sortSlots(sorted);
        } else if (ctrl.pickupType === 'dailySlots') {
            hsLocationSettings.sortDailySlots(sorted);
        }
        return sorted;
    };

    ctrl.isSameClosedWeekdays = function(a, b) {
        var aIsArray = Array.isArray(a);
        var bIsArray = Array.isArray(b);

        if (aIsArray !== bIsArray) return false;
        if (!aIsArray) return true;
        if (a.length !== b.length) return false;

        var aDays = new Set(a);
        var bDays = new Set(b);

        if (a.size !== b.size) return false;

        for (var day of bDays) {
            aDays.add(day);
        }
        return aDays.size === bDays.size;
    };

    ctrl.separateSlots = function() {
        ctrl.combinedSlots = false;
    };

    ctrl.combineSlots = function(source, target) {
        ctrl.copyFulfillment(source, target, ctrl.models);
        ctrl.combinedSlots = true;
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

}

hsApp.component('lsSlotsOverrides', {
    templateUrl: '/partials/components/location-settings-v2/components/slots-overrides.html',
    bindings: {
        slotsType: '<',
        slots: '<',
        overrides: '<',
        closedWeekdays: '<',
        onChange: '&',
    },
    controller: [ '$scope', 'hsLocationSettings', 'hsUtils', locationSettingsSlotsOverridesController ],
});

function locationSettingsSlotsOverridesController($scope, hsLocationSettings, hsUtils) {
    var ctrl = this;
    ctrl.dayOptions = [ 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday' ];

    ctrl.$onInit = function () {
        ctrl.selectedWeekday = null;

        ctrl.initClosedWeekdays();
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.closedWeekdays) {
            ctrl.initClosedWeekdays();
        }
    };

    ctrl.initClosedWeekdays = function () {
        var closedWeekdays = Array.isArray(ctrl.closedWeekdays) ? ctrl.closedWeekdays  : [];
        ctrl.open = {};

        for (var weekday of ctrl.dayOptions) {
            ctrl.open[weekday] = !closedWeekdays.includes(weekday);
        }
    };

    ctrl.toggleWeekdayEdit = function (weekday) {
        ctrl.selectedWeekday = ctrl.selectedWeekday === weekday ? null : weekday;
    };

    ctrl.isCustomSlots = function(weekday) {
        return weekday in ctrl.overrides && ctrl.overrides[weekday].slots;
    };

    ctrl.initCustomSlots = function(weekday) {
        if (!ctrl.overrides[weekday]) {
            ctrl.overrides[weekday] = {};
        }
        if (!ctrl.overrides[weekday].slots) {
            ctrl.overrides[weekday].slots = angular.copy(ctrl.slots);
        } else {
            delete ctrl.overrides[weekday];
        }
        ctrl.setChanged();
    };

    ctrl.getDailyVolumeFromSlots = function(slots) {
        if (!hsUtils.isNonEmptyArray(slots)) return 0;

        return slots.reduce(function(sum, slot) {
            return sum + (hsUtils.isPositiveInteger(slot.maxOrdersPerSlot) ? slot.maxOrdersPerSlot : 0);
        }, 0);
    };

    ctrl.getMaxOrdersFromSlots = function(slots) {
        if (!hsUtils.isNonEmptyArray(slots)) return 0;

        return slots.reduce(function(max, slot) {
            return Math.max(max, hsUtils.isPositiveInteger(slot.maxOrdersPerSlot) ? slot.maxOrdersPerSlot : 0);
        }, 0);
    };

    ctrl.getVolumeLimits = function(slots) {
        return {
            maxOrdersPerSlot: ctrl.getMaxOrdersFromSlots(slots),
            maxOrdersPerDay: ctrl.getDailyVolumeFromSlots(slots),
        };
    };

    ctrl.setVolumeLimits = function() {
        for (var weekday of ctrl.dayOptions) {
            if (weekday in ctrl.overrides) {
                ctrl.overrides[weekday].volumeLimits = ctrl.getVolumeLimits(ctrl.overrides[weekday].slots);
            }
        }
    };

    ctrl.setClosedWeekdays = function() {
        if (!Array.isArray(ctrl.closedWeekdays)) return;

        for (var weekday of ctrl.dayOptions) {
            var index = ctrl.closedWeekdays.indexOf(weekday);
            var open = ctrl.open[weekday];

            if (index === -1) {
                if (open) continue;

                ctrl.closedWeekdays.push(weekday);
            } else {
                if (!open) continue;

                ctrl.closedWeekdays.splice(index, 1);
            }
        }
        ctrl.onChange();
    };

    ctrl.setChanged = function() {
        if (ctrl.slotsType === 'slots') {
            ctrl.setVolumeLimits();
        }
        ctrl.onChange();
    };
}

hsApp.component('lsSlots', {
    templateUrl: '/partials/components/location-settings-v2/components/slots.html',
    bindings: {
        slotsType: '<',
        slots: '<',
        onChange: '&',
    },
    controller: [ '$scope', 'hsLocationSettings', '$timeout', 'hsUtils', locationSettingsSlotsController ],
});

function locationSettingsSlotsController($scope, hsLocationSettings, $timeout, hsUtils) {
    var ctrl = this;
    var AM = 0;
    var PM = 12;

    ctrl.validation = {
        rules: {
            maxOrdersPerSlot: {
                required: true,
                gt: 0,
            },
            delay: {
                required: true,
                min: 0,
            },
            slotDuration: {
                required: true,
                min: 1,
            },
        },
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        
        ctrl.HOURS = [ 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
        ctrl.DISPLAY_HOURS = ctrl.HOURS.slice(1);
        ctrl.MINUTES = ctrl.generateDisplayMinutes(5);
        ctrl.PERIODS = [ AM, PM ];

        ctrl.resetSlotInput();
    };

    ctrl.$onChanges = function(changes) {
        ctrl.resetSlotInput();
    };

    ctrl.generateDisplayMinutes = function(increment) {
        var minutes = [];

        for (var i = 0; i < 60; i += increment) {
            minutes.push(i);
        }
        return minutes;
    };

    ctrl.resetSlotInput = function() {
        // Start - End time input
        ctrl.startHour = null;
        ctrl.startMin = null;
        ctrl.startPeriod = null;
        ctrl.endHour = null;
        ctrl.endMin = null;
        ctrl.endPeriod = null;
        ctrl.endHours = null;
        ctrl.endMinutes = null;
        ctrl.endPeriods = null;

        // slots
        ctrl.cutoffHour = 0;
        ctrl.cutoffMin = 0;
        ctrl.cutoffMinutesDisplay = 0;
        ctrl.maxOrdersPerSlot = 10;

        // dailySlots
        ctrl.slotDuration = 30;
        ctrl.delay = 0;

        ctrl.error = null;
        ctrl.overlapIndex = null;
        ctrl.editingIndex = null;
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

///////////////////////////////////////////////////////  Time input  ///////////////////////////////////////////////////////

    ctrl.isStartTimeSelected = function() {
        return ctrl.startHour !== null && ctrl.startMin !== null && ctrl.startPeriod !== null;
    };

    ctrl.isEndTimeSelected = function() {
        return ctrl.endHour !== null && ctrl.endMin !== null && ctrl.endPeriod !== null;
    };

    ctrl.onStartHourChange = function() {
        if (!hsUtils.isInteger(ctrl.startMin)) {
            ctrl.startMin = 0;
        }
        if (!ctrl.startPeriod) {
            ctrl.startPeriod = AM;
        }
        if (!ctrl.endHour) {
            if (ctrl.startHour === 12) {
                ctrl.endHour = 1;
            } else {
                ctrl.endHour = ctrl.startHour + 1;
            }
            ctrl.endMin = 0;
            ctrl.endPeriod = ctrl.endHour === 12 ? PM : ctrl.startPeriod;
        }
        ctrl.setEndTime();
    };

    ctrl.onEndHourChange = function() {
        var startHour = ctrl.getStartHour();
        var endHour = ctrl.getEndHour();
        var startMin = ctrl.startMin;
        var endMin = ctrl.endMin;
        var startMinIndex = ctrl.MINUTES.indexOf(startMin);
        var hasAvailableMinutes = startMinIndex < ctrl.MINUTES.length - 1;

        // Not converting end time to 24 hours as it will add another special case

        if (startHour === 0 && endHour === 0 && endMin === 0 && hasAvailableMinutes) {
            ctrl.endMin = ctrl.MINUTES[startMinIndex + 1];
        }
        // if it can be set to 12:xxPM - set it
        if (startHour < 12 && endHour === 12) {
            ctrl.endPeriod = PM;
        }
        // If start time in AM and no minutes left to select, and end time transitions to the same hour
        // then endtime should be set to PM without incrementing the end hour since user wishes it to be this hour.
        if (startHour < 12 && startHour === endHour && !hasAvailableMinutes) {
            ctrl.endPeriod = PM;
        }
        // Force end hour to stay at 12 even if it can't making it 24:00
        if (startHour === 12 && startHour === endHour && !hasAvailableMinutes) {
            ctrl.endPeriod = AM;
            ctrl.endMin = 0;
        }
        // If end hour was changed to be below start hour, switch to PM
        if (startHour > endHour) {
            // If the end hour was changed to 12, force it to be 24:00
            if (endHour === 12) {
                ctrl.endPeriod = AM;
                ctrl.endMin = 0;
            } else {
                ctrl.endPeriod = PM;
            }
        }
        ctrl.setEndTime();
    };

    ctrl.onEndPeriodChange = function() {
        var startHour = ctrl.getStartHour();
        var endHour = ctrl.getEndHour();
        var startMin = ctrl.startMin;
        var endMin = ctrl.endMin;
        var startMinIndex = ctrl.MINUTES.indexOf(startMin);
        var hasAvailableMinutes = startMinIndex < ctrl.MINUTES.length - 1;

        // If end hour was 12 and we change end period to AM,
        // keep end hour as 0:xx if possible, else convert end hour to 24:00
        if (endHour === 0) {
            if (startHour === 0 && startMin >= endMin) {
                if (hasAvailableMinutes) {
                    ctrl.endMin = ctrl.MINUTES[startMinIndex + 1];
                } else {
                    ctrl.endMin = 0;
                }
            } else {
                ctrl.endMin = 0;
            }
        }
        ctrl.setEndTime();
    };

    ctrl.getStartHour = function() {
        return ctrl.HOURS.indexOf(ctrl.startHour) + ctrl.startPeriod;
    };

    ctrl.getEndHour = function() {
        return ctrl.HOURS.indexOf(ctrl.endHour) + ctrl.endPeriod;
    };

    ctrl.setEndTime = function() {
        var startHour = ctrl.getStartHour();
        var endHour = ctrl.getEndHour();
        var startMin = ctrl.startMin;
        var endMin = ctrl.endMin;
        var startMinIndex = ctrl.MINUTES.indexOf(startMin);
        var hasAvailableMinutes = startMinIndex < ctrl.MINUTES.length - 1;

        // The only allowed interpretation of 12:00 AM for end time is 24:00
        if (endHour === 0 && endMin === 0) {
            endHour = 24;
        }
        // If hours are in conflict, keep hours the same if possible,
        // otherwise, increment end hour to be ahead of start hour.
        if (startHour > endHour) {
            if (startMin < endMin) {
                endHour = startHour;
            } else {
                endHour = startHour + 1;
            }
        }
        // If only minutes are in conflict, increment minutes if possible, otherwise, increment end hour
        if (startHour === endHour && startMin >= endMin) {
            // check if minutes can be incremented
            if (hasAvailableMinutes) {
                endMin = ctrl.MINUTES[startMinIndex + 1];
            } else {
                endHour = startHour + 1;
            }
        }
        ctrl.setEndTimeValues(endHour, endMin);
        ctrl.endHours = ctrl.getEndHours(startHour, hasAvailableMinutes);
        ctrl.endMinutes = ctrl.getEndMinutes(startHour, startMin, endHour, hasAvailableMinutes);
        ctrl.endPeriods = ctrl.getEndPeriods(startHour, endHour, hasAvailableMinutes);
    };

    ctrl.setEndTimeValues = function(endHour, endMin) {
        ctrl.endMin = endMin;

        if (endHour === 0 || endHour === 24) {
            ctrl.endHour = 12;
            ctrl.endPeriod = AM;
        } else if (endHour === 12) {
            ctrl.endHour = 12;
            ctrl.endPeriod = PM;
        } else if (endHour > 12) {
            ctrl.endHour = endHour - 12;
            ctrl.endPeriod = PM;
        } else {
            ctrl.endHour = endHour;
            ctrl.endPeriod = AM;
        }
    };

    ctrl.getEndMinutes = function(startHour, startMin, endHour, hasAvailableMinutes) {
        var startMinIndex = ctrl.MINUTES.indexOf(startMin);

        if (endHour === 24 || endHour === 0) {
            // check if any minutes are left to use if start hour is 12:xx AM
            if (startHour === 0 && hasAvailableMinutes) {
                return [0].concat(ctrl.MINUTES.slice(startMinIndex + 1));
            }
            return [0];
        } else if (startHour == endHour) {
            return ctrl.MINUTES.slice(startMinIndex + 1);
        }
        return ctrl.MINUTES;
    };

    ctrl.getEndHours = function(startHour, hasAvailableMinutes) {
        var endHoursStartIndex = startHour;

        if (!hasAvailableMinutes) {
            endHoursStartIndex += 1;
        }
        if (endHoursStartIndex <= 12) {
            endHoursStartIndex = 1;
        } else {
            endHoursStartIndex -= 12;
        }
        return ctrl.HOURS.slice(endHoursStartIndex);
    };

    ctrl.getEndPeriods = function(startHour, endHour, hasAvailableMinutes) {
        if (endHour === 24) {
            if (startHour > 12) return [ AM ];
            if (startHour < 12 || hasAvailableMinutes) return [ AM, PM ];
            return [ AM ];
        }
        if (startHour > 12 || startHour === 12 && !hasAvailableMinutes) {
            return [ PM ];
        }
        if (startHour === 12) {
            return endHour === 12 ? [ AM, PM ] : [ PM ];
        }
        if (endHour < 12 && endHour >= startHour || endHour >= 12 && (endHour - 12) >= startHour) {
            if (startHour === endHour - 12 && !hasAvailableMinutes && endHour !== 12) {
                return [ PM ];
            } else {
                return [ AM, PM ];
            }
        }
        return endHour === 12 ? [ AM, PM ] : [ PM ];
    };

    ctrl.setTimeInputs = function(startHour, startMin, endHour, endMin) {
        ctrl.startHour = (startHour < 12 ? startHour : startHour - 12) || 12;
        ctrl.startMin = startMin;
        ctrl.startPeriod = startHour < 12 ? AM : PM;

        ctrl.endHour = (endHour < 12 ? endHour : endHour - 12) || 12;
        ctrl.endMin = endMin;
        ctrl.endPeriod = endHour < 12 || endHour === 24 ? AM : PM;
    };

//////////////////////////////////////////////////////////  Slots  //////////////////////////////////////////////////////////

    ctrl.getDisplayString = function(slot) {
        return ctrl.isRegularSlots() ? ctrl.getSlotString(slot) : ctrl.getDailySlotString(slot);
    };

    ctrl.getSlotString = function(slot) {
        return slot.displayName + ', Cutoff - ' + ctrl.getCutoffMinutesFromSlot(slot)
            + (slot.maxOrdersPerSlot ? ', Max - ' + slot.maxOrdersPerSlot : '');
    };

    ctrl.getSlotDisplayName = function() {
        return ctrl.getSlotDisplayNameComponent(ctrl.startHour, ctrl.startMin, ctrl.startPeriod)
            + ' - ' + ctrl.getSlotDisplayNameComponent(ctrl.endHour, ctrl.endMin, ctrl.endPeriod);
    };

    ctrl.getSlotDisplayNameComponent = function(hour, min, period) {
        if (hour === 12 && min === 0 && period === AM) {
            return 'Midnight';
        }
        if (hour === 12 && min === 0 && period === PM) {
            return 'Noon';
        }
        var str = hour.toString();

        if (min) {
            str += ':' + min.toString().padStart(2, '0');
        }
        str += period === AM ? 'AM' : 'PM';

        return str;
    };

    ctrl.setCutoff = function() {
        if (!ctrl.cutoffMinutesDisplay) {
            ctrl.cutoffMinutesDisplay = 0;
        }
        ctrl.cutoffHour = Math.floor(ctrl.cutoffMinutesDisplay / 60);
        ctrl.cutoffMin = ctrl.cutoffMinutesDisplay % 60;
    };

    ctrl.setMaxOrdersPerSlot = function() {
        if (!ctrl.maxOrdersPerSlot) {
            ctrl.maxOrdersPerSlot = 0;
        }
    };

    ctrl.canAddSlot = function() {
        return ctrl.isStartTimeSelected() && ctrl.isEndTimeSelected();
    };

    ctrl.addSlot = function() {
        if (!ctrl.canAddSlot() || !ctrl.form.validate()) return;

        ctrl.error = null;
        ctrl.overlapIndex = null;
        var newSlot = ctrl.isRegularSlots() ? ctrl.generateSlot() : ctrl.generateDailySlot();
        var error = ctrl.isRegularSlots() ? null : ctrl.validateDailySlot(newSlot);

        if (error) {
            ctrl.error = error;
            return;
        }
        var foundIndex = ctrl.isRegularSlots() ? ctrl.findSlot(newSlot) : ctrl.findDailySlot(newSlot);

        if (foundIndex !== -1) {
            ctrl.slots[foundIndex] = newSlot;
        } else {
            var index = ctrl.isRegularSlots() ? ctrl.findSlotOverlapIndex(newSlot) : ctrl.findDailySlotOverlapIndex(newSlot);

            if (index !== -1) {
                ctrl.overlapIndex = index;
                ctrl.error = hsLocationSettings.errorMessages.OVERLAPPING_SLOTS;
                return;
            }
            if (ctrl.editingIndex !== null) {
                ctrl.slots[ctrl.editingIndex] = newSlot;
            } else {
                ctrl.slots.push(newSlot);
            }
        }
        ctrl.isRegularSlots() ? hsLocationSettings.sortSlots(ctrl.slots) : hsLocationSettings.sortDailySlots(ctrl.slots);
        ctrl.resetSlotInput();
        ctrl.onChange();
    };

    ctrl.findSlot = function(slot) {
        return ctrl.slots.findIndex(function(existing) {
            if (slot.displayName === existing.displayName) return true;
        });
    };

    ctrl.removeSlot = function(index) {
        ctrl.error = null;
        ctrl.overlapIndex = null;

        if (ctrl.editingIndex !== null) {
            if (index === ctrl.editingIndex) {
                ctrl.editingIndex = null;
            } else if (index < ctrl.editingIndex) {
                ctrl.editingIndex--;
            }
        }
        ctrl.slots.splice(index, 1);
        ctrl.onChange();
    };

    ctrl.findSlotOverlapIndex = function(newSlot) {
        for (var i = 0; i < ctrl.slots.length; i++) {
            if (ctrl.editingIndex === i) continue;

            var slot = ctrl.slots[i];

            var slotTime = hsLocationSettings.parseSlotString(slot.displayName);
            var newSlotTime = hsLocationSettings.parseSlotString(newSlot.displayName);

            var newEndBeforeStart = slotTime.startHour > newSlotTime.endHour
                || slotTime.startHour === newSlotTime.endHour && slotTime.startMin >= newSlotTime.endMin;

            if (newEndBeforeStart) continue;

            var newStartAfterEnd = slotTime.endHour < newSlotTime.startHour
                || slotTime.endHour === newSlotTime.startHour && slotTime.endMin <= newSlotTime.startMin;

            if (newStartAfterEnd) continue;

            return i;
        }
        return -1;
    };

    ctrl.generateSlot = function() {
        var cutoff = ctrl.getSlotCutoff();
        var slot = {
            displayName: ctrl.getSlotDisplayName(),
            cutoffHour: cutoff.hour,
            maxOrdersPerSlot: ctrl.maxOrdersPerSlot,
        };
        if (cutoff.min) {
            slot.cutoffMin = cutoff.min;
        }
        return slot;
    };

    ctrl.getSlotCutoff = function() {
        var startHour = ctrl.getStartHour();
        var startTime = dayjs.utc().startOf('day').hour(startHour).minute(ctrl.startMin);
        var cutoffTime = startTime.subtract(ctrl.cutoffMinutesDisplay, 'minute');

        if (startTime.date() !== cutoffTime.date()) {
            return {
                hour: 0,
                min: 0,
            };
        }
        return {
            hour: cutoffTime.hour(),
            min: cutoffTime.minute(),
        };
    };

    ctrl.getCutoffMinutesFromSlot = function(slot) {
        var time = hsLocationSettings.parseSlotString(slot.displayName);
        var startTime = dayjs.utc().startOf('day').hour(time.startHour).minute(time.startMin);
        var cutoffTime = dayjs.utc().startOf('day').hour(slot.cutoffHour).minute(slot.cutoffMin || 0);
        var cutoffMinutes = startTime.diff(cutoffTime) / 1000 / 60;

        return cutoffMinutes;
    };

    ctrl.toggleEditSlot = function(index) {

        if (ctrl.editingIndex === index) {
            ctrl.resetSlotInput();
        } else {
            ctrl.editingIndex = index;

            ctrl.isRegularSlots() ? ctrl.setSlotInputs(index) : ctrl.setDailySlotInputs(index);
            ctrl.setEndTime();
        }
        // need this to clear form errors
        $timeout(function() {
            ctrl.form.validate();
        });
    };

    ctrl.setSlotInputs = function(index) {
        var slot = ctrl.slots[index];
        var slotTime = hsLocationSettings.parseSlotString(slot.displayName);

        ctrl.setTimeInputs(slotTime.startHour, slotTime.startMin, slotTime.endHour, slotTime.endMin);

        ctrl.cutoffHour = slot.cutoffHour || 0;
        ctrl.cutoffMin = slot.cutoffMin || 0;
        ctrl.cutoffMinutesDisplay = ctrl.getCutoffMinutesFromSlot(slot);
        ctrl.maxOrdersPerSlot = slot.maxOrdersPerSlot || 0;
    };

    ctrl.getDailyVolume = function() {
        if (!ctrl.slots || !ctrl.slots.length) return 0;

        return ctrl.slots.reduce(function(acc, slot) {
            return acc + (hsUtils.isPositiveInteger(slot.maxOrdersPerSlot) ? slot.maxOrdersPerSlot : 0);
        }, 0);
    };

    ctrl.isRegularSlots = function() {
        return ctrl.slotsType === 'slots';
    };

///////////////////////////////////////////////////////  Daily Slots  ///////////////////////////////////////////////////////

    ctrl.setDelay = function() {
        if (!ctrl.delay) {
            ctrl.delay = 0;
        }
    };

    ctrl.setSlotDuration = function() {
        if (!ctrl.slotDuration) {
            ctrl.slotDuration = 0;
        }
    };

    ctrl.generateDailySlot = function() {
        var slot = {
            startHour: ctrl.getDailySlotHour(ctrl.startHour, ctrl.startPeriod),
            startMin: ctrl.startMin,
            closingHour: ctrl.getDailySlotHour(ctrl.endHour, ctrl.endPeriod),
            closingMin: ctrl.endMin,
            slotDuration: ctrl.slotDuration,
            delay: ctrl.delay,
        };
        if (slot.closingHour === 0 && slot.closingMin === 0) {
            slot.closingHour = 24;
        }
        return slot;
    };

    ctrl.getDailySlotHour = function(hour, period) {
        return (hour === 12 ? 0 : hour) + period;
    };

    ctrl.isValidDailySlotDuration = function(slot) {
        var duration = ctrl.getSlotDurationMinutes(slot);
        return duration >= slot.slotDuration && duration >= slot.delay;
    };

    ctrl.getSlotDurationMinutes = function(slot) {
        var startTime = dayjs.utc().startOf('day').hour(slot.startHour).minute(slot.startMin);
        var endTime = dayjs.utc().startOf('day').hour(slot.closingHour).minute(slot.closingMin);
        return Math.round((endTime - startTime) / 1000 / 60);
    };

    ctrl.findDailySlotOverlapIndex = function(newSlot) {
        for (var i = 0; i < ctrl.slots.length; i++) {
            if (ctrl.editingIndex === i) continue;

            var slot = ctrl.slots[i];

            var newEndBeforeStart = slot.startHour > newSlot.closingHour
                || slot.startHour === newSlot.closingHour && slot.startMin >= newSlot.closingMin;

            if (newEndBeforeStart) continue;

            var newStartAfterEnd = slot.closingHour < newSlot.startHour
                || slot.closingHour === newSlot.startHour && slot.closingMin <= newSlot.startMin;

            if (newStartAfterEnd) continue;

            return i;
        }
        return -1;
    };

    ctrl.getDailySlotString = function(slot) {
        var str = getTimeString(slot.startHour, slot.startMin) + ' - ' + getTimeString(slot.closingHour, slot.closingMin);
        str += ', Prep - ' + slot.delay + ', Increment - ' + slot.slotDuration;

        return str;

        function getTimeString(hour, min) {
            var strMin = min.toString().padStart(2, '0');
            var strHour = hour === 0 || hour === 24 ? '12' : (hour <= 12 ? hour : hour - 12).toString();

            return strHour + ':' + strMin + (hour < 12 || hour === 24 ? 'AM' : 'PM');
        }
    };

    ctrl.setDailySlotInputs = function(index) {
        var slot = ctrl.slots[index];

        ctrl.setTimeInputs(slot.startHour, slot.startMin, slot.closingHour, slot.closingMin);

        ctrl.slotDuration = slot.slotDuration;
        ctrl.delay = slot.delay;
    };

    ctrl.findDailySlot = function(newSlot) {
        return ctrl.slots.findIndex(function(slot) {
            var slotToCompare = {
                startHour: slot.startHour,
                startMin: slot.startMin,
                closingHour: slot.closingHour,
                closingMin: slot.closingMin ,
            };
            var newSlotToCompare = {
                startHour: newSlot.startHour,
                startMin: newSlot.startMin,
                closingHour: newSlot.closingHour,
                closingMin: newSlot.closingMin,
            };
            return _.isEqual(slotToCompare, newSlotToCompare);
        });
    };

    ctrl.validateDailySlot = function(slot) {
        if (!ctrl.isValidDailySlotDuration(slot)) {
            return 'Slot duration has to be greater than or equal to the food prep time or increment.';
        }
    };
}

hsApp.component('lsStandardTips', {
    templateUrl: '/partials/components/location-settings-v2/components/standard-tips.html',
    bindings: {
        standardTips: '<',
        onChange: '&',
        registerValidator: '&',
        fulfillment: '<',
    },
    controller: [ '$scope', 'hsLocationSettings', 'hsUtils', 'ENV', locationSettingsStandardTipsController ],
});

function locationSettingsStandardTipsController($scope, hsLocationSettings, hsUtils, ENV) {
    var ctrl = this;
    var logPrefix = '[locationSettingsStandardTipsController]: ';

    ctrl.validation = {
        ignore: "",
        rules: {
            standardTipsInput: {
                standardTips: true
            }
        },
        messages: {
            standardTipsInput: {
                standardTips: "Please enter three unique values greater than zero"
            }
        }
    };

    ctrl.$onInit = function () {
        void 0;

        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.DEFAULT_STANDARD_TIPS = [
            {
                display: '10%',
                percentage: 10,    
            },
            {
                display: '15%',
                percentage: 15,
            },
            {
                display: '20%',
                percentage: 20,
            }
        ];

        ctrl.initModels();
        ctrl.deregisterValidator = ctrl.registerValidator({f: ctrl.isValid});
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.standardTips) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.$onDestroy = function() {
        ctrl.deregisterValidator();
    }

    ctrl.isValid = function() {
        if(ctrl.form.validate()) {
            return true;
        } 
        return false;
    }

    ctrl.initModels = function() {
        if (!hsUtils.isArray(ctrl.standardTips)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
        ctrl.isEnabled = hsUtils.isNonEmptyArray(ctrl.standardTips);
        ctrl.initInputFields();
    };

    ctrl.initInputFields = function() {
        var inputValues = ctrl.models.standardTips.map((value) => {
            return hsUtils.isObject(value) && value.percentage
                ? value.percentage
                : '';
        });

        ctrl.firstInput = inputValues[0];
        ctrl.secondInput = inputValues[1];
        ctrl.thirdInput = inputValues[2];
    }

    ctrl.getModelObject = function() {
        return {
            standardTips: ctrl.standardTips,
        };
    };

    ctrl.setChanged = function() {
        ctrl.onChange({ value: ctrl.models.standardTips });
    };

    ctrl.setIsEnabled = function(value) {
        ctrl.isEnabled = value; 
        if (ctrl.isEnabled) {
            ctrl.models.standardTips = ctrl.DEFAULT_STANDARD_TIPS;
        } else {
            ctrl.models.standardTips = [];
        }
        ctrl.initInputFields();
        ctrl.setChanged();
    };

    ctrl.updateStandardTipsIndex = function(index) {
        var values = {
            0: ctrl.firstInput,
            1: ctrl.secondInput,
            2: ctrl.thirdInput,
        };
        var newValue = values[index];
        ctrl.models.standardTips[index] = newValue ? { display: newValue + '%', percentage: newValue } : null;
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('aboutPricelistSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/about-pricelist-settings.html',
    bindings: {
        priceListData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', aboutPricelistSettingsController ],
});

function aboutPricelistSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[aboutPricelistSettingsController]: ';


    ctrl.validation = {
        rules: {
            title: {
                maxlength: 100,
                required: true,
            },
            description: {
                maxlength: 200,
            },
        },
        messages: {
            title: {
                required: 'Pricelist title can not be empty',
            },
            description: {
                required: 'Pricelist description can not be empty',
            },
        }
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
 
        ctrl.initModels();
    };

    ctrl.$onChanges = function (changes) {
        void 0;
        if (changes && changes.priceListData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.priceListData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }

        ctrl.models = ctrl.getModelObject();
        ctrl.isEnabled = !ctrl.models.priceList.isDisabled;
        ctrl.formattedDescription = ctrl.formatDescriptionForDisplay(ctrl.models.priceList.description);
    };

    ctrl.formatDescriptionForDisplay = function(description) {
        return description.split('<br>').join('\n');
    }

    ctrl.formatDescriptionForServer = function(description) {
        return description.split('\n').join('<br>');
    }

    ctrl.getModelObject = function() {
        return {
            priceList: {
                isDisabled: ctrl.priceListData.isDisabled,
                title: ctrl.priceListData.title,
                type: ctrl.priceListData.type,
                description: ctrl.priceListData.description,
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.setIsDisabled = function(value) {
        ctrl.models.priceList.isDisabled = !value;
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key,  fieldName) {
        hsLocationSettings.showDescription(key,  fieldName);
    };

    ctrl.shouldHidePriceListType = function() {
        return !hsUtils.isNonEmptyString(ctrl.models.priceList.type);
    }

    ctrl.setPriceListDescription = function() {
        var formattedDescription = ctrl.formatDescriptionForServer(ctrl.formattedDescription);
        ctrl.models.priceList.description = formattedDescription;
        ctrl.setChanged();
    }
}
hsApp.component('aboutSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/about-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
        onImageUpload: '&',
    },
    controller: ['hsUtils', 'hsLocationSettings', aboutSettingsController ],
});

function aboutSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[aboutSettingsController]: ';

    ctrl.validation = {
        rules: {
            name: {
                maxlength: 50,
                required: true,
            },
            locationDescription: {
                maxlength: 200,
            },
        },
        messages: {
            name: {
                required: 'Location name can not be empty',
            },
        },
    };

    ctrl.handleImageUpload = function(image, width, height) {
        var imageSource = {
            src: image,
            width: width,
            height: height
        };

        return ctrl.onImageUpload({imageSource: imageSource})
            .then(function(response) {
                ctrl.models.location.imageSource = imageSource;
                // this means that the dimension check passed, which means we want to keep this as the primary image src
                ctrl.fallbackImage = imageSource;
                return response;
            })
            .catch(function(error) {
                ctrl.models.location.imageSource = null;
                ctrl.error = null;
                throw error;
            })
            .finally(function() {
                ctrl.setChanged();
            });
    }

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.urlLink = ctrl.locationData.locationImgUrl || null;
        ctrl.isLoading = false;

        ctrl.initModels();
    }; 

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
        ctrl.isEnabled = !ctrl.models.location.isDisabled;
        ctrl.orderingEnabled = !ctrl.models.location.orderingDisabled;
    };

    ctrl.getModelObject = function() {
        return {
            location: {
                isDisabled: ctrl.locationData.isDisabled,
                locationDescription: ctrl.locationData.locationDescription,
                name: ctrl.locationData.name,
                operatingHours: JSON.parse(JSON.stringify(ctrl.locationData.operatingHours || [])),
                orderingDisabled: ctrl.locationData.orderingDisabled,
                timezone: ctrl.locationData.timezone,
                imageSource: null,
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();
            ctrl.isLoading = true;
            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function(err) {
                    ctrl.error = (err.message || err || hsLocationSettings.errorMessages.GENERIC_ERROR);
                })
                .finally(function() {
                    if (ctrl.fallbackImage && ctrl.fallbackImage.src) {
                        ctrl.urlLink = URL.createObjectURL(ctrl.fallbackImage.src);
                    }
                    ctrl.isLoading = false;
                })
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.setIsDisabled = function(value) {
        ctrl.models.location.isDisabled = !value;
        ctrl.setChanged();
    };

    ctrl.setOrderingDisabled = function(value) {
        ctrl.models.location.orderingDisabled = !value;
        ctrl.setChanged();
    };

    ctrl.setOperatingHours = function(value) {
        ctrl.models.location.operatingHours = value;
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.showLocationDescription = function() {
        return ctrl.locationData.isVirtual;
    }
}

hsApp.component('addressSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/address-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'NgMap', 'hsUtils', 'hsLocationSettings', '$scope', 'hsDelivery', addressSettingsController ],
});

function addressSettingsController(NgMap, hsUtils, hsLocationSettings, $scope, hsDelivery) {
    var ctrl = this;
    var logPrefix = '[addressSettingsController]: ';

    ctrl.$onInit = function () {
        void 0
        
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;

        ctrl.initModels();
        $scope.$watch('address', function() {
            ctrl.processAddress();
        }, true);
    }

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }

        ctrl.models = ctrl.getModelObject();
        $scope.address = ctrl.models.location.address;
    }

    ctrl.getModelObject = function() {
        return {
            location: {
                address: Object.assign({}, ctrl.locationData.address),
                latitude: ctrl.locationData.latitude,
                longitude: ctrl.locationData.longitude,
                country: ctrl.locationData.country,
            },
        };
    }

    ctrl.updateLatLong = function() {
        var address = hsDelivery.getAddress(ctrl.models.location.address);
        return NgMap.getGeoLocation(address)
            .then(function(resp) {
                ctrl.models.location.latitude = resp.lat().toFixed(6);
                ctrl.models.location.longitude = resp.lng().toFixed(6);
            })
            .catch(function(err) {
                void 0;
            });
    }

    ctrl.processAddress = function () {    
        return ctrl.updateLatLong().then(function() {
            var address = ctrl.models.location.address;
            ctrl.deleteAdditionalFields(address);
            ctrl.setChanged();
        });
    }

    ctrl.deleteAdditionalFields = function(address) {
        delete address._isValid;
        delete address.country;
    }

    ctrl.saveSettings = function() {
        $scope.$broadcast('validateAddress-location-settings-v2', function(isValid) {
            if (!isValid) {
                return;
            }

            var params = ctrl.getChangedParams();

            return ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        });
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('checkoutPricelistSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/checkout-pricelist-settings.html',
    bindings: {
        priceListData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', checkoutPricelistSettingsController ],
});

function checkoutPricelistSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;

    ctrl.validation = {
        rules: {
            authHoldPercentDisplay: {
                number: true,
                min: 0,
            },
            orderCutoffMinDays: {
                number: true,
                min: 1,
            },
            orderCutoffMaxDays: {
                number: true,
                min: 2,
            },
        },
        messages: {},
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.isCatering = false;
        ctrl.DAY_START = 'T00:00';
        ctrl.DAY_END = 'T23:59';

        ctrl.blackoutFromDate = {
			model: '',
			format: 'MM-dd-yyyy',
			opened: false,
			dateOptions: {
				showWeeks: false,
				formatYear: 'yy',
				minDate: new Date(),
				startingDay: 1,
				showClear: false,
            }
        };

        ctrl.blackoutToDate = {
			model: '',
			format: 'MM-dd-yyyy',
			opened: false,
			dateOptions: {
				showWeeks: false,
				formatYear: 'yy',
				minDate: new Date(),
				startingDay: 1,
				showClear: false,
            }
        };

        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        });
        ctrl.expiredDatesTooltipText = 'This timeslot has expired and can be safely removed';

        ctrl.initModels();
    };

    ctrl.disableBlackoutDatesSubmitButton = function() {
        return !hsUtils.isDateObject(ctrl.blackoutFromDate.model) 
            || !hsUtils.isDateObject(ctrl.blackoutToDate.model)
            || ctrl.blackoutFromDate.model > ctrl.blackoutToDate.model;
    }

    ctrl.getDateString = function(date) {
        return date.getFullYear() + '-' + (date.getMonth() + 1).toString().padStart(2, 0) + '-' + date.getDate().toString().padStart(2, 0);
    }

    ctrl.addToBlackoutDates = function() {
        if (hsUtils.isDateObject(ctrl.blackoutFromDate.model) 
            && hsUtils.isDateObject(ctrl.blackoutToDate.model)
            && ctrl.blackoutFromDate.model <= ctrl.blackoutToDate.model) {

                var startDate = ctrl.blackoutFromDate.model;
                var startDateStr = ctrl.getDateString(startDate);
                var endDate = ctrl.blackoutToDate.model;
                var endDateStr = ctrl.getDateString(endDate);
                
                ctrl.models.priceList.blackoutDates.push({
                    startDate: startDateStr,
                    endDate: endDateStr
                });

                ctrl.blackoutFromDate.model = '';
                ctrl.blackoutToDate.model = '';
                ctrl.blackoutToDate.dateOptions.minDate = new Date();
                delete ctrl.blackoutFromDate.dateOptions.maxDate;
                ctrl.setChanged();
        }
    }

    ctrl.toggleBlackoutFromDatePicker = function() {
        ctrl.blackoutFromDate.opened = !ctrl.blackoutFromDate.opened;
    }

    ctrl.toggleBlackoutToDatePicker = function() {
        ctrl.blackoutToDate.opened = !ctrl.blackoutToDate.opened;
    }

    ctrl.processToDateChanges = function() {
        if (hsUtils.isDateObject(ctrl.blackoutToDate.model)) {
            ctrl.blackoutFromDate.dateOptions.maxDate = ctrl.blackoutToDate.model;    
        } else {
            delete ctrl.blackoutFromDate.dateOptions.maxDate;
        }
    }

    ctrl.processFromDateChanges = function() {
        if (hsUtils.isDateObject(ctrl.blackoutFromDate.model)) {
            ctrl.blackoutToDate.dateOptions.minDate = ctrl.blackoutFromDate.model;
        } else {
            ctrl.blackoutToDate.dateOptions.minDate = new Date();
        }
    }

    ctrl.getFormattedBlackoutDatesText = function(date) {
        var startDate = new Date(date.startDate + ctrl.DAY_START);
        var endDate = new Date(date.endDate + ctrl.DAY_END);

        return hsUtils.getDateString(startDate) + ' - ' + hsUtils.getDateString(endDate);
    }

    ctrl.isExpiredTimeslot = function(date) {
        var endDate = new Date(date.endDate + ctrl.DAY_END);
        var currentDate = new Date();

        return currentDate > endDate;
    }

    ctrl.removeBlackoutDate = function(idx) {
        ctrl.models.priceList.blackoutDates.splice(idx, 1);
        ctrl.setChanged();
    }

    ctrl.$onChanges = function (changes) {
        if (changes && changes.priceListData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.priceListData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.isCatering = hsLocationSettings.isCatering(ctrl.priceListData);
        ctrl.isPreorder = hsLocationSettings.isPreorder(ctrl.priceListData);
        ctrl.models = ctrl.getModelObject();
        ctrl.authHoldPercentDisplay = ctrl.models.priceList.authHoldPercent * 100;

        if (ctrl.isCatering) {
            ctrl.orderCutoffDisplay = {
                minDays: Math.round(ctrl.models.priceList.orderCutoff.minHours / 24),
                maxDays: Math.round(ctrl.models.priceList.orderCutoff.maxHours / 24),
            };
        }
    };

    ctrl.getModelObject = function() {
        var models = {
            priceList: {
                authHoldPercent: ctrl.priceListData.authHoldPercent,
                fulfillment: {},
            },
        };
        if (hsUtils.isObject(ctrl.priceListData.fulfillment)) {
            if (hsUtils.isObject(ctrl.priceListData.fulfillment.pickup)) {
                models.priceList.fulfillment.pickup = JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment.pickup));
            }
            if (hsUtils.isObject(ctrl.priceListData.fulfillment.delivery)) {
                models.priceList.fulfillment.delivery = JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment.delivery));
            } else if (hsUtils.isObject(ctrl.priceListData.fulfillment.managedDelivery)) {
                models.priceList.fulfillment.managedDelivery = JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment.managedDelivery));
            }
        }
        if (ctrl.hasAnySlots(models)) {
            models.priceList.volumeLimits = JSON.parse(JSON.stringify(ctrl.priceListData.volumeLimits));
        }
        if (ctrl.isCatering) {
            models.priceList.orderCutoff = JSON.parse(JSON.stringify(ctrl.priceListData.orderCutoff));
        }
        if (ctrl.isPreorder || ctrl.isCatering) {
            models.priceList.enableImmediatePreAuth = ctrl.priceListData.enableImmediatePreAuth;
        }
        if(!hsUtils.isNonEmptyArray(ctrl.priceListData.blackoutDates)) {
            models.priceList.blackoutDates = [];
        } else {
            models.priceList.blackoutDates = JSON.parse(JSON.stringify(ctrl.priceListData.blackoutDates));
        }
        return models;
    };

    ctrl.saveSettings = function() {
        ctrl.error = null;

        if (ctrl.form.validate()) {
            if (ctrl.isCatering && !ctrl.isValidOrderCutoff()) {
                ctrl.error = 'Min Lead Time has to be less than Max Lead Time';
                return;
            }

            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });

        if (!ctrl.changed) {
            ctrl.error = null;
        }
    };

    ctrl.setAuthHoldPercent = function() {
        if (isNaN(ctrl.authHoldPercentDisplay) || ctrl.authHoldPercentDisplay === '') {
            ctrl.authHoldPercentDisplay = 0;
        }
        ctrl.models.priceList.authHoldPercent = Number((ctrl.authHoldPercentDisplay / 100).toFixed(2));
        ctrl.setChanged();
    };

    ctrl.setOrderCutoffMinHours = function() {
        if (isNaN(ctrl.orderCutoffDisplay.minDays) || ctrl.orderCutoffDisplay.minDays === '') {
            ctrl.orderCutoffDisplay.minDays = 0;
        }
        ctrl.models.priceList.orderCutoff.minHours = Math.round(ctrl.orderCutoffDisplay.minDays * 24);
        ctrl.setChanged();
    };

    ctrl.setOrderCutoffMaxHours = function() {
        if (isNaN(ctrl.orderCutoffDisplay.maxDays) || ctrl.orderCutoffDisplay.maxDays === '') {
            ctrl.orderCutoffDisplay.maxDays = 0;
        }
        ctrl.models.priceList.orderCutoff.maxHours = Math.round(ctrl.orderCutoffDisplay.maxDays * 24);
        ctrl.setChanged();
    };

    ctrl.isValidOrderCutoff = function() {
        return ctrl.models.priceList.orderCutoff.minHours < ctrl.models.priceList.orderCutoff.maxHours;
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.getDailyVolumeFromSlots = function(slots) {
        if (!hsUtils.isNonEmptyArray(slots)) return 0;

        return slots.reduce(function(sum, slot) {
            return sum + (hsUtils.isPositiveInteger(slot.maxOrdersPerSlot) ? slot.maxOrdersPerSlot : 0);
        }, 0);
    };

    ctrl.getMaxOrdersFromSlots = function(slots) {
        if (!hsUtils.isNonEmptyArray(slots)) return 0;

        return slots.reduce(function(max, slot) {
            return Math.max(max, hsUtils.isPositiveInteger(slot.maxOrdersPerSlot) ? slot.maxOrdersPerSlot : 0);
        }, 0);
    };

    ctrl.getVolumeLimits = function(slots) {
        return {
            maxOrdersPerSlot: ctrl.getMaxOrdersFromSlots(slots),
            maxOrdersPerDay: ctrl.getDailyVolumeFromSlots(slots),
        };
    };

    ctrl.setVolumeLimitsToMax = function(targetVolumeLimits, slots) {
        var volumeLimits = ctrl.getVolumeLimits(slots);

        targetVolumeLimits.maxOrdersPerSlot = Math.max(
            targetVolumeLimits.maxOrdersPerSlot, volumeLimits.maxOrdersPerSlot
        );
        targetVolumeLimits.maxOrdersPerDay = Math.max(
            targetVolumeLimits.maxOrdersPerDay, volumeLimits.maxOrdersPerDay
        );
    };

    ctrl.hasAnySlots = function(models) {
        return hsUtils.isObject(models.priceList.fulfillment) && (
            hsUtils.isObject(models.priceList.fulfillment.pickup)
            && (models.priceList.fulfillment.pickup.slots || models.priceList.fulfillment.pickup.slotsOverrides)
            || hsUtils.isObject(models.priceList.fulfillment.delivery)
            && (models.priceList.fulfillment.delivery.slots || models.priceList.fulfillment.delivery.slotsOverrides)

        );
    };

    ctrl.setChangedSlots = function(value) {
        if (ctrl.hasAnySlots(ctrl.models)) {
            ctrl.models.priceList.volumeLimits = {
                maxOrdersPerSlot: 0,
                maxOrdersPerDay: 0,
            };
        }
        if (value.pickup) {
            if (value.pickup.slots) {
                ctrl.models.priceList.fulfillment.pickup.slots = value.pickup.slots;
                ctrl.setVolumeLimitsToMax(ctrl.models.priceList.volumeLimits, value.pickup.slots);
            }
            if (value.pickup.slotsOverrides) {
                ctrl.models.priceList.fulfillment.pickup.slotsOverrides = value.pickup.slotsOverrides;
            }
            if (value.pickup.dailySlots) {
                ctrl.models.priceList.fulfillment.pickup.dailySlots = value.pickup.dailySlots;
            }
            if (value.pickup.dailySlotsOverrides) {
                ctrl.models.priceList.fulfillment.pickup.dailySlotsOverrides = value.pickup.dailySlotsOverrides;
            }
            if (value.pickup.closedWeekdays) {
                ctrl.models.priceList.fulfillment.pickup.closedWeekdays = value.pickup.closedWeekdays;
            }
        }
        if (value.delivery) {
            if (value.delivery.slots) {
                ctrl.models.priceList.fulfillment.delivery.slots = value.delivery.slots;
                ctrl.setVolumeLimitsToMax(ctrl.models.priceList.volumeLimits, value.delivery.slots);
            }
            if (value.delivery.slotsOverrides) {
                ctrl.models.priceList.fulfillment.delivery.slotsOverrides = value.delivery.slotsOverrides;
            }
            if (value.delivery.dailySlots) {
                ctrl.models.priceList.fulfillment.managedDelivery.dailySlots = value.delivery.dailySlots;
            }
            if (value.delivery.dailySlotsOverrides) {
                ctrl.models.priceList.fulfillment.managedDelivery.dailySlotsOverrides = value.delivery.dailySlotsOverrides;
            }
            if (value.delivery.closedWeekdays) {
                if (ctrl.models.priceList.fulfillment.delivery) {
                    ctrl.models.priceList.fulfillment.delivery.closedWeekdays = value.delivery.closedWeekdays;
                } else {
                    ctrl.models.priceList.fulfillment.managedDelivery.closedWeekdays = value.delivery.closedWeekdays;
                }
            }
        }
        ctrl.setChanged();
    };

    ctrl.isHomesomeAccount = function() {
        return hsLocationSettings.isHomesomeAccount();
    };

}

hsApp.component('contactSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/contact-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', contactSettingsController ],
});

function contactSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[contactSettingsController]: ';

    ctrl.validation = {
        rules: {
            phone: {
                required: true,
                phoneUS: true,
            },
            supportEmail: {
                required: true,
                email: true,
            },
            orderNotificationEmail: {
                email: true,
            },
            email: {
                required: true,
                email: true,
            },
            name: {
                required: true,
            },
        },
        messages: {
            phone: {
                required: 'Please enter a phone number',
                phoneUS: 'Please enter a valid phone number',
            },
            supportEmail: {
                required: 'Please enter an email address',
                email: 'Please enter a valid email address',
            },
            orderNotificationEmail: {
                email: 'Please enter a valid email address',
            },
            email: {
                required: 'Please enter an email address',
                email: 'Please enter a valid email address',
            },
            name: {
                required: 'Required',
            },
        },
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;

        ctrl.initModels();
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.getModelObject = function() {
        return {
            location: {
                phone: ctrl.locationData.phone,
                supportEmail: ctrl.locationData.supportEmail,
                orderNotificationEmail: ctrl.locationData.orderNotificationEmail,
                fromEmail: Object.assign({}, ctrl.locationData.fromEmail),
                email: ctrl.locationData.email,
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.setSupportEmail = function() {
        ctrl.models.location.email = ctrl.models.location.supportEmail;
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

}
hsApp.component('deliverySettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/delivery-settings.html',
    bindings: {
        priceListData: '<',
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', 'toastr', deliverySettingsController ],
});

function deliverySettingsController(hsUtils, hsLocationSettings, toastr) {
    var ctrl = this;
    var logPrefix = '[deliverySettingsController]: ';

    ctrl.validation = {
        rules: {
            pickupInstructions: {
                maxlength: 280,
            },
        }
    };

    ctrl.$onInit = function () {

        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.deliveryType = null;
        ctrl.DELIVERY_TYPES = {
            DELIVERY: 'delivery',
            MANAGED_DELIVERY: 'managedDelivery',
        };
        ctrl.validConfig = true;
        ctrl.externalValidators = [];

        ctrl.initModels();

    }

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.priceListData) || !hsUtils.isObject(ctrl.locationData) || !hsUtils.isObject(ctrl.priceListData.fulfillment)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }

        if(hsUtils.isObject(ctrl.priceListData.fulfillment.delivery)) {
            ctrl.deliveryType = 'delivery';
        } else if (hsUtils.isObject(ctrl.priceListData.fulfillment.managedDelivery)) {
            ctrl.deliveryType = 'managedDelivery';
        } else {
            ctrl.error = hsLocationSettings.errorMessages.INVALID_SETTING_DETECTED;
            ctrl.validConfig = false;
            return;
        }

        ctrl.validConfig = true;
        ctrl.error = null;
        ctrl.models = ctrl.getModelObject();

        ctrl.deliveryProviders = [];
        ctrl.addDeliveryProviders();

        // Re-assigned here to avoid using ctrl.deliveryType in HTML.
        ctrl.pickupInstructions = ctrl.models.priceList.fulfillment[ctrl.deliveryType].pickupInstructions;
        ctrl.standardTips = JSON.parse(JSON.stringify(ctrl.models.priceList.fulfillment[ctrl.deliveryType].standardTips));
        ctrl.isEnabled = !ctrl.models.priceList.fulfillment[ctrl.deliveryType].isDisabled;
        ctrl.deliveryProviderConfigs = JSON.parse(JSON.stringify(ctrl.models.priceList.fulfillment[ctrl.deliveryType].deliveryProviderConfigs));
        ctrl.exceptionCities = JSON.parse(JSON.stringify(ctrl.models.priceList.fulfillment[ctrl.deliveryType].exceptionCities));
        ctrl.exceptionZipcodes = JSON.parse(JSON.stringify(ctrl.models.priceList.fulfillment[ctrl.deliveryType].exceptionZipcodes));
    }

    ctrl.addDeliveryProviderConfigs = function(retVal) {
        retVal.priceList.fulfillment[ctrl.deliveryType] = {
            deliveryProviderConfigs: JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment[ctrl.deliveryType].deliveryProviderConfigs)),
            exceptionCities: JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment[ctrl.deliveryType].exceptionCities || [])),
            exceptionZipcodes: JSON.parse(JSON.stringify(ctrl.priceListData.fulfillment[ctrl.deliveryType].exceptionZipcodes|| [])),
        };
    }

    ctrl.allowDisable = function () {
        var enableCount = 0;

        for (var provider of ctrl.deliveryProviders) {
            if (provider.enabled){
                enableCount++;
            }
        }
        return enableCount > 1;
    },

    ctrl.addDeliveryProviders = function() {
        var setPreferred = false;
        for (var deliveryProvider of Object.keys(ctrl.priceListData.availableDeliveryProviders)) {
            var isEnabled = ctrl.priceListData.enabledDeliveryProviders.includes(deliveryProvider);
            var providerDetails = {
                name: deliveryProvider,
                enabled: isEnabled,
                preferred: false,
            }
            if (isEnabled && !setPreferred) {
                providerDetails.preferred = true;
                setPreferred = true;
            }
            ctrl.deliveryProviders.push(providerDetails);
        }
    };

    ctrl.getModelObject = function() {
        var retVal = {
            priceList: {
                fulfillment: {},
            }  
        };

        retVal.priceList.enabledDeliveryProviders = JSON.parse(JSON.stringify(ctrl.priceListData.enabledDeliveryProviders));
        ctrl.addDeliveryProviderConfigs(retVal);
        retVal.priceList.fulfillment[ctrl.deliveryType].isDisabled = ctrl.priceListData.fulfillment[ctrl.deliveryType].isDisabled;
        retVal.priceList.fulfillment[ctrl.deliveryType].pickupInstructions = ctrl.priceListData.fulfillment[ctrl.deliveryType].pickupInstructions.slice(0, ctrl.validation.rules.pickupInstructions.maxlength);
        retVal.priceList.fulfillment[ctrl.deliveryType].standardTips = ctrl.priceListData.fulfillment[ctrl.deliveryType].standardTips;
        
        return retVal;
    };

    ctrl.registerValidator = function(f) {
        ctrl.externalValidators.push(f);
        return function() {
            var index = ctrl.externalValidators.findIndex(function(obj) { return obj === f; });

            if (index !== -1) {
                ctrl.externalValidators.splice(index, 1);
            }
        };
    };

    ctrl.$onChanges = function (changes) {
        if (changes && (changes.locationData || changes.priceListData)) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate() && ctrl.externalValidators.every(function(f) { return f(); })) {
            var params = ctrl.getChangedParams();
            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        if (ctrl.validConfig) {
            var changes = ctrl.getChangedParams();
            ctrl.changed = !!Object.keys(changes).length;
            ctrl.onChange({ changed: ctrl.changed });
        }
    };

    ctrl.setDeliveryProviderConfigs = function(value) {
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].deliveryProviderConfigs = JSON.parse(JSON.stringify(value.deliveryProviderConfigs));
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].exceptionCities = JSON.parse(JSON.stringify(value.allowedCities));
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].exceptionZipcodes = JSON.parse(JSON.stringify(value.allowedZipcodes));
        ctrl.setChanged();
    }
    
    ctrl.updateDeliveryProvidersModel = function() {
        ctrl.models.priceList.enabledDeliveryProviders = [];
        
        for (var provider of ctrl.deliveryProviders) {
            if (provider.enabled) {
                ctrl.models.priceList.enabledDeliveryProviders.push(provider.name);
            }
        }
    }

    ctrl.updateDeliveryProviders = function(updateParams) {
        ctrl.resetPreferredProvider();

        if (updateParams && hsUtils.isObject(updateParams)) {

            var event = updateParams.event;
            var idx = updateParams.idx;

            if (event === 'enable') {
                ctrl.deliveryProviders[idx].enabled = true;
            } else if (event === 'disable') {
                if (ctrl.allowDisable()) {
                    ctrl.deliveryProviders[idx].enabled = false;
                } else {
                    toastr.error("Cannot disable delivery provider. Atleast one provider must be enabled.");
                    return;
                }
            }
        }

        for (var provider of ctrl.deliveryProviders) {
            if (provider.enabled) {
                provider.preferred = true;
                break;
            }
        }

        ctrl.updateDeliveryProvidersModel();
        ctrl.setChanged();
    }

    ctrl.resetPreferredProvider = function() {
        for (var provider of ctrl.deliveryProviders) {
            if (provider.preferred) {
                provider.preferred = false;
            }
        }
    }

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.updatePickupInstructions = function() {
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].pickupInstructions = ctrl.pickupInstructions || '';
        ctrl.setChanged();
    }

    ctrl.setStandardTips = function (value) {
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].standardTips = JSON.parse(JSON.stringify(value));
        ctrl.setChanged();
    }

    ctrl.setIsDisabled = function(value) {
        ctrl.models.priceList.fulfillment[ctrl.deliveryType].isDisabled = !value;
        ctrl.setChanged();
    };
}
hsApp.component('featuresPricelistSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/features-pricelist-settings.html',
    bindings: {
        priceListData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', featuresPricelistSettingsController ],
});

function featuresPricelistSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[featuresPricelistSettingsController]: ';

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.initModels();
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.priceListData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.priceListData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.getModelObject = function() {
        return {
            priceList: {
                aiIntegrations: JSON.parse(JSON.stringify(ctrl.priceListData.aiIntegrations)),
            },
        };
    };

    ctrl.saveSettings = function() {
        var params = ctrl.getChangedParams();

        ctrl.onSave({ params: params })
            .then(function() {
                ctrl.error = null;
            })
            .catch(function (err) {
                ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
            });
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.isHomesomeAccount = function() {
        return hsLocationSettings.isHomesomeAccount();
    }

}
hsApp.component('featuresSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/features-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', featuresSettingsController ],
});

function featuresSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[featuresSettingsController]: ';

    ctrl.validation = {
        rules: {
            textForOrder: {
                phoneUS: true,
            },
        },
        messages: {
            textForOrder: {
                phoneUS: "Please enter a valid phone number",
            },
        }
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
 
        ctrl.initModels();
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.getModelObject = function() {
        return {
            location: {
                enableShopByDiet: ctrl.locationData.enableShopByDiet,
                textForOrder: ctrl.locationData.textForOrder,
                callForOrder: ctrl.locationData.callForOrder,
                ebtConfig: JSON.parse(JSON.stringify(ctrl.locationData.ebtConfig)),
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.isHomesomeAccount = function() {
        return hsLocationSettings.isHomesomeAccount();
    };

    ctrl.setEbtConfig = function(value) {
        ctrl.models.location.ebtConfig = value;
        ctrl.setChanged();
    };

}
hsApp.component('feesSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/fees-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', feesSettingsController ],
});

function feesSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[feesSettingsController]: ';

    ctrl.validation = {
        rules: {
            salestax: {
                required: true,
                number: true,
                min: 0,
                max: 100,
            },
            bagFee: {
                required: true,
                number: true,
                min: 0,
            },
        },
        messages: {
            salestax: {
                required: 'Please enter a valid sales tax rate',
                number: 'Please enter a valid sales tax rate',
                min: 'Please enter a number between 0-100',
                max: 'Please enter a number between 0-100',
            },
            bagFee: {
                required: 'Please enter a valid bag fee',
                number: 'Please enter a valid bag fee',
                min: 'Please enter a value greater than 0',
            },
        },
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;

        ctrl.initModels();
    }

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.getModelObject = function() {
        return {
            location: {
                taxRate: ctrl.locationData.taxRate,
                taxRateDisplay: parseFloat((ctrl.locationData.taxRate * 100).toFixed(3)),
                bagFee: ctrl.locationData.bagFee,
                deliveryFeeTaxable: ctrl.locationData.deliveryFeeTaxable || false,
                serviceFeeTaxable: ctrl.locationData.serviceFeeTaxable || false,
            },
        };
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setSalesTaxRate = function() {
        if (isNaN(ctrl.models.location.taxRateDisplay) || ctrl.models.location.taxRateDisplay === '') {
            ctrl.models.location.taxRateDisplay = 0;
        }
        ctrl.models.location.taxRate = parseFloat((ctrl.models.location.taxRateDisplay / 100).toFixed(5));
        ctrl.setChanged();
    }

    ctrl.setBagFee = function() {
        if (isNaN(ctrl.models.location.bagFee) || ctrl.models.location.bagFee === '') {
            ctrl.models.location.bagFee = 0;
        }
        ctrl.models.location.bagFee = parseFloat(ctrl.models.location.bagFee);
        ctrl.setChanged();
    }

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('pickingSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/picking-settings.html',
    bindings: {
        locationData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', pickingSettingsController ],
});

function pickingSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[pickingSettingsController]: ';
    
    ctrl.validation = {
        rules: {},
        messages: {}
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;

        ctrl.initModels();
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.locationData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.locationData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
    };

    ctrl.getModelObject = function() {
        return {
            location: {
                customItemRequiresUpc: ctrl.locationData.customItemRequiresUpc,
                deliveryRequiresPacking: ctrl.locationData.deliveryRequiresPacking,
                processedOrderRequiresPacking: ctrl.locationData.processedOrderRequiresPacking,
                enableBagsBarcodes: ctrl.locationData.enableBagsBarcodes,
                shouldSendPickupOrderMessage: ctrl.locationData.shouldSendPickupOrderMessage,
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };
}
hsApp.component('pickupSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/pickup-settings.html',
    bindings: {
        priceListData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', pickupSettingsController ],
});

function pickupSettingsController(hsUtils, hsLocationSettings) {
    var ctrl = this;
    var logPrefix = '[pickupSettingsController]: ';


    ctrl.validation = {
        ignore: "",
        rules: {
            pickupInstructions: {
                maxlength: 280,
            },
            fee: {
                required: true,
                number: true,
                min: 0,
            },
            serviceFeeRate: {
                required: true,
                number: true,
                min: 0,
                max: 100,
            },
            minOrder: {
                required: true,
                number: true,
                min: 0,
            },
            minOrderWithNoFee: {
                required: true,
                number: true,
                min: 0,
            },
        },
        messages: {
            fee: {
                required: "Please enter pickup fee value",
                number: "Please enter valid pickup fee value",
                min: "Please enter pickup fee value greater than or equal to 0",
            },
            minOrder: {
                required: "Please enter minimum order value",
                number: "Please enter valid minimum order value",
                min: "Please enter minimum order value greater than than or equal to 0",
            },
            serviceFeeRate: {
                required: "Please enter service fee rate",
                number: "Please enter valid service fee rate",
                min: "Please enter service fee rate between 0-100",
                max: "Please enter service fee rate between 0-100",
            },
            minOrderWithNoFee: {
                required: "Please enter min order for free pickup",
                number: "Please enter valid min order for free pickup",
                min: "Please enter value greater than or equal to 0",
            },
        }
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.externalValidators = [];
 
        ctrl.initModels();
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.priceListData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };

    ctrl.initModels = function() {
        if (!hsUtils.isObject(ctrl.priceListData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }

        ctrl.models = ctrl.getModelObject();
        ctrl.isEnabled = !ctrl.models.priceList.fulfillment.pickup.isDisabled;
        ctrl.serviceFeeRateDisplay = ctrl.models.priceList.fulfillment.pickup.serviceFeeRate * 100;
        ctrl.standardTips = JSON.parse(JSON.stringify(ctrl.models.priceList.fulfillment.pickup.standardTips));
    };

    ctrl.getModelObject = function() {
        return {
            priceList: {
                fulfillment: {
                    pickup: {
                        isDisabled: !!ctrl.priceListData.fulfillment.pickup.isDisabled,
                        pickupInstructions: (ctrl.priceListData.fulfillment.pickup.pickupInstructions || '').slice(0, ctrl.validation.rules.pickupInstructions.maxlength),
                        fee: ctrl.priceListData.fulfillment.pickup.fee,
                        serviceFeeRate: ctrl.priceListData.fulfillment.pickup.serviceFeeRate,
                        minOrder: ctrl.priceListData.fulfillment.pickup.minOrder,
                        noFeeFulfillmentAllowed: !!ctrl.priceListData.fulfillment.pickup.noFeeFulfillmentAllowed,
                        minOrderWithNoFee: ctrl.priceListData.fulfillment.pickup.minOrderWithNoFee,
                        standardTips: ctrl.priceListData.fulfillment.pickup.standardTips,        
                    }
                }
            },
        };
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate() && ctrl.externalValidators.every(function(f) { return f(); })) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.setChanged = function() {
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.registerValidator = function(f) {
        ctrl.externalValidators.push(f);
        return function() {
            var index = ctrl.externalValidators.findIndex(function(obj) { return obj === f; });
    
            if (index !== -1) {
                ctrl.externalValidators.splice(index, 1);
            }
        };
    };
    ctrl.setIsDisabled = function(value) {
        ctrl.models.priceList.fulfillment.pickup.isDisabled = !value;
        ctrl.setChanged();
    };

    ctrl.setServiceFeeRate = function() {
        ctrl.models.priceList.fulfillment.pickup.serviceFeeRate = parseFloat((ctrl.serviceFeeRateDisplay / 100).toFixed(5));
        ctrl.setChanged();
    };

    ctrl.setStandardTips = function(value) {
        ctrl.models.priceList.fulfillment.pickup.standardTips = JSON.parse(JSON.stringify(value));
        ctrl.setChanged();
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

}
hsApp.component('processingSettings', {
    templateUrl: '/partials/components/location-settings-v2/settings-views/processing-settings.html',
    bindings: {
        priceListData: '<',
        onChange: '&',
        onSave: '&',
    },
    controller: [ 'hsUtils', 'hsLocationSettings', 'ENV', processingSettingsController ],
});

function processingSettingsController(hsUtils, hsLocationSettings, ENV) {
    var ctrl = this;
    var logPrefix = '[pickupSettingsController]: ';

    ctrl.validation = {
        rules: {
            orderEditableCutOffTime: {
                required: true,
                number: true,
                gt: 0,
            },
        },
        messages: {
            orderEditableCutOffTime: {
                required: 'Please enter order cutoff hours',
                number: 'Please enter order cutoff hours'
            },
        },
    };

    ctrl.$onInit = function () {
        ctrl.error = null;
        ctrl.changed = false;
        ctrl.form = null;
        ctrl.initModels();
    }

    ctrl.initModels = function() {
        ctrl.enableSchedulePreorder = null;
        ctrl.enableAutoScheduleDelivery = null;
        ctrl.orderEditableCutOffTimeDisplay = null;

        if (!hsUtils.isObject(ctrl.priceListData)) {
            ctrl.error = hsLocationSettings.errorMessages.LOAD_ERROR;
            return;
        }
        ctrl.models = ctrl.getModelObject();
        ctrl.enableOrderEdits = !ctrl.models.priceList.disableUserOrderEditing;
        ctrl.orderEditableCutOffTimeDisplay = parseFloat(ctrl.models.priceList.orderEditableCutOffTime/3.6e6).toFixed(2);

        if (ctrl.isPreorder()) {
            ctrl.enableSchedulePreorder = !ctrl.models.priceList.disableSchedulePreorder;
        }

        if (ctrl.isCatering()) {
            ctrl.enableAutoScheduleDelivery = !ctrl.models.priceList.disableAutoScheduleDelivery;
        }
    };

    ctrl.getModelObject = function() {
        var retVal = {
            priceList: {
                disableUserOrderEditing: ctrl.priceListData.disableUserOrderEditing,
                orderEditableCutOffTime: ctrl.priceListData.orderEditableCutOffTime,
                processOrderOnSDP: ctrl.priceListData.processOrderOnSDP,
            },
        };
        
        if (ctrl.isPreorder()) {
            retVal.priceList.disableSchedulePreorder = ctrl.priceListData.disableSchedulePreorder
        }

        if (ctrl.isCatering()) {
            retVal.priceList.disableAutoScheduleDelivery = ctrl.priceListData.disableAutoScheduleDelivery
        }

        return retVal;
    };

    ctrl.isPreorder = function() {
        return ctrl.priceListData.type && ctrl.priceListData.type === hsLocationSettings.priceListTypes.PREORDER;
    }

    ctrl.setDisableSchedulePreorder = function(value) {
        ctrl.models.priceList.disableSchedulePreorder = !value;
        ctrl.setChanged();
    }

    ctrl.isCatering = function() {
        return ctrl.priceListData.type && ctrl.priceListData.type === hsLocationSettings.priceListTypes.CATERING;
    }


    ctrl.setDisableAutoScheduleDelivery = function(value) {
        ctrl.models.priceList.disableAutoScheduleDelivery = !value;
        ctrl.setChanged();
    }

    ctrl.setEnableOrderEdits = function(value) {
        if (ENV.isRestaurant) {
            return;
        }
        ctrl.models.priceList.disableUserOrderEditing = !value;
        ctrl.setChanged();
    }

    ctrl.setOrderEditableCutOffTime = function() {
        if (isNaN(ctrl.orderEditableCutOffTimeDisplay) || ctrl.orderEditableCutOffTimeDisplay === '') {
            ctrl.orderEditableCutOffTimeDisplay = 0;
        }
        ctrl.models.priceList.orderEditableCutOffTime = parseInt(ctrl.orderEditableCutOffTimeDisplay * 3.6e6)
        ctrl.setChanged();
    }

    ctrl.setChanged = function() {
        void 0
        var changes = ctrl.getChangedParams();
        ctrl.changed = !!Object.keys(changes).length;
        ctrl.onChange({ changed: ctrl.changed });
    };

    ctrl.hasDescription = function(key) {
        return hsLocationSettings.hasDescription(key);
    };

    ctrl.showDescription = function(key, fieldName) {
        hsLocationSettings.showDescription(key, fieldName);
    };

    ctrl.saveSettings = function() {
        if (ctrl.form.validate()) {
            var params = ctrl.getChangedParams();

            ctrl.onSave({ params: params })
                .then(function() {
                    ctrl.error = null;
                })
                .catch(function (err) {
                    ctrl.error = hsLocationSettings.errorMessages.GENERIC_ERROR;
                });
        }
    };

    ctrl.getChangedParams = function() {
        return hsLocationSettings.getSettingsChanges(ctrl.getModelObject(), ctrl.models);
    };

    ctrl.$onChanges = function (changes) {
        if (changes && changes.priceListData) {
            ctrl.initModels();
            ctrl.setChanged();
        }
    };
}
hsApp.component('customItem', {
    bindings: {
        onSubmit: '&',
        isLoading: '<',
        isOrderForUser: '<',
        location: '<',
    },  
    templateUrl: '/partials/components/product/admin/custom-item.html',
    controller: [ 'hsUtils', 'hsAdminOrder', 'globalFunctions', customItemController ],
});

function customItemController(hsUtils, hsAdminOrder, globalFunctions) {
    var ctrl = this;
    var logPrefix = '[customItem]:';

    ctrl.UNITS = {
        COUNT: 'count',
        LB: 'lb'
    };

    ctrl.VALIDATION_RULES = {
        rules: {
            "custom-item-upc": {
                required: function() {
                    return ctrl.location.customItemRequiresUpc;
                },
            },
            "custom-item-displayName": {
                required: true
            },
            "custom-item-price": {
                required: true,
                number: true,
                gt: 0
            },
            "custom-item-weight" : {
                required: true,
                number: true,
                gt: 0
            },
            "custom-item-tax-rate": {
                required: true,
                number: true,
                gt: 0,
                max: 100
            }
        },
        messages: {
            "custom-item-upc": {
                required: 'Please enter upc'
            },
            "custom-item-displayName": {
                required: 'Please enter item name'
            },
            "custom-item-price": {
                required: 'Please enter price',
                number: 'Price must be a number',
                gt: 'Price must be more than 0'
            },
            "custom-item-weight": {
                required: 'Please enter weight',
                number: 'Weight must be a number',
                gt: 'Weight must be more than 0'
            },
            "custom-item-tax-rate": {
                required: 'Please enter tax rate',
                number: 'Tax rate must be a number',
                gt: 'Tax rate must be more than 0',
                max: 'Tax rate must be less than 100'
            }
        }
    };

    ctrl.$onInit = function () {
        void 0;
        ctrl.customItemForm = null;

        if (!ctrl.location) {
            if (ctrl.isOrderForUser) {
                ctrl.location = hsAdminOrder.getSelectedLocation();
            } else {
                ctrl.location = globalFunctions.getSelectedLocationFromStorage();
            }
        }
        ctrl.defaultTaxRate = +((ctrl.location.taxRate || 0)*100).toFixed(2);
        ctrl.customItemData = ctrl.getCustomItemModel();
    };

    ctrl.getCustomItemModel = function() {
        return {
            upc: '',
            displayName: '',
            unit: ctrl.UNITS.COUNT,
            price: '',
            quantity: 1,
            weight: '',
            itemizedPrice: '',
            instructions: '',
            isTaxable: false,
            taxRate: ctrl.defaultTaxRate,
        };
    };

    ctrl.handleCustomItemSubmit = function() {
        if (ctrl.customItemForm.validate()) {
            var customItem = {
                upc: ctrl.customItemData.upc,
                displayName: ctrl.customItemData.displayName,
                price: ctrl.getRoundedPrice(),
                unit: ctrl.customItemData.unit,
                isCustomItem: true,
                organic: false,
                isTaxable: ctrl.customItemData.isTaxable,
                instructions: ctrl.customItemData.instructions
            };
    
            if (customItem.unit === ctrl.UNITS.LB) {
                customItem.quantity = ctrl.getRoundedWeight();
            } else {
                customItem.quantity = ctrl.customItemData.quantity;
            }
    
            if (customItem.isTaxable) {
                if (hsUtils.isPositiveNumber(ctrl.customItemData.taxRate)) {
                    customItem.taxRate = +(ctrl.customItemData.taxRate/100).toFixed(4);
                } else {
                    customItem.taxRate = 0;
                }
            } else {
                customItem.taxRate = 0;
            }
    
            ctrl.onSubmit({customItem: customItem});
        }
    };

    ctrl.updateIsTaxable = function(value) {
        ctrl.customItemData.isTaxable = value;
    };

    ctrl.updateCustomItemQuantity = function(value) {
        ctrl.customItemData.quantity = value;
        ctrl.calculateItemizedPrice();
    };

    ctrl.getRoundedPrice = function() {
        return +ctrl.customItemData.price.toFixed(2);
    }

    ctrl.getRoundedWeight = function() {
        return +ctrl.customItemData.weight.toFixed(3);
    }

    ctrl.calculateItemizedPriceForCountItem = function () {
        if (hsUtils.isNumber(ctrl.customItemData.quantity) && hsUtils.isNumber(ctrl.customItemData.price)) {
            var roundedPrice = ctrl.getRoundedPrice();
            ctrl.customItemData.itemizedPrice = +(ctrl.customItemData.quantity * roundedPrice).toFixed(2);
        } else {
            ctrl.customItemData.itemizedPrice = '';
        }
    };

    ctrl.calculateItemizedPriceForWeightedItem = function () {
        if (hsUtils.isNumber(ctrl.customItemData.weight) && hsUtils.isNumber(ctrl.customItemData.price)) {
            var roundedWeight = ctrl.getRoundedWeight();
            var roundedPrice = ctrl.getRoundedPrice();
            ctrl.customItemData.itemizedPrice = +(roundedWeight * roundedPrice).toFixed(2);
        } else {
            ctrl.customItemData.itemizedPrice = '';
        }
    };

    ctrl.calculateItemizedPrice = function () {
        if (ctrl.customItemData.unit === ctrl.UNITS.LB) {
            ctrl.calculateItemizedPriceForWeightedItem();
        } else {
            ctrl.calculateItemizedPriceForCountItem();
        }
    };

    ctrl.getPriceLabelDisplayText = function() {
        if (ctrl.customItemData.unit === ctrl.UNITS.LB) {
            return 'Price per LB';
        }
        return 'Item Price';
    };
}

hsApp.component('closableButton', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/closable-button.html',
    bindings: {
        text: '@',
    },
    controller: [
        closableButtonController
    ]
});

function closableButtonController () {
    var ctrl = this;
}
hsApp.component('promotionProgressBrandsFilter', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-brands-filter.html',
    bindings: {
        brandFilterLetters: '<',
        filterBrands: '<',
        handleBrandSelection: '&',
        handleSearch: '&',
        selectedLetter: '<',
        setSelectedLetter: '&'
    },
    controller: [
        promotionProgressBrandsFilterController
    ]
});

function promotionProgressBrandsFilterController () {
    var ctrl = this;

    ctrl.handleSelection = function (key, itemName) {
        ctrl.handleBrandSelection({key, itemName});
    }
}
hsApp.component('promotionProgressCheckbox', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-checkbox.html',
    bindings: {
        name: '@',
        selected: '<',
        handleSelection: '&',
    },
    controller: [
        promotionProgressCheckboxController
    ]
});

function promotionProgressCheckboxController () {
    var ctrl = this;

    ctrl.handleChange = function () {
        ctrl.handleSelection({ name: ctrl.name });
    }
}
hsApp.component('promotionProgressDietaryFilter', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-dietary-filter.html',
    bindings: {
        healthClaims: '<',
        handleSelection: '&'
    },
    controller: [
        promotionProgressDietaryFilterController
    ]
});

function promotionProgressDietaryFilterController () {
    var ctrl = this;

    ctrl.handleDietaryFilterChange = function (healthClaim) {
        ctrl.handleSelection({ healthClaim });
    }
}

hsApp.component('promotionProgressFilterContainer', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-filter-container.html',
    bindings: {
        products: '<',
        filterCategories: '<',
        visibleBrands: '<',
        filterBrands: '<',
        healthClaims: '<',
        priceMenu: '<',
        selectedBrandsCount: '<',
        selectedPriceCount: '<',
        selectedHealthClaimCount: '<',
        selectedCategoryCount: '<',
        handleBrandSelection: '&',
        handleFilterByLetter: '&',
        toggleFilterSection: '&',
        handleDietaryFilterSelection: '&',
        handlePriceSelection: '&',
        handleCategorySelection: '&',
        handleClearAll: '&',
        handleApplyFilter: '&'
    },
    controller: [
        'hsPromotionsV2',
        promotionProgressFilterContainerController
    ]
});

function promotionProgressFilterContainerController (hsPromotionsV2) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.brandFilterLetters = Array.from(Array(26)).map((e, i) => String.fromCharCode(i + 65));
        ctrl.brandFilterLetters.unshift('#');
        ctrl.selectedLetter = '';
        ctrl.filterMenu = ctrl.getFilterMenu();
        ctrl.selectedOption = ctrl.filterMenu[0].key;
    };

    ctrl.getFilterMenu = function () {
        return [
            {
                label: 'Categories',
                key: 'categories',
                count: ctrl.selectedCategoryCount
            },
            {
                label: 'Dietary Filters',
                key: 'dietary-filters',
                count: ctrl.selectedHealthClaimCount
            },
            {
                label: 'Brands',
                key: 'brands',
                count: ctrl.selectedBrandsCount
            },
            {
                label: 'Price',
                key: 'price',
                count: ctrl.selectedPriceCount
            },
        ];
    }

    ctrl.$onChanges = function (changeObj) {
        ctrl.filterMenu = ctrl.getFilterMenu();
    };

    ctrl.handleFilterSidebarChange = function (selectedOption) {
        ctrl.selectedOption = selectedOption;
    };

    ctrl.getPriceString = function (priceObj) {
        return hsPromotionsV2.getPriceString(priceObj);
    };

    ctrl.setSelectedLetter = function (letter) {
        if (letter.toUpperCase() === ctrl.selectedLetter) {
            ctrl.selectedLetter = '';
        } else {
            ctrl.selectedLetter = letter.toUpperCase();
        }
        ctrl.handleFilterByLetter({letter: ctrl.selectedLetter});
    };

    ctrl.filterBrandsBySearchText = function (searchText) {
        ctrl.handleFilterByLetter({letter: ctrl.selectedLetter});
        ctrl.visibleBrands = hsPromotionsV2.getFilteredBrands(searchText, ctrl.visibleBrands, ctrl.selectedLetter);
    };

    ctrl.handleBrandSearch = function (value) {
        if(value) {
            ctrl.selectedLetter  = value.charAt(0).toUpperCase();
            ctrl.filterBrandsBySearchText(value);
        } else {
            ctrl.setSelectedLetter('');
        }
    };

    ctrl.onCategorySelection = function (category, name, isCategory) {
        ctrl.handleCategorySelection({category, name, isCategory});
    };

    ctrl.onBrandSelection = function (key, itemName) {
        ctrl.handleBrandSelection({key, itemName})
    };

    ctrl.onPriceSelection = function (priceObj) {
        ctrl.handlePriceSelection({priceObj})
    };

    ctrl.onDietaryFilterSelection = function (healthClaim) {
        ctrl.handleDietaryFilterSelection({healthClaim})
    }
}

hsApp.component('promotionProgressFilterPrice', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-filter-price.html',
    bindings: {
        priceMenu: '<',
        handleSelection: '&'
    },
    controller: [
        'hsPromotionsV2',
        promotionProgressFilterPriceController
    ]
});

function promotionProgressFilterPriceController ( hsPromotionsV2 ) {
    var ctrl = this;

    ctrl.getPriceString = function (priceObj) {
        return hsPromotionsV2.getPriceString(priceObj);
    };

    ctrl.handlePriceSelection = function (priceObj) {
        ctrl.handleSelection({ priceObj });
    }
}

hsApp.component('promotionProgressFilterSection', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-filter-section.html',
    bindings: {
        categories: '<',
        handleSelection: '&'
    },
    controller: [
        promotionProgressFilterSectionController
    ]
});

function promotionProgressFilterSectionController () {
    var ctrl = this;

    ctrl.handleCategorySelection = function (parentName, name, isParent) {
        ctrl.handleSelection({ category: parentName, name, isCategory: isParent })
    }
}

hsApp.component('promotionProgressFilterSidebar', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-filter-sidebar.html',
    bindings: {
        filters: '<',
        selectedOption: '@',
        handleFilterSidebarChange: '&'
    },
    controller: [
        promotionProgressFilterSidebarController
    ]
});

function promotionProgressFilterSidebarController () {
    var ctrl = this;

    ctrl.handleChange = function (selectedOption) {
        ctrl.handleFilterSidebarChange({selectedOption})
    }
}
hsApp.component('promotionProgressFooter', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-footer.html',
    bindings: {
        handleNext: '&',
        handleBack: '&',
        showBackButton: '<',
        showNextButton: '<',
        disableNextButton: '<',
        hideNextIcon: '<',
        overrideNextBtnText: '@',
    },
    controller: [
        promotionProgressFooterController
    ]
});

function promotionProgressFooterController () {
    var ctrl = this;
}

hsApp.component('promotionProgressHeader', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-header.html',
    bindings: {
        tag: '@',
        endDate: '<',
        steps: '<',
        currentStepIndex: '<',
        progressPercent: '<',
        savings: '<',
        handleSearch: '&',
        showFilter: '&'
    },
    controller: [
        promotionProgressHeaderController
    ]
});

function promotionProgressHeaderController () {
    var ctrl = this;

    ctrl.isPromotionCompleted = function () {
        return parseInt(ctrl.progressPercent) === 100;
    }
}
hsApp.component('promotionProgressItemCard', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-item-card.html',
    bindings: {
        product: '<',
        updateQuantity: '&'
    },
    controller: [
        'hsPromotionsV2',
        promotionProgressItemCardController
    ]
});

function promotionProgressItemCardController (hsPromotionsV2) {
    var ctrl = this;

    ctrl.canShowDeleteBtn = function (item) {
        return hsPromotionsV2.hasItemReachedMinQuantity(item);
    };

    ctrl.getProductDisplayName = function(item) {
        return hsPromotionsV2.getProductDisplayName(item);
    };
}
hsApp.component('promotionProgressList', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-list.html',
    bindings: {
        products: '<',
        updateQuantity: '&'
    },
    controller: [
        'hsCart',
        promotionProgressListController
    ]
});

function promotionProgressListController (hsCart) {
    var ctrl = this;

}
hsApp.component('promotionProgressPopup', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-popup.html',
    bindings: {
        promoId: '<'
    },
    controller: [
        '$rootScope',
        'hsPromotionsV2',
        'toastr',
        'hsUtils',
        'globalFunctions',
        promotionProgressPopupController
    ]
});

function promotionProgressPopupController ($rootScope, hsPromotionsV2, toastr, hsUtils, globalFunctions) {
    var ctrl = this;

    ctrl.$onInit = function () {
        ctrl.showFilter = false;
        ctrl.productDetails = {
            show: false,
            product: null,
        };
        ctrl.promotionProgress = {};
        ctrl.currentStepItems = [];
        ctrl.currentStepIndex = 0;
        ctrl.searchText = null;
        ctrl.loading = false;
        ctrl.progressPercent = 0;
        ctrl.filterCategories = {};
        ctrl.filterBrands = {}; 
        ctrl.visibleBrands = {};
        ctrl.healthClaims = [];
        ctrl.selectedBrandsCount = hsPromotionsV2.getSelectedBrandsCount(ctrl.filterBrands);;
        ctrl.selectedPriceCount = hsPromotionsV2.getSelectedItemsCount(ctrl.priceMenu);
        ctrl.selectedHealthClaimCount = hsPromotionsV2.getSelectedItemsCount(ctrl.healthClaims);
        ctrl.selectedCategoryCount = hsPromotionsV2.getSelectedCategoryCount(ctrl.filterCategories);;
        ctrl.priceMenu = hsPromotionsV2.getPriceMenu();
        ctrl.getPromotionProgress();
    };

    ctrl.toggleFilterSection = function () {
        ctrl.showFilter = !ctrl.showFilter;
    };

    ctrl.handleBrandSelection = function (key, itemName) {
        ctrl.filterBrands[key].brands[itemName].selected = !ctrl.filterBrands[key].brands[itemName].selected;
        ctrl.filterBrands[key].atleastOneBrandSelected = hsPromotionsV2.atleastOneBrandSelected(ctrl.filterBrands[key].brands);
        ctrl.selectedBrandsCount = hsPromotionsV2.getSelectedBrandsCount(ctrl.filterBrands);
    };

    ctrl.handleFilterByLetter = function (letter) {
        if (!letter) {
            ctrl.visibleBrands = ctrl.filterBrands;
        } else {
            if(ctrl.filterBrands[letter]) {
                ctrl.visibleBrands = {};
                ctrl.visibleBrands[letter] = ctrl.filterBrands[letter];
            }
        }
    };

    ctrl.setProgressDetails = function () {
        ctrl.setCurrentStepItems();
        ctrl.setProgressPercent();
    };

    ctrl.handleCategorySelection = function (category, name, isCategory) {
        if (isCategory) {
            var isSelected = !ctrl.filterCategories[name].selected;
            ctrl.filterCategories[name].selected = isSelected;
            for (var subCategory in ctrl.filterCategories[name].subCategories) {
                ctrl.filterCategories[category].subCategories[subCategory].selected = isSelected;
            }
        } else {
            ctrl.filterCategories[category].subCategories[name].selected = !ctrl.filterCategories[category].subCategories[name].selected;
            hsPromotionsV2.setTypeSelection(category, ctrl.filterCategories);
        }
        ctrl.selectedCategoryCount = hsPromotionsV2.getSelectedCategoryCount(ctrl.filterCategories);
    };

    ctrl.handleDietaryFilterSelection = function (healthClaim) {
        ctrl.healthClaims = hsPromotionsV2.getUpdatedHealthClaims(healthClaim, ctrl.healthClaims);
        ctrl.selectedHealthClaimCount = hsPromotionsV2.getSelectedItemsCount(ctrl.healthClaims || []);
    };

    ctrl.handlePriceSelection = function (priceObj) {
        ctrl.priceMenu = ctrl.priceMenu.map(function (price) {
            if (price.min === priceObj.min && price.max === priceObj.max) {
                price.selected = !price.selected;
            }

            return price
        });
        ctrl.selectedPriceCount = hsPromotionsV2.getSelectedItemsCount(ctrl.priceMenu || []);
    };

    ctrl.handleSearch = function (value) {
        ctrl.searchText = value;
        if(value !== "") {
            ctrl.currentStepItems = hsPromotionsV2.getFilteredItemsBySearchText(ctrl.searchText, ctrl.promotionProgress, ctrl.currentStepIndex);
        }
    };

    ctrl.getPromotionProgress = function () {
        ctrl.loading = true;
        hsPromotionsV2.getPromotionProgress(ctrl.promoId)
            .then (function (response) {
                ctrl.promotionProgress = hsPromotionsV2.getSortedPromotionProgress(response);
                ctrl.setProgressDetails();
            })
            .catch(function (err) {
                var message = hsUtils.getMessageFromError(err);
                void 0;
                toastr.error(message);
            })
            .finally(function () {
                ctrl.loading = false;
            });
    };

    ctrl.handleApplyFilter = function () {
        ctrl.currentStepItems = hsPromotionsV2.filterProducts(
            ctrl.filterCategories,
            ctrl.filterBrands,
            ctrl.healthClaims,
            ctrl.priceMenu,
            ctrl.promotionProgress,
            ctrl.currentStepIndex
        );
        ctrl.toggleFilterSection();
    };

    ctrl.setCurrentStepItems = function () {
        ctrl.currentStepItems = hsPromotionsV2.getCurrentStepItems(ctrl.promotionProgress, ctrl.currentStepIndex);
        ctrl.setInitialFilterData();
    };

    ctrl.setInitialFilterData = function () {
        ctrl.filterCategories = hsPromotionsV2.getFilterCategories(ctrl.currentStepItems);
        ctrl.filterBrands = hsPromotionsV2.getFilterBrands(ctrl.currentStepItems);
        ctrl.healthClaims = hsPromotionsV2.getHealthClaimsForFilter(ctrl.currentStepItems);
        ctrl.visibleBrands = ctrl.filterBrands;
        ctrl.priceMenu = hsPromotionsV2.getPriceMenu();

        ctrl.selectedBrandsCount = hsPromotionsV2.getSelectedBrandsCount(ctrl.filterBrands);
        ctrl.selectedPriceCount = hsPromotionsV2.getSelectedItemsCount(ctrl.priceMenu);
        ctrl.selectedHealthClaimCount = hsPromotionsV2.getSelectedItemsCount(ctrl.healthClaims);
        ctrl.selectedCategoryCount = hsPromotionsV2.getSelectedCategoryCount(ctrl.filterCategories);
    };

    ctrl.isCurrentStepInProgress = function () {
        return hsPromotionsV2.isCurrentStepInProgress(ctrl.promotionProgress, ctrl.currentStepIndex);
    };

    ctrl.showNextButton = function() {
        if (ctrl.productDetails.show) {
            return false;
        }
        return ctrl.currentStepIndex + 1 < ctrl.promotionProgress.steps.length;
    };

    ctrl.showBackButton = function() {
        return ctrl.productDetails.show || ctrl.currentStepIndex >= 1;
    };

    ctrl.isNextButtonDisabled = function() {
        return ctrl.isCurrentStepInProgress();
    };

    ctrl.handleNext = function () {
        ctrl.currentStepIndex++;
        ctrl.setProgressDetails();
    };

    ctrl.handleBack = function () {
        if (ctrl.productDetails.show) {
            ctrl.closeProductDetails(null);
            return;
        }
        ctrl.currentStepIndex--;
        ctrl.setProgressDetails();
    };

    ctrl.handleCategorySelection = function (category, name, isCategory) {
        if (isCategory) {
            var isSelected = !ctrl.filterCategories[name].selected;
            ctrl.filterCategories[name].selected = isSelected;
            for (var subCategory in ctrl.filterCategories[name].subCategories) {
                ctrl.filterCategories[category].subCategories[subCategory].selected = isSelected;
            }
        } else {
            ctrl.filterCategories[category].subCategories[name].selected = !ctrl.filterCategories[category].subCategories[name].selected;
            hsPromotionsV2.setCategorySelection(category, ctrl.filterCategories);
        }
        ctrl.selectedCategoryCount = hsPromotionsV2.getSelectedCategoryCount(ctrl.filterCategories);
    };

    ctrl.setProgressPercent = function () {
        ctrl.progressPercent = hsPromotionsV2.getProgressPercent(ctrl.promotionProgress);
    };

    ctrl.addItemToCart = function (item, quantity, isUpdating) {
        item.loading = true;
        hsPromotionsV2.addItemToCart(item, quantity, ctrl.promoId)
            .then(function (response) {
                ctrl.promotionProgress = hsPromotionsV2.getUpdatedPromotionProgress(response, ctrl.promotionProgress);
                ctrl.setProgressDetails();

                if (isUpdating) {
                    toastr.success('Quantity updated successfully.');
                } else {
                    toastr.success('Product added to cart successfully.');
                }
            })
            .catch(function (err) {
                toastr.error(hsUtils.getMessageFromError(err));
            })
            .finally(function () {
                item.loading = false;
            });
    };

    ctrl.removeItem = function (item) {
        if (!$rootScope.loggedIn) {
            hsPromotionsV2.removeItemFromCartForLoggedOutUser(item);
        } else {
            item.loading = true;
            hsPromotionsV2.removeItemFromCartForLoggedInUser(item, ctrl.promoId)
                .then(function (response) {
                    ctrl.promotionProgress = hsPromotionsV2.getUpdatedPromotionProgress(response, ctrl.promotionProgress);
                    ctrl.setProgressDetails();
                    toastr.success('Item removed successfully.');
                })
                .catch(function (err) {
                    toastr.error(hsUtils.getMessageFromError(err));
                })
                .finally(function () {
                    item.loading = false;
                });
        }
    };

    ctrl.updateItemQuantity = function (operation, item) {
        var quantity = hsPromotionsV2.getUpdatedQuantity(operation, item);
        if (operation === 'add') {
            if (hsPromotionsV2.hasItemReachedMaxQuantity(item)) {
                toastr.error(globalFunctions.product.maxQuantityError(item.maxQuantity));
            } else {
                ctrl.addItemToCart(item, quantity, item.quantity >= 1);
            }
        } else if(operation === 'subtract') {
            if (hsPromotionsV2.hasItemReachedMinQuantity(item)) {
                ctrl.removeItem(item);
            } else {
                ctrl.addItemToCart(item, quantity);
            }
        }
    };

    ctrl.updateQuantity = function (operation, item) {
        if (item.hasModifiers) {
            if (operation === 'add') {
                ctrl.setProductDetails(item);
                ctrl.showProductDetails();
            } else if (operation === 'subtract') {
                // temporary message until remove modifiers UI is implemented
                toastr.warning('Items with modifiers must be removed from cart.');
            }
        } else {
            if (["add", "subtract"].includes(operation)) {
                if (item.quantity === 0 && operation === "add") {
                    var quantity = hsPromotionsV2.getUpdatedQuantity(operation, item);
                    ctrl.addItemToCart(item, quantity);
                } else {
                    ctrl.updateItemQuantity(operation, item);
                }
            }
        }
    };

    ctrl.setProductDetails = function(product) {
        ctrl.productDetails.product = product;
    };

    ctrl.showProductDetails = function () {
        ctrl.productDetails.show = true;
    };

    ctrl.closeProductDetails = function(promotionProgress) {
        if (promotionProgress) {
            ctrl.promotionProgress = promotionProgress;
            ctrl.setProgressDetails();
        }
        
        ctrl.productDetails.show = false;
        ctrl.setProductDetails(null);
    };
}
hsApp.component('promotionProgressProductDetails', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-product-details.html',
    bindings: {
        productData: '<',
        promoId: '<',
        closeProductDetails: '&'
    },
    controller: [
        '$rootScope',
        '$scope',
        'ENV',
        'hsPromotionsV2',
        'hsUtils',
        'ngDialog',
        'toastr',
        'globalFunctions',
        promotionProgressProductDetailsController
    ]
});

function promotionProgressProductDetailsController ($rootScope, $scope, ENV, hsPromotionsV2, hsUtils, ngDialog, toastr, globalFunctions) {
    var ctrl = this;

    ctrl.$onInit = function() {
        ctrl.initProduct();
    };

    ctrl.$onChanges = function(changes) {
        if (changes && changes.productData) {
            ctrl.initProduct();
        }
    };

    ctrl.initProduct = function() {
        ctrl.product = {};

        if (ctrl.productData) {
            ctrl.product = angular.copy(ctrl.productData);
        }

        ctrl.quantity = 1;
        ctrl.itemInstructions = '';

        if (hsUtils.isNonEmptyObject(ctrl.product)) {
            ctrl.quantity = Math.max(
                hsPromotionsV2.getUnitIncrement(ctrl.product),
                ctrl.product.minQuantity
            );

            if(ctrl.product.hasModifiers) {
                ctrl.product.modifiers.forEach(function (mod) {
                    mod.error = '';
                    mod.options.forEach(function(option) {
                        option.checked = option.name === mod.defaultOption;
                    });
                });
            } else {
                if (ctrl.product.instructions) {
                    ctrl.itemInstructions = ctrl.product.instructions;
                }
                if (ctrl.product.quantity) {
                    ctrl.quantity = ctrl.product.quantity;
                }
            }
        }
    };

    ctrl.getProductDisplayName = function(product) {
        return hsPromotionsV2.getProductDisplayName(product);
    };

    ctrl.getProductPrice = function() {
        return hsPromotionsV2.calculateProductPrice(ctrl.product);
    };

    ctrl.calculatePricePerQuantity = function(product) {
        return hsPromotionsV2.calculatePricePerQuantity(product);
    };

    ctrl.shouldShowUnit = function() {
        return !ENV.hideItemUnit;
    };

    ctrl.updateQuantityCounter = function (item, operation) {
        var itemCopy = angular.copy(item);
        itemCopy.quantity = ctrl.quantity;

        if (operation === 'add' && hsPromotionsV2.hasItemReachedMaxQuantity(itemCopy)) {
            toastr.error(globalFunctions.product.maxQuantityError(itemCopy.maxQuantity));
        } else if (operation === 'subtract' && hsPromotionsV2.hasItemReachedMinQuantity(itemCopy)) {
            return;
        } else {
            ctrl.quantity = hsPromotionsV2.getUpdatedQuantity(operation, itemCopy);
        }
    };

    ctrl.addItemToCart = function() {
        if (ctrl.product.hasModifiers) {
            var selectedModifiers = ctrl.getSelectedModifiers();
            if (!Array.isArray(selectedModifiers)) {
                return;
            }

            ctrl.product.selectedModifiers = selectedModifiers;
        }

        ctrl.product.instructions = ctrl.itemInstructions;

        if (!$rootScope.loggedIn) {
            // not implemented
        } else {
            ctrl.addItemToCartLoggedIn();
        }
    };

    ctrl.addItemToCartLoggedIn = function() {
        ctrl.product.loading = true;
        hsPromotionsV2.addItemToCart(ctrl.product, ctrl.quantity, ctrl.promoId)
            .then(function(promotionsData) {
                toastr.success('Item added to cart successfully.');
                ctrl.closeProductDetails({ promotionProgress: promotionsData });
            })
            .catch(function(err) {
                void 0;
                toastr.error(hsUtils.getMessageFromError(err, 'Error adding product.'));
            })
            .finally(function() {
                ctrl.product.loading = false;
            });
    };

    ctrl.getSelectedModifiers = function() {
        var selectedModifiers = [];
        var errors = [];

        ctrl.product.modifiers.forEach(function (modifier) {
            modifier.error = '';

            var userSelections = [];
            var isSelectionFulfilled = !modifier.selectionRequired;

            if (modifier.selectionRequired) {
                modifier.options.forEach(function (option) {
                    if (option.checked) {
                        isSelectionFulfilled = true;
                        selectedModifiers.push(option);
                        userSelections.push(option);
                    }
                });

                if (!isSelectionFulfilled) {
                    modifier.error = "Please select an option below.";
                    errors.push(true);
                }
            } else {
                modifier.options.forEach(function(option) {
                    if(option.checked) {
                        selectedModifiers.push(option);
                        userSelections.push(option);
                    }
                });
            }

            if (!modifier.singleSelection) {
                if (modifier.minSelections && (userSelections.length < modifier.minSelections)) {
                    errors.push(true);
                    modifier.error = "Please select at least " + modifier.minSelections + " items.";
                } else if (modifier.maxSelections && (userSelections.length > modifier.maxSelections)) {
                    errors.push(true);
                    modifier.error = "Max " + modifier.maxSelections + " items are allowed.";
                }
            }
        });

        if (errors.length) {
            return null;
        } else {
            return selectedModifiers;
        }
    };

    ctrl.updateModifierSelection = function(modifier, option, isCheckbox) {
        angular.forEach(modifier.options, function(o) {
            if (isCheckbox) {
                if(o.name === option.name) {
                    o.checked = !o.checked;
                }
            } else {
                if (o.name === option.name) {
                    if (modifier.selectionRequired) {
                        o.checked = true;
                    } else {
                        o.checked = !o.checked;
                    }
                } else {
                    if (modifier.singleSelection) {
                        o.checked = false;
                    }
                }
            }
        });
    };

    ctrl.calculateAvailableTimeString = function(product) {
        return hsPromotionsV2.calculateAvailableTimeString(product, 'product');
    };

    ctrl.showAvailableTimes = function(product) {
        var $availableTimesScope = $scope.$new(true);
        $availableTimesScope.product = product;

        ngDialog.open({
            template: '<div><available-times '
                + 'product="product">'
                + '</available-times></div>',
            scope: $availableTimesScope,
            plain: true,
            closeByDocument: true,
            closeByNavigation: true,
        });
    };

};
hsApp.component('promotionProgressRing', {
    templateUrl: '/partials/components/promotions-v2/promotion-progress/promotion-progress-ring.html',
    bindings: {
        progress: '<',
        isPromotionCompleted: '&'
    },
    controller: [
        promotionProgressRingController
    ]
});

function promotionProgressRingController () {
    var ctrl = this;

    ctrl.$onChanges = function (changes) {
        if (changes.progress && changes.progress.currentValue !== changes.progress.previousValue) {
            var progressBar = document.querySelector('.progress-bar');
            var progressPercent = ctrl.progress || 0;
            progressBar.style.background = 'radial-gradient(closest-side, white 79%, transparent 80% 100%),conic-gradient(#148114 ' + progressPercent + '%, #D8D8D8 0)';
        }
    };
}
